<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【休闲】轻松惬意的假日</title>
      <link href="/p/1ca18c4f.html"/>
      <url>/p/1ca18c4f.html</url>
      
        <content type="html"><![CDATA[<p><img src="/p/1ca18c4f/0401.jpg" alt="山坳里远眺"><br><img src="/p/1ca18c4f/0402.jpg" alt="野生娃娃鱼"><br><img src="/p/1ca18c4f/0403.jpg" alt="民宿前厅"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 休闲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在校园里小憩</title>
      <link href="/p/1e30e629.html"/>
      <url>/p/1e30e629.html</url>
      
        <content type="html"><![CDATA[<p><img src="/p/1e30e629/001.jpg" alt="在校园小憩"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 休闲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（11）霍夫曼编码（HuffmanCoding）</title>
      <link href="/p/14e7f5a9.html"/>
      <url>/p/14e7f5a9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p><a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p><a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p><a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p><a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p><a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p><a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p><p><a href="https://nilsli.com/p/b0e10b1c.html">【数据结构与算法】-（8）栈之算法题</a></p><p><a href="https://nilsli.com/p/cc625709.html">【数据结构与算法】-（8.1）字符串去重算法</a></p><p><a href="https://nilsli.com/p/8a586c1e.html">【数据结构与算法】-（8.2）字符串搜索算法和RK&amp;BP算法</a></p><p><a href="https://nilsli.com/p/22d3726c.html">【数据结构与算法】-（8.3）KMP算法</a></p><p><a href="https://nilsli.com/p/919af6b6.html#toc-heading-15">【数据结构与算法】-（9）二叉树与顺序表实现</a></p><p><a href="https://nilsli.com/p/919af6b6.html#toc-heading-15">【数据结构与算法】-（10）线索化二叉树</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文章字数: 约4.5k</span><br><span class="line">阅读时长: 25 分钟</span><br></pre></td></tr></table></figure><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h3 id="1-1-霍夫曼编码的定义"><a href="#1-1-霍夫曼编码的定义" class="headerlink" title="1.1 霍夫曼编码的定义"></a>1.1 霍夫曼编码的定义</h3><p>霍夫曼编码（Huffman Coding）是一种被广泛使用的数据压缩编码算法，由美国计算机科学家大卫·霍夫曼（David A. Huffman）在1952年发明。这种编码方式是一种变长编码方法，其核心思想是：对出现频率高的字符使用较短的编码，对出现频率低的字符使用较长的编码，以此来达到压缩数据的目的。</p><h3 id="1-2-霍夫曼编码的特点"><a href="#1-2-霍夫曼编码的特点" class="headerlink" title="1.2 霍夫曼编码的特点"></a>1.2 霍夫曼编码的特点</h3><ol><li>变长编码：不同字符的编码长度可以不同</li><li>前缀编码：任一字符的编码都不是其他字符编码的前缀</li><li>最优性：在变长编码中，霍夫曼编码是最优的</li></ol><h3 id="1-3-霍夫曼树"><a href="#1-3-霍夫曼树" class="headerlink" title="1.3 霍夫曼树"></a>1.3 霍夫曼树</h3><p>霍夫曼编码的关键在于构建霍夬曼树。霍夫曼树是一种特殊的二叉树，具有以下特点：</p><ul><li>树中每个叶节点代表一个字符及其出现频率</li><li>树中每个非叶节点的权值等于其左右子树权值之和</li><li>树的带权路径长度最小</li></ul><h2 id="二、霍夫曼树的存储结构"><a href="#二、霍夫曼树的存储结构" class="headerlink" title="二、霍夫曼树的存储结构"></a>二、霍夫曼树的存储结构</h2><h3 id="2-1-节点结构"><a href="#2-1-节点结构" class="headerlink" title="2.1 节点结构"></a>2.1 节点结构</h3><p>霍夫曼树的节点结构通常包含以下信息：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> weight;  <span class="comment">// 权值（频率）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> parent, lchild, rchild;  <span class="comment">// 父节点、左子节点、右子节点</span></span><br><span class="line">&#125; HTNode, *HuffmanTree;</span><br></pre></td></tr></table></figure><h3 id="2-2-霍夫曼编码表"><a href="#2-2-霍夫曼编码表" class="headerlink" title="2.2 霍夫曼编码表"></a>2.2 霍夫曼编码表</h3><p>为了方便编码和解码，我们还需要一个霍夫曼编码表：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>** HuffmanCode;</span><br></pre></td></tr></table></figure><h2 id="三、霍夫曼编码的实现"><a href="#三、霍夫曼编码的实现" class="headerlink" title="三、霍夫曼编码的实现"></a>三、霍夫曼编码的实现</h2><h3 id="3-1-构建霍夫曼树"><a href="#3-1-构建霍夫曼树" class="headerlink" title="3.1 构建霍夫曼树"></a>3.1 构建霍夫曼树</h3><p>构建霍夫曼树的过程是一个自底向上的过程，主要步骤如下：</p><ol><li>将所有叶子节点（即待编码的字符）按照权值（频率）从小到大排序</li><li>取出权值最小的两个节点，生成一个新节点作为它们的父节点，新节点的权值为两个子节点权值之和</li><li>从序列中删除这两个节点，将新节点加入序列</li><li>重复步骤2和3，直到只剩一个节点，这个节点就是霍夫曼树的根节点</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanTree</span><span class="params">(HuffmanTree *HT, <span class="type">int</span> n, <span class="type">int</span> *w)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;  <span class="comment">// 霍夫曼树总节点数</span></span><br><span class="line">    *HT = (HuffmanTree)<span class="built_in">malloc</span>((m + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HTNode));  <span class="comment">// 0号单元未用</span></span><br><span class="line">    HuffmanTree p = *HT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p[i].weight = w[i - <span class="number">1</span>];</span><br><span class="line">        p[i].parent = <span class="number">0</span>;</span><br><span class="line">        p[i].lchild = <span class="number">0</span>;</span><br><span class="line">        p[i].rchild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        p[i].weight = <span class="number">0</span>;</span><br><span class="line">        p[i].parent = <span class="number">0</span>;</span><br><span class="line">        p[i].lchild = <span class="number">0</span>;</span><br><span class="line">        p[i].rchild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建霍夫曼树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> s1, s2;</span><br><span class="line">        Select(*HT, i - <span class="number">1</span>, &amp;s1, &amp;s2);  <span class="comment">// 选择两个权值最小的节点</span></span><br><span class="line">        p[s1].parent = i;</span><br><span class="line">        p[s2].parent = i;</span><br><span class="line">        p[i].lchild = s1;</span><br><span class="line">        p[i].rchild = s2;</span><br><span class="line">        p[i].weight = p[s1].weight + p[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>Select</code> 函数用于选择权值最小的两个节点：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Select</span><span class="params">(HuffmanTree HT, <span class="type">int</span> n, <span class="type">int</span> *s1, <span class="type">int</span> *s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> min1 = UINT_MAX, min2 = UINT_MAX;</span><br><span class="line">    *s1 = *s2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; min1) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                *s2 = *s1;</span><br><span class="line">                min1 = HT[i].weight;</span><br><span class="line">                *s1 = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HT[i].weight &lt; min2) &#123;</span><br><span class="line">                min2 = HT[i].weight;</span><br><span class="line">                *s2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-生成霍夫曼编码"><a href="#3-2-生成霍夫曼编码" class="headerlink" title="3.2 生成霍夫曼编码"></a>3.2 生成霍夫曼编码</h3><p>生成霍夫曼编码的过程是从叶子节点出发，向根节点回溯，记录路径的过程。通常约定向左子树走记为0，向右子树走记为1。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HuffmanCoding</span><span class="params">(HuffmanTree HT, <span class="type">int</span> n, HuffmanCode *HC)</span> &#123;</span><br><span class="line">    *HC = (HuffmanCode)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    <span class="type">char</span> *cd = (<span class="type">char</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">char</span>));  <span class="comment">// 临时存放编码</span></span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> start = n - <span class="number">1</span>;  <span class="comment">// 编码结束符位置</span></span><br><span class="line">        <span class="type">int</span> c = i;</span><br><span class="line">        <span class="type">int</span> f = HT[i].parent;</span><br><span class="line">        <span class="keyword">while</span> (f != <span class="number">0</span>) &#123;</span><br><span class="line">            --start;</span><br><span class="line">            <span class="keyword">if</span> (HT[f].lchild == c)</span><br><span class="line">                cd[start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            c = f;</span><br><span class="line">            f = HT[f].parent;</span><br><span class="line">        &#125;</span><br><span class="line">        (*HC)[i] = (<span class="type">char</span>*)<span class="built_in">malloc</span>((n - start) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>((*HC)[i], &amp;cd[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、霍夫曼编码的应用"><a href="#四、霍夫曼编码的应用" class="headerlink" title="四、霍夫曼编码的应用"></a>四、霍夫曼编码的应用</h2><h3 id="4-1-数据压缩"><a href="#4-1-数据压缩" class="headerlink" title="4.1 数据压缩"></a>4.1 数据压缩</h3><p>霍夫曼编码最常见的应用是数据压缩。通过对高频字符使用短编码，低频字符使用长编码，可以显著减少数据的存储空间。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Compress</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* input, <span class="type">const</span> <span class="type">char</span>* output, HuffmanCode HC)</span> &#123;</span><br><span class="line">    FILE *in = fopen(input, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE *out = fopen(output, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> buf_len = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(in)) != EOF) &#123;</span><br><span class="line">        <span class="type">char</span> *code = HC[ch];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; code[i]; ++i) &#123;</span><br><span class="line">            buf = (buf &lt;&lt; <span class="number">1</span>) | (code[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (++buf_len == <span class="number">8</span>) &#123;</span><br><span class="line">                fputc(buf, out);</span><br><span class="line">                buf = <span class="number">0</span>;</span><br><span class="line">                buf_len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (buf_len) &#123;</span><br><span class="line">        buf &lt;&lt;= (<span class="number">8</span> - buf_len);</span><br><span class="line">        fputc(buf, out);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-数据解压"><a href="#4-2-数据解压" class="headerlink" title="4.2 数据解压"></a>4.2 数据解压</h3><p>解压过程是编码的逆过程，需要利用霍夫曼树从根节点开始，根据读取的位进行左右子树的选择，直到到达叶子节点。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Decompress</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* input, <span class="type">const</span> <span class="type">char</span>* output, HuffmanTree HT, <span class="type">int</span> root)</span> &#123;</span><br><span class="line">    FILE *in = fopen(input, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    FILE *out = fopen(output, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> p = root;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (fread(&amp;ch, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, in) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch &amp; (<span class="number">1</span> &lt;&lt; (<span class="number">7</span> - i)))</span><br><span class="line">                p = HT[p].rchild;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = HT[p].lchild;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (HT[p].lchild == <span class="number">0</span> &amp;&amp; HT[p].rchild == <span class="number">0</span>) &#123;</span><br><span class="line">                fputc(p, out);</span><br><span class="line">                p = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、霍夫曼编码的优缺点"><a href="#五、霍夫曼编码的优缺点" class="headerlink" title="五、霍夫曼编码的优缺点"></a>五、霍夫曼编码的优缺点</h2><h3 id="5-1-优点"><a href="#5-1-优点" class="headerlink" title="5.1 优点"></a>5.1 优点</h3><ol><li>压缩效率高：对于出现频率差异大的数据，压缩效果显著</li><li>无损压缩：解压后可以完全还原原始数据</li><li>编解码速度快：使用查表法可以快速进行编解码</li></ol><h3 id="5-2-缺点"><a href="#5-2-缺点" class="headerlink" title="5.2 缺点"></a>5.2 缺点</h3><ol><li>需要预先知道字符频率：这可能需要对数据进行两次扫描</li><li>不适合均匀分布的数据：如果所有字符出现频率相近，压缩效果不明显</li><li>编码表可能很大：如果字符种类很多，编码表本身可能占用较大空间</li></ol><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>霍夫曼编码是一种经典的数据压缩算法，它通过构建霍夫曼树来为字符赋予变长编码，从而达到数据压缩的目的。这种算法在数据压缩、信息论等领域有着广泛的应用。</p><p>理解和掌握霍夫曼编码不仅能帮助我们更好地理解数据压缩的原理，还能让我们对树结构、贪心算法等重要的数据结构和算法概念有更深入的认识。在实际应用中，霍夫曼编码常常与其他压缩技术结合使用，以获得更好的压缩效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 霍夫曼树 </tag>
            
            <tag> 数据压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（10）线索化二叉树</title>
      <link href="/p/440a10cd.html"/>
      <url>/p/440a10cd.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p><a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p><a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p><a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p><a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p><a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p><a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p><p><a href="https://nilsli.com/p/b0e10b1c.html">【数据结构与算法】-（8）栈之算法题</a></p><p><a href="https://nilsli.com/p/cc625709.html">【数据结构与算法】-（8.1）字符串去重算法</a></p><p><a href="https://nilsli.com/p/8a586c1e.html">【数据结构与算法】-（8.2）字符串搜索算法和RK&amp;BP算法</a></p><p><a href="https://nilsli.com/p/22d3726c.html">【数据结构与算法】-（8.3）KMP算法</a></p><p><a href="https://nilsli.com/p/919af6b6.html#toc-heading-15">【数据结构与算法】-（9）二叉树与顺序表实现</a></p></blockquote> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文章字数: 约4k</span><br><span class="line">阅读时长: 20 分钟</span><br></pre></td></tr></table></figure><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h3 id="1-1-线索化二叉树的定义"><a href="#1-1-线索化二叉树的定义" class="headerlink" title="1.1 线索化二叉树的定义"></a>1.1 线索化二叉树的定义</h3><p>线索化二叉树(Threaded Binary Tree)是一种特殊的二叉树结构。在普通二叉树中,叶子节点的左右指针往往指向NULL,造成了存储空间的浪费。线索化二叉树的主要思想是利用这些空闲指针,存储该节点在某种遍历序列中的前驱和后继节点的信息,从而加快树的遍历速度。</p><h3 id="1-2-线索化二叉树的特点"><a href="#1-2-线索化二叉树的特点" class="headerlink" title="1.2 线索化二叉树的特点"></a>1.2 线索化二叉树的特点</h3><ol><li>充分利用空指针域,节省存储空间</li><li>可以直接找到任一节点的前驱和后继,而不需要重新遍历</li><li>遍历算法变得简单,不再需要使用栈</li></ol><h3 id="1-3-线索化二叉树的分类"><a href="#1-3-线索化二叉树的分类" class="headerlink" title="1.3 线索化二叉树的分类"></a>1.3 线索化二叉树的分类</h3><p>根据线索化的方式,可以将线索二叉树分为:</p><ul><li>前序线索化二叉树</li><li>中序线索化二叉树</li><li>后序线索化二叉树</li></ul><p>本文将主要讨论中序线索化二叉树。</p><h2 id="二、线索化二叉树的存储结构"><a href="#二、线索化二叉树的存储结构" class="headerlink" title="二、线索化二叉树的存储结构"></a>二、线索化二叉树的存储结构</h2><h3 id="2-1-节点结构"><a href="#2-1-节点结构" class="headerlink" title="2.1 节点结构"></a>2.1 节点结构</h3><p>线索化二叉树的节点结构需要在普通二叉树节点的基础上增加两个标志位:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>  <span class="comment">// 左右孩子指针</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag;             <span class="comment">// 左右线索标志</span></span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li>ltag为0时指向该节点的左孩子,为1时指向该节点的前驱</li><li>rtag为0时指向该节点的右孩子,为1时指向该节点的后继</li></ul><h2 id="三、线索化二叉树的实现"><a href="#三、线索化二叉树的实现" class="headerlink" title="三、线索化二叉树的实现"></a>三、线索化二叉树的实现</h2><h3 id="3-1-中序线索化"><a href="#3-1-中序线索化" class="headerlink" title="3.1 中序线索化"></a>3.1 中序线索化</h3><p>中序线索化的过程实际上就是对二叉树进行中序遍历的过程。在遍历的同时,将空指针改为指向前驱或后继节点。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;  <span class="comment">// 全局变量,始终指向刚刚访问过的节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p) &#123;</span><br><span class="line">        InThread(p-&gt;lchild);  <span class="comment">// 递归线索化左子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lchild) &#123;  <span class="comment">// 左子树为空,建立前驱线索</span></span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre &amp;&amp; !pre-&gt;rchild) &#123;  <span class="comment">// 建立前驱节点的后继线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;  <span class="comment">// 保持pre指向p的前驱</span></span><br><span class="line">        </span><br><span class="line">        InThread(p-&gt;rchild);  <span class="comment">// 递归线索化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span> &#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T) &#123;</span><br><span class="line">        InThread(T);</span><br><span class="line">        <span class="comment">// 处理最后一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-中序线索二叉树的遍历"><a href="#3-2-中序线索二叉树的遍历" class="headerlink" title="3.2 中序线索二叉树的遍历"></a>3.2 中序线索二叉树的遍历</h3><p>利用线索化的特性,我们可以实现非递归的中序遍历:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse_Thr</span><span class="params">(ThreadTree T)</span> &#123;</span><br><span class="line">    ThreadNode *p = T;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="comment">// 找到中序遍历的起始节点</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);  <span class="comment">// 访问该节点</span></span><br><span class="line">        <span class="comment">// 如果右指针是线索,直接访问后继</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rtag == <span class="number">1</span> &amp;&amp; p-&gt;rchild) &#123;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则转向右子树</span></span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-查找节点的前驱和后继"><a href="#3-3-查找节点的前驱和后继" class="headerlink" title="3.3 查找节点的前驱和后继"></a>3.3 查找节点的前驱和后继</h3><p>在线索二叉树中,查找某个节点的前驱和后继变得非常简单:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找中序后继</span></span><br><span class="line">ThreadNode* <span class="title function_">InOrderNext</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">1</span>) <span class="keyword">return</span> p-&gt;rchild;  <span class="comment">// 右指针为线索</span></span><br><span class="line">    p = p-&gt;rchild;  <span class="comment">// 转向右子树</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild;  <span class="comment">// 找到右子树的最左节点</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找中序前驱</span></span><br><span class="line">ThreadNode* <span class="title function_">InOrderPrev</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag == <span class="number">1</span>) <span class="keyword">return</span> p-&gt;lchild;  <span class="comment">// 左指针为线索</span></span><br><span class="line">    p = p-&gt;lchild;  <span class="comment">// 转向左子树</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>) p = p-&gt;rchild;  <span class="comment">// 找到左子树的最右节点</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、线索化二叉树的应用"><a href="#四、线索化二叉树的应用" class="headerlink" title="四、线索化二叉树的应用"></a>四、线索化二叉树的应用</h2><ol><li><p><strong>快速遍历</strong>: 线索化后的二叉树可以在O(n)时间内完成遍历,而不需要使用栈或者递归。</p></li><li><p><strong>寻找前驱后继</strong>: 在某些应用中,需要频繁地查找某个节点的前驱或后继,线索化二叉树可以在O(1)时间内完成这个操作。</p></li><li><p><strong>空间优化</strong>: 对于叶子节点很多的二叉树,线索化可以充分利用空指针域,节省存储空间。</p></li></ol><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>线索化二叉树通过改造普通二叉树的结构,在节省空间的同时,提高了某些操作的效率。但是,线索化的过程会增加树的构建时间,且会使得树的结构变得复杂。因此,在实际应用中,需要根据具体需求来权衡是否使用线索化二叉树。</p><p>线索化二叉树是二叉树结构的一个重要变种,深入理解它的原理和实现,对于掌握树结构和提高算法设计能力都有很大帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 线索化二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【一起学Metal】01-Metal初体验</title>
      <link href="/p/82a3d28c.html"/>
      <url>/p/82a3d28c.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Metal-简介"><a href="#一、Metal-简介" class="headerlink" title="一、Metal 简介"></a>一、Metal 简介</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>Metal 是一个兼顾图形与计算功能的，面向底层、低开销的硬件加速应用程序接口（API），其类似于将 OpenGL 与 OpenCL 的功能集成到了同一个API上，最初支持它的系统是 iOS 8。Metal 使得 iOS 可以实现其他平台的类似功能，例如 Khronos Group 的跨平台 Vulkan 与 Microsoft Windows 上的 Direct3D 12。</p><h3 id="2-2-历史"><a href="#2-2-历史" class="headerlink" title="2.2 历史"></a>2.2 历史</h3><p>2014年6月2日，Metal 开始支持iOS设备（仅支持Apple A7或更新款处理器的iPhone、iPad）；2015年6月8日，Metal 开始支持运行 OS X El Capitan 的Mac设备（仅2012年中或更新款机种）。</p><p>2017年6月5日，Apple于WWDC宣布了Metal的第二个版本，支持macOS High Sierra、iOS 11和tvOS 11。由于受相同硬件支持，Metal 2并不是Metal的独立API。 Metal 2在Xcode中实现了更高效的分析和调试，加速了机器学习、降低了CPU工作负载、支持macOS上的虚拟现实以及Apple A11处理器的特性。</p><p>在2020年WWDC 上，苹果宣布了Mac 移至 Apple Silicon计划。使用Apple 芯片的Mac电脑将突出Apple GPU的特征，这些曾在macOS 和iOS 上的体现过，也将能受益于Apple GPU的 贴图延迟渲染（TBDR）架构的特征。</p><h3 id="2-3-支持的CPU"><a href="#2-3-支持的CPU" class="headerlink" title="2.3 支持的CPU"></a>2.3 支持的CPU</h3><p>在iOS，tvOS，macOS中，Metal 支持苹果设计的A7以后的单片系统。</p><p>在macOS 中，metal也支持从HD4000 以后的 Intel 高清集成显示系统，也支持AMD GCM和 RDNA的GPU系列。</p><p>NVIDIA CPU 也受支持，但支持新设备（10系列起的新设备）的Metal 驱动程序从macOS 起已失效。</p><p><img src="/p/82a3d28c/01.jpg" alt="使用Metal的多人在线战斗竞技场游戏《虚荣》，运行于iPhone 6"></p><p>By Super Evil Megacorp, CC BY-SA 3.0, <a href="https://commons.wikimedia.org/w/index.php?curid=37251144">https://commons.wikimedia.org/w/index.php?curid=37251144</a></p><h2 id="二、Metal-案例1：渐变背景"><a href="#二、Metal-案例1：渐变背景" class="headerlink" title="二、Metal 案例1：渐变背景"></a>二、Metal 案例1：渐变背景</h2><h3 id="2-1-效果一览"><a href="#2-1-效果一览" class="headerlink" title="2.1 效果一览"></a>2.1 效果一览</h3><p><img src="/p/82a3d28c/02.gif"></p><h3 id="2-2-实现思路"><a href="#2-2-实现思路" class="headerlink" title="2.2 实现思路"></a>2.2 实现思路</h3><p><img src="/p/82a3d28c/03.png"></p><h3 id="2-3-代码分析"><a href="#2-3-代码分析" class="headerlink" title="2.3 代码分析"></a>2.3 代码分析</h3><h2 id="三、Metal-案例2：绘制一个三角形"><a href="#三、Metal-案例2：绘制一个三角形" class="headerlink" title="三、Metal 案例2：绘制一个三角形"></a>三、Metal 案例2：绘制一个三角形</h2><h2 id="四、比较Metal-与OpenGL"><a href="#四、比较Metal-与OpenGL" class="headerlink" title="四、比较Metal 与OpenGL"></a>四、比较Metal 与OpenGL</h2><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2>]]></content>
      
      
      
        <tags>
            
            <tag> opengl </tag>
            
            <tag> metal </tag>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉【03-OpenGL正背面剔除】</title>
      <link href="/p/bb33e4b9.html"/>
      <url>/p/bb33e4b9.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h3 id="1-1隐藏面消除"><a href="#1-1隐藏面消除" class="headerlink" title="1.1隐藏面消除"></a>1.1隐藏面消除</h3><p>绘制3D场景式，尤其是在透视投影时，需要决定目标的哪一部分展示，哪一部分隐藏。如下图所示，如果不做隐藏面消除的配置，在3D目标旋转时，会出现透视bug，有些不该出现的出现了。</p><p><img src="/p/bb33e4b9/01.webp" alt="开启深度测试前"></p><h3 id="1-2深度测试"><a href="#1-2深度测试" class="headerlink" title="1.2深度测试"></a>1.2深度测试</h3><h2 id="二、实现深度测试"><a href="#二、实现深度测试" class="headerlink" title="二、实现深度测试"></a>二、实现深度测试</h2><h3 id="2-1-创建3D目标"><a href="#2-1-创建3D目标" class="headerlink" title="2.1 创建3D目标"></a>2.1 创建3D目标</h3><h3 id="2-2-开启正背面剔除"><a href="#2-2-开启正背面剔除" class="headerlink" title="2.2 开启正背面剔除"></a>2.2 开启正背面剔除</h3><h3 id="2-2-开启深度测试"><a href="#2-2-开启深度测试" class="headerlink" title="2.2 开启深度测试"></a>2.2 开启深度测试</h3><p>在渲染方法里添加深度测试，开启深度测试的代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line"><span class="built_in">glFrontFace</span>(GL_CCW);</span><br><span class="line"><span class="built_in">glCullFace</span>(GL_BACK);</span><br></pre></td></tr></table></figure><p>开启后的效果：<br><img src="/p/bb33e4b9/02.webp" alt="开启深度测试后"></p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉【02-OpenGL创建正方形】</title>
      <link href="/p/d35ab8c1.html"/>
      <url>/p/d35ab8c1.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、目标结果"><a href="#一、目标结果" class="headerlink" title="一、目标结果"></a>一、目标结果</h2><p><img src="/p/d35ab8c1/001.gif"></p><h2 id="二、分析过程"><a href="#二、分析过程" class="headerlink" title="二、分析过程"></a>二、分析过程</h2><p>分析流程简图如下</p><p><img src="/p/d35ab8c1/002.png" alt="渲染流程简图"></p><h2 id="三、全部代码如下："><a href="#三、全部代码如下：" class="headerlink" title="三、全部代码如下："></a>三、全部代码如下：</h2><p>下面从main.cpp 的流水线讲解整个实现过程</p><h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1 准备工作"></a>3.1 准备工作</h3><h4 id="3-1-1-设置当前工作目录"><a href="#3-1-1-设置当前工作目录" class="headerlink" title="3.1.1 设置当前工作目录"></a>3.1.1 设置当前工作目录</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gltSetWorkingDirectory(argv[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>其中<code>argv</code> 源自<code>int main(int argc,char *argv[])&#123;&#125;</code> 函数的参数</p><h4 id="3-1-2-初始化GLUT的库"><a href="#3-1-2-初始化GLUT的库" class="headerlink" title="3.1.2 初始化GLUT的库"></a>3.1.2 初始化GLUT的库</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glutInit</span>(&amp;argc, argv);</span><br></pre></td></tr></table></figure><h4 id="3-1-3-初始化双缓冲区"><a href="#3-1-3-初始化双缓冲区" class="headerlink" title="3.1.3 初始化双缓冲区"></a>3.1.3 初始化双缓冲区</h4><p>初始化双缓冲窗口，其中标志<strong>GLUT_DOUBLE</strong>、<strong>GLUT_RGBA</strong>、<strong>GLUT_DEPTH</strong>、<strong>GLUT_STENCIL</strong>分别指双缓冲窗口、RGBA颜色模式、深度测试、模板缓冲区</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glutInitDisplayMode</span>(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL);</span><br></pre></td></tr></table></figure><h4 id="3-1-4-配置GLUT-窗口"><a href="#3-1-4-配置GLUT-窗口" class="headerlink" title="3.1.4 配置GLUT 窗口"></a>3.1.4 配置GLUT 窗口</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glutInitWindowSize</span>(<span class="number">300</span>, <span class="number">300</span>); <span class="comment">// 初始化窗口</span></span><br><span class="line"><span class="built_in">glutCreateWindow</span>(<span class="string">&quot;Triangle&quot;</span>); <span class="comment">// 配置创建窗口名</span></span><br></pre></td></tr></table></figure><h3 id="3-2-GLUT-内部循环"><a href="#3-2-GLUT-内部循环" class="headerlink" title="3.2 GLUT 内部循环"></a>3.2 GLUT 内部循环</h3><h4 id="3-2-1-注册重塑函数"><a href="#3-2-1-注册重塑函数" class="headerlink" title="3.2.1 注册重塑函数"></a>3.2.1 注册重塑函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glutReshapeFunc</span>(changeSize);</span><br></pre></td></tr></table></figure><p>ChangeSize函数，主要作用是窗口大小改变是，接收新的宽度和高度，实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">changeSize</span><span class="params">(<span class="type">int</span> w,<span class="type">int</span> h)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      x,y 参数代表窗口中视图的左下角坐标，而宽度、高度是像素为表示，通常x,y 都是为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-注册显示函数（渲染）"><a href="#3-2-2-注册显示函数（渲染）" class="headerlink" title="3.2.2 注册显示函数（渲染）"></a>3.2.2 注册显示函数（渲染）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glutDisplayFunc</span>(RenderScene);</span><br></pre></td></tr></table></figure><p>有以下步骤</p><ul><li><p><strong>清理一个或一组特定的缓冲区</strong></p><ul><li>GL_COLOR_BUFFER_BIT :指示当前激活的用来进行颜色写入缓冲区</li><li>GL_DEPTH_BUFFER_BIT :指示深度缓存区</li><li>GL_STENCIL_BUFFER_BIT:指示模板缓冲区</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);</span><br></pre></td></tr></table></figure></li><li><p>设置一组浮点数来表示红色</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GLfloat vRed[] = &#123;<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0f</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>传递到存储着色器</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed);</span><br></pre></td></tr></table></figure></li><li><p>提交着色器</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">triangleBatch.Draw();</span><br></pre></td></tr></table></figure></li><li><p>交换缓冲区：这里主要是讲后台缓冲区进行渲染，结束后把图像结果交给前台</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glutSwapBuffers</span>();</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-3-注册特殊函数（键位移动）"><a href="#3-2-3-注册特殊函数（键位移动）" class="headerlink" title="3.2.3 注册特殊函数（键位移动）"></a>3.2.3 注册特殊函数（键位移动）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glutSpecialFunc(SpecialKeys);</span><br></pre></td></tr></table></figure><p>其实这里的键位比较简单，主要步骤如下：</p><ol><li><p>设置按键每次移动的步长</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GLfloat stepSize = <span class="number">0.25f</span>;</span><br></pre></td></tr></table></figure></li><li><p>配置移动起始X, Y坐标，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GLfloat blockX = vVerts[0];</span><br><span class="line">GLfloat blockY = vVerts[10];</span><br></pre></td></tr></table></figure></li><li><p>移动后X，Y坐标，这里主要判断key </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key == GLUT_KEY_UP) &#123;</span><br><span class="line">    </span><br><span class="line">    blockY += stepSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key == GLUT_KEY_DOWN) &#123;</span><br><span class="line">    </span><br><span class="line">    blockY -= stepSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key == GLUT_KEY_LEFT) &#123;</span><br><span class="line">    blockX -= stepSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key == GLUT_KEY_RIGHT) &#123;</span><br><span class="line">    blockX += stepSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>边界碰撞的配置（碰撞后返回）</p><ul><li><p>碰到最左边</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (blockX &lt; <span class="number">-1.0f</span>) &#123;</span><br><span class="line">        blockX = <span class="number">-1.0f</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>碰到最右边</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.0 - blockSize * 2 = 总边长 - 正方形的边长 = 最左边点的位置</span></span><br><span class="line"><span class="keyword">if</span> (blockX &gt; (<span class="number">1.0</span> - blockSize * <span class="number">2</span>)) &#123;</span><br><span class="line">    blockX = <span class="number">1.0f</span> - blockSize * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>碰到最下边</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-1.0 - blockSize * 2 = Y（负轴边界） - 正方形边长 = 最下面点的位置</span></span><br><span class="line"><span class="keyword">if</span> (blockY &lt; <span class="number">-1.0f</span> + blockSize * <span class="number">2</span> ) &#123;</span><br><span class="line">    </span><br><span class="line">    blockY = <span class="number">-1.0f</span> + blockSize * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>碰到最顶边</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (blockY &gt; <span class="number">1.0f</span>) &#123;</span><br><span class="line">    blockY = <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>重新计算所有顶点</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vVerts[<span class="number">0</span>] = blockX;</span><br><span class="line">vVerts[<span class="number">1</span>] = blockY - blockSize*<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%f,%f)\n&quot;</span>,vVerts[<span class="number">0</span>],vVerts[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">vVerts[<span class="number">3</span>] = blockX + blockSize*<span class="number">2</span>;</span><br><span class="line">vVerts[<span class="number">4</span>] = blockY - blockSize*<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%f,%f)\n&quot;</span>,vVerts[<span class="number">3</span>],vVerts[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">vVerts[<span class="number">6</span>] = blockX + blockSize*<span class="number">2</span>;</span><br><span class="line">vVerts[<span class="number">7</span>] = blockY;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%f,%f)\n&quot;</span>,vVerts[<span class="number">6</span>],vVerts[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">vVerts[<span class="number">9</span>] = blockX;</span><br><span class="line">vVerts[<span class="number">10</span>] = blockY;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%f,%f)\n&quot;</span>,vVerts[<span class="number">9</span>],vVerts[<span class="number">10</span>]);</span><br></pre></td></tr></table></figure></li><li><p>添加顶点到缓冲区</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">triangleBatch.CopyVertexData3f(vVerts);</span><br></pre></td></tr></table></figure></li><li><p>通知重新渲染</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glutPostRedisplay</span>();</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-3-GLUEW-库安全"><a href="#3-3-GLUEW-库安全" class="headerlink" title="3.3 GLUEW 库安全"></a>3.3 GLUEW 库安全</h3><p>初始化一个GLEW库,确保OpenGL API对程序完全可用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GLenum status = glewInit();</span><br><span class="line"><span class="keyword">if</span> (GLEW_OK != status) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GLEW Error:%s\n&quot;</span>,glewGetErrorString(status));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-4-配置渲染环境"><a href="#3-4-配置渲染环境" class="headerlink" title="3.4 配置渲染环境"></a>3.4 配置渲染环境</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setupRC();</span><br></pre></td></tr></table></figure><h4 id="3-4-1-设置清屏颜色"><a href="#3-4-1-设置清屏颜色" class="headerlink" title="3.4.1 设置清屏颜色"></a>3.4.1 设置清屏颜色</h4><p>其实也是设置当前窗口的背景色</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glClearColor(<span class="number">0.98f</span>, <span class="number">0.80f</span>, <span class="number">0.7f</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="3-4-2-初始化固定着色器"><a href="#3-4-2-初始化固定着色器" class="headerlink" title="3.4.2 初始化固定着色器"></a>3.4.2 初始化固定着色器</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shaderManager.InitializeStockShaders();</span><br></pre></td></tr></table></figure><h4 id="3-4-3-顶点连接类型配置和提交缓冲区"><a href="#3-4-3-顶点连接类型配置和提交缓冲区" class="headerlink" title="3.4.3 顶点连接类型配置和提交缓冲区"></a>3.4.3 顶点连接类型配置和提交缓冲区</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">triangleBatch.Begin(GL_TRIANGLE_FAN, <span class="number">4</span>);</span><br><span class="line">triangleBatch.CopyVertexData3f(vVerts);</span><br><span class="line">triangleBatch.End();</span><br></pre></td></tr></table></figure><h3 id="3-5-添加到任务的-loop"><a href="#3-5-添加到任务的-loop" class="headerlink" title="3.5 添加到任务的 loop"></a>3.5 添加到任务的 loop</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glutMainLoop();</span><br></pre></td></tr></table></figure><h3 id="3-6-总流程main-的步骤"><a href="#3-6-总流程main-的步骤" class="headerlink" title="3.6 总流程main 的步骤"></a>3.6 总流程main 的步骤</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> gltSetWorkingDirectory(argv[<span class="number">0</span>]);</span><br><span class="line"> glutInit(&amp;argc, argv);</span><br><span class="line"> glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL);</span><br><span class="line"> glutInitWindowSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line"> glutCreateWindow(<span class="string">&quot;Triangle&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//注册重塑函数</span></span><br><span class="line"> glutReshapeFunc(changeSize);</span><br><span class="line"> <span class="comment">//注册显示函数</span></span><br><span class="line"> glutDisplayFunc(RenderScene);</span><br><span class="line"> <span class="comment">//注册特殊函数</span></span><br><span class="line">glutSpecialFunc(SpecialKeys);</span><br><span class="line"></span><br><span class="line"> GLenum status = glewInit();</span><br><span class="line"> <span class="keyword">if</span> (GLEW_OK != status) &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;GLEW Error:%s\n&quot;</span>,glewGetErrorString(status));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line"> setupRC();</span><br><span class="line"> glutMainLoop();</span><br></pre></td></tr></table></figure><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>这篇文章，简单的介绍了，在特定色彩下，绘制一个正方形，并且通过按键移动它，可以见到，OpenGL 语句还是相当的见解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉【01-搭建OpenGL开发环境】</title>
      <link href="/p/7b6be80a.html"/>
      <url>/p/7b6be80a.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、搭建环境"><a href="#一、搭建环境" class="headerlink" title="一、搭建环境"></a>一、搭建环境</h2><h3 id="1-1-环境准备："><a href="#1-1-环境准备：" class="headerlink" title="1.1 环境准备："></a>1.1 环境准备：</h3><ul><li><strong>开发环境：</strong>Mac OS、Xcode 11+</li><li>OpenGL 工具包（会在本文末尾提供）<ul><li>include 文件夹</li><li>libGLTools.a 静态文件</li></ul></li></ul><h3 id="1-2创建项目"><a href="#1-2创建项目" class="headerlink" title="1.2创建项目"></a>1.2创建项目</h3><p>注意，我们使用Mac 应用来熟悉OpenGL<br><img src="/p/7b6be80a/001.png"></p><h3 id="1-3-添加库"><a href="#1-3-添加库" class="headerlink" title="1.3 添加库"></a>1.3 添加库</h3><p>这里需要添加的是GLUT和OpenGL,这些都是苹果内置的。<br><strong>步骤</strong>：在Build Phrases - Link Binary With Libraries 里，点击加号后，搜索GLUT 和OpenGL添加，如下图：<br><img src="/p/7b6be80a/002.png"><br><img src="/p/7b6be80a/003.png"><br><img src="/p/7b6be80a/004.png"></p><h3 id="1-4-引入第三方库"><a href="#1-4-引入第三方库" class="headerlink" title="1.4 引入第三方库"></a>1.4 引入第三方库</h3><ol><li>将文件包内的<code>include</code> 文件夹里拖入拷贝至工程内<br> <img src="/p/7b6be80a/005.png"></li><li>把静态库 <code>libGTools.a</code> 拖入Framework 文件夹下<br> <img src="/p/7b6be80a/006.png"></li><li>结果的文件夹结构如下：<br> <img src="/p/7b6be80a/007.png"></li></ol><h3 id="1-5-单独引用-GLTools-h-和glew-h："><a href="#1-5-单独引用-GLTools-h-和glew-h：" class="headerlink" title="1.5 单独引用 GLTools.h 和glew.h："></a>1.5 单独引用 GLTools.h 和glew.h：</h3><p><strong>具体操作：</strong>在Build Phrases —— Complie Sources 添加GLTools.h 和glew.h文件。</p><p><strong>结果如下：</strong></p><p><img src="/p/7b6be80a/008.png"></p><h3 id="1-6-删掉多余代码："><a href="#1-6-删掉多余代码：" class="headerlink" title="1.6 删掉多余代码："></a>1.6 删掉多余代码：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">需要删除的有：</span><br><span class="line">* AppDelegate.h</span><br><span class="line">* AppDelegate.m</span><br><span class="line">* ViewController.h</span><br><span class="line">* ViewController.m</span><br><span class="line">* Main.stroyboard</span><br><span class="line">* main.m</span><br></pre></td></tr></table></figure><p>目录如图所示：<br>    <img src="/p/7b6be80a/009.png"></p><h3 id="1-7-添加启动文件-main-cpp"><a href="#1-7-添加启动文件-main-cpp" class="headerlink" title="1.7 添加启动文件 main.cpp"></a>1.7 添加启动文件 main.cpp</h3><ol><li><p>创建c++ 文件：<br> <img src="/p/7b6be80a/010.png"></p></li><li><p>添加 main 文件，注意关掉创建头文件的对勾<br> <img src="/p/7b6be80a/011.png"></p></li><li><p>创建基础代码，如下：</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>至此，本Demo 已经可以独立运行了</p><h2 id="二、扩展：绘制三角形"><a href="#二、扩展：绘制三角形" class="headerlink" title="二、扩展：绘制三角形"></a>二、扩展：绘制三角形</h2><h3 id="2-1-业务代码"><a href="#2-1-业务代码" class="headerlink" title="2.1 业务代码"></a>2.1 业务代码</h3><p>上面的环境搭建好了，何不来个小小的Demo 来验证一下，输入业务代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GLTools.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLUT/GLUT.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">GLBatch triangleBatch;</span><br><span class="line"></span><br><span class="line">GLShaderManager shaderManager;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChangeSize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span><br><span class="line">&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetupRC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    </span><br><span class="line">    shaderManager.InitializeStockShaders();</span><br><span class="line">    </span><br><span class="line">    GLfloat vVerts[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    triangleBatch.Begin(GL_TRIANGLES, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    triangleBatch.CopyVertexData3f(vVerts);</span><br><span class="line">    </span><br><span class="line">    triangleBatch.End();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RenderScene</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    GLfloat vRed[] = &#123;</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    shaderManager.UseStockShader(GLT_SHADER_IDENTITY, vRed);</span><br><span class="line">    </span><br><span class="line">    triangleBatch.Draw();</span><br><span class="line">    </span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    gltSetWorkingDirectory(argv[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    glutInit(&amp;argc, argv);</span><br><span class="line">    </span><br><span class="line">    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH | GLUT_STENCIL);</span><br><span class="line">    </span><br><span class="line">    glutInitWindowSize(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    </span><br><span class="line">    glutCreateWindow(<span class="string">&quot;Triangle&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    glutReshapeFunc(ChangeSize);</span><br><span class="line">    </span><br><span class="line">    glutDisplayFunc(RenderScene);</span><br><span class="line">    </span><br><span class="line">    GLenum err = glewInit();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (GLEW_OK != err) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;glew error: %s\n&quot;</span>, glewGetErrorString(err));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SetupRC();</span><br><span class="line">    </span><br><span class="line">    glutMainLoop();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-小bug-解决"><a href="#2-2-小bug-解决" class="headerlink" title="2.2 小bug 解决"></a>2.2 小bug 解决</h3><p>运行后发现会出现如下bug，</p><p><img src="/p/7b6be80a/012.png"> </p><p>这里提示的是饮用方式的不对，修改根据提示修改，结果如下：</p><p><img src="/p/7b6be80a/013.png"> </p><p>其他的错误提示也算大同小异，也一样的根据系统提示做修改。</p><h3 id="2-3-结果展示"><a href="#2-3-结果展示" class="headerlink" title="2.3 结果展示"></a>2.3 结果展示</h3><p>最终结果如下：</p><p><img src="/p/7b6be80a/014.png"> </p><p>在这里画了一个简单的三角形，并用红色进行和内部渲染。</p><h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>本文介绍了OpenGL环境搭建，并简单的通过业务代码创建了一个红色三角形，由于是初次接触，内部的语法不妨略过，享受一下结果，会在以后的章节进行步骤的详细讲解。</p><ul><li>附：Demo的 <a href="https://github.com/newjia/OpenGLDemo">Github下载</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> OpenGL </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离屏渲染-超详细解析</title>
      <link href="/p/7f336030.html"/>
      <url>/p/7f336030.html</url>
      
        <content type="html"><![CDATA[<h2 id="〇、序章"><a href="#〇、序章" class="headerlink" title="〇、序章"></a>〇、序章</h2><p>作为一个面试中经常出现的话题，离屏渲染（Offscreen rendering）恐怕是极高频率提起的——最熟悉的陌生人，我们多少知道一点，也了解到由于它的出现，会带来的屏幕刷新卡顿，滑动式不跟手等体验，但是又不是知道的那么透彻。在这篇文章里，我将比较详细的讲解一下其概念、发生的场景，以及解决方案。</p><h3 id="0-1-概念"><a href="#0-1-概念" class="headerlink" title="0.1 概念"></a>0.1 概念</h3><blockquote><p>离屏渲染，就是计算机在帧缓冲区外另外开辟一个区域，用来存储多个复杂涂层的组合绘制结果的过程。</p></blockquote><p>说到离屏渲染的概念，先得了解计算机屏幕刷新原理，以及与之对应的屏内渲染。</p><h4 id="①-屏内渲染（Inscreen-Rendering）："><a href="#①-屏内渲染（Inscreen-Rendering）：" class="headerlink" title="① 屏内渲染（Inscreen Rendering）："></a>① 屏内渲染（Inscreen Rendering）：</h4><p>CPU和GPU 可以在其自有的帧缓冲区（Frame Buffer Zone）内进行图像绘制，无需额外开辟空间，待绘制完成后将绘制结果直接进行渲染</p><h4 id="②-离屏渲染（Offscreen-Rendering）："><a href="#②-离屏渲染（Offscreen-Rendering）：" class="headerlink" title="② 离屏渲染（Offscreen Rendering）："></a>② 离屏渲染（Offscreen Rendering）：</h4><p>CPU与GPU 在渲染图像之前，由于工作任务的繁重，需要在当前GPU 的双帧缓冲区之外，额外开辟一个缓冲区用来绘制图像，这个缓冲区被称为离屏缓冲区（Offscreen Buffer zone），待绘制结束之后，系统将缓冲区绘制的结果渲染到帧缓冲区，进行图像展示。</p><h2 id="一、CPU-与-GPU"><a href="#一、CPU-与-GPU" class="headerlink" title="一、CPU 与 GPU"></a>一、CPU 与 GPU</h2><h3 id="1-1-名词解释"><a href="#1-1-名词解释" class="headerlink" title="1.1 名词解释"></a>1.1 名词解释</h3><blockquote><p><strong>CPU</strong>(<strong>C</strong>entral <strong>P</strong>rocessing <strong>U</strong>nit): 是计算机的主要设备之一，功能主要是解释计算机指令以及处理计算机软件中的数据。</p><p><strong>GPU</strong>（<strong>G</strong>raphics <strong>P</strong>rocessing <strong>U</strong>nit）：又称为显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备上运行绘图运算工作的微处理器。</p></blockquote><h3 id="1-2-组织架构："><a href="#1-2-组织架构：" class="headerlink" title="1.2 组织架构："></a>1.2 组织架构：</h3><h4 id="1-2-1-CPU-组织架构"><a href="#1-2-1-CPU-组织架构" class="headerlink" title="1.2.1 CPU 组织架构"></a>1.2.1 CPU 组织架构</h4><p>CPU 主要有以下组织：</p><ul><li>Control：控制器</li><li>ALU： 算术逻辑单元</li><li>CACHE：缓存区</li><li>DRAM：动态随机存储器</li></ul><p>示意图如下：</p><p><img src="/p/7f336030/0.gif" alt="CPU 输入输出逻辑结构"></p><p><img src="/p/7f336030/6.png" alt="CPU 的组织架构"></p><h4 id="1-2-2-GPU组织架构"><a href="#1-2-2-GPU组织架构" class="headerlink" title="1.2.2 GPU组织架构"></a>1.2.2 GPU组织架构</h4><p>GPU有如下组织构成：</p><ol><li><strong>BIF</strong>（Bus Interface）：总线接口</li><li><strong>PMU</strong>（Power Management Unit）: 电源管理单元</li><li><strong>VPU</strong>（Video Processing Unit）：视频处理单元</li><li><strong>DIF</strong>（Display Interface）：显示接口</li><li><strong>GMC</strong>（Graphic Memory Controller）：图像内存控制器</li><li><strong>GCA</strong>（Graphic and Compute Array）：图形和计算数组</li></ol><p>如下：</p><p><img src="/p/7f336030/5.png" alt="GPU 组织架构"></p><h3 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3 特点"></a>1.3 特点</h3><table><thead><tr><th>类型</th><th>身份与作用</th><th>特点</th><th>特点</th></tr></thead><tbody><tr><td>CPU</td><td>运算核心&#x2F;控制</td><td>逻辑复杂，处理数据</td><td>依赖性非常高，假并发</td></tr><tr><td>GPU</td><td>绘图运算的微处理器</td><td>逻辑简单，绘制图形</td><td>依赖性低，多核真正并发</td></tr></tbody></table><h2 id="二、计算机渲染原理"><a href="#二、计算机渲染原理" class="headerlink" title="二、计算机渲染原理"></a>二、计算机渲染原理</h2><h3 id="2-1-计算机扫描方式"><a href="#2-1-计算机扫描方式" class="headerlink" title="2.1 计算机扫描方式"></a>2.1 计算机扫描方式</h3><h4 id="2-1-1-随机扫描显示"><a href="#2-1-1-随机扫描显示" class="headerlink" title="2.1.1 随机扫描显示"></a>2.1.1 随机扫描显示</h4><p>随机扫描显示，常见于老的CRT 显示器，通过固定的线段来画出图形的线段，流程是从屏幕中的一个点移动到下一个点。在画完图后，系统会循环回到第一行，重复绘制下一个图形。</p><p>该过程如图所示：<br><img src="http://www.srcmini.com/wp-content/uploads/2020/03/random-scan-display.png"></p><p><strong>优点如下：</strong></p><ul><li>电子束仅仅指向绘制图形的部分区域屏幕</li><li>产生的线条是平滑的</li><li>分辨率较高</li></ul><p><strong>缺点：</strong></p><p>无法绘制较为复杂的阴影场景</p><h4 id="2-1-2-光栅扫描显示"><a href="#2-1-2-光栅扫描显示" class="headerlink" title="2.1.2 光栅扫描显示"></a>2.1.2 光栅扫描显示</h4><p><img src="/p/7f336030/41.png"></p><h5 id="2-1-2-1-概念"><a href="#2-1-2-1-概念" class="headerlink" title="2.1.2.1 概念"></a>2.1.2.1 概念</h5><p>光栅扫描效果如下图所示，它是由电极发射电子束从上到下，从左到右依次扫描，形成图形。</p><h5 id="2-1-2-2-特点"><a href="#2-1-2-2-特点" class="headerlink" title="2.1.2.2 特点"></a>2.1.2.2 特点</h5><ul><li><p>左上角开始横向扫描</p></li><li><p>依次纵向扫描</p></li><li><p>由像素阵列组成</p></li><li><p>显示整个光栅所需的时间</p></li><li><p>扫描只与屏幕像素油管，而和图像<strong>无关</strong></p></li><li><p>扫描会产生视觉暂留</p><ul><li>16帧-保证连贯</li></ul></li></ul><h5 id="2-1-2-3-优点如下："><a href="#2-1-2-3-优点如下：" class="headerlink" title="2.1.2.3 优点如下："></a>2.1.2.3 优点如下：</h5><ol><li>逼真的形象</li><li>数百万种将生成的颜色</li><li>阴影场景是可能的。</li></ol><h5 id="2-1-2-4-缺点如下："><a href="#2-1-2-4-缺点如下：" class="headerlink" title="2.1.2.4 缺点如下："></a>2.1.2.4 缺点如下：</h5><ol><li>低解析度</li><li>昂贵</li></ol><h4 id="2-1-3-光栅扫描结构"><a href="#2-1-3-光栅扫描结构" class="headerlink" title="2.1.3 光栅扫描结构"></a>2.1.3 光栅扫描结构</h4><ul><li><p>显示器</p></li><li><p>视频控制器 - </p><ul><li>负责控制刷新 - 管理帧缓冲区与缓冲器</li><li>负责将帧缓冲区的内容绘制到显示器</li></ul></li><li><p>帧缓冲区</p><ul><li>由阵列组成</li><li>存储颜色值（黑白值）</li><li>又名：显存</li><li>连续的计算机存储空间，存储即将显示的渲染数据</li><li>计算：大小 60 * 60 的图片 &#x3D; 60 * 60 * 4 （RGBA） &#x3D; 14400bit</li></ul></li><li><p>简单光栅扫描显示系统结构</p><ul><li>系统总线<ul><li>CPU</li><li>系统内存</li><li>显示处理器  <ul><li>显示处理器存储区</li><li>帧缓冲区</li></ul></li></ul></li><li>显示控制器</li><li>显示器</li></ul></li></ul><h3 id="2-2-计算机渲染流程"><a href="#2-2-计算机渲染流程" class="headerlink" title="2.2 计算机渲染流程"></a>2.2 计算机渲染流程</h3><p><img src="/p/7f336030/31.png" alt="计算机渲染流程"></p><h2 id="三、iOS-环境下渲染原理"><a href="#三、iOS-环境下渲染原理" class="headerlink" title="三、iOS 环境下渲染原理"></a>三、iOS 环境下渲染原理</h2><h3 id="3-1-渲染流程"><a href="#3-1-渲染流程" class="headerlink" title="3.1 渲染流程"></a>3.1 渲染流程</h3><p>iOS 下的流程如下图所示，总结为一下几个步骤：</p><ol><li>App 配置图形代码。如生成一个 UIImageView 或 CoreAnimation动画的生成</li><li>iOS 框架代码的调用。通常有CoreGraphics、CoreAnimation和CoreImage。</li><li>系统底层引擎的调用与图形绘制计算。这部分工作交由OpenGL ES 或者原生的Metal 来完成。</li><li>调用系统显存GPU驱动器。</li><li>通过GPU 驱动器，将绘制计算好的数据存入GPU 也就是帧缓冲区。</li><li>通过视频控制器将GPU 内绘制好的数据，按照每帧的方式显示在显示器上面。</li></ol><p><img src="/p/7f336030/4.png" alt="计算机渲染流程"></p><h3 id="3-2-iOS-下的CoreAnimation"><a href="#3-2-iOS-下的CoreAnimation" class="headerlink" title="3.2 iOS 下的CoreAnimation"></a>3.2 iOS 下的CoreAnimation</h3><h4 id="3-2-1-结构"><a href="#3-2-1-结构" class="headerlink" title="3.2.1 结构"></a>3.2.1 结构</h4><p>UIKit&#x2F;AppKit为表层，来驱动 CoreAnimation 驱动 Metal&#x2F;CoreGraphic 来驱动图形硬件</p><blockquote><p>Render, compose, and animate visual elements –Apple</p><p>渲染，构建，和将视觉组件构成动画 —— Apple</p></blockquote><h4 id="3-2-2-layer"><a href="#3-2-2-layer" class="headerlink" title="3.2.2 layer"></a>3.2.2 layer</h4><blockquote><h1 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h1><p>An object that manages image-based content and allows you to perform animations on that content.</p></blockquote><p>用来显示位图，比如有<code>content</code> 属性</p><ul><li><p>UIView</p><ul><li>绘制和动画</li><li>布局和子View 的管理</li><li>点击事件管理</li></ul></li><li><p>CALayer </p><ul><li>渲染</li><li>动画</li></ul></li></ul><h2 id="四、CoreAnimation-渲染"><a href="#四、CoreAnimation-渲染" class="headerlink" title="四、CoreAnimation 渲染"></a>四、CoreAnimation 渲染</h2><h3 id="4-1-Application-应用"><a href="#4-1-Application-应用" class="headerlink" title="4.1 Application - 应用"></a>4.1 Application - 应用</h3><ul><li>HandleEvents - 处理事件</li><li>Commit Transaction - 提交事件，如（图片解码）</li></ul><h3 id="4-2-RenderServer-渲染服务"><a href="#4-2-RenderServer-渲染服务" class="headerlink" title="4.2 RenderServer - 渲染服务"></a>4.2 RenderServer - 渲染服务</h3><p>主要做以下两组工作：</p><ul><li>Decode - 解码</li><li>Draw Calls - 显示调用（需要等待下一个Runloop）</li></ul><h3 id="4-3-GPU-内的操作"><a href="#4-3-GPU-内的操作" class="headerlink" title="4.3 GPU 内的操作"></a>4.3 GPU 内的操作</h3><ul><li>会将 CoreAnimation 提交OpenGL</li><li>调用GPU 开启渲染流程<ul><li>顶点数据</li><li>顶点着色器</li><li>偏远着色器</li></ul></li></ul><h3 id="4-4-显示"><a href="#4-4-显示" class="headerlink" title="4.4 显示"></a>4.4 显示</h3><p>在下一个Runloop，从帧缓冲区提取数据，显示到屏幕</p><h2 id="五、画面撕裂卡顿与掉帧"><a href="#五、画面撕裂卡顿与掉帧" class="headerlink" title="五、画面撕裂卡顿与掉帧"></a>五、画面撕裂卡顿与掉帧</h2><h3 id="5-1-画面撕裂"><a href="#5-1-画面撕裂" class="headerlink" title="5.1 画面撕裂"></a>5.1 画面撕裂</h3><ul><li><p>定义</p><p>在G-SYNC中有一个很重要的关键词，那就是“屏幕刷新率”。对于传统显示屏来说，它的屏幕刷新率是固定的，例如60Hz的刷新率，就是指每秒钟固定刷新60帧图像。如果说显卡输出图像的速度与刷新率刚好吻合，那意味着每一张图像都可以显示在用户面前，形成一个连贯、流畅影像。</p><p><img src="http://img.expreview.com/review/2015/07/G-sync/G-Sync-1.jpg"></p><p>但是在现实中显卡输出的图像帧率并不是固定的，它输出一帧图像的时间可能会高于1&#x2F;60秒，也能会低于1&#x2F;60秒，这样显卡的输出帧率与屏幕刷新率就不同步了。当输出帧率高于屏幕刷新率的时候，显卡输出的图像就不一定每一帧都能显示在屏幕上，如果画面恰好处于动态变换的过程中，这样的影像就不连贯了，有可能会产生“图像上半部分是前一帧，下半部分是后一帧”的问题，通俗来说就是图像撕裂。</p></li><li><p>效果图</p><p> <img src="/p/7f336030/005.jpg" alt="分裂成3段的图片"></p></li><li><p>原因</p><p>在60Hz 的扫描率下，在1&#x2F;60秒周期过后，CPU 交互给GPU 的计算工作未完成，无法给予最新的图片，故帧缓冲区未及时更新，还是上一帧的内容。</p></li><li><p>苹果解决方案</p><ol><li><p>垂直同步 Vsync （Vertical sync）</p><ul><li>帧缓冲区加锁</li><li>扫描未完成，显示图片全是上一帧的图片</li><li>保证图片的扫描是完整的</li></ul></li><li><p>双缓冲区</p><p>两个缓冲区，一个展示时，另一个在做准备</p><p>&#x2F;&#x2F; 图片</p></li><li><p>缺点：<strong>掉帧</strong></p></li></ol></li></ul><h3 id="5-2-卡顿与掉帧"><a href="#5-2-卡顿与掉帧" class="headerlink" title="5.2 卡顿与掉帧"></a>5.2 卡顿与掉帧</h3><h4 id="5-2-1-掉帧："><a href="#5-2-1-掉帧：" class="headerlink" title="5.2.1 掉帧："></a>5.2.1 掉帧：</h4><ul><li><p>原因：当接受到Vsync 垂直信号时，CPU&#x2F;GPU 的 计算还未完成（准备好），控制器会从帧缓冲区取出并显示上一帧的图像，从而本帧为正确显示，成为掉帧</p></li><li><p>三缓冲区：</p><ul><li>CPU&#x2F;GPU运算时，还有个缓冲区可以存储数据</li></ul></li></ul><h4 id="5-2-2-屏幕卡顿"><a href="#5-2-2-屏幕卡顿" class="headerlink" title="5.2.2 屏幕卡顿"></a>5.2.2 屏幕卡顿</h4><ul><li>CPU&#x2F;GPU 渲染流水线耗时过长，导致<strong>掉帧</strong></li><li>Vsync + doubleBuffering 为了解决屏幕撕裂，会付出掉帧的代价</li><li><strong>三缓冲区时</strong>：合理使用CPU&#x2F;GPU，仅仅是减少了掉帧的次数</li></ul><h2 id="六、产生原因"><a href="#六、产生原因" class="headerlink" title="六、产生原因"></a>六、产生原因</h2><h3 id="6-1-垂直同步Vsync-与双缓冲区"><a href="#6-1-垂直同步Vsync-与双缓冲区" class="headerlink" title="6.1 垂直同步Vsync 与双缓冲区"></a>6.1 垂直同步Vsync 与双缓冲区</h3><h4 id="6-1-1-垂直同步"><a href="#6-1-1-垂直同步" class="headerlink" title="6.1.1 垂直同步"></a>6.1.1 垂直同步</h4><p>苹果对移动设备采用的是垂直同步Vsync + 双缓冲区的策略：计算机发出<strong>垂直信号</strong>，向显存——也就是帧缓冲区（Frame Buffer Zone）索取计CPU和GPU 绘制好的帧图像，从而由视频控制器显示到屏幕中，接下来发出下一次垂直信号。</p><p>这个周期由刷新频率而定，一般来说屏幕刷新频率是60Hz，这样每个刷新周期，就是16.666ms（1 &#x2F;60 * 1000）。</p><p><img src="/p/7f336030/007.png" alt="iOS正常的渲染流程"></p><h3 id="6-2-离屏缓冲区最终由来"><a href="#6-2-离屏缓冲区最终由来" class="headerlink" title="6.2 离屏缓冲区最终由来"></a>6.2 离屏缓冲区最终由来</h3><ol><li>一旦绘制的图层较多，以及对图层绘制较为复杂（设置圆角、透明度以及阴影等），由于帧缓冲区对绘制的图层使用完毕会之后都会丢弃，就无法满足保存临时结果。</li><li>为了使得多个图层的绘制结果能再处理过程中得以保留，系统会自动开辟一个缓冲区——离屏缓冲区，用来保存临时生成的结果。</li><li>当所有的图层运算完毕，系统将礼品缓冲区的绘制结果放入帧缓冲区，由帧缓冲区交付结果，显示到屏幕中。</li></ol><p><img src="/p/7f336030/008.png" alt="iOS离屏渲染下的渲染流程"></p><h3 id="6-3-渲染举例"><a href="#6-3-渲染举例" class="headerlink" title="6.3 渲染举例"></a>6.3 渲染举例</h3><h3 id="6-3-1-代码"><a href="#6-3-1-代码" class="headerlink" title="6.3.1 代码"></a>6.3.1 代码</h3><p>我们举例，一个视图上放一张图片视图，代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addContentView&#123;</span><br><span class="line">    UIView *contentView = [[UIView alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">300</span>)];</span><br><span class="line">    contentView.backgroundColor = [UIColor redColor];</span><br><span class="line">    contentView.layer.cornerRadius = <span class="number">20</span>;</span><br><span class="line">    contentView.layer.masksToBounds = YES;</span><br><span class="line">    [self.view addSubview:contentView];</span><br><span class="line">    </span><br><span class="line">    UIImageView *iv = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@<span class="string">&quot;saga.jpg&quot;</span>]];</span><br><span class="line">    iv.backgroundColor = [UIColor blueColor];</span><br><span class="line">    iv.layer.cornerRadius = <span class="number">20</span>;</span><br><span class="line">    iv.layer.masksToBounds = YES;</span><br><span class="line">    iv.frame = <span class="built_in">CGRectMake</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">150</span>);</span><br><span class="line">    [contentView addSubview:iv];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，打开模拟器，在Device 中打开 离屏渲染检测按钮—— Color off-screen Rendered ，即</p><img src="/p/7f336030/011.png" style="zoom:50%;"><p>可以得到如下的图片，四周的黄色区域显示——设置过背景和圆角的这张图片，已经参与了离屏渲染了：<img src="/p/7f336030/010.png" style="zoom:50%;"></p><img src="/p/7f336030/009.png" alt="图层示意图" style="zoom: 25%;"><p><strong>原因：</strong>两个图层进行了绘制并融合，需要开辟离屏渲染区域。</p><h2 id="七、优点、缺点与特性"><a href="#七、优点、缺点与特性" class="headerlink" title="七、优点、缺点与特性"></a>七、优点、缺点与特性</h2><h3 id="7-1-优点："><a href="#7-1-优点：" class="headerlink" title="7.1 优点："></a>7.1 优点：</h3><ul><li>可以解决复杂图层渲染</li><li>复用复杂图形：如果图像多次出现，可以保存在离屏渲染缓冲区，达到<strong>复用</strong>的优点。</li></ul><h3 id="7-2-缺点："><a href="#7-2-缺点：" class="headerlink" title="7.2 缺点："></a>7.2 缺点：</h3><ul><li><p>性能问题——掉帧</p><p>由于离屏渲染往往是要承担较为复杂的绘制过程，通常是超过1个图层的复杂绘制，当硬件性能低下，以及绘制图层复杂双重压力下，CPU 往往无法在一个扫描周期——也就是16.67ms 内完成绘制工作并交付GPU，为了维护图片的完整性，系统会选用上一帧的图片来显示，虽然只是1帧图像的滞后，肉眼还是能察觉到图片的滞后——尤其是在视图滚动时，更为明显，这就是我们常常提到的掉帧。</p></li></ul><h3 id="7-3-特性"><a href="#7-3-特性" class="headerlink" title="7.3 特性"></a>7.3 特性</h3><ul><li><strong>自动触发</strong></li><li>空间有限制：大小为屏幕像素的2.5倍</li></ul><h3 id="8-4-离屏渲染的模式"><a href="#8-4-离屏渲染的模式" class="headerlink" title="8.4 离屏渲染的模式"></a>8.4 离屏渲染的模式</h3><ol><li>拿到第一个图层，结果放入离屏渲染区</li><li>拿到第二个图层，结果放入离屏渲染区</li><li>拿到第三个图层，结果放入离屏渲染区</li><li>从离屏渲染区，获取第一个图层，添加圆角</li><li>从离屏渲染区，获取第二个图层，添加圆角</li><li>从离屏渲染区，获取第三个图层，添加圆角</li><li>3个图层，进行组合，放入帧缓冲区</li><li>进行显示到屏幕</li></ol><p>小结： 多个图层特殊处理，每一步都需要临时的存出结果</p><h2 id="八、产生的场景"><a href="#八、产生的场景" class="headerlink" title="八、产生的场景"></a>八、产生的场景</h2><h3 id="8-1-圆角"><a href="#8-1-圆角" class="headerlink" title="8.1 圆角"></a>8.1 圆角</h3><p>对，就是圆角，可能印象中，设置了圆角就会带来离屏渲染，真的是这样吗？</p><p>先看看苹果对圆角（cornerRadius）的定义：</p><blockquote><p>Setting the radius to a value greater than <code>0.0</code> causes the layer to begin drawing rounded corners on its background. By default, the corner radius does not apply to the image in the layer’s <a href="apple-reference-documentation://hc8wq1-J90"><code>contents</code></a> property; it applies only to the background color and border of the layer. However, setting the <a href="apple-reference-documentation://hciTGlVHPz"><code>masksToBounds</code></a> property to <code>YES</code> causes the content to be clipped to the rounded corners. </p></blockquote><p>简单的翻一下：</p><blockquote><p>当给定radius 超过0.0 会导致图层（layer）开始在<strong>其背景</strong>中绘制圆角。默认下，圆角半径不会应用到图层的内容属性的图像中；它只会应用到其背景和自身的边界线中。因此，将<code>maskToBounds</code>设置成<code>YES</code>，会导致内容切成圆角。</p></blockquote><p>由此可以得到两个结论</p><ul><li>设置 cornerRadius 不会渲染该图层的内容图像</li><li>设置 corner Radius 只会渲染 layer 的边框及背景</li><li>属性 maskToBounds 设置YES，会切成圆角</li></ul><h3 id="8-2-开启了光栅化-shouldRasterize"><a href="#8-2-开启了光栅化-shouldRasterize" class="headerlink" title="8.2 开启了光栅化 shouldRasterize"></a>8.2 开启了光栅化 shouldRasterize</h3><ul><li>如果layer 不能被复用，则没有必要打开光栅化</li><li>如果layer 不是静态的，需要被频繁修改，比如处于动画之中，那么开启离屏渲染反而影响效率</li><li>离屏渲染缓存内容有时间限制，缓存内容100ms 内容如果没有被使用，那么它就会丢弃；无法进行复用了</li><li>离屏渲染缓存空间有限，超过2.5 倍屏幕像素大小，也会失效，且无法进行复用</li></ul><h3 id="8-3-常见的触发场景"><a href="#8-3-常见的触发场景" class="headerlink" title="8.3 常见的触发场景"></a>8.3 常见的触发场景</h3><ul><li>使用了 mask 的layer layer.mask</li><li>需要进行裁剪的layer —— layer.maskToBound &#x2F; view.clipToBounds</li><li>设置了组透明为YES， 且透明度部位1 的layer —— layer.allowsGroupOpacity&#x2F;layer.opacity</li><li>添加了投影的layer —— layer.shadow</li><li>采用了光栅化的 layer —— layer.shouldRasterize</li><li>绘制了文字的 layer —— UILabel 、CATextLayer、 CoreText等</li></ul><h2 id="九、解决方案"><a href="#九、解决方案" class="headerlink" title="九、解决方案"></a>九、解决方案</h2><h3 id="10-1-方案一：单一图片圆角"><a href="#10-1-方案一：单一图片圆角" class="headerlink" title="10.1 方案一：单一图片圆角"></a>10.1 方案一：单一图片圆角</h3><p>设置切歌边角，以及圆角半径</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">imageView.clipToBounds = YES;</span><br><span class="line">imageView.layer.cornerRadius = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="9-3-方案二：将圆角图片绘制成位图（YYImage）"><a href="#9-3-方案二：将圆角图片绘制成位图（YYImage）" class="headerlink" title="9.3 方案二：将圆角图片绘制成位图（YYImage）"></a>9.3 方案二：将圆角图片绘制成位图（YYImage）</h3><p>这个方案在YYImaage 中已经做得非常好了，主要的原理是，根据传入的圆角，CPU进行上下文重绘制，得到UIImage 图片，由于最终得到的图像只有一张图片，自然不会离屏渲染了，相关代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (UIImage *)imageByRoundCornerRadius:(CGFloat)radius</span><br><span class="line">                              corners:(UIRectCorner)corners</span><br><span class="line">                          borderWidth:(CGFloat)borderWidth</span><br><span class="line">                          borderColor:(UIColor *)borderColor</span><br><span class="line">                       borderLineJoin:(CGLineJoin)borderLineJoin &#123;</span><br><span class="line">    </span><br><span class="line">    if (corners != UIRectCornerAllCorners) &#123;</span><br><span class="line">        UIRectCorner tmp = 0;</span><br><span class="line">        if (corners &amp; UIRectCornerTopLeft) tmp |= UIRectCornerBottomLeft;</span><br><span class="line">        if (corners &amp; UIRectCornerTopRight) tmp |= UIRectCornerBottomRight;</span><br><span class="line">        if (corners &amp; UIRectCornerBottomLeft) tmp |= UIRectCornerTopLeft;</span><br><span class="line">        if (corners &amp; UIRectCornerBottomRight) tmp |= UIRectCornerTopRight;</span><br><span class="line">        corners = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(self.size, NO, self.scale);</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</span><br><span class="line">    CGContextScaleCTM(context, 1, -1);</span><br><span class="line">    CGContextTranslateCTM(context, 0, -rect.size.height);</span><br><span class="line">    </span><br><span class="line">    CGFloat minSize = MIN(self.size.width, self.size.height);</span><br><span class="line">    if (borderWidth &lt; minSize / 2) &#123;</span><br><span class="line">        UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];</span><br><span class="line">        [path closePath];</span><br><span class="line">        </span><br><span class="line">        CGContextSaveGState(context);</span><br><span class="line">        [path addClip];</span><br><span class="line">        CGContextDrawImage(context, rect, self.CGImage);</span><br><span class="line">        CGContextRestoreGState(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (borderColor &amp;&amp; borderWidth &lt; minSize / 2 &amp;&amp; borderWidth &gt; 0) &#123;</span><br><span class="line">        CGFloat strokeInset = (floor(borderWidth * self.scale) + 0.5) / self.scale;</span><br><span class="line">        CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset);</span><br><span class="line">        CGFloat strokeRadius = radius &gt; self.scale / 2 ? radius - self.scale / 2 : 0;</span><br><span class="line">        UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:corners cornerRadii:CGSizeMake(strokeRadius, borderWidth)];</span><br><span class="line">        [path closePath];</span><br><span class="line">        </span><br><span class="line">        path.lineWidth = borderWidth;</span><br><span class="line">        path.lineJoinStyle = borderLineJoin;</span><br><span class="line">        [borderColor setStroke];</span><br><span class="line">        [path stroke];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-方案三：-在现有图层上方遮罩图片"><a href="#10-3-方案三：-在现有图层上方遮罩图片" class="headerlink" title="10.3 方案三： 在现有图层上方遮罩图片"></a>10.3 方案三： 在现有图层上方遮罩图片</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@<span class="function">interface <span class="title">RoundImageView</span><span class="params">()</span></span></span><br><span class="line"><span class="function">@<span class="title">property</span> <span class="params">(strong, nonatomic)</span> UIImageView *maskView</span>;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation RoundImageView</span><br><span class="line"></span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</span><br><span class="line">        _maskView = [[UIImageView alloc] initWithFrame:CGRectZero];</span><br><span class="line">        _maskView.image = [UIImage imageNamed:@<span class="string">&quot;maskIV&quot;</span>];</span><br><span class="line">        [self addSubview:_maskView];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)layoutSubviews&#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    CGRect bounds = self.bounds;</span><br><span class="line">    _maskView.frame = bounds;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从上文得知，离屏渲染是苹果为较为复杂的图像效果做出的一种妥协方案，作为一种空间换时间的方案，必然会损失一些性能，为了挽回这些损失，我们只有在深入理解背后的原理后，方能做到较为理想的结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 离屏渲染 </tag>
            
            <tag> offscreen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉【02-OpenGL概念篇】</title>
      <link href="/p/7fad6178.html"/>
      <url>/p/7fad6178.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、计算机视觉简介"><a href="#一、计算机视觉简介" class="headerlink" title="一、计算机视觉简介"></a>一、计算机视觉简介</h2><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念:"></a>1.1 概念:</h4><p><strong>计算机视觉</strong>（Computer Vision）是一门跨学科科学，用于处理计算机如何从数码相片或视频中获取高层次理解。从工程学的角度来讲，它的目的是理解并将人类视觉系统的工作任务自动化。</p><blockquote><p>计算机视觉（Computer vision）是一门研究如何使机器“看”的科学，更进一步的说，就是指用摄影机和计算机代替人眼对目标进行识别、跟踪和测量等机器视觉，并进一步做图像处理，用计算机处理成为更适合人眼观察或传送给仪器检测的图像。</p><p>——黄亚勤《基于视线跟踪技术的眼控鼠标研究与实现》</p></blockquote><p><img src="https://photojournal.jpl.nasa.gov/jpeg/PIA04413.jpg" alt="NASA好奇号火星探测车（图片版权：NASA）"></p><h4 id="1-2-演进历史"><a href="#1-2-演进历史" class="headerlink" title="1.2 演进历史"></a>1.2 演进历史</h4><p>从1960年后期，作为人工智能的先锋学科，计算机视觉在大学校园里开始开设。它起初被用来模拟人类视觉系统，借此赋予机器人智能的行为。在1966年，人们相信该目的可以被达成，通过将一枚摄像头附属到计算机上并让其”展示所看到“。</p><p>真正将计算机视觉从流行的领域数字图像处理区别开来的时机，是一个将3D结构从图像中抽取出来并达到全景理解的需求。1970年代的一些研究，最终形成了现今存在的计算机视觉算法的早期框架，包括<strong>图像的边缘提取</strong>，<strong>线段标签</strong>，<strong>非多面体与多面体的模型</strong>，<strong>将对象表示为较小结构的互连</strong>，<strong>光流</strong>，和<strong>运动估计</strong>。</p><p>接下来的<strong>十年</strong>见证了基于更多严谨的数学分析和计算机视觉量化的方向。这些包括了<strong>空间刻度</strong>概念，形状的多种线索提示比如<strong>阴影</strong>、<strong>纹理</strong>、<strong>焦点</strong>，以及被称为snakes 的轮廓模型。</p><p>在1990年代，一些先前的研究话题变得比其他的更为活跃，三维重建引导了更好的相机标定的理解。随着相机标定的优化技术的发展，人们意识到，从摄影测量学领域的束调整理论中已经探索了许多想法。这推动了从多个图像中进行稀疏三维场景重建的方法。</p><h4 id="1-2-关联领域："><a href="#1-2-关联领域：" class="headerlink" title="1.2 关联领域："></a>1.2 关联领域：</h4><ul><li>人工智能</li><li>信息工程</li><li>固态物理学</li><li>神经生物学</li><li>信号处理</li><li>其他领域</li></ul><h3 id="1-2-OpenGL-是什么"><a href="#1-2-OpenGL-是什么" class="headerlink" title="1.2 OpenGL 是什么"></a>1.2 OpenGL 是什么</h3><p>OpenGL（Open Graphic Library）是一种应用程序编程接口（Application Programming Interface, API），它是一种可以对图形硬件设备特性进行访问的软件库。</p><h2 id="二、概念"><a href="#二、概念" class="headerlink" title="二、概念"></a>二、概念</h2><h3 id="1-上下文-Context："><a href="#1-上下文-Context：" class="headerlink" title="1. 上下文 Context："></a>1. <strong>上下文</strong> Context：</h3><p>一组完整的 OpenGL 状态变量。注意帧缓存的内容不属于OpenGL 状态的一部分，但是帧缓存的配置（以及相关的渲染缓存）属于它的一部分。</p><h3 id="2-状态机"><a href="#2-状态机" class="headerlink" title="2. 状态机"></a>2. <strong>状态机</strong></h3><p>理论上是OpenGL用来形容状态的工具。它描述了对象在生命周期中的各种状态、状态间发生的转变、发生转变的原因、条件及转变中执行的过程。一般具有以下特点：</p><ul><li>有记忆功能，记忆当前的状态</li><li>可以接收输入，根据输入的内容和自己的院线状态，修改自己当前状态，并且可以有对应的输出</li><li>当进入特殊状态（如停机）的时候，变不再接受输入，停止工作。</li></ul><h3 id="3-渲染-Rendering"><a href="#3-渲染-Rendering" class="headerlink" title="3. 渲染 - Rendering"></a>3. <strong>渲染</strong> - Rendering</h3><p>将图形&#x2F;图像数据转换成2D空间图像的操作。</p><ul><li>渲染器 - Renderer<br>Apple Computer 的Mac OS X 操作系统的OpenGL 实现。由于一台计算机可能有多个图形功能的设备（如多个图形卡或软件实现），因此一台Mac OS X 机器上也许可以支持多个渲染器。</li></ul><h3 id="4-顶点数组-VertexArray"><a href="#4-顶点数组-VertexArray" class="headerlink" title="4. 顶点数组 VertexArray"></a>4. <strong>顶点数组</strong> VertexArray</h3><p>顶点数据的块（顶点坐标、纹理坐标、表面法线、RGBA颜色、颜色索引、边界标志）可以存储在一个数组中，然后通过使用单个OpenGL 命令的执行，设置多个几何图元。</p><h3 id="5-顶点缓冲区-VertexBuffer"><a href="#5-顶点缓冲区-VertexBuffer" class="headerlink" title="5. 顶点缓冲区 VertexBuffer"></a>5. <strong>顶点缓冲区</strong> VertexBuffer</h3><p>绘制图形前，提前分配一块显存，将顶点数据预先传入显存中，这部分的显存，被称为顶点缓冲区。</p><h3 id="6-管线-Pipeline"><a href="#6-管线-Pipeline" class="headerlink" title="6. 管线 Pipeline"></a>6. <strong>管线 Pipeline</strong></h3><p>就是一套流水线，负责管理渲染的过程</p><h3 id="7-固定管线-fixed-function-pipeline"><a href="#7-固定管线-fixed-function-pipeline" class="headerlink" title="7. 固定管线 fixed-function pipeline"></a>7. <strong>固定管线</strong> fixed-function pipeline</h3><p>一种图形流水线，它包含其操作由程序可配置的一系列参数控制的处理过程。</p><h3 id="8-可编程管线"><a href="#8-可编程管线" class="headerlink" title="8. 可编程管线"></a>8. <strong>可编程管线</strong></h3><p>它允许开发者使用更为灵活地操作来替代固定功能的操作。比如现在的OpenGL 管线是可编程的流水线，</p><h3 id="9-着色器-Shader"><a href="#9-着色器-Shader" class="headerlink" title="9. 着色器 Shader"></a>9. <strong>着色器</strong> Shader</h3><p>执行程序的工程，输入数据（例如定点、图元、或片元）到管线的一个阶段，并产生不同类型的结果数据，准备作为管线中后级阶段的输入数据使用。</p><ol><li>固定着色器：也叫做存储着色器，</li><li>自定义着色器</li><li>顶点着色器</li><li><strong>片元着色器</strong> fragment shader<br> 在光栅化完成之后执行的着色器。片元着色器的每个请求都是对一个光栅化之后的片元执行的。片元着色器也可以说是像素点着色器，负责处理一个个的像素点。如一个图像由120 * 120 像素点组成，就需要 120 * 120 &#x3D; 14400 次的GPU 运算</li></ol><h3 id="10-光栅化"><a href="#10-光栅化" class="headerlink" title="10. 光栅化"></a>10. <strong>光栅化</strong></h3><p>转换投影点、线或多边形，或者位图和图像的像素到片源信息，他们每一个都对应帧缓存中的一个像素。<br><strong>注意</strong>：所有的图元都会被光栅化，而不仅仅是点、线或多边形。</p><h3 id="11-纹理"><a href="#11-纹理" class="headerlink" title="11. 纹理"></a>11. <strong>纹理</strong></h3><p>可以理解为图片。用来修改光栅化产生的片元颜色的1维或2维图像</p><h3 id="12-混合-Blending"><a href="#12-混合-Blending" class="headerlink" title="12. 混合 Blending"></a>12. <strong>混合</strong> Blending</h3><p>混合可以理解为，将像素的颜色和帧缓冲区中颜色附着上的颜色混合在一起，达到新的颜色或者形状的效果。举个例子，可以将两个图层（透明度0.2 的粉色图层，透明度0.5的绿色图层）混合叠加在一起，这个过程就叫做混合</p><h3 id="13-变换矩阵"><a href="#13-变换矩阵" class="headerlink" title="13. 变换矩阵"></a>13. <strong>变换矩阵</strong></h3><p>一个多维矩阵，用来描述顶点位置，进而帮助实现图像的平移、缩放、旋转变化的效果。</p><h3 id="14-投影矩阵-Projection-MATRIX"><a href="#14-投影矩阵-Projection-MATRIX" class="headerlink" title="14. 投影矩阵 - Projection MATRIX"></a>14. <strong>投影矩阵</strong> - Projection MATRIX</h3><ul><li><strong>正投影：</strong> 将图像完整的投影在2D平面上，关键字：【1：1】、【2D效果】。</li><li><strong>透视投影：</strong> 将图像按照远小近大的原则投影在2D平面上，能产生3D的立体视觉效果。<br><img src="/p/7fad6178/001.png" alt="透视投影与正投影"></li></ul><h3 id="15-视口-Viewpoint"><a href="#15-视口-Viewpoint" class="headerlink" title="15. 视口 Viewpoint"></a>15. <strong>视口</strong> Viewpoint</h3><p>屏幕上的像素点集合，决定我们作为观察者在渲染的场景中看到的内容的大小。在开发中，常见的有全幅和局部的视口。</p><ul><li>全幅视口</li><li>局部视口</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章学习了随着抖音、美颜相机等流行的应用而变得火热的计算机视觉的概念，以及其底层OpenGL的相关名词，下一篇，将开始介绍其搭建过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> opengl </tag>
            
            <tag> 音频 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 音视频 </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block使用及原理探究</title>
      <link href="/p/1bf24dc1.html"/>
      <url>/p/1bf24dc1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>出于需要，本文分析时引用苹果开源的libclosure-74 源码，请点击对比查看<a href="https://opensource.apple.com/tarballs/libclosure/">苹果libclosure源码</a></p></blockquote><h2 id="一、Block概念"><a href="#一、Block概念" class="headerlink" title="一、Block概念"></a>一、Block概念</h2><h3 id="1-1-名词解释"><a href="#1-1-名词解释" class="headerlink" title="1.1 名词解释"></a>1.1 名词解释</h3><p>也成为匿名函数，是将函数及其执行上下文封装起来的对象。有参数和返回值。</p><p>Block的结构是：__block_impl</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line"><span class="type">void</span> *isa;<span class="comment">// isa 对象</span></span><br><span class="line"><span class="type">int</span> Flags;</span><br><span class="line"><span class="type">int</span> Reserved;</span><br><span class="line"><span class="type">void</span> *FuncPtr;<span class="comment">//函数指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h3><p>根据Block 所属的libclosure 所示，一共有6种。具体操作：进入<a href="https://opensource.apple.com/tarballs/libclosure/">苹果libclosure源码</a>，选择最新的libclosure-74，下载后打开工程文件，搜索<code>NSBlock</code>得知具体6种如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * _NSConcreteStackBlock[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">void</span> * _NSConcreteMallocBlock[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">void</span> * _NSConcreteAutoBlock[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">void</span> * _NSConcreteFinalizingBlock[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">void</span> * _NSConcreteGlobalBlock[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">void</span> * _NSConcreteWeakBlockVariable[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><p>其中：<em>NSConcreteStackBlock</em>、<em>NSConcreteMallocBlock</em>、<em>NSConcreteGlobalBlock</em> 是常用到的栈区、堆区、全局区的block，其余3种为系统级别，实际开发较少会用到，所以先不展开说明。</p><h4 id="1-2-1-NSGlobalBlock（全局Block）"><a href="#1-2-1-NSGlobalBlock（全局Block）" class="headerlink" title="1.2.1 NSGlobalBlock（全局Block）"></a>1.2.1 NSGlobalBlock（全局Block）</h4><p>当生成的block是独立的，不引用外部变量或者作为参赛参与其他函数，处于<strong>全局区，是为全局block</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void (^block)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;hello world!&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">NSLog(@&quot;block       %@&quot;, block);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">03</span>:<span class="number">21</span>:<span class="number">33.996335</span>+<span class="number">0800</span> DDD[<span class="number">12987</span>:<span class="number">411279</span>] hello world!</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">03</span>:<span class="number">21</span>:<span class="number">33.996513</span>+<span class="number">0800</span> DDD[<span class="number">12987</span>:<span class="number">411279</span>] block       &lt;__NSGlobalBlock__: <span class="number">0x10e714050</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-NSStackBlock（栈区）"><a href="#1-2-2-NSStackBlock（栈区）" class="headerlink" title="1.2.2 NSStackBlock（栈区）"></a>1.2.2 NSStackBlock（栈区）</h4><p>当block 被copy 前，会处于<strong>栈区</strong></p><p>以下为相关示例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__block <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">NSLog(@<span class="string">&quot;%@&quot;</span>, ^&#123;</span><br><span class="line">   NSLog(@<span class="string">&quot;aaa %d&quot;</span>, a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">11</span>:<span class="number">36</span>:<span class="number">10.746965</span>+<span class="number">0800</span> DDD[<span class="number">14013</span>:<span class="number">600887</span>] &lt;__NSStackBlock__: <span class="number">0x7ffeeb06b188</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-NSMallocBlock（堆区）"><a href="#1-2-3-NSMallocBlock（堆区）" class="headerlink" title="1.2.3 NSMallocBlock（堆区）"></a>1.2.3 NSMallocBlock（堆区）</h4><p>当block 引用外部变量，此时block 会从<strong>全局区</strong>移动到<strong>堆区</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__block int a = 10;</span><br><span class="line">void (^block)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;a       %d&quot;, a);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">NSLog(@&quot;block       %@&quot;, block);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-05-25 03:22:31.565749+0800 DDD[13022:421048] a       10</span><br><span class="line">2020-05-25 03:22:31.565921+0800 DDD[13022:421048] block       &lt;__NSMallocBlock__: 0x600000ddc1b0&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-Block-的常见使用"><a href="#1-3-Block-的常见使用" class="headerlink" title="1.3 Block 的常见使用"></a>1.3 Block 的常见使用</h3><ol><li><p>作为局部变量</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;</span><br><span class="line">  <span class="comment">// do sth..</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>作为属性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);c</span><br></pre></td></tr></table></figure></li><li><p>作为函数声明中的参数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName;</span><br></pre></td></tr></table></figure></li><li><p>作为函数调用中的参数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[someObject someMethodThatTakesABlock:^returnType (parameters) &#123;</span><br><span class="line">  <span class="comment">// do sth</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li><li><p>作为typedef</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">returnType</span> <span class="params">(^TypeName)</span><span class="params">(parameterTypes)</span>;</span><br><span class="line">TypeName blockName = ^returnType(parameters) &#123;</span><br><span class="line"><span class="comment">// DO STH</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、循环引用及解决"><a href="#二、循环引用及解决" class="headerlink" title="二、循环引用及解决"></a>二、循环引用及解决</h2><h3 id="2-1-循环引用的产生"><a href="#2-1-循环引用的产生" class="headerlink" title="2.1 循环引用的产生"></a>2.1 循环引用的产生</h3><p>举一个常见的循环引用的例子</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.view.backgroundColor = [UIColor purpleColor];</span><br><span class="line">    self.name = @<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ① self 持有block</span></span><br><span class="line">    self.block  = ^&#123;</span><br><span class="line">        <span class="comment">// ② block 又持有self</span></span><br><span class="line">        NSLog(@<span class="string">&quot;__name  %@&quot;</span>, self.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    self.block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>)dealloc&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;进入dealloc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当示例代码中①处 self 持有了属性 block，而 ②种 block 代码块又持有了 self，这样会导致相互引用，最终系统在执行 dealloc 方法时，向任何一个变量发送release消息时，两者都因为引用其他变量而无法释放，最终会引起内存泄漏。示意图如下：</p><p><img src="/p/1bf24dc1/001.png"></p><h3 id="2-2-循环引用的解决"><a href="#2-2-循环引用的解决" class="headerlink" title="2.2 循环引用的解决"></a>2.2 循环引用的解决</h3><p>此时我们只讨论由block 引起的循环引用</p><h4 id="2-2-1-使用weak-修饰"><a href="#2-2-1-使用weak-修饰" class="headerlink" title="2.2.1 使用weak 修饰"></a>2.2.1 使用weak 修饰</h4><p>可以考虑对当前持有block 的对象，进行weak 修饰，创建一个弱引用指向它（原理为加入到弱引用计数表，而非引用技术表），但是并不会增加引用计数。</p><p>当前案例中，引用block 的是self，所以创建一个weak 对象 weakSelf。</p><p>如下所示，即可跳出 self - block - self 的循环引用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__weak <span class="title function_">typeof</span><span class="params">(self)</span> weakSelf = self;</span><br><span class="line">self.block  = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;__name  %@&quot;</span>, weakSelf.name);</span><br><span class="line">&#125;;</span><br><span class="line">self.block();</span><br></pre></td></tr></table></figure><h4 id="2-2-2-weak-strong-dance（多级block）"><a href="#2-2-2-weak-strong-dance（多级block）" class="headerlink" title="2.2.2 weak-strong-dance（多级block）"></a>2.2.2 weak-strong-dance（多级block）</h4><p>在多级block 的场景下，弱引用会造成一些意外的情况。</p><p>对上面的例子做一些小改动，对block代码块执行的<code>NSLog</code> 函数，做一个延迟3秒执行操作，并让这个执行在页面消失之后，也就是dealloc 之后，看看是否还能打印 <code>weakSelf.name</code>。</p><p>新的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.view.backgroundColor = [UIColor purpleColor];</span><br><span class="line">    self.name = @<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    __weak <span class="title function_">typeof</span><span class="params">(self)</span> weakSelf = self;</span><br><span class="line">    self.block  = ^&#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="type">int64_t</span>)(<span class="number">3</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    NSLog(@<span class="string">&quot;__name  %@&quot;</span>, weakSelf.name);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    self.block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>)dealloc&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;进入dealloc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">12</span>:<span class="number">43</span>:<span class="number">05.876909</span>+<span class="number">0800</span> DDD[<span class="number">14542</span>:<span class="number">686386</span>] 进入dealloc</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">12</span>:<span class="number">43</span>:<span class="number">06.475894</span>+<span class="number">0800</span> DDD[<span class="number">14542</span>:<span class="number">686386</span>] __name  (null)</span><br></pre></td></tr></table></figure><p>可见，在进入dealloc 之后，添加的弱引用，已经被释放掉了，而设计的3秒后执行 <code>weakSelf.name</code> 也因为 weakSelf 为 nil 了，所以打印为<code>null</code></p><p><strong>解决</strong>：在代码块内，添加临时的强引用，将<code>weakSelf</code> 添加到强引用表里，会让dealloc 延迟执行，而当执行完之后block 会对临时的强引用进行释放，避免了循环引用的产生。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.view.backgroundColor = [UIColor purpleColor];</span><br><span class="line">    self.name = @<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    NSLog(@<span class="string">&quot;初始name  %@&quot;</span>, self.name);</span><br><span class="line">    __weak <span class="title function_">typeof</span><span class="params">(self)</span> weakSelf = self;</span><br><span class="line">    self.block  = ^&#123;</span><br><span class="line">        __strong typeof(self) strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="type">int64_t</span>)(<span class="number">5</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    NSLog(@<span class="string">&quot;__name  %@&quot;</span>, strongSelf.name);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    self.block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>)dealloc&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;进入dealloc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果及顺序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">12</span>:<span class="number">49</span>:<span class="number">42.141133</span>+<span class="number">0800</span> DDD[<span class="number">14610</span>:<span class="number">698670</span>] 初始name  hello</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">12</span>:<span class="number">49</span>:<span class="number">47.634568</span>+<span class="number">0800</span> DDD[<span class="number">14610</span>:<span class="number">698670</span>] __name  hello</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">12</span>:<span class="number">49</span>:<span class="number">47.635013</span>+<span class="number">0800</span> DDD[<span class="number">14610</span>:<span class="number">698670</span>] 进入dealloc</span><br></pre></td></tr></table></figure><p>从结果可以看出，12:49:42 秒进入本页面，47秒后 进入打印strongSelf.name 成功，同时立刻执行<code>dealloc</code>方法。可见修改是成功的。</p><h4 id="2-2-3-用临时VC-变量替代"><a href="#2-2-3-用临时VC-变量替代" class="headerlink" title="2.2.3 用临时VC  变量替代"></a>2.2.3 用临时VC  变量替代</h4><p>在上文中，都是通过weak 对self修饰，来避免循环引用，实际上，还可以对self 所代替的Controller 引入临时变量，来解决循环引用，话不多说，实战一下。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__block SecViewController *vc = self;</span><br><span class="line">self.block  = ^&#123;</span><br><span class="line"> </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="type">int64_t</span>)(<span class="number">5</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                NSLog(@<span class="string">&quot;__name  %@&quot;</span>, vc.name);</span><br><span class="line">        vc = nil;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">self.block();</span><br></pre></td></tr></table></figure><ol><li>创建一个临时变量vc，使用__block 修饰，因为后面会对他做修改。</li><li>在block内部进行打印属性，完毕后置空，跳出循环引用。</li></ol><p>打印结果如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">12</span>:<span class="number">54</span>:<span class="number">28.262738</span>+<span class="number">0800</span> DDD[<span class="number">14645</span>:<span class="number">705623</span>] 初始name  hello</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">12</span>:<span class="number">54</span>:<span class="number">33.263402</span>+<span class="number">0800</span> DDD[<span class="number">14645</span>:<span class="number">705623</span>] __name  hello</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">12</span>:<span class="number">54</span>:<span class="number">33.263773</span>+<span class="number">0800</span> DDD[<span class="number">14645</span>:<span class="number">705623</span>] 进入dealloc</span><br></pre></td></tr></table></figure><p>可见通过ViewController 来替代self 也算可用性的</p><h4 id="2-2-4-将VC-作为block-变量替代"><a href="#2-2-4-将VC-作为block-变量替代" class="headerlink" title="2.2.4 将VC 作为block 变量替代"></a>2.2.4 将VC 作为block 变量替代</h4><p>如果block 是可以引入参数的，可以将控制器self 传入进去，作为临时变量，打印后block 会自动销毁，无需担心循环引用，具体如下：</p><p>创建block ，引入当前VC 的引用，的代码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@property (copy, nonatomic) <span class="type">void</span> (^block)(SecViewController *);</span><br></pre></td></tr></table></figure><p>执行函数为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">self.block  = ^(SecViewController *vc)&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="type">int64_t</span>)(<span class="number">5</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                NSLog(@<span class="string">&quot;__name  %@&quot;</span>, vc.name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">self.block(self);</span><br></pre></td></tr></table></figure><p>此时通过<code>self.block(self)</code> 传入self 的引用，block 内部会自动创建一个新的临时变量指向self，该临时变量使用后会销毁。打印机如果如下；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">12</span>:<span class="number">57</span>:<span class="number">17.929178</span>+<span class="number">0800</span> DDD[<span class="number">14671</span>:<span class="number">710117</span>] 初始name  hello</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">12</span>:<span class="number">57</span>:<span class="number">22.929717</span>+<span class="number">0800</span> DDD[<span class="number">14671</span>:<span class="number">710117</span>] __name  hello</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="number">12</span>:<span class="number">57</span>:<span class="number">22.930072</span>+<span class="number">0800</span> DDD[<span class="number">14671</span>:<span class="number">710117</span>] 进入dealloc</span><br></pre></td></tr></table></figure><h2 id="三、底层探索"><a href="#三、底层探索" class="headerlink" title="三、底层探索"></a>三、底层探索</h2><h3 id="3-1-Block-的本质"><a href="#3-1-Block-的本质" class="headerlink" title="3.1 Block 的本质"></a>3.1 Block 的本质</h3><blockquote><p>Block 是一种匿名函数，它的类型是一种对象，本质是结构体。</p></blockquote><p>为了证明这一点，对main.m 进行cpp 源码分析，现在main.m 生成一个block</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>进入项目文件下，输入编译命令：<code>xcrun -sdk iphonesimulator clang -rewrite-objc main.m</code> 得到main.cpp</p><p>打开查看相关cpp 实现如下：</p><ul><li><p>OC 代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure></li><li><p>C++ 源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*block)(<span class="type">void</span>) = ((<span class="type">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">  ((<span class="type">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br></pre></td></tr></table></figure><p>将代码精简一下成为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">  (block)-&gt;FuncPtr)(block);</span><br></pre></td></tr></table></figure></li></ul><p>可见主函数为<code>__main_block_impl_0</code>，在C++ 源码中的部分为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见，我们平常使用的代码块block代码块是一个结构体，有以下几个部分组成</p><ul><li>block 实现 - __block_impl，这个是个指针函数，生成后会返回</li><li>block 描述信息 - __main_block_desc_0</li><li>内部构造函数 - __main_block_impl_0。主要执行了 生成薪的impl 的函数赋值（如isa，flags，funptr）</li></ul><p>继续挖， __block_impl 类型的结构体，实现如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  <span class="type">void</span> *isa;</span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="type">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为有熟悉的<code>isa</code> 的存在，可知其也算个对象类的结构体。</p><h3 id="3-2-Block-自动捕获外部变量"><a href="#3-2-Block-自动捕获外部变量" class="headerlink" title="3.2 Block 自动捕获外部变量"></a>3.2 Block 自动捕获外部变量</h3><p>接下来看block 是如何捕获外界变量的，一共分为3重大的类型：</p><ul><li>局部变量</li><li>局部静态变量</li><li>全局变量和全局静态变量</li></ul><h4 id="3-2-1-局部变量捕获"><a href="#3-2-1-局部变量捕获" class="headerlink" title="3.2.1 局部变量捕获"></a>3.2.1 局部变量捕获</h4><blockquote><p>局部变量的捕获，是指的捕获</p></blockquote><p>此时生成一个变量 int a，在代码块对其进行引用，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>继续进行cpp 编译，发现<code>int main</code> 函数下，变成了如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">void</span> (*block)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line">((<span class="built_in">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br></pre></td></tr></table></figure><p>通过精简，其内容如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    block = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line">    block-&gt;<span class="built_in">FuncPtr</span>(block);</span><br></pre></td></tr></table></figure><p>可见<code>__main_block_impl_0</code>传入了新的参数<code>a</code>，接下来看如何实现，新的 <code>main_block_impl_0</code> 结构体如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> _a, <span class="type">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见这里比起之前的结构体，生成了一个新的属性<code>a</code> ，在构造函数里，发现了<code>__main_block_impl_0</code>中也多了一句<code>a(_a) </code> 的代码，可以猜测是生成了一个新的<code>a</code>，将传入的内部属性_a 赋值给  a</p><p>继续看<code>main_block_func_0</code> 的实现如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="type">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_b68344_mi_0, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时静态函数<code>__main_block_func_0</code>的内部对传入的block 进行了处理——接受了其内部的变量<code>a</code>——通过自身新生成一个<code>a</code>，就是这行代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br></pre></td></tr></table></figure><p>自动生成的注释很清晰的说明了原理，通过<code>copy</code>绑定新的<strong>值</strong>，所以说是值捕获。最终通过<code>NSLog</code> 打印新的变量<code>a</code></p><h4 id="3-2-2-局部静态变量捕获"><a href="#3-2-2-局部静态变量捕获" class="headerlink" title="3.2.2 局部静态变量捕获"></a>3.2.2 局部静态变量捕获</h4><blockquote><p>局部静态变量的捕获，是指针捕获</p></blockquote><p>接下来尝试一下，在block内部生成一个用<code>static</code>修饰的局部静态变量，看看如何捕获</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> NSInteger num = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">NSInteger (^block)(NSInteger) = ^(NSInteger n)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> n * num;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">num = <span class="number">1</span>;</span><br><span class="line">NSLog(@<span class="string">&quot;%ld&quot;</span>, (<span class="type">long</span>)block(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>进入项目文件下，输入编译命令：<code>xcrun -sdk iphonesimulator clang -rewrite-objc main.m</code> 得到main.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  NSInteger *num;</span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, NSInteger *_num, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">num</span>(_num) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself, NSInteger n) &#123;</span><br><span class="line">  NSInteger *num = __cself-&gt;num; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> n * (*num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> NSInteger num = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSInteger</span> (*block)(NSInteger) = ((<span class="built_in">long</span> (*)(NSInteger))&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;num));</span><br><span class="line">        <span class="comment">// 精简为 *block = __main_block_impl_0(&amp;__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;num);</span></span><br><span class="line"> </span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_ef866b_mi_0, (<span class="type">long</span>)((<span class="built_in">NSInteger</span> (*)(__block_impl *, NSInteger))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>(((<span class="built_in">Class</span> (*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)<span class="built_in">objc_getClass</span>(<span class="string">&quot;AppDelegate&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, __null, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>变化：</strong></p><ul><li><p>生成了新的整形指针<code>NSInteger *num;</code></p></li><li><p>将传入的<code>NSInteger *_num</code> 赋值给num</p></li><li><p>代码块调用有所不同，如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原函数</span></span><br><span class="line">        <span class="built_in">NSInteger</span> (*block)(NSInteger) = ((<span class="built_in">long</span> (*)(NSInteger))&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;num));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精简后</span></span><br><span class="line">__main_block_impl_0(&amp;__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;num)</span><br></pre></td></tr></table></figure><p>可以清晰的看出来，此时传入的<code>num</code> 是一个指针，可见，是进行了<strong>指针拷贝</strong>，而不是值拷贝，所以这里num 得到了改变，打印结果会是2</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2020-05-27 00:11:06.899579+0800 DDD[25215:2116517] 2</span><br></pre></td></tr></table></figure><h4 id="3-3-3-全局变量、全局静态变量的捕获"><a href="#3-3-3-全局变量、全局静态变量的捕获" class="headerlink" title="3.3.3 全局变量、全局静态变量的捕获"></a>3.3.3 全局变量、全局静态变量的捕获</h4><blockquote><p>全局变量、全局静态变量的捕获是直接取值</p></blockquote><p>这次来点刺激的，把所有用的到的都写到block 里面，再验证下cpp 会发生什么</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> NSInteger num3 = <span class="number">300</span>;            <span class="comment">// 静态变量</span></span><br><span class="line">NSInteger num4 = <span class="number">3000</span>;                  <span class="comment">// 全局静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"> </span><br><span class="line">        NSInteger num = <span class="number">30</span>;             <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">static</span> NSInteger num2 = <span class="number">3</span>;      <span class="comment">// 局部静态变量</span></span><br><span class="line">        </span><br><span class="line">        __block NSInteger num5 = <span class="number">30000</span>; <span class="comment">// __block 修饰的变量</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">void</span>(^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">            NSLog(@<span class="string">&quot;%ld&quot;</span>, (<span class="type">long</span>)num);</span><br><span class="line">            NSLog(@<span class="string">&quot;%ld&quot;</span>, (<span class="type">long</span>)num2);</span><br><span class="line">            NSLog(@<span class="string">&quot;%ld&quot;</span>, (<span class="type">long</span>)num3);</span><br><span class="line">            NSLog(@<span class="string">&quot;%ld&quot;</span>, (<span class="type">long</span>)num4);</span><br><span class="line">            NSLog(@<span class="string">&quot;%ld&quot;</span>, (<span class="type">long</span>)num5);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        block();</span><br><span class="line">        </span><br><span class="line">        appDelegateClassName = NSStringFromClass([AppDelegate class]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入项目文件下，输入编译命令：<code>xcrun -sdk iphonesimulator clang -rewrite-objc main.m</code> 得到main.cpp</p><p>不管了，就先一股脑儿的贴上来吧，接下来分析：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> NSInteger num3 = <span class="number">300</span>;<span class="comment">// 全局变量</span></span><br><span class="line">NSInteger num4 = <span class="number">3000</span>;<span class="comment">// 静态全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_num5_0</span> &#123;<span class="comment">// __block 修饰的变量</span></span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">__Block_byref_num5_0 *__forwarding;</span><br><span class="line"> <span class="type">int</span> __flags;</span><br><span class="line"> <span class="type">int</span> __size;</span><br><span class="line"> NSInteger num5;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  NSInteger num;</span><br><span class="line">  NSInteger *num2;</span><br><span class="line">  __Block_byref_num5_0 *num5; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, NSInteger _num, NSInteger *_num2, __Block_byref_num5_0 *_num5, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">num</span>(_num), <span class="built_in">num2</span>(_num2), <span class="built_in">num5</span>(_num5-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_num5_0 *num5 = __cself-&gt;num5; <span class="comment">// bound by ref</span></span><br><span class="line">  NSInteger num = __cself-&gt;num; <span class="comment">// bound by copy</span></span><br><span class="line">  NSInteger *num2 = __cself-&gt;num2; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_0, (<span class="type">long</span>)num);</span><br><span class="line">            <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_1, (<span class="type">long</span>)(*num2));</span><br><span class="line">            <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_2, (<span class="type">long</span>)num3);</span><br><span class="line">            <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_3, (<span class="type">long</span>)num4);</span><br><span class="line">            <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_4, (<span class="type">long</span>)(num5-&gt;__forwarding-&gt;num5));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="type">void</span>*)&amp;dst-&gt;num5, (<span class="type">void</span>*)src-&gt;num5, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="type">void</span>*)src-&gt;num5, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">  <span class="built_in">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="built_in">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        NSInteger num = <span class="number">30</span>;</span><br><span class="line">        <span class="type">static</span> NSInteger num2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        __attribute__((__blocks__(byref))) __Block_byref_num5_0 num5 = &#123;(<span class="type">void</span>*)<span class="number">0</span>,(__Block_byref_num5_0 *)&amp;num5, <span class="number">0</span>, <span class="built_in">sizeof</span>(__Block_byref_num5_0), <span class="number">30000</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">void</span>(*block)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, num, &amp;num2, (__Block_byref_num5_0 *)&amp;num5, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">        ((<span class="built_in">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>(((<span class="built_in">Class</span> (*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)<span class="built_in">objc_getClass</span>(<span class="string">&quot;AppDelegate&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, __null, appDelegateClassName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>分析：</strong>我们看到了，num、num2、num5 在block 的构造函数<code>__main_block_impl_0</code> 中都有了各自的实现，有的是取值，有的是通过forwarding 传递指针。</p><p>但是num3，和num4 呢？通篇下来，没有做任何处理，在block 函数内部，通过NSLog 直接取值了……</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_2, (<span class="type">long</span>)num3);</span><br><span class="line"><span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_3, (<span class="type">long</span>)num4);</span><br></pre></td></tr></table></figure><p><strong>结论：</strong>静态变量、全局静态变量，因为他们存在<strong>全局存储区</strong>，占用静态的单元，所以block 调用时是直接把值取过来用，并不需要指针引用。</p><h4 id="3-3-4-小结"><a href="#3-3-4-小结" class="headerlink" title="3.3.4 小结"></a>3.3.4 小结</h4><p>捕获变量的流程，除了静态变量和全局变量以外，都是block 在内部<strong>自动生成一个新的变量</strong>，用来接收外部变量。 </p><h3 id="3-3-Block-为什么要捕获Block"><a href="#3-3-Block-为什么要捕获Block" class="headerlink" title="3.3 Block 为什么要捕获Block()"></a>3.3 Block 为什么要捕获Block()</h3><p>block() 这种写法和普通的函数不一样，通过上文可以看到，最终实现的代码为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">block-&gt;FuncPtr(block);</span><br></pre></td></tr></table></figure><p>分析一下，这里是 block 结构体执行了其内部函数指针指向的函数，即声明一个函数式的属性，在任何想要调用的的地方调用。最终我们的确是调用了。</p><h3 id="3-4-block-的原理"><a href="#3-4-block-的原理" class="headerlink" title="3.4 __block 的原理"></a>3.4 __block 的原理</h3><p>为了让外部变量在block 内部得到更改，我们通常在外部对变量使用__block 的修饰符，究竟发生了什么呢？</p><p>那么这次，对外部加上<code>__block</code> 试试</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__block <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    a++;</span><br><span class="line">    NSLog(@<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><h4 id="3-4-1-CPP分析"><a href="#3-4-1-CPP分析" class="headerlink" title="3.4.1 CPP分析"></a>3.4.1 CPP分析</h4><p>可以看到，构造函数结构体有了变化;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  __Block_byref_a_0 *a; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">a</span>(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与之前的变量不一样，生成了一个<code>__Block_byref_a_0 *a; // by ref</code> 的结构体指针对象，点击查看，结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_a_0</span> &#123;</span></span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> <span class="type">int</span> __flags;</span><br><span class="line"> <span class="type">int</span> __size;</span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见和类的结构类似，有isa、数据a、内存大小_size、类似链表的<code>__forwarding</code>指针。结合<code>__main_block_impl_0</code> 的结构，可以清楚的看到，内部创建的一个结构体指针<code>__Block_byref_a_0 *a</code>，而 __a 的指针指向了 a。即，这里产生了一次指针拷贝。</p><p>接下来看看函数的实现：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  (a-&gt;__forwarding-&gt;a)++;</span><br><span class="line">            <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_acd650_mi_0, (a-&gt;__forwarding-&gt;a));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="type">void</span>*)&amp;dst-&gt;a, (<span class="type">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="type">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-源码分析"><a href="#3-4-2-源码分析" class="headerlink" title="3.4.2 源码分析"></a>3.4.2 源码分析</h4><p>在上文中，我们看到关键函数是<code>_Block_object_assign</code>，打开<code>libclosure</code> 查看相应的函数实现，得到如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// When Blocks or Block_byrefs hold objects then their copy routine helpers use this entry point</span></span><br><span class="line"><span class="comment">// to do the assignment.</span></span><br><span class="line"><span class="type">void</span> _Block_object_assign(<span class="type">void</span> *destArg, <span class="type">const</span> <span class="type">void</span> *object, <span class="type">const</span> <span class="type">int</span> flags) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> **dest = (<span class="type">const</span> <span class="type">void</span> **)destArg;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">os_assumes</span>(flags &amp; BLOCK_ALL_COPY_DISPOSE_FLAGS)) &#123;</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">        <span class="comment">/*省略*/</span></span><br><span class="line">        *dest = _Block_copy(object);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BYREF:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the onstack __block container to the heap</span></span><br><span class="line"><span class="comment">         // Note this __weak is old GC-weak/MRC-unretained.</span></span><br><span class="line"><span class="comment">         // ARC-style __weak is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __block ... x;</span></span><br><span class="line"><span class="comment">         __weak __block ... x;</span></span><br><span class="line"><span class="comment">         [^&#123; x; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line">            </span><br><span class="line">        *dest = _Block_byref_copy(object);</span><br></pre></td></tr></table></figure><p>注释简单的翻译是：当block 或者block 引用持有对象时，他们的拷贝常规帮助者会使用它们的入口点来做分配工作。</p><p>里面的是现实对持有对象类型的switch，重点关注<code>BLOCK_FIELD_IS_BYREF</code>，注释已经说了</p><blockquote><p>copy the onstack __block container to the heap</p><p>拷贝栈内__block 容器到堆</p></blockquote><p>太棒了， 这就是我们需要的实现函数，即对__block 的方法做出相应，拷贝到堆区，再来看函数 <code>_Block_byref_copy(object)</code> 具体的实现：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">Block_byref</span> *_Block_byref_copy(<span class="type">const</span> <span class="type">void</span> *arg) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Block_byref</span> *src = (<span class="keyword">struct</span> Block_byref *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// src points to stack</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Block_byref</span> *copy = (<span class="keyword">struct</span> Block_byref *)<span class="built_in">malloc</span>(src-&gt;size);</span><br><span class="line">        copy-&gt;isa = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// byref value 4 is logical refcount of 2: one for caller, one for stack</span></span><br><span class="line">        copy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | <span class="number">4</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 问题 - __block 修饰变量 block具有修改能力</span></span><br><span class="line">        copy-&gt;forwarding = copy; <span class="comment">// patch heap copy to point to itself</span></span><br><span class="line">        src-&gt;forwarding = copy;  <span class="comment">// patch stack to point to heap copy</span></span><br><span class="line">        </span><br><span class="line">        copy-&gt;size = src-&gt;size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里可以看到，具体的实现了：</p><ol><li><p>拷贝新的对象到堆区，并置空<code>isa</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Block_byref</span> *copy = (<span class="keyword">struct</span> Block_byref *)<span class="built_in">malloc</span>(src-&gt;size);</span><br><span class="line">copy-&gt;isa = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li><li><p>将新的拷贝对象的flag 与之前栈区对象的flags的相等</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// byref value 4 is logical refcount of 2: one for caller, one for stack</span></span><br><span class="line">copy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | <span class="number">4</span>;</span><br></pre></td></tr></table></figure></li><li><p>将新的对象指向原对象，即进行指针拷贝——这个是__block 的关键，新的指向原对象，与原地址指向同一个内存空间，故具备修改能力！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题 - __block 修饰变量 block具有修改能力</span></span><br><span class="line">copy-&gt;forwarding = copy; <span class="comment">// patch heap copy to point to itself</span></span><br><span class="line">src-&gt;forwarding = copy;  <span class="comment">// patch stack to point to heap copy</span></span><br></pre></td></tr></table></figure></li><li><p>新对象大小与原对象大小相等</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">copy-&gt;size = src-&gt;size;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结：</strong>可见生成的a 是一个<code>__Block_byref_a_0</code> 类型结构体引用，而不是值拷贝的引用。**__block 在作用于内部生成了变量的指针，通过改变指针指向的地址，来即改变原变量。**</p><p>原理图如下：</p><p><img src="/p/1bf24dc1/003.png"></p><h2 id="四、签名"><a href="#四、签名" class="headerlink" title="四、签名"></a>四、签名</h2><h3 id="4-1-block-结构分析"><a href="#4-1-block-结构分析" class="headerlink" title="4.1 block 结构分析"></a>4.1 block 结构分析</h3><p>block 的结构如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Block_layout</span> &#123;</span><br><span class="line">    <span class="type">void</span> *isa;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int32_t</span> flags; <span class="comment">// contains ref count</span></span><br><span class="line">    <span class="type">int32_t</span> reserved;</span><br><span class="line">    BlockInvokeFunction invoke;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Block_descriptor_1</span> *descriptor; <span class="comment">//</span></span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*BlockInvokeFunction)</span><span class="params">(<span class="type">void</span> *, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>分析如下：</p><ul><li><p>isa- 指向block父类的指针</p></li><li><p>用来描述block 对象的flags </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Values for Block_layout-&gt;flags to describe block objects</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BLOCK_DEALLOCATING =      (<span class="number">0x0001</span>),  <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_REFCOUNT_MASK =     (<span class="number">0xfffe</span>),  <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_NEEDS_FREE =        (<span class="number">1</span> &lt;&lt; <span class="number">24</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_HAS_COPY_DISPOSE =  (<span class="number">1</span> &lt;&lt; <span class="number">25</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_CTOR =          (<span class="number">1</span> &lt;&lt; <span class="number">26</span>), <span class="comment">// compiler: helpers have C++ code</span></span><br><span class="line">    BLOCK_IS_GC =             (<span class="number">1</span> &lt;&lt; <span class="number">27</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_IS_GLOBAL =         (<span class="number">1</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_USE_STRET =         (<span class="number">1</span> &lt;&lt; <span class="number">29</span>), <span class="comment">// compiler: undefined if !BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    BLOCK_HAS_SIGNATURE  =    (<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_EXTENDED_LAYOUT=(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)  <span class="comment">// compiler</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>预留数值</p></li><li><p>函数调用invoke</p></li><li><p>描述信息 struct Block_descriptor_1 *descriptor; &#x2F;&#x2F; </p><p>此处的描述信息，是动态的，如果flags 中<code>BLOCK_HAS_COPY_DISPOSE</code> 值存在，则存在<code>Block_descriptor_2</code>，其结构如下;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_DESCRIPTOR_2 1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Block_descriptor_2</span> &#123;</span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_COPY_DISPOSE</span></span><br><span class="line">    BlockCopyFunction copy;</span><br><span class="line">    BlockDisposeFunction dispose;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包含的是拷贝函数<strong>copy</strong>以及销毁函数 <strong>dispose</strong></p><p>如果flags 中<code>BLOCK_HAS_SIGNATURE</code> 存在，即block 包含有签名存在，则存在<code>Block_descriptor_3</code></p><p>方法签名就在3里面：</p><ul><li><strong>方法签名</strong></li><li>方法布局</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_DESCRIPTOR_3 1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Block_descriptor_3</span> &#123;</span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *signature;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *layout;     <span class="comment">// contents depend on BLOCK_HAS_EXTENDED_LAYOUT</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>&#x2F;&#x2F; 引入的变量等</p></li></ul><h3 id="4-2-block签名的访问"><a href="#4-2-block签名的访问" class="headerlink" title="4.2 block签名的访问"></a>4.2 block签名的访问</h3><p>上文中提到的<code>Block_descriptor_2</code>、<code>Block_descriptor_3</code>，都可以通过 <code>Block_descriptor_1</code> 的内存偏移进行访问到，block 的签名为<code>@？</code></p><h4 id="4-2-1-代码部署："><a href="#4-2-1-代码部署：" class="headerlink" title="4.2.1 代码部署："></a>4.2.1 代码部署：</h4><p>先设定一个最简单的代码块块用来检查：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>(^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><h4 id="4-2-2-汇编断点配置"><a href="#4-2-2-汇编断点配置" class="headerlink" title="4.2.2 汇编断点配置"></a>4.2.2 汇编断点配置</h4><ul><li><p>连接真机。配置汇编监控打开：Xcode——Debug——Debug Workflow——Always show Dissembly</p></li><li><p>对block 代码块打断点，运行程序</p></li><li><p>会跳转到汇编的main 步骤，通过<code>Step Over</code>键进入到 <code>objc_retainBlock</code>函数下</p></li><li><p>打印当前x0寄存器：<code>register read x0</code>得到当前运行的block 函数的位置为<code>0x0000000104afc028</code></p></li><li><p>打印地址为<code>0x0000000104afc028</code>，得到block的类型、签名和内部实现地址：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;__NSGlobalBlock__: <span class="number">0x104afc028</span>&gt;</span><br><span class="line"> signature: <span class="string">&quot;v8@?0&quot;</span></span><br><span class="line"> invoke   : <span class="number">0x104afa01c</span> (/private/var/containers/Bundle/Application/<span class="number">3F</span>9F1F87<span class="number">-526B</span><span class="number">-499</span>C<span class="number">-93</span>CE<span class="number">-784F</span>88CE7DB4/DDD.app/DDD`__main_block_invoke)</span><br></pre></td></tr></table></figure><p>具体的细节请见下图</p><p><img src="/p/1bf24dc1/004.png" alt="查看方法签名"></p></li></ul><h4 id="4-2-1-访问-Block-descriptor-2"><a href="#4-2-1-访问-Block-descriptor-2" class="headerlink" title="4.2.1 访问 Block_descriptor_2"></a>4.2.1 访问 <strong>Block_descriptor_2</strong></h4><p>当block 的<code>block_layout</code>结构中flag 参数<code>BLOCK_HAS_COPY_DISPOSE</code> 值为1 即可通过内存偏移访问到，相关原理可以见下方代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">Block_descriptor_2</span> * _Block_descriptor_2(<span class="keyword">struct</span> Block_layout *aBlock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! (aBlock-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">uint8_t</span> *desc = (<span class="type">uint8_t</span> *)aBlock-&gt;descriptor;</span><br><span class="line">    desc += <span class="built_in">sizeof</span>(<span class="keyword">struct</span> Block_descriptor_1);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> Block_descriptor_2 *)desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数实现中，第3行<code>desc += sizeof(struct Block_descriptor_1);</code> 即内存地址偏移<code>Block_descriptor_1</code> 的内存位，即可访问到<code>Block_descriptor_2</code>。</p><h4 id="4-2-2-访问-Block-descriptor-3"><a href="#4-2-2-访问-Block-descriptor-3" class="headerlink" title="4.2.2 访问 Block_descriptor_3"></a>4.2.2 访问 <strong>Block_descriptor_3</strong></h4><p>同理，在该<code>block</code>的flag 值 <code>BLOCK_HAS_SIGNATURE</code> 为正时，亦可以通过<code>Block_descriptor_1</code>的内存偏移而访问到<code>Block_descriptor_3</code>，当然，如果此时<code>BLOCK_HAS_COPY_DISPOSE</code> 值也为1，必须叠加<code>Block_descriptor_2</code> 的偏移位</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_3</span> * _<span class="title">Block_descriptor_3</span>(<span class="keyword">struct</span> <span class="title">Block_layout</span> *<span class="title">aBlock</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (! (aBlock-&gt;flags &amp; BLOCK_HAS_SIGNATURE)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">uint8_t</span> *desc = (<span class="type">uint8_t</span> *)aBlock-&gt;descriptor;</span><br><span class="line">    desc += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Block_descriptor_1);</span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">        desc += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Block_descriptor_2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> Block_descriptor_3 *)desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、block的copy-分析"><a href="#五、block的copy-分析" class="headerlink" title="五、block的copy 分析"></a>五、block的copy 分析</h2><h3 id="5-1-源码"><a href="#5-1-源码" class="headerlink" title="5.1 源码"></a>5.1 源码</h3><p>在<code>libclosure</code> 源码中，<code>runtime.cpp</code>这一页，<code>block_copy</code> 的函数实现如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *_Block_copy(<span class="type">const</span> <span class="type">void</span> *arg) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Block_layout</span> *aBlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following would be better done as a switch statement</span></span><br><span class="line">    aBlock = (<span class="keyword">struct</span> Block_layout *)arg;</span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        <span class="comment">// latches on high</span></span><br><span class="line">        <span class="built_in">latching_incr_int</span>(&amp;aBlock-&gt;flags);</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Its a stack block.  Make a copy.</span></span><br><span class="line">        <span class="keyword">struct</span> Block_layout *result =</span><br><span class="line">            (<span class="keyword">struct</span> Block_layout *)<span class="built_in">malloc</span>(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">        <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memmove</span>(result, aBlock, aBlock-&gt;descriptor-&gt;size); <span class="comment">// bitcopy first</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">        <span class="comment">// Resign the invoke pointer as it uses address authentication.</span></span><br><span class="line">        result-&gt;invoke = aBlock-&gt;invoke;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// reset refcount</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed</span></span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br><span class="line">        _Block_call_copy_helper(result, aBlock);</span><br><span class="line">        <span class="comment">// Set isa last so memory analysis tools see a fully-initialized object.</span></span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-分析"><a href="#5-2-分析" class="headerlink" title="5.2 分析"></a>5.2 分析</h3><p>我们知道，基于<code>block</code> 的性质，在block 的使用中，当<code>block</code>被copy 时，会从堆区到栈区进行<code>copy</code>，具体发生了什么，不妨读一读源码，看看苹果工程师是如何设计<code>block</code>的<code>copy</code>实现：</p><ol><li><p>先判断block 的类型：先强转<code>arg</code>获取block_layout ，判断其flags</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">aBlock = (<span class="keyword">struct</span> Block_layout *)arg;</span><br></pre></td></tr></table></figure></li><li><p>如果是堆<code>block</code>，即<strong>BLOCK_NEEDS_FREE</strong>：创建的对象需要程序员手动释放——由于此时block 空间已经初始化，所以不做拷贝，只增加引用计数即可，如下;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">    <span class="comment">// latches on high</span></span><br><span class="line">    <span class="built_in">latching_incr_int</span>(&amp;aBlock-&gt;flags);</span><br><span class="line">    <span class="keyword">return</span> aBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果是全局<code>block</code> –BLOCK_IS_GLOBAL，直接返回</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">    <span class="keyword">return</span> aBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果是栈区block：进行一次拷贝操作，拷贝到——&gt;<strong>堆区</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    else &#123;</span><br><span class="line">        // Its a stack block.  Make a copy.</span><br><span class="line">        struct Block_layout *result =</span><br><span class="line">            (struct Block_layout *)malloc(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">        if (!result) return NULL;</span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first</span><br><span class="line">#if __has_feature(ptrauth_calls)</span><br><span class="line">        // Resign the invoke pointer as it uses address authentication.</span><br><span class="line">        result-&gt;invoke = aBlock-&gt;invoke;</span><br><span class="line">#endif</span><br><span class="line">        // reset refcount</span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    // XXX not needed</span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | 2;  // logical refcount 1</span><br><span class="line">        _Block_call_copy_helper(result, aBlock);</span><br><span class="line">        // Set isa last so memory analysis tools see a fully-initialized object.</span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>创建一个新的<code>Block_layout</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Block_layout</span> *result =</span><br><span class="line">    (<span class="keyword">struct</span> Block_layout *)<span class="built_in">malloc</span>(aBlock-&gt;descriptor-&gt;size);</span><br></pre></td></tr></table></figure></li><li><p>如果有函数指针调用，将新的Block_layout 指针指向原函数实现，即替换原方法实现：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">        <span class="comment">// Resign the invoke pointer as it uses address authentication.</span></span><br><span class="line">        result-&gt;invoke = aBlock-&gt;invoke;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>把原来<code>aBlock </code>的数据通过内存拷贝到堆区</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memmove</span>(result, aBlock, aBlock-&gt;descriptor-&gt;size); <span class="comment">// bitcopy first</span></span><br></pre></td></tr></table></figure></li><li><p>重置引用计数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed</span></span><br><span class="line">   result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br><span class="line">   _Block_call_copy_helper(result, aBlock);</span><br></pre></td></tr></table></figure></li><li><p>重置isa 指向到一个新的堆block</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">result-&gt;isa = _NSConcreteMallocBlock;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="5-3-小结"><a href="#5-3-小结" class="headerlink" title="5.3 小结"></a>5.3 小结</h3><h4 id="5-3-1-操作copy-结果"><a href="#5-3-1-操作copy-结果" class="headerlink" title="5.3.1 操作copy 结果"></a>5.3.1 操作copy 结果</h4><ol><li>对栈block进行copy：拷贝一份到堆区</li><li>对全局block进行copy：仍是全局block</li><li>对堆block进行copy：增加引用计数</li></ol><h4 id="5-3-2-总结图"><a href="#5-3-2-总结图" class="headerlink" title="5.3.2 总结图"></a>5.3.2 总结图</h4><p>俗话说的好，有图有真相，将上述流程汇总成一张图，是这样的</p><p><img src="/p/1bf24dc1/002.png"></p><h2 id="六、release-与dispose"><a href="#六、release-与dispose" class="headerlink" title="六、release 与dispose"></a>六、release 与dispose</h2><p>当block 需要释放时，系统内做了哪些工作呢？先看看<code>_Block_object_dispose</code> 函数如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void _Block_object_dispose(const void *object, const int flags) &#123;</span><br><span class="line">    switch (os_assumes(flags &amp; BLOCK_ALL_COPY_DISPOSE_FLAGS)) &#123;</span><br><span class="line">      case BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      case BLOCK_FIELD_IS_BYREF:</span><br><span class="line">        // get rid of the __block data structure held in a Block</span><br><span class="line">        _Block_byref_release(object);</span><br><span class="line">        break;</span><br><span class="line">      case BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">        _Block_release(object);</span><br><span class="line">        break;</span><br><span class="line">      case BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">        _Block_release_object(object);</span><br><span class="line">        break;</span><br><span class="line">      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK  | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，除了<code>BLOCK_FIELD_IS_BYREF</code>类型的情况，此种情况为通过__block修饰变量进入，其他情况直接调用release 或者不用操作即可。</p><p><code>BLOCK_FIELD_IS_BYREF</code> 的情况下，需要调用release 方法，即<code>_Block_byref_release(object)</code>，继续查看如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _Block_byref_release(<span class="type">const</span> <span class="type">void</span> *arg) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Block_byref</span> *byref = (<span class="keyword">struct</span> Block_byref *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dereference the forwarding pointer since the compiler isn&#x27;t doing this anymore (ever?)</span></span><br><span class="line">    byref = byref-&gt;forwarding;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (byref-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) &#123;</span><br><span class="line">        <span class="type">int32_t</span> refcount = byref-&gt;flags &amp; BLOCK_REFCOUNT_MASK;</span><br><span class="line">        <span class="built_in">os_assert</span>(refcount);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">latching_decr_int_should_deallocate</span>(&amp;byref-&gt;flags)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (byref-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">Block_byref_2</span> *byref2 = (<span class="keyword">struct</span> Block_byref_2 *)(byref+<span class="number">1</span>);</span><br><span class="line">                (*byref2-&gt;byref_destroy)(byref);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(byref);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放的过程比较简单：</p><ol><li><p>isa 指回原对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">byref = byref-&gt;forwarding;</span><br></pre></td></tr></table></figure></li><li><p>生成一个新的<code>Block_byref_2</code> 指针&#96;&#96;byref2<code>，指向</code>byref&#96;下个内存位</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Block_byref_2</span> *byref2 = (<span class="keyword">struct</span> Block_byref_2 *)(byref+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过<code>byref2</code> 向原blog引用发送摧毁消息</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(*byref2-&gt;byref_destroy)(byref);</span><br></pre></td></tr></table></figure></li><li><p>释放原block（byref）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(byref);</span><br></pre></td></tr></table></figure></li></ol><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>本片篇幅较多，主要从block 的结构、block 循环引用的原理解决、block捕获外部变量，__block 究竟做了什么，以及源码层面上做了大量的分析。总的来说block是很巧妙的一项涉及，合理地用好，可以帮我们极大地提高工作效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> block </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】查找算法（二）平衡二叉树</title>
      <link href="/p/d4ce128d.html"/>
      <url>/p/d4ce128d.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><ul><li><p><strong>平衡二叉树</strong></p><p>（Self-Balancing Banary Search Tree 或者 Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。</p></li><li><p><strong>AVL 树</strong></p><p>两位俄罗斯数学家G.M.Adelson-Velskii 和E.M.Landis 在1962年共同发明一种解决平衡二叉树的算法，所以不少资料这样的平衡二叉树为 <strong>AVL树</strong>。可以看出它是一种<strong>高度平衡的二叉排序树</strong>。</p></li><li><p><strong>平衡因子</strong></p><p>我们将二叉树上左子树深度减去右子树深度的值称为平衡因子<strong>BF（Balance Factor）</strong>。</p></li><li><p><strong>最小不平衡子树</strong></p><p>当向一棵树插入结点，距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为<strong>最小不平衡子树</strong>。</p></li></ul><p>举例如下：</p><p><strong>符合平衡二叉树</strong></p><p><img src="/p/d4ce128d/001.png"></p><p><strong>不符合的如下</strong>：</p><ul><li>第一张图是因为并非升序。</li><li>第二张图：虽然其他姐都都比较平衡，但是结点6的左子树深度3，右子树0，差别为3，不符合<strong>每一个结点</strong>的左子树和右子树高度差至多等于1。</li></ul><p><img src="/p/d4ce128d/002.png"></p><p>最小不平衡树示意图，插入<strong>新结点5</strong>后，树原本的平衡被打破，结点4 的左右子树深度为，左3 - 右 1 &#x3D; 2，大于1。称为了非平衡结点。此时从<strong>结点5</strong>开始以下的子树为最小不平衡子树。</p><p><img src="/p/d4ce128d/003.png"></p><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><h2 id="三、算法实现"><a href="#三、算法实现" class="headerlink" title="三、算法实现"></a>三、算法实现</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 平衡二叉树 </tag>
            
            <tag> AVL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】查找算法（一）</title>
      <link href="/p/87f3f6a9.html"/>
      <url>/p/87f3f6a9.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、概论"><a href="#一、概论" class="headerlink" title="一、概论"></a>一、概论</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><p><strong>查找</strong>（searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定制的数据元素（或记录）。</p><p><strong>查找表</strong>（search table）是由同一类型的数据元素（或记录）构成的组合。例如下图：</p><p><img src="/p/87f3f6a9/001.png"></p><p><strong>关键字（key）</strong>三数据元素中某个数据项的值，又称为键值。用它可以标示一个记录的某个数据项，我们称为关键码。</p><h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h3><p>按照表查找方式来分有辆大众：静态查找表和动态查找表。</p><p><strong>静态查找表（Static Search Table）： 只做查找操作的查找表</strong>，主要操作有：</p><ol><li>查询某个“特定的”数据元素是否在查找表中</li><li>检索某个“特点的“数据元素和各种属性</li></ol><p><strong>动态查找表（Dynamic Search Table）</strong>：<strong>在查找的过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素</strong>。动态查找表的操作是两个：</p><ol><li>查找时插入数据元素</li><li>查找时删除数据元素</li></ol><h2 id="二、静态查找"><a href="#二、静态查找" class="headerlink" title="二、静态查找"></a>二、静态查找</h2><h3 id="2-1-顺序查找"><a href="#2-1-顺序查找" class="headerlink" title="2.1 顺序查找"></a>2.1 顺序查找</h3><p><strong>顺序查找</strong>（Sequential Search）又叫线性查找，是最基本的查找技术，他的查找过程是：从表的第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，</p><ol><li>若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；</li><li>如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。</li></ol><h4 id="2-3-1-顺序查找算法"><a href="#2-3-1-顺序查找算法" class="headerlink" title="2.3.1 顺序查找算法"></a>2.3.1 顺序查找算法</h4><p>算法比较简单，在数组里遍历查找:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-顺序查找优化"><a href="#2-3-2-顺序查找优化" class="headerlink" title="2.3.2 顺序查找优化"></a>2.3.2 顺序查找优化</h4><p>由于上述算法，每次都需要判断<code>i</code>是否越界，稍显复杂，我们对算法进行改进，在0位加入一个<strong>哨兵</strong>，可以减少一次让 i 与 n 比较，具体如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 1. 在0 位设置称为key，称为哨兵</span></span><br><span class="line">    a[<span class="number">0</span>] = key ;</span><br><span class="line">    i = n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 从尾部开始倒序循环</span></span><br><span class="line">    <span class="keyword">while</span> (a[i] != key) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 返回&gt;0 说明找到虚序号；=0 则 = key，表示查找失败</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里改动了3个步骤</p><ol><li>在0 位设置称为key，称为哨兵</li><li><strong>循环倒置</strong>。从尾部开始倒序循环，好处是形成了一个完整循环（包括哨兵）</li><li><strong>查找结果二合一</strong>：返回&gt;0 说明找到虚序号；&#x3D;0 则 &#x3D; key，表示查找失败</li></ol><h3 id="2-4-折半查找"><a href="#2-4-折半查找" class="headerlink" title="2.4 折半查找"></a>2.4 折半查找</h3><p><strong>折半查找（Binary Search）</strong>，又称为二分查找。</p><p><strong>前提</strong>是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。</p><p>折半查找的基本思想：</p><ul><li>在有序表中，去中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；</li><li>若给定值小于中间记录的关键字，则在中间记录作伴去继续查找；</li><li>若给定值大于中间记录的关键字中，则在中间记录的右半区继续查找。</li></ul><p>不断重复上述过程直到查找成功，或所有查找区域无记录，查找失败位置。</p><p>举例：现在有个数组 $&lt;!–swig￼20–&gt;$，查找其中 $88$ 的序号</p><p>代码实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 折半查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">1</span>;</span><br><span class="line">    high = n;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid])&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找流程如下图:</p><p><img src="/p/87f3f6a9/002.png"></p><h3 id="2-3-插值查找"><a href="#2-3-插值查找" class="headerlink" title="2.3 插值查找"></a>2.3 插值查找</h3><h4 id="2-3-1-折半改进"><a href="#2-3-1-折半改进" class="headerlink" title="2.3.1 折半改进"></a>2.3.1 折半改进</h4><p>由于折半查找会从中间开始查找，一旦超过一定量级，查找任务还是比较繁重。所以考虑是否还有改进空间</p><p>查找代码中求 <code>mid</code>的计算公式可以改进为：</p><p>$$<br>mid &#x3D; \frac{low+high}{2} &#x3D; low + \frac{1}{2} (high - low)<br>$$<br>也就是 mid等于最下标 <code>low</code> 加上 最高下标 <code>high</code> 与<code>low</code> 的差值的<strong>一半</strong>。</p><p>考虑将这个<strong>一半</strong>改进为以下方案：<br>$$<br>mid &#x3D; low + \frac{ key - a [low]}{ a[high] - a[low]}(high - low)<br>$$<br><strong>改进的好处：</strong>可以大大减少查找的次数。</p><p>比如数组  {6,12,18,25,31,37,43,50,56,62,68,75,82,88,96}，查找<strong>18</strong> ，按照<strong>折半查找</strong>需要查找4步才可以找到</p><p>使用新公示，需要  $\frac{ key - a [low]}{a[high] - a[low]}$ &#x3D; $ \frac{(18 - 12)}{(96 - 12)} \approx 0.071$，那么此时 $mid\approx 1 + 0.071\times (15-1) &#x3D; 1.994$，取整后，只需要查询2次即可，大大提升了效率。</p><p>这样的到了另一种有虚表查找算法，插值查找法。</p><h4 id="2-3-2-核心概念"><a href="#2-3-2-核心概念" class="headerlink" title="2.3.2 核心概念"></a>2.3.2 核心概念</h4><p><strong>插值查找法(Interpolation Search)</strong> 是根据要查找的关键字<code>key</code> 与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值公示:<br>$$<br>\frac{key - a[low]}{a[high] - a[low]}<br>$$<br><strong>缺点：</strong>不适合数字差距不均匀的数组。如 {0, 1, 2, 1000, 30000}</p><h4 id="2-3-2-算法实现"><a href="#2-3-2-算法实现" class="headerlink" title="2.3.2 算法实现"></a>2.3.2 算法实现</h4><p>由上可知，只需要改进一行代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 插值查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">1</span>;</span><br><span class="line">    high = n;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="comment">//  插值公示</span></span><br><span class="line">        mid = low + (high - low) * (key - a[low]) / (a[high] - a[low]));</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid])&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-斐波那契查找"><a href="#2-5-斐波那契查找" class="headerlink" title="2.5 斐波那契查找"></a>2.5 斐波那契查找</h3><p><strong>斐波那契查找（Fibonacci Search）</strong>，利用了黄金分割来实现。</p><p>查找的流程，先举例实现吧，假设给定一个数组 $a[10] &#x3D; $ {0, 1, 16, 24, 35, 47, 59, 62,73, 88, 99}, 此时$n &#x3D; 10$，需要查找的键为 $key &#x3D; 99$</p><ul><li><p>先定义一个斐波那契数列 <code>F[n]</code> </p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>F</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>5</td><td>8</td><td>13</td><td>21</td><td>34</td></tr></tbody></table><p>  它原理之前有学习过，实现原理是<strong>递归原理</strong>，代码实现如下：</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">F[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    F[i] = F[i <span class="number">-1</span>] + F[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义变量和下表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> low, high, mid, i, k;</span><br><span class="line">low = <span class="number">1</span>, high = n;</span><br></pre></td></tr></table></figure><p>其中 <code>low</code> 、<code>high</code>分别为数组最低下标，默认 high为最大</p><p><img src="/p/87f3f6a9/004.png"></p></li><li><p>计算 n 位于斐波那契数列的位置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (n &gt; F[k]) <span class="number">-1</span></span><br><span class="line">k++;</span><br></pre></td></tr></table></figure><p>由于上文给出的数组长度$n &#x3D; 10$，得出 $F[6] &lt; n &lt; F[7]$， 所以此时 $k &#x3D; 7$，在队列中如图示</p><p><img src="/p/87f3f6a9/003.png"></p></li><li><p>将不满的数值补全，用<code>a[n]</code>，<strong>为什么</strong>补齐？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = n; i &lt; F[k] - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    a[i] = a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始查找：</p><ol><li><p>设定初始条件 $low &lt;&#x3D; high$，假设查找 n &#x3D; 10，需要查找key &#x3D; 59</p></li><li><p>计算当前分割下标，$mid &#x3D; low + F[k - 1] -1$， 此时$mid &#x3D; 1 + F[7-1] -1 &#x3D;8$</p></li><li><p>判断，若 $key &lt; a[mid]$ ，即如果查找记录小于当前分割记录</p><ul><li><p>最高下标调整到分隔下标的 $mid -1$ 处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">high = mid <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></li><li><p>斐波那契数列下标减$1$位</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k--;</span><br></pre></td></tr></table></figure></li></ul><p>这一步中 key 为59， a[mid] 及a[8] 为73，所以$key&lt;a[mid]$，需要进行调整， 如下图所示</p><p><img src="/p/87f3f6a9/005.png"></p><p>此时各项<strong>参数结果</strong>为：$k &#x3D; 6, low &#x3D; 1, mid &#x3D; 8, high &#x3D; 7$</p></li><li><p>继续循环查找。</p><ol><li>计算当前分隔的下标：$mid &#x3D; F[6-1] - 1 &#x3D; 5$ 。</li><li>继续判断 key 与 a[mid]，此时 $a[5] &#x3D; 47 &lt; key$，</li><li>执行两个步骤：</li></ol><ul><li><p>最低下标调整到分割下标 $mid + 1$ 处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">low = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>斐波那契数列下标减2位</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k = k - <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><p>实现示意图如下：<img src="/p/87f3f6a9/006.png"></p><p>此时各项<strong>参数结果</strong>为：$k &#x3D; 4, low &#x3D; 6, mid &#x3D; 5, high &#x3D; 7$</p></li><li><p>再次循环。</p><ol><li>计算当前分隔的下标：$mid &#x3D; 6 + F[4-1] -1 &#x3D; 7$。</li><li>继续判断 key 与 a[mid] 的大小，此时 $a[7] &#x3D; 62 &gt; key$，因此执行第三步的策略。</li><li>重复一下如下：</li></ol><ul><li><p>最高下标调整到分隔下标的 $mid -1$ 处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">high = mid <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></li><li><p>斐波那契数列下标减$1$位</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k--</span><br></pre></td></tr></table></figure></li></ul><p>实现示意图如下：</p><p><img src="/p/87f3f6a9/007.png"></p><p>此时各项<strong>参数结果</strong>为：$k &#x3D; 3, low &#x3D; 6, mid &#x3D; 5, high &#x3D; 6$</p></li><li><p>再次循环。</p><ol><li><p>计算当前分隔的下标：$mid &#x3D; 6 + F[3-1] &#x3D;1 &#x3D; 6$</p></li><li><p>判断 key 与 a[mid] ，此时 a[6] &#x3D; 59 &#x3D; key 。说明查找到，进行返回数组下标，返回值为 $6$</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mid &lt; n)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> n;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>回答为什么补齐$a[n]$</p><p>在循环查找的过程中，如果查找的$key&#x3D;99$，</p><p>那么第一次查找时， </p><ul><li>$mid &#x3D; 8$；</li><li>$low &#x3D; mid + 1 &#x3D; 9$</li><li>$k &#x3D; k - 2 &#x3D; 7 - 2 &#x3D; 5$</li></ul><p>第二次循环时，此时改变分隔mid 下标的值，$mid &#x3D;low + F[k - 1] - 1 &#x3D; 9 + 3 - 1 &#x3D; 11$， 而此时a[mid] 为a[11] ，数组a 中的11位时没有值，会导致下一步与 key 的比较失败，为了避免情况发生，对上文中将不满的数值补全，用 <code>a[i] = a[n]</code>。</p></li></ul><h4 id="2-2-2-算法核心"><a href="#2-2-2-算法核心" class="headerlink" title="2.2.2 算法核心"></a>2.2.2 算法核心</h4><p>根据上文的查找流程，总结一下算法核心</p><ol><li>当 $key &#x3D; a[mid]$ 时，查找成功</li><li>当 $key &lt; a[mid]$ 时，新范围是第 low 个到第 mid -1 个，此时范围个数为 F[k - 1] - 1  个 </li><li>当 $key &gt; a[mid]$ 时，新范围是第 m+1 个到第 high 个，此时范围个数为 F[k-2] -1 个</li></ol><p>示意图如下：</p><p><img src="/p/87f3f6a9/008.png"></p><h4 id="2-2-2-算法实现"><a href="#2-2-2-算法实现" class="headerlink" title="2.2.2 算法实现"></a>2.2.2 算法实现</h4><p>先看看代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> F[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">Fibonnaci_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid, i, k;</span><br><span class="line">    low = <span class="number">1</span>;</span><br><span class="line">    high = n;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; F[k] - <span class="number">1</span>) &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &lt; F[k] - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        a[i] = a[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = low + F[k <span class="number">-1</span>] <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">            high = mid <span class="number">-1</span>;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            low = mid++;</span><br><span class="line">            k = k <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt;= n)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-查找效率"><a href="#2-6-查找效率" class="headerlink" title="2.6 查找效率"></a>2.6 查找效率</h3><p>三种查找方式的公式如下，三种方式各有优劣，适合不同场景:</p><ul><li>折半查找: $mid &#x3D; (low + high) &#x2F; 2$</li><li>插值查找，适合: $mid &#x3D; low + \frac{key - a[low]}{a[high] - a[low]} * (high - low)$</li><li>斐波那契查找: $mid &#x3D; low + F[k - 1] - 1$</li></ul><p>优劣点即使用场景：</p><ul><li>折半查找：适合数据规模较小，执行效率高</li><li>插值查找：适合数据规模较大，比折半查找更高效，但规模较小，以数值递增波动较大时与折半查找区别不大；</li><li>斐波那契：相比插值查找，适合数据递增波动较大的场景。</li></ul><h2 id="三、动态查找"><a href="#三、动态查找" class="headerlink" title="三、动态查找"></a>三、动态查找</h2><h3 id="3-1-二叉排序树"><a href="#3-1-二叉排序树" class="headerlink" title="3.1 二叉排序树"></a>3.1 二叉排序树</h3><h4 id="3-1-1-定义"><a href="#3-1-1-定义" class="headerlink" title="3.1.1 定义"></a>3.1.1 定义</h4><p>二叉排序树（Binary Sort Tree），又称为二叉查找树。它是一种空树，或者具有下列性质的二叉树：</p><ul><li>若它的左子树不空，则右子树上所有结点的值均小于它的根结点的值</li><li>若它的右子树不空，则左子树上所有结点的值均大于它的根结点的值</li><li>它的左、右子树分别为二叉排序树</li></ul><h4 id="3-1-2-查找"><a href="#3-1-2-查找" class="headerlink" title="3.1.2 查找"></a>3.1.2 查找</h4><ol><li><p>二叉树的结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span> *<span class="title">lChild</span>, *<span class="title">rChild</span>;</span> <span class="comment">// 指针分别指向左、右子树</span></span><br><span class="line">&#125;BitNode, *BiTree;</span><br></pre></td></tr></table></figure></li><li><p>代码实现如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">SearchBST</span><span class="params">(BiTree T, <span class="type">int</span> key, BiTree f, BiTree *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) &#123;</span><br><span class="line">        *p = f;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( key == T-&gt;data)&#123;</span><br><span class="line">        *p = T;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lChild, key, T, p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rChild, key, T, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分析查找流程:</p><ol><li>判断树的有效性</li><li>指针 f 指向 T 结点的双亲，如果第一次，使用值为 <code>NULL</code></li><li>判断结点数值与 目标值元素结点的数据是否相等<ol><li>结点的值与目标值相等——指针 p 指向元素结点，返回成功</li><li>如果目标值<code>key</code>小于元素结点数据，在左子树上，进行查找函数递归</li><li>如果目标 <code>key</code>大于元素结点数据，在右子树上，进行查找函数递归</li></ol></li></ol></li><li><p>示意图如下：</p><p><img src="/p/87f3f6a9/009.png"></p><p><img src="/p/87f3f6a9/010.png"></p></li></ol><h4 id="3-1-3-插入"><a href="#3-1-3-插入" class="headerlink" title="3.1.3 插入"></a>3.1.3 插入</h4><p>插入的流程有以下几个步骤</p><ul><li>先查找目标元素，如果存在，无需插入，返回</li><li>如果不存在，判断 目标值 <code>key</code> 与 指针<code>p</code><ul><li>如果大于，则 插入 s 为左孩子</li><li>如果小于，则插入 s 为右孩子</li></ul></li></ul><p>代码实现如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InsertBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree p, s;</span><br><span class="line">    <span class="keyword">if</span> (!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p)) &#123;</span><br><span class="line">        s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</span><br><span class="line">        s-&gt;data = key;</span><br><span class="line">        s-&gt;lChild = s-&gt;rChild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            *T = s;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; p-&gt;data)&#123;</span><br><span class="line">            p-&gt;lChild = s;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;rChild = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-删除"><a href="#3-2-4-删除" class="headerlink" title="3.2.4 删除"></a>3.2.4 删除</h4><p>删除结点有三种情况分析:</p><ul><li>叶子结点</li><li>仅有左&#x2F;右子树的结点</li><li>左右子树都有结点的</li></ul><p>对应的策略如下：</p><ul><li><p>当删除叶子结点：</p><p>无需操作，free 即可</p></li><li><p>当删除仅有左&#x2F;右子树的结点时：</p><p>将它的原子树移动到它的位置，替代他即可</p></li><li><p>当删除结点左右子树都有结点时：</p><ul><li>找到待删结点的前缀</li><li>重接q 的右子树</li><li>重接q 的左子树</li></ul></li></ul><p>代码实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DeleteBST</span><span class="params">(BiTree *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree q,s;</span><br><span class="line">    <span class="comment">// 右子树为空</span></span><br><span class="line">    <span class="keyword">if</span> ((*p)-&gt;rChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;lChild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左子树为空</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((*p)-&gt;lChild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;rChild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 左右子树均不为空</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        s = (*p)-&gt;lChild;</span><br><span class="line">        <span class="keyword">while</span> (s-&gt;rChild) &#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rChild;</span><br><span class="line">        &#125;</span><br><span class="line">        (*p)-&gt;data = s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (q!= *p) &#123;</span><br><span class="line">            q-&gt;rChild = s-&gt;lChild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q-&gt;lChild = s-&gt;lChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示意图如下：</strong></p><ul><li>找到目标结点 $8$，标记为 p</li><li>将p 赋值给临时变量 q，再将其左子树赋值给临时变量 s</li></ul><p><img src="/p/87f3f6a9/011.png"></p><ul><li>循环找到左子树的右结点，知道右侧尽头，得到结点$7$，将临时变量<code>s</code>指向该结点</li></ul><p><img src="/p/87f3f6a9/012.png"></p><ul><li>将删除结点的数值赋值为 临时变量 s-&gt; data，即 <code>p-&gt;data = s-&gt;data</code>。</li></ul><p><img src="/p/87f3f6a9/013.png"></p><ul><li>最后一步，将目标结点7 进行<strong>释放</strong>，至此，删除完成。</li></ul><p>上述情况时最右侧结点为叶子结点，还有一种情况最右侧结点右子结点，该如何处理呢。</p><ul><li>这里的步骤和上文一样，赋值临时变量p，s</li></ul><p><img src="/p/87f3f6a9/014.png"></p><ul><li>找到目标结点6，将临时变量s 指向6</li></ul><p><img src="/p/87f3f6a9/015.png"></p><ul><li>将删除结点的数值赋值为 临时变量 s-&gt; data，即 <code>p-&gt;data = s-&gt;data</code>。此时相当于结点6 被删除，它的子结点需要妥善处理。</li></ul><p><img src="/p/87f3f6a9/016.png"></p><ul><li><p>此时如果 p 和 q 指向不相同，则将 6 的子树交给 它的父结点。</p><p>即 <code>q-&gt;rChild = s-&gt;lChild</code>。这样节点6 留下的左结点被链接进入树了。</p></li></ul><p><img src="/p/87f3f6a9/017.png"></p><ul><li><p>最后一步，free 掉删除的目标结点</p><p><img src="/p/87f3f6a9/017.png"></p></li></ul><h4 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5 总结"></a>3.2.5 总结</h4><p>二叉排序树是以连接的方式存储，保持了链式存储结构在执行插入和删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
            <tag> 斐波那契 </tag>
            
            <tag> 插值 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法10】拓扑排序</title>
      <link href="/p/96e21745.html"/>
      <url>/p/96e21745.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>拓扑排序，其实就是对一个有向图构造拓扑序列的过程。</p></blockquote><h3 id="AOV-网"><a href="#AOV-网" class="headerlink" title="AOV 网"></a>AOV 网</h3><p>在一个表示工程的有向图中，用定点表示活动，用弧表示活动之间的有限关系，这样的有向图为顶点表示活动的网，我们称为<strong>AOV 网</strong>(Activity On Vertex Network)。</p><h3 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h3><p>设 G&#x3D; (V, E) 设一个具有n 个顶点的有向图， V 中的顶点序列 v<sub>1</sub>,  v<sub>2</sub>, ……  v<sub>n</sub>，满足若从订单 v<sub>i</sub> 到 v<sub>j</sub> 有一条路径，则在顶点序列中定点  v<sub>i</sub> 必在顶点  v<sub>j</sub> 之前。则我们称这样的顶点序列为一个<strong>拓扑序列</strong>。</p><h2 id="二、排序算法"><a href="#二、排序算法" class="headerlink" title="二、排序算法"></a>二、排序算法</h2><h2 id="三、流程解析"><a href="#三、流程解析" class="headerlink" title="三、流程解析"></a>三、流程解析</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 拓扑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【多线程】锁分析</title>
      <link href="/p/48b87814.html"/>
      <url>/p/48b87814.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h3 id="1-1-同步"><a href="#1-1-同步" class="headerlink" title="1.1 同步"></a>1.1 同步</h3><p>为了避免多个线程同时读写同一个数据而产生不可预料的后果，我们要将各个线程对同一个数据的访问<strong>同步</strong>（Synchronization）。</p><p>所谓<strong>同步</strong>，即指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。如此，对数据的访问被原子化了。</p><p>同步最常见的方法是使用<strong>锁</strong>（Lock）。</p><h3 id="1-2-锁"><a href="#1-2-锁" class="headerlink" title="1.2 锁"></a>1.2 锁</h3><p>锁是一种非强制机制，每一个线程在访问数据或资源之前首先试图<strong>获取</strong>（Acquire）锁，并在访问结束之后释放（Release）锁。在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。</p><h2 id="二、类型"><a href="#二、类型" class="headerlink" title="二、类型"></a>二、类型</h2><p>在计算机开发中，锁通常有3大类：<strong>自旋锁、互斥锁、条件锁</strong>。</p><h3 id="2-1-自旋锁（SpinLock）"><a href="#2-1-自旋锁（SpinLock）" class="headerlink" title="2.1 自旋锁（SpinLock）"></a>2.1 自旋锁（SpinLock）</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>线程反复检查变量是否可用。由于线程在这一过程中保持执行，因此属于忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li>OSSpinLock 因为<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">线程安全</a>，现已被废弃</li></ul><h3 id="2-2-互斥锁（Mutex）"><a href="#2-2-互斥锁（Mutex）" class="headerlink" title="2.2 互斥锁（Mutex）"></a>2.2 互斥锁（Mutex）</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>防止两条线程同时对同一公共资源进行读写的机制。通过将代码切片成一个个临界区而实现。</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><ul><li>pthread_mutex</li><li>@synchronized</li><li>NSLock </li><li>os_unfair_lock</li></ul><h3 id="2-3-条件锁（Condition-Variable）"><a href="#2-3-条件锁（Condition-Variable）" class="headerlink" title="2.3 条件锁（Condition Variable）"></a>2.3 条件锁（Condition Variable）</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>作为一种同步手段，作用类似一个栅栏。当进程的某些资源要求不满足就进入休眠，也就是锁住。当资源被分配到了，条件锁打开，进程继续进行。</p><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><ul><li>NSCondition</li><li>NSConditionLock</li></ul><h3 id="2-4-递归锁-recursive"><a href="#2-4-递归锁-recursive" class="headerlink" title="2.4 递归锁(recursive)"></a>2.4 递归锁(recursive)</h3><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>同一个线程可以加锁N 次而不会引起死锁</p><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><ul><li>NSRecursiveLock</li><li>pthread_mutex(recursive)</li></ul><h3 id="2-5-信号量（Semaphore）"><a href="#2-5-信号量（Semaphore）" class="headerlink" title="2.5 信号量（Semaphore）"></a>2.5 信号量（Semaphore）</h3><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><p>允许多给写线程并发访问的资源，简称信号量，一个初始值为N的信号量允许N个线程并发放温。</p><p>线程访问资源时做以下操作:</p><ul><li>信号值减1</li><li>如果信号值小于0，则进入等待状态，否则继续执行</li></ul><p>线程访问完资源后，释放信号量时操作如下：</p><ul><li>信号量得值加1</li><li>如果信号量的值小于1，唤醒一个等待中的线程</li></ul><h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><ul><li>dispatch_semaphore</li></ul><h2 id="三、常见锁分析"><a href="#三、常见锁分析" class="headerlink" title="三、常见锁分析"></a>三、常见锁分析</h2><h3 id="3-1-递归锁-synchronized分析"><a href="#3-1-递归锁-synchronized分析" class="headerlink" title="3.1 递归锁 - @synchronized分析"></a>3.1 递归锁 - @synchronized分析</h3><h4 id="3-1-1-引子"><a href="#3-1-1-引子" class="headerlink" title="3.1.1 引子"></a>3.1.1 引子</h4><p>先编写    如下代码，并打开汇编诊断（Xcode中，Debug——Debug Flow——Always Show Dissembly）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@synchronizedd (self) &#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;hey jude&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到如下调用栈：</p><p><img src="/p/48b87814/001.png"></p><p>留意到有objc_sync_enter 以及objc_sync_exit，进入退出一一匹配，猜测可能就是锁的加锁与解锁。先不管了，找到<code>objc</code> <a href="https://opensource.apple.com/tarballs/objc4/">开源库</a></p><h4 id="3-1-2-objc-sync-enter"><a href="#3-1-2-objc-sync-enter" class="headerlink" title="3.1.2 objc_sync_enter"></a>3.1.2 objc_sync_enter</h4><p>在objc4 中可以找到objc_sync_enter 函数，它的作用是：开始锁住<code>obj</code>，如有必要，开辟递归互斥锁关联到<strong>obj</strong>，一旦锁被获取到，返回OBJC_SYNC_SUCCESS的标识</p><blockquote><p>&#x2F;&#x2F; Begin synchronizing on ‘obj’. </p><p>&#x2F;&#x2F; Allocates recursive mutex associated with ‘obj’ if needed.</p><p>&#x2F;&#x2F; Returns OBJC_SYNC_SUCCESS once lock is acquired.  </p></blockquote><p>函数实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">objc_sync_enter</span><span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        ASSERT(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronizedd(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;NIL SYNC DEBUG: @synchronizedd(nil); set a breakpoint on objc_sync_nil to debug&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下方法实现：</p><ul><li><p>如果加锁目标对象不存在，不作操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @synchronizedd(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;NIL SYNC DEBUG: @synchronizedd(nil); set a breakpoint on objc_sync_nil to debug&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br></pre></td></tr></table></figure><p>注释已经写得很清楚了，does nothing。继续看<code>objc_sync_nil</code> 如何实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BREAKPOINT_FUNCTION(</span><br><span class="line">    <span class="type">void</span> objc_sync_nil(<span class="type">void</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>的确，啥也没干。这样也解释了某些场合下，锁一个空对象，是不会做操作的。</p></li><li><p>如果传入对象存在</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj) &#123;</span><br><span class="line">   SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">   ASSERT(data);</span><br><span class="line">   data-&gt;mutex.lock();</span><br></pre></td></tr></table></figure><p><strong>防止死锁：</strong>这里的SyncData 拥有<code>next</code> 指向的递归锁结构，好处就是最终总会有 object 为 nil，会跳出循环，不会死锁。</p><p>这里的好处就是最终总会有 <code>object</code> 为 <code>nil</code>，会跳出循环，防止死锁。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title function_">alignas</span><span class="params">(CacheLineSize)</span> SyncData &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span>* <span class="title">nextData</span>;</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object;</span><br><span class="line">    <span class="type">int32_t</span> threadCount;  <span class="comment">// number of THREADS using this block</span></span><br><span class="line">    <span class="type">recursive_mutex_t</span> mutex;</span><br><span class="line">&#125; SyncData;</span><br></pre></td></tr></table></figure><p>里面有数据域：DisguisedPtr、threadCount、recursive_mutex_t，以及指针域：<code>SyncData* nextData</code></p><p>继续看 <code>id2data</code> 的实现如下：</p><ol><li><p>查询<strong>当前</strong>单一线程的快速缓存文件匹配。</p><p>如果有，对锁住的次数，根据传入参数类型(获取、释放、查看)，分别进行操作。</p><ul><li>如果是获取资源：锁次数++</li><li>如果是释放资源：锁次数–。当然如果次数变为0，此时锁也不复存在，需要从快速缓存移除。</li><li>如果是查看资源：不操作。</li></ul><p>相关代码精简如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SyncData *data = (SyncData *)tls_get_direct(SYNC_DATA_DIRECT_KEY);</span><br><span class="line"><span class="keyword">if</span> (data)&#123;</span><br><span class="line"><span class="type">uintptr_t</span> lockCount;</span><br><span class="line"><span class="keyword">switch</span>(why)&#123;</span><br><span class="line"><span class="keyword">case</span> ACQUIRE: &#123;</span><br><span class="line">            lockCount++;</span><br><span class="line">    <span class="keyword">case</span> RELEASE:</span><br><span class="line">            lockCount--;</span><br><span class="line">            <span class="keyword">if</span> (lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// remove from fast cache</span></span><br><span class="line">             tls_set_direct(SYNC_DATA_DIRECT_KEY, <span class="literal">NULL</span>);</span><br><span class="line">         <span class="keyword">case</span> CHECK:</span><br><span class="line">             <span class="comment">// do nothing</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询<strong>所有</strong>线程内部缓存文件与锁持有对象的匹配</p><p>首先会查找一个线程缓存<code>SyncCache</code>，查找的过程是这样的（有精简）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> SyncCache *<span class="title function_">fetch_cache</span><span class="params">(<span class="type">bool</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line">    _objc_pthread_data *data;</span><br><span class="line">    </span><br><span class="line">    data = _objc_fetch_pthread_data(create);</span><br><span class="line"><span class="comment">/* 省略部分*/</span></span><br><span class="line">    <span class="comment">// Make sure there&#x27;s at least one open slot in the list.</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;syncCache-&gt;allocated == data-&gt;syncCache-&gt;used) &#123;</span><br><span class="line">        data-&gt;syncCache-&gt;allocated *= <span class="number">2</span>;</span><br><span class="line">        data-&gt;syncCache = (SyncCache *)</span><br><span class="line">            <span class="built_in">realloc</span>(data-&gt;syncCache, <span class="keyword">sizeof</span>(SyncCache) </span><br><span class="line">                    + data-&gt;syncCache-&gt;allocated * <span class="keyword">sizeof</span>(SyncCacheItem));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data-&gt;syncCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>先创建一个<code>_objc_pthread_data</code> 类型的线程数据</p></li><li><p>查看线程私有数据，如果有，就会更新<code>data</code></p></li><li><p>接下来对同步缓存容量查看，如果使用已满（allocated &#x3D;&#x3D; used），会进行 *2 扩建扩容</p></li><li><p>接下来将同步缓存返回</p></li></ul><p>有意思的是这个<code>syncCache</code> 是专门针对@synchronized 准备的，如下图</p><p><img src="/p/48b87814/002.png"></p><p>接下来根据缓存文件<code>SyncCache</code> 的存在，进行循环遍历，取出<code>cache</code>内的元素—— <code>SyncCacheItem</code> 结构体，根据传入参数类型(获取、释放、查看)，进行内部属性，分别进行操作。</p><ul><li><p>如果是获取资源：锁次数++</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> ACQUIRE:</span><br><span class="line">     item-&gt;lockCount++;=</span><br></pre></td></tr></table></figure></li><li><p>如果是释放资源：锁次数–。当然如果次数变为0，需要从线程缓存数据移除。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> RELEASE:</span><br><span class="line">item-&gt;lockCount--;</span><br><span class="line">  <span class="keyword">if</span> (item-&gt;lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// remove from per-thread cache</span></span><br><span class="line">      cache-&gt;<span class="built_in">list</span>[i] = cache-&gt;<span class="built_in">list</span>[--cache-&gt;used];</span><br></pre></td></tr></table></figure></li><li><p>如果是查看资源：不操作。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> CHECK:</span><br><span class="line">    <span class="comment">// do nothing</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>去已使用列表查找匹配对象（快速、慢速缓存均未找到）</p><p>在介绍步骤之前，先普及一下已使用列表（in-use list） 的结构。在这个<code>id2data</code>函数执行初始时，执行了两个代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> SyncData* <span class="title function_">id2data</span><span class="params">(id object, <span class="keyword">enum</span> usage why)</span></span><br><span class="line">&#123;    </span><br><span class="line">  <span class="type">spinlock_t</span> *lockp = &amp;LOCK_FOR_OBJ(object);</span><br><span class="line">    SyncData **listp = &amp;LIST_FOR_OBJ(object);</span><br></pre></td></tr></table></figure><p>即生成了一个名为<code>lockp</code> 的自旋锁，以及<code>SyncData</code> 指针对象。而<code>LOCK_FOR_OBJ</code>与<code>LIST_FOR_OBJ</code>是两个宏操作，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use multiple parallel lists to decrease contention among unrelated objects.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class="line"><span class="type">static</span> StripedMap&lt;SyncList&gt; sDataLists;</span><br></pre></td></tr></table></figure><p>看得出都说在查找一个<code>sDataLists</code> 的列表元素的lock、data属性，这个表结构比较简单：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncList</span> &#123;</span></span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    constexpr <span class="title function_">SyncList</span><span class="params">()</span> : <span class="title function_">data</span><span class="params">(nil)</span>, <span class="title function_">lock</span><span class="params">(fork_unsafe_lock)</span> &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来重点关注一下<code>StripedMap</code> 这个类，可以成为条纹映射map，是一种结构<code>void* -&gt; T</code>的map，有一个<code>indexForPointer</code> 的函数，用来指向内部存储的对象——即缓存的syncData 对象</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> addr = reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，接下来看</p><ul><li><p>先加锁</p></li><li><p>如果找到，添加到快速缓存以及线程内缓存里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">        <span class="keyword">if</span> (!fastCacheOccupied) &#123;</span><br><span class="line">            <span class="comment">// Save in fast thread cache</span></span><br><span class="line">            tls_set_direct(SYNC_DATA_DIRECT_KEY, result);</span><br><span class="line">            tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Save in thread cache</span></span><br><span class="line">            <span class="keyword">if</span> (!cache) cache = fetch_cache(YES);</span><br><span class="line">            cache-&gt;<span class="built_in">list</span>[cache-&gt;used].data = result;</span><br><span class="line">            cache-&gt;<span class="built_in">list</span>[cache-&gt;used].lockCount = <span class="number">1</span>;</span><br><span class="line">            cache-&gt;used++;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果未找到，创建新的<code>data</code>，并加入到<code>datalist</code> 内部</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">posix_memalign((void **)&amp;result, alignof(SyncData), sizeof(SyncData));</span><br><span class="line">result-&gt;object = (objc_object *)object;</span><br><span class="line">result-&gt;threadCount = 1;</span><br><span class="line">new (&amp;result-&gt;mutex) recursive_mutex_t(fork_unsafe_lock);</span><br><span class="line">result-&gt;nextData = *listp;</span><br><span class="line">*listp = result;</span><br></pre></td></tr></table></figure></li><li><p>解锁</p></li></ul><p>小结：这个查找锁的过程，很类似方法查找的过程，先通过缓存查找，接着在方法列表里查找，如果查找不到，会创建一个并加入到列表以及二级缓存中，进行返回。</p></li><li><p>对已获取的<strong>data</strong> 加锁</p><p>执行如下操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = data-&gt;mutex.tryLock();</span><br></pre></td></tr></table></figure><p>这里会返回这个tryLock 的实现是一个递归互斥锁的执行结果，具体实现如下： </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">tryLock</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (os_unfair_recursive_lock_trylock(&amp;mLock)) &#123;</span><br><span class="line">        lockdebug_recursive_mutex_lock(this);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="3-1-3-objc-send-exit"><a href="#3-1-3-objc-send-exit" class="headerlink" title="3.1.3 objc_send_exit"></a>3.1.3 objc_send_exit</h4><p>分析完了enter，再看看如何对@synchronized 如何离开。</p><p>函数主要操作是：</p><ul><li>终止同步锁obj，</li><li>返回OBJC_SYNC_SUCCESS（成功） 或者OBJC_SYNC_NOT_OWNING_THREAD_ERROR（失败）</li></ul><blockquote><p>&#x2F;&#x2F; End synchronizing on ‘obj’. </p><p>&#x2F;&#x2F; Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</p></blockquote><ol><li><p>查看同步数据是否存在</p><p>主函数实现精简如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">  <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">      result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">      <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">          result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果锁列表里找不到obj，即加锁对象不存在，退出并报出对象同步未拥有的线程错误</p></li><li><p>如果有找到，尝试解锁<code>tryUnlock</code>。这里的解锁也是递归锁的解锁，具体实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">tryUnlock</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (os_unfair_recursive_lock_tryunlock4objc(&amp;mLock)) &#123;</span><br><span class="line">        lockdebug_recursive_mutex_unlock(this);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果解锁失败，也报出对象同步未拥有的线程错误</p></li></ol><h4 id="3-1-4-总结"><a href="#3-1-4-总结" class="headerlink" title="3.1.4 总结"></a>3.1.4 总结</h4><ol><li>针对pthread 进行了封装，体现在tls 的查找机制。</li><li>@synchronized 分为高速缓存、线程内数据缓存（tls）以及已使用对象的列表进行加锁缓存</li><li>加锁为一个syncList 的列表，列表内有多个syncData 的对象</li><li>外界对加锁对象的获取&#x2F;释放，会相应的对同步数据节点的属性+1&#x2F;-1</li><li><strong>优点：采用缓存机制，不会产生死锁</strong></li></ol><h4 id="3-1-5-引申"><a href="#3-1-5-引申" class="headerlink" title="3.1.5 引申"></a>3.1.5 引申</h4><p>先看一下会打印什么，注意，这里对self.arr 进行了@synchronized 锁操作？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        @synchronizedd (self.arr) &#123;</span><br><span class="line">            self.arr = [NSMutableArray <span class="built_in">array</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果，会崩溃</p><p><img src="/p/48b87814/003.png"></p><p>为什么，注意到这个可变数组 <code>self.arr </code>  一直属于 nil，那上文源码中得知：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @synchronizedd(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;NIL SYNC DEBUG: @synchronizedd(nil); set a breakpoint on objc_sync_nil to debug&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>即去锁一个空对象，是不会有锁操作，反而会报错崩溃。</p><p><strong>解决</strong></p><p>解决方案也简单：</p><p>对<code>self</code> 进行同步锁，这个似乎太臃肿了</p><p>也可以使用引入NSLock 进行锁定，如下操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        NSLock *lock  = [[NSLock alloc] init];</span><br><span class="line">        self.arr = [NSMutableArray <span class="built_in">array</span>];</span><br><span class="line">        [lock lock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来分析一下<code>NSLock</code></p><h3 id="3-2-互斥锁-NSLock-的分析"><a href="#3-2-互斥锁-NSLock-的分析" class="headerlink" title="3.2 互斥锁 - NSLock 的分析"></a>3.2 互斥锁 - NSLock 的分析</h3><p>大家都知道OC 中Foundation 并没有开源，所以无从查看NSLock 的实现，但是Swift 对Foundation 却开源了， 我们不妨曲线救国，在<em>Swift</em> 中一探究竟。相关Swift Foundation的源码可以在苹果的<a href="https://github.com/apple/swift-corelibs-foundation">Github仓库</a> 下载</p><h4 id="3-2-1-创建"><a href="#3-2-1-创建" class="headerlink" title="3.2.1 创建"></a>3.2.1 创建</h4><ol><li><p>类的生成</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">NSLock</span>: <span class="title class_">NSObject</span>, <span class="title class_">NSLocking</span> &#123;</span><br><span class="line"><span class="comment">// 内部私有的互斥锁，容量创建为1</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> mutex <span class="operator">=</span> _MutexPointer.allocate(capacity: <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>公用的<code>init</code>方法如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line"> </span><br><span class="line">        pthread_mutex_init(mutex, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">#if</span> os(macOS) <span class="operator">||</span> os(iOS)</span><br><span class="line">        pthread_cond_init(timeoutCond, <span class="literal">nil</span>)</span><br><span class="line">        pthread_mutex_init(timeoutMutex, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见，这个类的初始化，对内部的<code>pthread_mutex_init</code> 进行了操作，初始化局部变量互斥锁mutex</p></li></ol><h4 id="3-2-2-加锁"><a href="#3-2-2-加锁" class="headerlink" title="3.2.2 加锁"></a>3.2.2 加锁</h4><p>加锁的过程很简单，就是对内部这个互斥锁加锁</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">lock</span>() &#123;</span><br><span class="line">    pthread_mutex_lock(mutex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是常见的<code>pthread_mutex_lock</code> 函数用来操作互斥锁。这里的问题是，如果mutex 当前被锁住，执行函数，会让当前线程阻塞，直到<code>mutex</code>状态改变为可以执行位置。</p><p>在这种情况下，大胆的猜测一下，当多次调用NSLock 的lock 方法时（递归），会反复调用mutex，造成锁等待，谁也开不了谁，最终线程阻塞，影响性能。</p><p>可见 NSLock 虽好，可以有造成线程阻塞的风险，尤其是进行递归循环的时候。</p><h4 id="3-2-3-解锁"><a href="#3-2-3-解锁" class="headerlink" title="3.2.3 解锁"></a>3.2.3 解锁</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">unlock</span>() &#123;</span><br><span class="line">        pthread_mutex_unlock(mutex)</span><br><span class="line"><span class="keyword">#if</span> os(macOS) <span class="operator">||</span> os(iOS)</span><br><span class="line">        <span class="comment">// Wakeup any threads waiting in lock(before:)</span></span><br><span class="line">        pthread_mutex_lock(timeoutMutex)</span><br><span class="line">        pthread_cond_broadcast(timeoutCond)</span><br><span class="line">        pthread_mutex_unlock(timeoutMutex)</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解锁时，会对当前的<code>mutex</code> 进行解锁，以及超时解锁（使用）</p><h3 id="3-3-递归锁与互斥锁区别"><a href="#3-3-递归锁与互斥锁区别" class="headerlink" title="3.3 递归锁与互斥锁区别"></a>3.3 递归锁与互斥锁区别</h3><h4 id="3-3-4-阻塞分析及解决"><a href="#3-3-4-阻塞分析及解决" class="headerlink" title="3.3.4 阻塞分析及解决"></a>3.3.4 阻塞分析及解决</h4><p>提问：下面会打印什么：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)showLock&#123;</span><br><span class="line">    NSLock *lock = [[NSLock alloc] init];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="type">static</span> <span class="built_in">void</span> (^test)(<span class="type">int</span>);</span><br><span class="line">        test = ^(<span class="type">int</span> value)&#123;</span><br><span class="line">            [lock lock];</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;加锁🔐&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(@<span class="string">&quot;value1      %d&quot;</span>, value);</span><br><span class="line">                <span class="built_in">test</span>(value - <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">NSLog</span>(@<span class="string">&quot;value2      %d&quot;</span>, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;开锁🔐&quot;</span>);</span><br><span class="line">            [lock unlock];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">test</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果会不会是 5-1 &#x3D;4 ? 看一下打印如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">39</span>:<span class="number">13.720485</span>+<span class="number">0800</span> DDD[<span class="number">7989</span>:<span class="number">543814</span>] 加锁🔐</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">39</span>:<span class="number">13.720724</span>+<span class="number">0800</span> DDD[<span class="number">7989</span>:<span class="number">543814</span>] value1      <span class="number">5</span></span><br></pre></td></tr></table></figure><p>记过很残酷，block 只进行到第一个 NSLog 就不走了，第二个NSLog 都不再走了。</p><p><strong>原因</strong>：递归调用普通的互斥锁，会造成<strong>线程阻塞</strong>（因为不会查询缓存）。block 反复调用自身block，都走不到</p><p><strong>解决</strong>：使用<strong>递归锁</strong> NSCursiveLock 替换 NSLock</p><p>即代码为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)showLock&#123;</span><br><span class="line">    NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="type">static</span> <span class="built_in">void</span> (^test)(<span class="type">int</span>);</span><br><span class="line">        test = ^(<span class="type">int</span> value)&#123;</span><br><span class="line">            [lock lock];</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;加锁🔐&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(@<span class="string">&quot;value1      %d&quot;</span>, value);</span><br><span class="line">                <span class="built_in">test</span>(value - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            [lock unlock];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">test</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">20.645879</span>+<span class="number">0800</span> DDD[<span class="number">8048</span>:<span class="number">551083</span>] 加锁🔐</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">20.646149</span>+<span class="number">0800</span> DDD[<span class="number">8048</span>:<span class="number">551083</span>] value1      <span class="number">5</span></span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">20.646378</span>+<span class="number">0800</span> DDD[<span class="number">8048</span>:<span class="number">551083</span>] 加锁🔐</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">20.646562</span>+<span class="number">0800</span> DDD[<span class="number">8048</span>:<span class="number">551083</span>] value1      <span class="number">4</span></span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">20.646739</span>+<span class="number">0800</span> DDD[<span class="number">8048</span>:<span class="number">551083</span>] 加锁🔐</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">20.646890</span>+<span class="number">0800</span> DDD[<span class="number">8048</span>:<span class="number">551083</span>] value1      <span class="number">3</span></span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">20.647074</span>+<span class="number">0800</span> DDD[<span class="number">8048</span>:<span class="number">551083</span>] 加锁🔐</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">20.647220</span>+<span class="number">0800</span> DDD[<span class="number">8048</span>:<span class="number">551083</span>] value1      <span class="number">2</span></span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">20.648720</span>+<span class="number">0800</span> DDD[<span class="number">8048</span>:<span class="number">551083</span>] 加锁🔐</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">20.648967</span>+<span class="number">0800</span> DDD[<span class="number">8048</span>:<span class="number">551083</span>] value1      <span class="number">1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">20.649133</span>+<span class="number">0800</span> DDD[<span class="number">8048</span>:<span class="number">551083</span>] 加锁🔐</span><br></pre></td></tr></table></figure><p>此时不再阻塞，递归锁顺利完成了任务</p><p><strong>内部实现</strong>：继续在Swift Foundation 查看NSRecursiveLock 的实现，结果如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">withUnsafeMutablePointer</span>(to: <span class="operator">&amp;</span>attrib) &#123; attrs <span class="keyword">in</span></span><br><span class="line">            pthread_mutexattr_init(attrs)</span><br><span class="line">            pthread_mutexattr_settype(attrs, <span class="type">Int32</span>(<span class="type">PTHREAD_MUTEX_RECURSIVE</span>))</span><br><span class="line">            pthread_mutex_init(mutex, attrs)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可见同 NSLock 类似，它的实现是调用<code>pthread_mutexattr_settype</code> 函数，并且类型为<code>PTHREAD_MUTEX_RECURSIVE</code></p><h4 id="3-3-2-递归锁的死锁"><a href="#3-3-2-递归锁的死锁" class="headerlink" title="3.3.2 递归锁的死锁"></a>3.3.2 递归锁的死锁</h4><p>还是上面的例子，加一个for 循环，结果会如何呢？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)showLock&#123;</span><br><span class="line">    NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">             <span class="type">static</span> <span class="type">void</span> (^test)(<span class="type">int</span>);</span><br><span class="line">             test = ^(<span class="type">int</span> value)&#123;</span><br><span class="line">                 [lock lock];</span><br><span class="line">                 NSLog(@<span class="string">&quot;加锁🔐&quot;</span>);</span><br><span class="line">                 <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                     NSLog(@<span class="string">&quot;value1      %d&quot;</span>, value);</span><br><span class="line">                     test(value - <span class="number">1</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                 [lock unlock];</span><br><span class="line">             &#125;;</span><br><span class="line">             test(<span class="number">5</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果很残酷，是这样的，又崩溃了（为什么要说又呢😿）</p><p><img src="/p/48b87814/004.png"></p><p>提示很明显，最后一行<code>String release</code> 释放一个野指针。。。</p><p><strong>原因:</strong> for 循环在block 内部，对同一个对象进行了多次锁操作，最后大家都锁了一次，直到这个资源身上挂着N把锁，最后大家都无法一次性解锁——找不到解锁的出口 。</p><p>即 操作1-&gt; 加锁1-&gt; 加锁2-&gt; 操作1结束 -(有2的锁)- 无法结束解锁——形成死锁 </p><p>**解决:**可以采用使用缓存的@synchronized ，因为它对对象进行所操作，会先从缓存查找是否有锁syncData 存在，如果有，直接返回而不加锁，保证锁的唯一性。</p><p>操作如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)showLock&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">static</span> <span class="built_in">void</span> (^test)(<span class="type">int</span>);</span><br><span class="line">            test = ^(<span class="type">int</span> value)&#123;</span><br><span class="line">                @<span class="built_in">synchronizedd</span> (self) &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(@<span class="string">&quot;加锁🔐&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">NSLog</span>(@<span class="string">&quot;value1      %d&quot;</span>, value);</span><br><span class="line">                        <span class="built_in">test</span>(value - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">test</span>(<span class="number">5</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：也很和谐如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">02.225527</span>+<span class="number">0800</span> DDD[<span class="number">8255</span>:<span class="number">571494</span>] 加锁🔐</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">02.225658</span>+<span class="number">0800</span> DDD[<span class="number">8255</span>:<span class="number">571494</span>] value1      <span class="number">5</span></span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">02.225762</span>+<span class="number">0800</span> DDD[<span class="number">8255</span>:<span class="number">571494</span>] 加锁🔐</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">02.225841</span>+<span class="number">0800</span> DDD[<span class="number">8255</span>:<span class="number">571494</span>] value1      <span class="number">4</span></span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">02.225931</span>+<span class="number">0800</span> DDD[<span class="number">8255</span>:<span class="number">571494</span>] 加锁🔐</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">02.226324</span>+<span class="number">0800</span> DDD[<span class="number">8255</span>:<span class="number">571494</span>] value1      <span class="number">3</span></span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">02.226424</span>+<span class="number">0800</span> DDD[<span class="number">8255</span>:<span class="number">571494</span>] 加锁🔐</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">02.226521</span>+<span class="number">0800</span> DDD[<span class="number">8255</span>:<span class="number">571494</span>] value1      <span class="number">2</span></span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">02.226977</span>+<span class="number">0800</span> DDD[<span class="number">8255</span>:<span class="number">571494</span>] 加锁🔐</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">02.227604</span>+<span class="number">0800</span> DDD[<span class="number">8255</span>:<span class="number">571494</span>] value1      <span class="number">1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">02.228490</span>+<span class="number">0800</span> DDD[<span class="number">8255</span>:<span class="number">571494</span>] 加锁🔐</span><br></pre></td></tr></table></figure><h4 id="3-3-3-递归锁内部区别"><a href="#3-3-3-递归锁内部区别" class="headerlink" title="3.3.3 递归锁内部区别"></a>3.3.3 递归锁内部区别</h4><ul><li>@synchronized 采用缓存机制，不会造成死锁</li><li>NSRecursiveLock 异步循环调用时，会造成多次加锁，造成死锁</li></ul><h4 id="3-3-4-应用场景"><a href="#3-3-4-应用场景" class="headerlink" title="3.3.4 应用场景"></a>3.3.4 应用场景</h4><ul><li>普通场景下，涉及到安全，可以用NSLock</li><li>循环调用时用 NSRecursiveLock</li><li>循环调用时，如果要注意死锁，建议使用 @synchronized</li></ul><h3 id="3-4-条件锁分析"><a href="#3-4-条件锁分析" class="headerlink" title="3.4 条件锁分析"></a>3.4 条件锁分析</h3><h4 id="A、NSCondiction"><a href="#A、NSCondiction" class="headerlink" title="A、NSCondiction"></a>A、NSCondiction</h4><p>实际上作为一个锁和一个线程检查器：锁主要为了当检测条件时保护数据源，执行条件引发的任务；县城检查其主要是根据条件决定是否运行线程，即线程是否被阻塞。</p><p>执行起来，主要有4个步骤</p><ol><li><code>[condition lock]</code> : 一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据原只被访问、修改一次，其他线程的命令需要在 <code>lock</code>外等待，直到 <code>unlock</code> 才可以访问</li><li><code>[condition unlock]</code>： 与<code>lock</code> 同时使用</li><li><code>[condition wait]</code> ; 让当前线程处于等待状态</li><li><code>[condition signal]</code>: CPU发信号高速县城不用再等待，可以继续执行了</li></ol><h4 id="B、NSConditionLock"><a href="#B、NSConditionLock" class="headerlink" title="B、NSConditionLock"></a>B、NSConditionLock</h4><p>是一种锁，一旦一个线程获得锁，其他线程一定等待。</p><p>主要有如下几个步骤：</p><ol><li><code>[lock lock]</code> : 标识lock 期待获得锁，如果没有其他线程获得锁（此时不需要判断内部condition）那他能执行以下代码，如果已经有其他线程获得锁（可能是条件锁，或者无条件锁），则等待，知道其他线程解锁。</li><li><code>[lock lockWhenCondition: A]</code>： 表示如果没有其它线程获得该锁，但是所内部的condition不等于条件A，他依然不能获得锁，仍然等待。如果内部的<code>condition</code> 等于条件A，并且没有其他线程获得该锁，则进入代码区，同时设置他获得该锁，其他任何线程都将等待它的代码完成，直至它解锁。</li><li><code>[lock unlockWhenCondition: A]</code>：表示释放锁，同时把内部的condition 设置为A条件。</li><li><code>return [xxx lockWhenCondition: A before: B]</code>表示如果锁定（没获得锁），并超过该时间则不再阻塞线程。但是需要注意的是：返回值是<strong>NO</strong>，它没有改变锁的状态，这个函数的目的在于可以实现两种状态下的处理。</li></ol><p>总结一下：所谓的condition（状态值）是证书，内部通过整数来比较条件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（9）二叉树与顺序表实现</title>
      <link href="/p/919af6b6.html"/>
      <url>/p/919af6b6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p><a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p><a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p><a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p><a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p><a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p><a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p><p><a href="https://nilsli.com/p/b0e10b1c.html">【数据结构与算法】-（8）栈之算法题</a></p><p><a href="https://nilsli.com/p/cc625709.html">【数据结构与算法】-（8.1）字符串去重算法</a></p><p><a href="https://nilsli.com/p/8a586c1e.html">【数据结构与算法】-（8.2）字符串搜索算法和RK&amp;BP算法</a></p><p><a href="https://nilsli.com/p/22d3726c.html">【数据结构与算法】-（8.3）KMP算法</a></p><p><a href="https://nilsli.com/p/919af6b6.html#toc-heading-15">【数据结构与算法】-（9）二叉树与顺序表实现</a></p></blockquote><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h3 id="1-1-树的定义"><a href="#1-1-树的定义" class="headerlink" title="1.1 树的定义"></a>1.1 树的定义</h3><blockquote><p>树是 n （n ≥ 0）个结点的有限集。n&#x3D;0时称为空树。</p><p>在任意一棵非空树中：（1）有且仅有一个特定的成为根（Root）的结点；（2）当 n &gt; 1 时，其余结点可分为m（m &gt; 0）个互不相交的有限集 T<sub>1</sub>、 T<sub>2</sub>、…… T<sub>m</sub>，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree），如下图所示：</p></blockquote><p><img src="/p/919af6b6/001.png" alt="001"></p><p>子树如下图所示：</p><p><img src="/p/919af6b6/002.png"></p><h3 id="1-2-树的其他特性"><a href="#1-2-树的其他特性" class="headerlink" title="1.2 树的其他特性"></a>1.2 树的其他特性</h3><ul><li>度（Degree）：结点拥有的子树数成为结点的度。<ul><li>度为0的结点成为叶子结点（Leaf）或终端结点</li><li>度不为0的结点成为非终端结点或分枝结点。</li></ul></li><li>层次（Level）：指从根开始定义起，结点所在的楼层。（按照根结点为1开始依次算起）</li><li>深度（Depth）：树中结点的最大层次成为树的深度或高度。</li><li>子结点、双亲结点：结点的子树的根成为该结点的孩子（Child），相应地，该结点成为孩子的双亲结点（Parent）</li></ul><p><img src="/p/919af6b6/003.png"></p><h3 id="1-3-二叉树的定义"><a href="#1-3-二叉树的定义" class="headerlink" title="1.3 二叉树的定义"></a>1.3 二叉树的定义</h3><blockquote><p>二叉树（Binary Tree） 是 n （n ≥ 0）个结点的有限集合，该集合或为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p></blockquote><p>因为二叉树最多只能由左结点和右结点，一个普遍的二叉树如图</p><p><img src="/p/919af6b6/004.png"></p><h3 id="1-4-二叉树的基本特点"><a href="#1-4-二叉树的基本特点" class="headerlink" title="1.4 二叉树的基本特点"></a>1.4 二叉树的基本特点</h3><h4 id="1-4-1-特点"><a href="#1-4-1-特点" class="headerlink" title="1.4.1 特点"></a>1.4.1 特点</h4><ul><li>每个结点最多有两棵子树，所以二叉树中不存在度大于2度结点。</li><li>左子树和右子树顺序不可颠倒。</li><li>即使树中某结点只有一棵子树，也要区分他是左子树还是右子树。</li></ul><h4 id="1-4-2-基本形态"><a href="#1-4-2-基本形态" class="headerlink" title="1.4.2 基本形态"></a>1.4.2 基本形态</h4><ul><li>空二叉树</li><li>只有一个根结点</li><li>根结点只有左子树</li><li>根结点只有右子树</li><li>根结点既有左子树也有右子树</li></ul><h3 id="1-5-特殊的二叉树"><a href="#1-5-特殊的二叉树" class="headerlink" title="1.5 特殊的二叉树"></a>1.5 特殊的二叉树</h3><h4 id="1-5-1-斜树"><a href="#1-5-1-斜树" class="headerlink" title="1.5.1 斜树"></a>1.5.1 斜树</h4><p>顾名思义，所有的结点都只有左子树或右子树。所有结点只有左子树的叫左斜树，只有右子树的成为右斜树，两者统称为斜树。</p><p><img src="/p/919af6b6/005.png"></p><h4 id="1-5-2-满二叉树"><a href="#1-5-2-满二叉树" class="headerlink" title="1.5.2 满二叉树"></a>1.5.2 满二叉树</h4><p>在一棵树中，如果所有的分支结点都存在左子树和右子树，并且所有的叶子都在同一层上，这样的二叉树称为满二叉树。</p><p><img src="/p/919af6b6/006.png"></p><h4 id="1-5-3-完全二叉树"><a href="#1-5-3-完全二叉树" class="headerlink" title="1.5.3 完全二叉树"></a>1.5.3 完全二叉树</h4><p>对一颗具有n个结点的二叉树按层序编号，如果编号为i（1≤ i ≤ n）的结点与同样深度的满二叉树中编号为i 的结点在二叉树中的位置完全相同，这棵二叉树称为完全二叉树。</p><p>如下图所示，完全二叉树并不要求所有子结点全部填满，只需要子树树按顺序排列。</p><p><img src="/p/919af6b6/007.png"></p><p>换句通俗的话说，哥哥一家没生满二胎，弟弟一家不允许要孩子……🐶，否则就不是完全二叉树。</p><p>如下图中，11节点丢失的情况下，不可以称为完全二叉树</p><p><img src="/p/919af6b6/008.png"></p><h2 id="二、二叉树的存储结构"><a href="#二、二叉树的存储结构" class="headerlink" title="二、二叉树的存储结构"></a>二、二叉树的存储结构</h2><h3 id="2-1-顺序存储结构"><a href="#2-1-顺序存储结构" class="headerlink" title="2.1 顺序存储结构"></a>2.1 顺序存储结构</h3><p>通常用数组来存储二叉树，先看看存储完全二叉树的情况</p><p><img src="/p/919af6b6/014.png"></p><p>可以看到，二叉树中的元素按照顺序依次放入开辟好的数组内存空间里。</p><p>但是，凡事都有但是，在某些极端情况下，某一棵树，缺胳膊少腿儿，导致空间大大浪费，比如下图：</p><p><img src="/p/919af6b6/015.png"></p><p>这棵树只有4个有效的结点，但是却不得不开辟从A～M一共13个结点的内存空间，这种情况的树，使用数组结构来存储，对内存空间是一种浪费。</p><h3 id="2-2-二叉链表"><a href="#2-2-二叉链表" class="headerlink" title="2.2 二叉链表"></a>2.2 二叉链表</h3><p>鉴于上文中数组结构无法更高效的表述二叉树，引入了链表的结构进行表述。</p><p>由于二叉树结构最多有两个孩子，所以引入的链表结点，结构分别为数据域、左孩子指针、右孩子指针</p><p>结点结构如下</p><table><thead><tr><th>左孩子</th><th>数据</th><th>右孩子</th></tr></thead><tbody><tr><td>lChild</td><td>data</td><td>rChild</td></tr></tbody></table><p>用代码来表述可以是这样的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">BiTreeNode *lChild;</span><br><span class="line">BITreeNode *rChild;</span><br><span class="line">&#125;BiTreeNode, *BiTree</span><br></pre></td></tr></table></figure><p>把上文中较特殊的二叉树，用这样的结点表述的二叉树结构如下：</p><p><img src="/p/919af6b6/016.png"></p><h2 id="三、二叉树的遍历"><a href="#三、二叉树的遍历" class="headerlink" title="三、二叉树的遍历"></a>三、二叉树的遍历</h2><blockquote><p>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p></blockquote><p>二叉树的遍历方法，主要有四种：</p><h3 id="3-1-前序遍历"><a href="#3-1-前序遍历" class="headerlink" title="3.1 前序遍历"></a>3.1 前序遍历</h3><p>遍历的规则是若二叉树为空，空操作返回；否则先访问根结点，然后前序遍历左子树，再前序遍历右子树</p><p>如图示：</p><p><img src="/p/919af6b6/010.png"></p><h3 id="3-2-中序遍历"><a href="#3-2-中序遍历" class="headerlink" title="3.2 中序遍历"></a>3.2 中序遍历</h3><p>遍历的规则是若二叉树为空，空操作返回；否则从根结点开始（但此时并不遍历根结点），先前序遍历左子树，先遍历访问根结点，再前序遍历右子树。</p><p>如图示：</p><p><img src="/p/919af6b6/011.png"></p><h3 id="3-3-后序遍历"><a href="#3-3-后序遍历" class="headerlink" title="3.3 后序遍历"></a>3.3 后序遍历</h3><p>遍历的规则是若二叉树为空，空操作返回；否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。</p><p>如图示</p><p><img src="/p/919af6b6/012.png"></p><h3 id="3-4-层序遍历"><a href="#3-4-层序遍历" class="headerlink" title="3.4 层序遍历"></a>3.4 层序遍历</h3><p>遍历的规则是若二叉树为空，空操作返回；否则从树的第一层——也就是根结点开始访问，从上往下，在同一层时从左至右对结点逐个访问。</p><p>访问顺序如图示：</p><p><img src="/p/919af6b6/013.png"></p><h2 id="三、顺序存储下的实现"><a href="#三、顺序存储下的实现" class="headerlink" title="三、顺序存储下的实现"></a>三、顺序存储下的实现</h2><h3 id="3-1-顺序存储的实现"><a href="#3-1-顺序存储的实现" class="headerlink" title="3.1 顺序存储的实现"></a>3.1 顺序存储的实现</h3><h4 id="3-1-1-二叉树基本操作"><a href="#3-1-1-二叉树基本操作" class="headerlink" title="3.1.1 二叉树基本操作"></a>3.1.1 二叉树基本操作</h4><ul><li><p>初始化环境</p><p>创建结点结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> level; <span class="comment">//结点层</span></span><br><span class="line">    <span class="type">int</span> order; <span class="comment">//本层的序号(按照满二叉树给定序号规则)</span></span><br><span class="line">&#125;Position;</span><br></pre></td></tr></table></figure><p>以及其他辅助条件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100 <span class="comment">/* 二叉树的最大结点数 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;        <span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> CElemType;      <span class="comment">/* 树结点的数据类型，目前暂定为整型 */</span></span><br><span class="line"><span class="keyword">typedef</span> CElemType SqBiTree[MAX_TREE_SIZE]; <span class="comment">/* 0号单元存储根结点  */</span></span><br><span class="line">CElemType Nil = <span class="number">0</span>;   <span class="comment">/*设整型以0为空 或者以 INT_MAX(65535)*/</span></span><br></pre></td></tr></table></figure></li><li><p>初始化一个二叉树T</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitBiTree</span><span class="params">(SqBiTree T)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_TREE_SIZE; i++) &#123;</span><br><span class="line">        <span class="comment">//将二叉树初始化值置空</span></span><br><span class="line">        T[i] = Nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建二叉树（放入数据）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateBiTree</span><span class="params">(SqBiTree T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf(&quot;按层序输入结点的值(整型),0表示空结点, 输入999结束.结点数&lt;=%d\n&quot;,MAX_TREE_SIZE);</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     1      --&gt;1</span></span><br><span class="line"><span class="comment">     2     3   --&gt;2</span></span><br><span class="line"><span class="comment">     4  5  6   7 --&gt;3</span></span><br><span class="line"><span class="comment">     8  9 10       --&gt;4</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     1 2 3 4 5 6 7 8 9 10 Nil Nil Nil</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        T[i] = i+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//结点不为空,且无双亲结点</span></span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; T[(i+<span class="number">1</span>)/<span class="number">2</span><span class="number">-1</span>] == Nil &amp;&amp; T[i] != Nil) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;出现无双亲的非根结点%d\n&quot;</span>,T[i]);</span><br><span class="line">            <span class="built_in">exit</span>(ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        i++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将空赋值给T的后面的结点</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; MAX_TREE_SIZE) &#123;</span><br><span class="line">        T[i] = Nil;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>清空二叉树</p><p>清空一棵二叉树，与构造一棵二傻树一样，只需将每个结点值置空即可。</p><p>可以直接定义一个新函数，将两个函数对等。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ClearBiTree InitBiTree</span></span><br></pre></td></tr></table></figure></li><li><p>判断二叉树是否为空</p><p>只需判断根结点是否为空</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">BiTreeEmpty</span><span class="params">(SqBiTree T)</span>&#123;</span><br><span class="line">    <span class="comment">//根结点为空,则二叉树为空</span></span><br><span class="line">    <span class="keyword">return</span> T[<span class="number">0</span>] == Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取二叉树的深度</p><p>计算深度，需要看从当前结点，到根结点经历的路径条数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BiTreeDepth</span><span class="params">(SqBiTree T)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到最后一个结点</span></span><br><span class="line">    <span class="comment">//MAX_TREE_SIZE -&gt; 100 -&gt; 10 目的找到最后一个结点10的位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = MAX_TREE_SIZE<span class="number">-1</span> ; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] != Nil)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( powl(<span class="number">2</span>, j) &lt;= i); <span class="comment">//计算2的次幂</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-2-结点操作"><a href="#3-1-2-结点操作" class="headerlink" title="3.1.2 结点操作"></a>3.1.2 结点操作</h4><ul><li><p>获取二叉树根结点的值</p><p>只需计算数组T 首结点的值即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Root</span><span class="params">(SqBiTree T,CElemType *e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BiTreeEmpty(T)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *e = T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回结点位置为e 的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CElemType <span class="title function_">Value</span><span class="params">(SqBiTree T,Position e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Position.level -&gt; 结点层.表示第几层;</span></span><br><span class="line"><span class="comment">     Position.order -&gt; 本层的序号(按照满二叉树给定序号规则)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pow(2,e.level-1) 找到层序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>,e.level<span class="number">-1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//e.order</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,e.order);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4+2-2;</span></span><br><span class="line">    <span class="keyword">return</span> T[(<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, e.level<span class="number">-1</span>)+e.order<span class="number">-2</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改结点位置e 的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Assign</span><span class="params">(SqBiTree T,Position e,CElemType value)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到当前e在数组中的具体位置索引</span></span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)powl(<span class="number">2</span>, e.level<span class="number">-1</span>)+e.order <span class="number">-2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//叶子结点的双亲为空</span></span><br><span class="line">    <span class="keyword">if</span> (value != Nil &amp;&amp;  T[(i+<span class="number">1</span>)/<span class="number">2</span><span class="number">-1</span>] == Nil) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给双亲赋空值但是有叶子结点</span></span><br><span class="line">    <span class="keyword">if</span> (value == Nil &amp;&amp; (T[i*<span class="number">2</span>+<span class="number">1</span>] != Nil || T[i*<span class="number">2</span>+<span class="number">2</span>] != Nil)) &#123;</span><br><span class="line">        <span class="keyword">return</span>  ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T[i] = value;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取结点位置e 的双亲</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CElemType <span class="title function_">Parent</span><span class="params">(SqBiTree T, CElemType e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//空树</span></span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">0</span>] == Nil) &#123;</span><br><span class="line">        <span class="keyword">return</span> Nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> ; i &lt; MAX_TREE_SIZE; i++) &#123;</span><br><span class="line">        <span class="comment">//找到e</span></span><br><span class="line">        <span class="keyword">if</span> (T[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> T[(i+<span class="number">1</span>)/<span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有找到</span></span><br><span class="line">    <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取某结点的左孩子</p><p>步骤为当前结点的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CElemType <span class="title function_">LeftChild</span><span class="params">(SqBiTree T,CElemType e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//空树</span></span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">0</span>] == Nil) &#123;</span><br><span class="line">        <span class="keyword">return</span> Nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; MAX_TREE_SIZE<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//找到e</span></span><br><span class="line">        <span class="keyword">if</span> (T[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> T[i*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有找到</span></span><br><span class="line">    <span class="keyword">return</span> Nil;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取某结点的右孩子</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CElemType <span class="title function_">RightChild</span><span class="params">(SqBiTree T,CElemType e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//空树</span></span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">0</span>] == Nil) &#123;</span><br><span class="line">        <span class="keyword">return</span> Nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; MAX_TREE_SIZE<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//找到e</span></span><br><span class="line">        <span class="keyword">if</span> (T[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> T[i*<span class="number">2</span>+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有找到</span></span><br><span class="line">    <span class="keyword">return</span> Nil;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取某结点的左兄弟</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CElemType <span class="title function_">LeftSibling</span><span class="params">(SqBiTree T,CElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 空树 */</span></span><br><span class="line">    <span class="keyword">if</span>(T[<span class="number">0</span>]==Nil)</span><br><span class="line">        <span class="keyword">return</span> Nil;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=MAX_TREE_SIZE<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="comment">/* 找到e且其序号为偶数(是右孩子) */</span></span><br><span class="line">        <span class="keyword">if</span>(T[i]==e&amp;&amp;i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> T[i<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Nil; <span class="comment">/* 没找到e */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取某结点的右兄弟</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CElemType <span class="title function_">RightSibling</span><span class="params">(SqBiTree T,CElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 空树 */</span></span><br><span class="line">    <span class="keyword">if</span>(T[<span class="number">0</span>]==Nil)</span><br><span class="line">        <span class="keyword">return</span> Nil;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=MAX_TREE_SIZE<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="comment">/* 找到e且其序号为奇数(是左孩子) */</span></span><br><span class="line">        <span class="keyword">if</span>(T[i]==e&amp;&amp;i%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> T[i+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Nil; <span class="comment">/* 没找到e */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-3-遍历二叉树"><a href="#3-1-3-遍历二叉树" class="headerlink" title="3.1.3 遍历二叉树"></a>3.1.3 遍历二叉树</h4><ul><li><p>前序遍历</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreTraverse</span><span class="params">(SqBiTree T,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印结点数据</span></span><br><span class="line">    visit(T[e]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先序遍历左子树</span></span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">2</span> * e + <span class="number">1</span>] != Nil) &#123;</span><br><span class="line">        PreTraverse(T, <span class="number">2</span>*e+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后先序遍历右子树</span></span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">2</span> * e + <span class="number">2</span>] != Nil) &#123;</span><br><span class="line">        PreTraverse(T, <span class="number">2</span>*e+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status <span class="title function_">PreOrderTraverse</span><span class="params">(SqBiTree T)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//树不为空</span></span><br><span class="line">    <span class="keyword">if</span> (!BiTreeEmpty(T)) &#123;</span><br><span class="line">        PreTraverse(T, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InTraverse</span><span class="params">(SqBiTree T, <span class="type">int</span> e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 左子树不空 */</span></span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">2</span>*e+<span class="number">1</span>] != Nil)</span><br><span class="line">        InTraverse(T, <span class="number">2</span>*e+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    visit(T[e]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 右子树不空 */</span></span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">2</span>*e+<span class="number">2</span>] != Nil)</span><br><span class="line">        InTraverse(T, <span class="number">2</span>*e+<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status <span class="title function_">InOrderTraverse</span><span class="params">(SqBiTree T)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 树不空 */</span></span><br><span class="line">    <span class="keyword">if</span> (!BiTreeEmpty(T)) &#123;</span><br><span class="line">        InTraverse(T, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostTraverse</span><span class="params">(SqBiTree T,<span class="type">int</span> e)</span></span><br><span class="line">&#123;   <span class="comment">/* 左子树不空 */</span></span><br><span class="line">    <span class="keyword">if</span>(T[<span class="number">2</span>*e+<span class="number">1</span>]!=Nil)</span><br><span class="line">        PostTraverse(T,<span class="number">2</span>*e+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 右子树不空 */</span></span><br><span class="line">    <span class="keyword">if</span>(T[<span class="number">2</span>*e+<span class="number">2</span>]!=Nil)</span><br><span class="line">        PostTraverse(T,<span class="number">2</span>*e+<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    visit(T[e]);</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">PostOrderTraverse</span><span class="params">(SqBiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BiTreeEmpty(T)) <span class="comment">/* 树不空 */</span></span><br><span class="line">        PostTraverse(T,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>层序遍历</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrderTraverse</span><span class="params">(SqBiTree T)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = MAX_TREE_SIZE<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到最后一个非空结点的序号</span></span><br><span class="line">    <span class="keyword">while</span> (T[i] == Nil) i--;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从根结点起,按层序遍历二叉树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">        <span class="comment">//只遍历非空结点</span></span><br><span class="line">        <span class="keyword">if</span> (T[j] != Nil)</span><br><span class="line">            visit(T[j]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-链式存储的实现"><a href="#3-2-链式存储的实现" class="headerlink" title="3.2 链式存储的实现"></a>3.2 链式存储的实现</h3><h4 id="3-2-1-二叉树的基本操作"><a href="#3-2-1-二叉树的基本操作" class="headerlink" title="3.2.1 二叉树的基本操作"></a>3.2.1 二叉树的基本操作</h4><ul><li><p>数据类型及结点结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> CElemType;</span><br><span class="line">CElemType Nil=<span class="string">&#x27; &#x27;</span>; <span class="comment">/* 字符型以空格符为空 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>  /* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CElemType data;        <span class="comment">/* 结点数据 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span> <span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure></li><li><p>初始化二叉树</p><p>只需对当前二叉树赋值为空即可。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitBiTree</span><span class="params">(BiTree *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    *T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建二叉树</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    CElemType ch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取字符</span></span><br><span class="line">    ch = str[indexs++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前字符是否为&#x27;#&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建新的结点</span></span><br><span class="line">        *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="comment">//是否创建成功</span></span><br><span class="line">        <span class="keyword">if</span> (!*T) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 生成根结点 */</span></span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        <span class="comment">/* 构造左子树 */</span></span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        <span class="comment">/* 构造右子树 */</span></span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>清空二叉树</p><p>这里的逻辑与数组存储树一样的，逻辑等于初始化二叉树，用新函数来等同于它。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ClearBiTree DestroyBiTree</span></span><br></pre></td></tr></table></figure></li><li><p>销毁二叉树</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void DestroyBiTree(BiTree *T)</span><br><span class="line">&#123;</span><br><span class="line">    if(*T)</span><br><span class="line">    &#123;</span><br><span class="line">        /* 有左孩子 */</span><br><span class="line">        if((*T)-&gt;lchild)</span><br><span class="line">            DestroyBiTree(&amp;(*T)-&gt;lchild); /* 销毁左孩子子树 */</span><br><span class="line">        </span><br><span class="line">        /* 有右孩子 */</span><br><span class="line">        if((*T)-&gt;rchild)</span><br><span class="line">            DestroyBiTree(&amp;(*T)-&gt;rchild); /* 销毁右孩子子树 */</span><br><span class="line">        </span><br><span class="line">        free(*T); /* 释放根结点 */</span><br><span class="line">        </span><br><span class="line">        *T=NULL; /* 空指针赋0 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断二叉树是否为空</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">BiTreeEmpty</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取二叉树的深度</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BiTreeDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算左孩子的深度</span></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild)</span><br><span class="line">        i=BiTreeDepth(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算右孩子的深度</span></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;rchild)</span><br><span class="line">        j=BiTreeDepth(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        j=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//比较i和j</span></span><br><span class="line">    <span class="keyword">return</span> i&gt;j?i+<span class="number">1</span>:j+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-2-结点操作"><a href="#3-2-2-结点操作" class="headerlink" title="3.2.2 结点操作"></a>3.2.2 结点操作</h4><ul><li><p>获取二叉树根结点的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CElemType <span class="title function_">Root</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BiTreeEmpty(T))</span><br><span class="line">        <span class="keyword">return</span> Nil;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取指针p 指向的结点的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CElemType <span class="title function_">Value</span><span class="params">(BiTree p)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给p 指向的结点赋值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Assign</span><span class="params">(BiTree p,CElemType value)</span></span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;data=value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-3-遍历操作"><a href="#3-2-3-遍历操作" class="headerlink" title="3.2.3 遍历操作"></a>3.2.3 遍历操作</h4><ul><li><p>前序遍历</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,T-&gt;data);<span class="comment">/* 显示结点数据，可以更改为其它对结点操作 */</span></span><br><span class="line">    PreOrderTraverse(T-&gt;lchild); <span class="comment">/* 再先序遍历左子树 */</span></span><br><span class="line">    PreOrderTraverse(T-&gt;rchild); <span class="comment">/* 最后先序遍历右子树 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    InOrderTraverse(T-&gt;lchild); <span class="comment">/* 中序遍历左子树 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,T-&gt;data);<span class="comment">/* 显示结点数据，可以更改为其它对结点操作 */</span></span><br><span class="line">    InOrderTraverse(T-&gt;rchild); <span class="comment">/* 最后中序遍历右子树 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PostOrderTraverse(T-&gt;lchild); <span class="comment">/* 先后序遍历左子树  */</span></span><br><span class="line">    PostOrderTraverse(T-&gt;rchild); <span class="comment">/* 再后序遍历右子树  */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,T-&gt;data);<span class="comment">/* 显示结点数据，可以更改为其它对结点操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（8.3）KMP算法</title>
      <link href="/p/22d3726c.html"/>
      <url>/p/22d3726c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p><a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p><a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p><a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p><a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p><a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p><a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p><p><a href="https://nilsli.com/p/b0e10b1c.html">【数据结构与算法】-（8）栈之算法题</a></p><p><a href="https://nilsli.com/p/cc625709.html">【数据结构与算法】-（8.1）字符串去重算法</a></p><p><a href="https://nilsli.com/p/8a586c1e.html">【数据结构与算法】-（8.2）字符串搜索算法和RK&amp;BP算法</a></p></blockquote><h2 id="〇、引言"><a href="#〇、引言" class="headerlink" title="〇、引言"></a>〇、引言</h2><p>在上篇文章中，我们着重介绍了朴素算法（BF算法）以及RK算法，是否还有更优的选择呢，</p><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><blockquote><p><strong>克努斯-莫里斯-普拉特算法</strong></p><p>在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个主文本字符串S内查找一个词W的出现位置。此算法通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。</p></blockquote><p>这个算法是由高德纳和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终由三人于1977年联合发表。</p><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><h3 id="2-1-回顾BF-算法"><a href="#2-1-回顾BF-算法" class="headerlink" title="2.1 回顾BF 算法"></a>2.1 回顾BF 算法</h3><p>再次回顾一下字符串查找的题目，给定一个字符串<code>S = &#39;abcdbdacd&#39;</code> ，模式串<code>T = &#39;abcdz&#39;&#39;</code> ，在这个场景下，S 和 T 的前4个字符都相等，从第5个字符开始不等。查找流程，如果所示</p><p><img src="/p/22d3726c/001.png"></p><p><img src="/p/22d3726c/002.png"></p><p><img src="/p/22d3726c/003.png"></p><p><img src="/p/22d3726c/004.png"></p><h3 id="2-2-弊端：无用回溯"><a href="#2-2-弊端：无用回溯" class="headerlink" title="2.2 弊端：无用回溯"></a>2.2 弊端：无用回溯</h3><p>从上面可以看到，按照之前的 <strong>BF</strong> 算法， 也就是朴素算法， 当模式串T 与主串S不一致时候，会将主串的起始序号<code>i</code> 回溯至2，模式串j回溯至1，重新开始匹配。</p><p>这样看起来非常有条理，代码写起来也容易看懂，但是是不是有些冗余呢？</p><p>这么说吧，给出的条件模式串<code>T</code> 中的 <code>abcdz</code>，第一位<code>a</code>与其他位的字符均不相，那么对比结果后，主串中的<code>S</code> 的首字符<code>a</code> 同样与不相等呢? 那么此时拿T中的首字符<code>a</code> 与<code>S</code> 中前2-5位字符，可以得知，必然都不相等。</p><p>那么，是不是可以，将主串<code>S</code>中，确定与模式串<code>T</code>匹配过的那一部分字符跳过——也就是主串的 <code>i</code> 不再进行回溯，而只移动模式串<code>T</code>呢？答案是可以的，不过要分两种情况。</p><h3 id="2-3-场景A：模式串T-无重复"><a href="#2-3-场景A：模式串T-无重复" class="headerlink" title="2.3 场景A：模式串T 无重复"></a>2.3 场景A：模式串<code>T</code> 无重复</h3><p>看看图所示。</p><p>在<code>S</code> 和 <code>T</code>模式串 <code>T</code> 中前4位均匹配，第5位匹配失败。</p><p>由于的<code>abcd</code> 均不相等，而第5位失败后，我们可以轻易得知，模式串首位<code>a</code> 与主串的前4位均不相等，故可以直接将主串的 <code>i</code> 移动到第5位与模式串相比。</p><p>此时 <code>i</code> 不变，<code>j</code> 回归到1</p><p><img src="/p/22d3726c/006.png"> </p><h3 id="2-4-场景B：模式串T有重复"><a href="#2-4-场景B：模式串T有重复" class="headerlink" title="2.4 场景B：模式串T有重复"></a>2.4 场景B：模式串<code>T</code>有重复</h3><p>那么，如果模式串中，如果有其他字符与<code>a</code> 重复，是不是也可以全部跳过呢？</p><p>当然不是。</p><p>我们设定一个场景，主串S &#x3D; <code>abcabd</code>，模式串为T &#x3D; <code>abcabz</code></p><p>我们通过BF 朴素算法再次排列一下，如图所示</p><p><img src="/p/22d3726c/007.png"></p><p>可见，由于模式串中首位<code>a</code> 与第二、三位的<code>b</code>、<code>c</code> 均不相等，所以第2、3步均为多余步骤，可以跳过。</p><p>而来到第4步时，由于模式串<code>T</code> 自身有重复的字符，即第1位&#x3D;第4位，第2位&#x3D;第5位。</p><p>在第1步中，模式串<code>T</code> 的第4位、第5位的<code>a</code>、<code>b</code> 均与 主串的第4、5位匹配过，是一一对应相等的。</p><p>那么等于说，第4步中，模式串的首字符<code>a</code>、<code>b</code>，被移动与<code>S</code> 的第4、5位去匹配，也可以省略。</p><p>汇总一下：<strong>模式串中有与首字符相同的字符，可以跳过一些重复判断步骤</strong>。</p><p>如下图所示，这样的步骤就可以跳过：</p><p><img src="/p/22d3726c/008.png"></p><p>从上图中可以看到，主串的 <code>i</code>是不会像BF算法一样，反复的回溯的， 这也是KMP算法的重要的一点，这样可以省掉一部分的时间复杂度。</p><h3 id="2-5-思考归纳"><a href="#2-5-思考归纳" class="headerlink" title="2.5 思考归纳"></a>2.5 思考归纳</h3><p>另外，<code>j</code>值的变化也值得寻味。</p><p>场景A中，由于模式串没有重复元素，j 从5回到了1 （重复数0）</p><p>而在场景B中，由于模式串中的 T &#x3D; <u>ab</u>c<u>ab</u>z，ab 是重复的，此时 j 跳到了3（重复数2）。</p><p>这里根据反复的思考，得出 j 值变化多少，与重复数量——也就是前缀，后缀相似度有关。</p><p>这里<strong>KMP算法</strong>，引入了一个next 数组，专门用来保管 <code>j</code>值的变化，数组结果如下</p><p><img src="/p/22d3726c/009.png"></p><p>究竟是怎么来的，继续探索</p><h3 id="2-5-逆推next-数组"><a href="#2-5-逆推next-数组" class="headerlink" title="2.5 逆推next 数组"></a>2.5 逆推next 数组</h3><p>探索之前，要牢记一句话：<strong>next数组用来保存 <code>j</code> 的变化后的位置</strong>。</p><h4 id="2-5-1-模式串为：abcdef"><a href="#2-5-1-模式串为：abcdef" class="headerlink" title="2.5.1 模式串为：abcdef"></a>2.5.1 模式串为：abcdef</h4><table><thead><tr><th align="center">j</th><th align="center">123456</th></tr></thead><tbody><tr><td align="center">模式串T</td><td align="center">abcdef</td></tr></tbody></table><ol><li>当 j &#x3D; 1 时，next[j] &#x3D; 1 ，属第一种情况</li><li>当 j &#x3D; 2 时，此时 j 从1位（a）到 j - 1 （b）位中，只有一个字符 ‘a’， 属于其他情况，此时 next[2] &#x3D; 1</li><li>当 j &#x3D; 3 时，此时 j 从1位（a）到 j - 1 （ab）位中，有2个字符 ‘ab’，但是a、b并不相等，第二种情况并不满足，所以此时 next[3] &#x3D; 1</li><li>当 j &#x3D; 4 时，此时 j 从1位（a）到 j - 1 （ab）位中，有3个字符 ‘abc’，但是a、b、c并不相等，第二种情况并不满足，所以此时 next[4] &#x3D; 1</li><li>当 j &#x3D; 5 时，此时 j 从1位（a）到 j - 1 （abcde）位中，有4个字符 ‘abcd’，但是a、b、c、d并不相等，第二种情况并不满足，所以此时 next[5] &#x3D; 1</li><li>于是总结一下得出next 数组为 <strong>01111</strong>。</li></ol><table><thead><tr><th align="center">j</th><th align="center">12345</th></tr></thead><tbody><tr><td align="center">模式串T</td><td align="center">abcde</td></tr><tr><td align="center">next[j]</td><td align="center">01111</td></tr></tbody></table><h4 id="2-5-2-模式串为：abcabf"><a href="#2-5-2-模式串为：abcabf" class="headerlink" title="2.5.2 模式串为：abcabf"></a>2.5.2 模式串为：abcabf</h4><table><thead><tr><th align="center">j</th><th align="center">123456</th></tr></thead><tbody><tr><td align="center">模式串</td><td align="center">abcabf</td></tr></tbody></table><ol><li>当 j &#x3D; 1 时，next[j] &#x3D; 1 ，属第一种情况</li><li>当 j &#x3D; 2 时，此时 j 从1位（a）到 j - 1 （b）位中，只有一个字符 ‘a’， 属于其他情况，此时 next[2] &#x3D; 1</li><li>当 j &#x3D; 3 时，此时 j 从1位（a）到 j - 1 （ab）位中，有2个字符 ‘ab’，但是a、b并不相等，第二种情况并不满足，所以此时 next[3] &#x3D; 1</li><li>当 j &#x3D; 4 时，此时 j 从1位（a）到 j - 1 （ab）位中，有3个字符 ‘abc’，但是a、b、c并不相等，第二种情况并不满足，所以此时 next[4] &#x3D; 1</li><li>当 j &#x3D; 5 时，此时 j 从1位（a）到 j - 1 （abcde）位中，有4个字符 ‘abcd’，第1位、第4位的a相等，所以此时k &#x3D; 5，即next[5] &#x3D; 2</li><li>当 j &#x3D; 6 时，此时 j 从1位（a）到 j - 1 （abcde）位中，有4个字符 ‘abcd’，第1位、第4位的a相等，所以此时k &#x3D; 5，即next[5] &#x3D; 2</li><li>于是总结一下得出next 数组为 <strong>011123</strong>。</li></ol><table><thead><tr><th align="center">j</th><th align="center">123456</th></tr></thead><tbody><tr><td align="center">模式串</td><td align="center">abcabf</td></tr><tr><td align="center">next[j]</td><td align="center">011123</td></tr></tbody></table><h4 id="2-5-3-模式串为：abcbbabc"><a href="#2-5-3-模式串为：abcbbabc" class="headerlink" title="2.5.3 模式串为：abcbbabc"></a>2.5.3 模式串为：abcbbabc</h4><table><thead><tr><th align="center">j</th><th align="center">12345678</th></tr></thead><tbody><tr><td align="center">模式串</td><td align="center">abcbbabc</td></tr></tbody></table><ol><li>当 j &#x3D; 1 时，next[j] &#x3D; 1 ，属第一种情况</li><li>当 j &#x3D; 2 时，此时 j 从1位（a）到 j - 1 （b）位中，只有一个字符 ‘a’， 属于其他情况，此时 next[2] &#x3D; 1</li><li>当 j &#x3D; 3 时，此时 j 从1位（a）到 j - 1 （ab）位中，有2个字符 ‘ab’，但是a、b并不相等，第二种情况并不满足，所以此时 next[3] &#x3D; 1</li><li>当 j &#x3D; 4 时，此时 j 从1位（a）到 j - 1 （ab）位中，有3个字符 ‘abc’，但是a、b、c并不相等，第二种情况并不满足，所以此时 next[4] &#x3D; 1</li><li>当 j &#x3D; 5 时，此时 j 从1位（a）到 j - 1 （abcb）位中，有4个字符 ‘abcb’，虽然第2、第4相等，但是并不满足前缀相等，所以此时k &#x3D; 5，即next[5] &#x3D; 1</li><li>当 j &#x3D; 6 时，此时 j 从1位（a）到 j - 1 （abcba）位中，<u>a</u>bcb<u>a</u>，首位相等，取第一位 + 1，所以此时k &#x3D; 2，即next[6]] &#x3D; 2</li><li>当 j &#x3D; 7 时，此时 j 从1位（a）到 j - 1 （abcbab）位中，<u>ab</u>cb<u>ab</u>，首位相等，取第2位 + 1，所以此时k &#x3D; 3，即next[7] &#x3D; 3</li><li>当 j &#x3D; 8 时，此时 j 从1位（a）到 j - 1 （abcbab）位中，<u>ab</u>cb<u>ab</u>，首位相等，取第3位 + 1，所以此时k &#x3D; 4，即next[8] &#x3D; 4</li></ol><p>综上所述，这时的next数组为 <strong>01111234</strong></p><table><thead><tr><th align="center">j</th><th align="center">12345678</th></tr></thead><tbody><tr><td align="center">模式串</td><td align="center">abcbbabc</td></tr><tr><td align="center">next[j]</td><td align="center">01111234</td></tr></tbody></table><h4 id="2-5-4-模式串为：aaaaab"><a href="#2-5-4-模式串为：aaaaab" class="headerlink" title="2.5.4 模式串为：aaaaab"></a>2.5.4 模式串为：aaaaab</h4><table><thead><tr><th>j</th><th>123456</th></tr></thead><tbody><tr><td>模式串</td><td>aaaaab</td></tr></tbody></table><p>分析如下：</p><ol><li>当 j &#x3D; 1 时，next[j] &#x3D; 1 ，属第一种情况</li><li>当 j &#x3D; 2 时，当 j &#x3D; 2 时，此时 j 从1位（a）到 j - 1 （b）位中，只有一个字符 ‘a’， 属于其他情况，此时 next[2] &#x3D; 1</li><li>当 j &#x3D; 3 时，此时 j 从1位（a）到 j - 1 （aa）位中，有<u>aa</u> 相等，取前面出现的序号+1，得k &#x3D; 1+1&#x3D;2，即 next[3] &#x3D; 2</li><li>当 j &#x3D; 4 时，此时 j 从1位（a）到 j - 1 （aaa）位中，前缀为 <u>aa</u>，后缀也为 <u>aa</u>， 取前面出现的序号+1，得k &#x3D; 2+1&#x3D;2，即 next[3] &#x3D; 3</li><li>当 j &#x3D; 5 时，此时 j 从1位（a）到 j - 1 （aaaa）位中，有<u>aaa</u> ，后缀 <u>aaa</u>，后缀也是 <u>aaa</u> 取前面出现的序号+1，得k &#x3D; 3+1&#x3D;4，即 next[3] &#x3D; 4</li><li>当 j &#x3D; 6 时，此时 j 从1位（a）到 j - 1 （aaaaa）位中，有<u>aaaaa</u> ，后缀 <u>aaaa</u>，后缀也是 <u>aaa</u> 取前面出现的序号+1，得k &#x3D; 4+1&#x3D;4，即 next[3] &#x3D; 5</li></ol><p>综上所述，此时的 next 数组为 <strong>0123456</strong></p><table><thead><tr><th align="center">j</th><th align="center">123456</th></tr></thead><tbody><tr><td align="center">模式串</td><td align="center">aaaaab</td></tr><tr><td align="center">next[j]</td><td align="center">012345</td></tr></tbody></table><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><h3 id="3-1-获取next-数组"><a href="#3-1-获取next-数组" class="headerlink" title="3.1 获取next 数组"></a>3.1 获取next 数组</h3><p>总结了半天next 数组，现在先来用代码创建一下</p><p>先定义一个特定的String 数组，用来装字符数组</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> String[MAXSIZE+<span class="number">1</span>]; <span class="comment">/*  0号单元存放串的长度 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_nextArray</span><span class="params">(String T, <span class="type">int</span> *next)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  i = <span class="number">1</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  next[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">// 这是第一种情况，初始为0</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> ( i &lt; T[<span class="number">0</span>]) <span class="comment">// 循环上限为模式串的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 比较模式串 T 的前缀后缀俩字符, </span></span><br><span class="line">        <span class="comment">//若相等，分别递增</span></span><br><span class="line">      <span class="keyword">if</span>( j == <span class="number">0</span> || T[i] == T[j])</span><br><span class="line">        &#123;</span><br><span class="line">           ++i;</span><br><span class="line">           ++j;</span><br><span class="line">          next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 如果不相等， j 回溯回当前</span></span><br><span class="line">          j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-获取匹配的字符串"><a href="#3-2-获取匹配的字符串" class="headerlink" title="3.2 获取匹配的字符串"></a>3.2 获取匹配的字符串</h3><p>拿到了当前的next 数组，现在就把它用起来吧</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getIndexKMP</span><span class="params">(String S, String T, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// s = 主串</span></span><br><span class="line"><span class="comment">// T = 模式串</span></span><br><span class="line"><span class="comment">// pos = 最终符合需求的位置</span></span><br><span class="line"><span class="type">int</span> i = pos;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// next 数组的初始化</span></span><br><span class="line">  <span class="type">int</span> next[<span class="number">255</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据模式串，定义出next</span></span><br><span class="line">  get_nextArray(T, next);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开始判断</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 主串与字串如果相等，继续</span></span><br><span class="line">      <span class="keyword">if</span> (j == <span class="number">0</span> || S[i] == T[j])</span><br><span class="line">        &#123;</span><br><span class="line">          ++i;</span><br><span class="line">          ++j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 两者不相等， j 回溯，具体位置为数组中的值</span></span><br><span class="line">          j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果 j 的长度大于模式串长度，即已经取得成功</span></span><br><span class="line">  <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>]) </span><br><span class="line">      <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-运行检验"><a href="#3-3-运行检验" class="headerlink" title="3.3 运行检验"></a>3.3 运行检验</h3><p>IDE 里操作一下，奥利给！</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一次查询&quot;</span>);</span><br><span class="line">    String S, T;</span><br><span class="line">    StrAssign(S, <span class="string">&quot;cccaababcabc&quot;</span>);</span><br><span class="line">    StrAssign(T, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = getIndexKMP(S, T, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;在里面的序号为:     %d\n\n&quot;</span>, result);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败，主串并无匹配的模式串!\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/p/22d3726c/010.png" alt="010"></p><p>给出的 <code>S = cccaababcabc</code> ， <code>T = abc</code> ，结果是从第7位开始重复，命中！</p><h2 id="四、优化改进"><a href="#四、优化改进" class="headerlink" title="四、优化改进"></a>四、优化改进</h2><h3 id="4-1-分析不足"><a href="#4-1-分析不足" class="headerlink" title="4.1 分析不足"></a>4.1 分析不足</h3><p>上面已经基本实现了KMP算法的时间部分，但是——有些场景还是会有些不理想。</p><p>假设给出<code>S = aaaaabcdefgh</code>， 给出的 <code>T = aaaaad</code> </p><p><img src="/p/22d3726c/011.png"></p><p>如上图所示，当前4位匹配已知，对比到第5位时，会对 j 进行回溯。</p><p>此时 <code>T</code> 的next 数组位 01234，所以j 回溯到 next[5] &#x3D; 4，即第4位，如<strong>第2张图</strong>所示。</p><p>而此时a 不等于 b，再次回溯，以此类推，一直到第5步，发现回溯完后，<code>T</code> 中的<code>a</code> 一直不等于b，不得不放弃回溯，直接将<code>S</code> 中的 i 增加，跳到下一个字符。</p><p>而我们明明看到了，a 中的前5位都是一致的，本来第1步时，模式串中<code>a</code> 不等于主串 中的<code>b</code>， 完全可以放弃2，3，4，5这几部的比较。</p><h3 id="4-2-新的nextVal-数组"><a href="#4-2-新的nextVal-数组" class="headerlink" title="4.2 新的nextVal 数组"></a>4.2 新的nextVal 数组</h3><p>根据上面的总结，说明之前的next数组有可以改进的地方，改进如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_nextVal</span><span class="params">(String T, <span class="type">int</span> *nextVal)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> i, j;</span><br><span class="line">      i = <span class="number">1</span>;</span><br><span class="line">      j = <span class="number">0</span>;</span><br><span class="line">      nextVal[<span class="number">1</span>] = <span class="number">0</span>;        <span class="comment">// 这是第一种情况，初始为0</span></span><br><span class="line">  </span><br><span class="line">      <span class="keyword">while</span> ( i &lt; T[<span class="number">0</span>])     <span class="comment">// 循环上限为模式串的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">          <span class="comment">// 比较模式串 T 的前缀后缀俩字符,</span></span><br><span class="line">        <span class="comment">//若相等，分别递增</span></span><br><span class="line">          <span class="keyword">if</span>( j == <span class="number">0</span> || T[i] == T[j])</span><br><span class="line">        &#123;</span><br><span class="line">           ++i;</span><br><span class="line">           ++j;</span><br><span class="line">            <span class="keyword">if</span> (T[i] == T[j]) &#123;</span><br><span class="line">                nextVal[i] =  nextVal[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nextVal[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 如果不相等， j 回溯回当前</span></span><br><span class="line">          j = nextVal[j] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在判断前后缀相同的时候，添加了这一段判断</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (T[i] == T[j]) </span><br><span class="line">    nextVal[i] = nextVal[j];</span><br></pre></td></tr></table></figure><p>这里的的意思是：</p><p>判断——如果当前 T 中的i 位字符与 T 的i位字符相等，且两串的各自下一个字符还是一一相等，把<code>T</code>中前缀的值——即上一次匹配 的的next 值，放入新的nextVal 数组中。</p><h3 id="4-3逆推nextVal数组"><a href="#4-3逆推nextVal数组" class="headerlink" title="4.3逆推nextVal数组"></a>4.3逆推nextVal数组</h3><p>声明比较的规则，即拿 </p><p>左边 &#x3D; T[j]   </p><p>右边 &#x3D;  T [next[j]] </p><p><strong>两者相比较！</strong></p><h4 id="4-3-1-模式串为：ababaaaba"><a href="#4-3-1-模式串为：ababaaaba" class="headerlink" title="4.3.1 模式串为：ababaaaba"></a>4.3.1 模式串为：ababaaaba</h4><table><thead><tr><th align="center">j</th><th align="center">123456789</th></tr></thead><tbody><tr><td align="center">模式串</td><td align="center">ababaaaba</td></tr><tr><td align="center">next[j]</td><td align="center">011234223</td></tr><tr><td align="center">nextVal[j]</td><td align="center">010104210</td></tr></tbody></table><ol><li>j &#x3D; 1, nextVal[1]&#x3D; 0;</li><li>j &#x3D; 2, <strong>照旧</strong>。左边为T [2] &#x3D; b，右边 T[next[2]] &#x3D; T[1] &#x3D; a 这种前后字符<strong>不相等</strong>，还是沿用之前next[i] 的逻辑，即 &#x3D; 1；</li><li>j &#x3D; 3，此时为<strong>新情况</strong>，左边为T [3] &#x3D; a，右边 T[next[3]] &#x3D; T[1] &#x3D; a 这种前后字符<strong>相等</strong>，使用新逻辑：nextVal[3] &#x3D; nextVal[1] &#x3D; 0；</li><li>j &#x3D; 4 ，此时为<strong>新情况</strong>，左边为T [4] &#x3D; b，右边 T[next[4]] &#x3D; T[2] &#x3D; b 这种前后字符<strong>相等</strong>，使用新逻辑：nextVal[4] &#x3D; nextVal[2] &#x3D; 1；</li><li>j &#x3D; 5，此时为<strong>新情况</strong>，左边为T [5] &#x3D; a，右边 T[next[5]] &#x3D; T[3] &#x3D; a 这种前后字符<strong>相等</strong>，使用新逻辑：nextVal[5] &#x3D; nextVal[3] &#x3D; 0；</li><li>j &#x3D; 6，<strong>照旧</strong>。左边为T [6] &#x3D; a，右边 T[next[6]] &#x3D; T[4] &#x3D; b 这种前后字符<strong>不相等</strong>，还是沿用之前next[i] 的逻辑，即 &#x3D; 4；</li><li>j &#x3D; 7，<strong>照旧</strong>。左边为T [7] &#x3D; a，右边 T[next[7]] &#x3D; T[2] &#x3D; b 这种前后字符<strong>不相等</strong>，还是沿用之前next[i] 的逻辑，即 &#x3D; 2；</li><li>j &#x3D; 8，此时为<strong>新情况</strong>，左边为T [8] &#x3D; b，右边 T[next[8]] &#x3D; T[2] &#x3D; b 这种前后字符<strong>相等</strong>，使用新逻辑：nextVal[8] &#x3D; nextVal[2] &#x3D; 1；</li><li>j &#x3D; 9，此时为<strong>新情况</strong>，左边为T [9] &#x3D; a，右边 T[next[9]] &#x3D; T[3] &#x3D; a 这种前后字符<strong>相等</strong>，使用新逻辑：nextVal[9] &#x3D; nextVal[3] &#x3D; 0；</li></ol><h4 id="4-3-2-模式串为：aaaacd"><a href="#4-3-2-模式串为：aaaacd" class="headerlink" title="4.3.2 模式串为：aaaacd"></a>4.3.2 模式串为：aaaacd</h4><table><thead><tr><th align="center">j</th><th align="center">123456</th></tr></thead><tbody><tr><td align="center">模式串</td><td align="center">aaaaad</td></tr><tr><td align="center">next[j]</td><td align="center">012345</td></tr><tr><td align="center">nextValue[j]</td><td align="center">000005</td></tr></tbody></table><p>现在回到引起需要改进的字符串里面来，aaaaad，依次分析</p><ol><li><p>j &#x3D; 1, nextVal[1]&#x3D; 0;</p></li><li><p>j &#x3D; 2, 此时为<strong>新情况</strong>，左边为T [2] &#x3D; a，右边 T[next[2]] &#x3D; T[1] &#x3D; a 这种前后字符<strong>相等</strong>，使用新逻辑：nextVal[2] &#x3D; nextVal[1] &#x3D; 0；</p></li><li><p>j &#x3D; 3，此时为<strong>新情况</strong>，左边为T [3] &#x3D; a，右边 T[next[3]] &#x3D; T[2] &#x3D; a 这种前后字符<strong>相等</strong>，使用新逻辑：nextVal[3] &#x3D; nextVal[2] &#x3D; 0；</p></li><li><p>同上累加</p></li><li><p>同上累加</p></li><li><p>同上累加</p></li><li><p>j &#x3D; 6，<strong>此时照旧</strong>。左边T[6] &#x3D; d， 右边 T [next[6]] &#x3D; T [5] &#x3D; a， 两者并不相等，沿用之前的next，即 nextVal[6] &#x3D; 5</p></li></ol><h3 id="4-4-改进小结"><a href="#4-4-改进小结" class="headerlink" title="4.4 改进小结"></a>4.4 改进小结</h3><p>总之，这里改进了的一句代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (T[i] == T[j]) &#123; nextVal[i] = nextVal[j];&#125;</span><br></pre></td></tr></table></figure><p>最终的含义：</p><p>是如果存在某个字符a，如果它当前next位指向的字符相等—— 它的偏移值nextVal 数组当前的值，就使用会沿用指向的那个值的nextVal值。其他情况的逻辑照旧。</p><p>画了个图解释一下：</p><p><img src="/p/22d3726c/012.png"></p><h3 id><a href="#" class="headerlink" title></a></h3><p>相关实现代码，放在<a href="https://github.com/newjia/kmp">GITHUB</a> 上，欢迎食用 XD!</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> KMP </tag>
            
            <tag> 字符串查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（8.2）字符串搜索算法和RK&amp;BP算法</title>
      <link href="/p/8a586c1e.html"/>
      <url>/p/8a586c1e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p><a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p><a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p><a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p><a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p><a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p><a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p><p><a href="https://nilsli.com/p/b0e10b1c.html">【数据结构与算法】-（8）栈之算法题</a></p><p> <a href="https://nilsli.com/p/cc625709.html">【数据结构与算法】-（8.1）字符串去重算法</a></p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p><strong>字符串搜索算法</strong>（String searching algorithms）</p><p>又称字符串比对算法（string matching algorithms）是一种搜索算法，是字符串算法中的一类，用以试图在一长字符串或文章中，找出其是否包含某一个或多个字符串，以及其位置。</p></blockquote><h2 id="题目：字符串匹配"><a href="#题目：字符串匹配" class="headerlink" title="题目：字符串匹配"></a>题目：字符串匹配</h2><p>给你一个仅包含小写字母的字符串主串<code>S</code> &#x3D; <code>abcacabdc</code>， 模式串 <code>T</code>&#x3D; <code>abd</code>,  请查找出模式串在主串第一次出现的位置；提示：主串和模式串均为小写字母且都是合法输入</p><h2 id="一、BF算法"><a href="#一、BF算法" class="headerlink" title="一、BF算法"></a><strong>一、B</strong>F算法</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><blockquote><p><strong>B</strong>rute-<strong>F</strong>orce算法，简称为 <strong>BF算法</strong>，是一种简单朴素的模式匹配算法，常用于在一个主串 S 内查找一个子串 T 的出现位置。</p></blockquote><h3 id="1-2-思路"><a href="#1-2-思路" class="headerlink" title="1.2 思路"></a>1.2 思路</h3><ol><li>排列两个串，对其内部字符进行逐一比较</li><li>首先对<code>S[1]</code> 和 <code>T[1]</code> 比较，如果相等则跳到<code>S[2]</code> 和<code>T[2]</code>，两者下标各加1 </li><li>如果<code>S[i]</code> 和 <code>T[j]</code>  不相等：<ol><li>主串的待选次序<code>i</code> 回退到之前<code>j</code> 的下一位，即是<code>i = i - j + 2</code></li><li><code>j</code> 退回到第1位</li></ol></li><li><strong>匹配成功条件</strong>：字串每一个字符都匹配完，即<code>j &gt; T[0]</code> 。此时，主串位置 <code>i</code> 即为所得</li></ol><p><img src="/p/8a586c1e/004.png"><img src="/p/8a586c1e/005.png"><img src="/p/8a586c1e/006.png"><img src="/p/8a586c1e/007.png"></p><h3 id="1-3-代码实现："><a href="#1-3-代码实现：" class="headerlink" title="1.3 代码实现："></a>1.3 代码实现：</h3><ol><li><p>字符生成字符串 <code>T</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 生成一个其值等于chars的串T */</span></span><br><span class="line">Status <span class="title function_">StrAssign</span><span class="params">(String T,<span class="type">char</span> *chars)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(chars)&gt;MAXSIZE)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[<span class="number">0</span>]=<span class="built_in">strlen</span>(chars);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=T[<span class="number">0</span>];i++)</span><br><span class="line">            T[i]=*(chars+i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>清除字符串 <code>S</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ClearString</span><span class="params">(String S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">/*  令串长为零 */</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出字符串里的字符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StrPrint</span><span class="params">(String T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=T[<span class="number">0</span>];i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,T[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出<code>Next</code> 数组的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NextPrint</span><span class="params">(<span class="type">int</span> next[],<span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=length;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,next[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回字符串 <code>s</code> 的元素个数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrLength</span><span class="params">(String S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> S[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行算法内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_BF</span><span class="params">(String S, String T,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配</span></span><br><span class="line">    <span class="type">int</span> i = pos;</span><br><span class="line">    <span class="comment">//j用于子串T中当前位置下标值</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若i小于S的长度并且j小于T的长度时，循环继续</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//比较的2个字母相等,则继续比较</span></span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不相等,则指针后退重新匹配</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//i 退回到上次匹配的首位的下一位;</span></span><br><span class="line">            <span class="comment">//加1,因为是子串的首位是1开始计算;</span></span><br><span class="line">            <span class="comment">//再加1的元素,从上次匹配的首位的下一位;</span></span><br><span class="line">            i = i-j+<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//j 退回到子串T的首位</span></span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果j&gt;T[0],则找到了匹配模式</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="comment">//i母串遍历的位置 - 模式字符串长度 = index 位置</span></span><br><span class="line">        <span class="keyword">return</span>  i - T[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证算法内容：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i,*p;</span><br><span class="line">    String s1,s2;</span><br><span class="line">    </span><br><span class="line">    StrAssign(s1, <span class="string">&quot;abcdex&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1子串为&quot;</span>);</span><br><span class="line">    StrPrint(s1);</span><br><span class="line">    </span><br><span class="line">  StrAssign(s2, <span class="string">&quot;xe&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2子串为&quot;</span>);</span><br><span class="line">    StrPrint(s2);</span><br><span class="line">  </span><br><span class="line">    i = Index_BF(s1, s2, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果验证：</p><p><img src="/p/8a586c1e/001.png" alt="001"></p></li></ol><h3 id="1-4-时间复杂度"><a href="#1-4-时间复杂度" class="headerlink" title="1.4 时间复杂度"></a>1.4 时间复杂度</h3><p>但是此直观算法较为暴力，复杂度达到了O(mn)，其中 <code>S</code> 的长度为<code>n</code>，<code>T</code> 的长度为<code>m</code>， 所以我们要考虑更快速的算法。</p><h2 id="二、RK算法"><a href="#二、RK算法" class="headerlink" title="二、RK算法"></a>二、RK算法</h2><h3 id="2-0-概念"><a href="#2-0-概念" class="headerlink" title="2.0 概念"></a>2.0 概念</h3><blockquote><p>RK 算法（<strong>Rabin–Karp algorithm</strong> ）是一个字符串查找算法，由<a href="https://en.wikipedia.org/wiki/Richard_M._Karp">Richard M. Karp</a> and <a href="https://en.wikipedia.org/wiki/Michael_O._Rabin">Michael O. Rabin</a> 在1987年提出，使用哈希算法，来比对字符串。</p></blockquote><p>在这里，与粗暴简单的BF 算法不一样，我们引入了哈希值来进行比对，这样计算机只需要匹配整形，相比匹配字符串，更快一些。</p><blockquote><p><strong>散列函数</strong>（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。</p></blockquote><p>散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。</p><h3 id="2-1-思路："><a href="#2-1-思路：" class="headerlink" title="2.1 思路："></a>2.1 思路：</h3><ul><li><p>主串分解成多个字串，用子串与模式串进行核对</p><p><img src="/p/8a586c1e/003.png" alt="拆分字串"></p></li><li><p>把需要匹配的字符串，转换成<code>hash</code> 值</p><p>以 a 为基点，将字符与<code>a</code> 的ASCII 码的差值，转换成整形：</p><p>如abc，结果为 </p><p>Result&#x3D; ( a - ‘a’ ) * 26<sup>2</sup> + (b - ‘a’ ) * 26 + (c - ‘a’ )</p><p><img src="/p/8a586c1e/008.png" alt="字符串转hash"></p></li><li><p>用主串对字串和模式串的的<code>hash</code> 值来互相判断，更为高效</p></li></ul><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><ul><li><p>二次确认<code>hash</code> 值相等。以防止有的字符串相同，但是<code>hash</code> 不相等。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span> *S, <span class="type">int</span> i, <span class="type">char</span> *P, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> is, ip;</span><br><span class="line">    <span class="keyword">for</span>(is=i, ip=<span class="number">0</span>; is != m &amp;&amp; ip != m; is++, ip++)</span><br><span class="line">        <span class="keyword">if</span>(S[is] != P[ip])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>算出 d 进制下的最高位:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span> m)</span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        h = (h*d);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行RK 进入查询</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">RK</span><span class="params">(<span class="type">char</span> *S, <span class="type">char</span> *P)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1. n:主串长度, m:子串长度</span></span><br><span class="line">    <span class="type">int</span> m  = (<span class="type">int</span>) <span class="built_in">strlen</span>(P);</span><br><span class="line">    <span class="type">int</span> n  = (<span class="type">int</span>) <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主串长度为:%d,子串长度为:%d\n&quot;</span>,n,m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//A.模式串的哈希值; St.主串分解子串的哈希值;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> A   = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> St  = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.求得子串与主串中0~m字符串的哈希值[计算子串与主串0-m的哈希值]</span></span><br><span class="line">    <span class="comment">//循环[0,m)获取模式串A的HashValue以及主串第一个[0,m)的HashValue</span></span><br><span class="line">    <span class="comment">//此时主串:&quot;abcaadddabceeffccdd&quot; 它的[0,2)是ab</span></span><br><span class="line">    <span class="comment">//此时模式串:&quot;cc&quot;</span></span><br><span class="line">    <span class="comment">//cc = 2 * 26^1 + 2 *26 ^0 = 52+2 = 54;</span></span><br><span class="line">    <span class="comment">//ab = 0 * 26^1 + 1 *26^0 = 0+1 = 1;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != m; i++)&#123;</span><br><span class="line">        <span class="comment">//第一次 A = 0*26+2;</span></span><br><span class="line">        <span class="comment">//第二次 A = 2*26+2;</span></span><br><span class="line">        A = (d*A + (P[i] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一次 st = 0*26+0</span></span><br><span class="line">        <span class="comment">//第二次 st = 0*26+1</span></span><br><span class="line">        St = (d*St + (S[i] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 获取d^m-1值(因为经常要用d^m-1进制值)</span></span><br><span class="line">    <span class="type">int</span> hValue = getMaxValue(m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.遍历[0,n-m], 判断模式串HashValue A是否和其他子串的HashValue 一致.</span></span><br><span class="line">    <span class="comment">//不一致则继续求得下一个HashValue</span></span><br><span class="line">    <span class="comment">//如果一致则进行二次确认判断,2个字符串是否真正相等.反正哈希值冲突导致错误</span></span><br><span class="line">    <span class="comment">//注意细节:</span></span><br><span class="line">    <span class="comment">//① 在进入循环时,就已经得到子串的哈希值以及主串的[0,m)的哈希值,可以直接进行第一轮比较;</span></span><br><span class="line">    <span class="comment">//② 哈希值相等后,再次用字符串进行比较.防止哈希值冲突;</span></span><br><span class="line">    <span class="comment">//③ 如果不相等,利用在循环之前已经计算好的st[0] 来计算后面的st[1];</span></span><br><span class="line">    <span class="comment">//④ 在对比过程,并不是一次性把所有的主串子串都求解好Hash值. 而是是借助s[i]来求解s[i+1] . 简单说就是一边比较哈希值,一边计算哈希值;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n-m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == St)</span><br><span class="line">            <span class="keyword">if</span>(isMatch(S,i,P,m))</span><br><span class="line">                <span class="comment">//加1原因,从1开始数</span></span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        St = ((St - hValue*(S[i]-<span class="string">&#x27;a&#x27;</span>))*d + (S[i+m]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-代码验证"><a href="#2-3-代码验证" class="headerlink" title="2.3 代码验证"></a>2.3 代码验证</h3><ul><li><p>执行查找代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf=<span class="string">&quot;abcababcabx&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *ptrn=<span class="string">&quot;abcabx&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主串为%s\n&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子串为%s\n&quot;</span>,ptrn);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> index = RK(buf, ptrn);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;find index : %d\n&quot;</span>,index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果如下：</p><p><img src="/p/8a586c1e/002.png" alt="通过RK 算法查找到的结果打印"></p></li></ul><h3 id="2-4-复杂度"><a href="#2-4-复杂度" class="headerlink" title="2.4 复杂度"></a>2.4 复杂度</h3><ul><li>时间复杂度：O(n+m)，最坏O((n-m) * m)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> RK </tag>
            
            <tag> BF </tag>
            
            <tag> 字符查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（8.1）字符串去重算法</title>
      <link href="/p/cc625709.html"/>
      <url>/p/cc625709.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p><a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p><a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p><a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p><a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p><a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p><a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p><p><a href="https://nilsli.com/p/b0e10b1c.html">【数据结构与算法】-（8）栈之算法题</a></p></blockquote><h2 id="去除重复字母"><a href="#去除重复字母" class="headerlink" title="去除重复字母"></a>去除重复字母</h2><p>LeetCode 级别：困难</p><h3 id="Q：-题目"><a href="#Q：-题目" class="headerlink" title="Q： 题目"></a>Q： 题目</h3><p>给你一个仅包含小写字母的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的<strong>字典序</strong>最小。要求：不能打乱其他字符的相对位置。<a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">原题目leetcode链接</a></p><p>示例1:</p><p>输入：<code>&quot;bcabc&quot;</code></p><p>输出：<code>&quot;abc&quot;</code></p><p>示例2:</p><p>输入：<code>&quot;cbacdcbc&quot;</code></p><p>输出：<code>&quot;acdb&quot;</code><code>~~cbad~~</code>, <code>~~bacd~~</code>, <code>~~adcb~~</code></p><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze:"></a>Analyze:</h3><p>分析关键字：<strong>字典序</strong>、<strong>不打乱</strong></p><ul><li>字典序最小：即排列顺序按照26个字母一次排序，比如给的<code>antman</code> 肯定要排在<code>ultraman</code> 前面</li><li>不打乱排序：即去除重复字母后，未被重复的那部分字母，不改变原来位置。比如<code>bcabc</code> 结果是 <code>abc</code> 那么去除的是第1、第2位的<code>b</code>和<code>c</code>， 后面3位<code>abc</code> 依然不变。</li></ul><h3 id="A：思路："><a href="#A：思路：" class="headerlink" title="A：思路："></a>A：思路：</h3><ol><li><p>给定字符串 <code>s</code> ，排除字符串异常情况；</p></li><li><p>使用一个<code>record</code> 数组，来记录字符串中字母出现的次数；</p></li><li><p>创建一个栈<code>stack</code> ，用来存储<strong>去除重复字母</strong>的结果，并利用它的特性帮助我们找到正确的次序。</p></li><li><p>遍历给定的字符串<code>s</code>；</p></li><li><p>从0～<code>top</code> 依次遍历 <code>stack</code>，判断当前的字符<code>s[i]</code> 是否存在于<code>stack</code> 中，用一个<code>int</code>类型的值<code>isExist</code>来表示是否存在。</p><ol><li><p>如果<code>isExsit</code> 存在，即&#x3D;&#x3D;1，将<code>record [s[i]]</code> 位置上出现次数减1，即<code>record[s[i]]--</code>，并继续遍历下一个字符；意思是，当前的stack 已经包含这个字符，以后都不需要继续处理这个字符了。</p></li><li><p>如果<code>isExist</code> 不存在，则需要<code>while</code>循环一下，找到这个字符正确的位置，然后存储起来。循环规则大概是这样：跳过栈中比当前字符大、而且后面还会出现的元素，将字符入栈。</p><p><code>while</code> 循环的条件如下：</p><ol><li>用<code>top</code> &gt; -1 来保证栈不为空</li><li>用 <code>stack[top] </code> &gt; s[i]  表示栈定元素比当前元素大</li><li>用 <code>record[stack[top]]</code> &gt; 1 表示后面还会出现</li></ol></li></ol></li><li><p>等遍历完所有的字符后，对当前的字符栈<code>stack</code> 添加一个结束符<code>\0</code>，并返回当前字符串首地址；</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">removeDuplicateLetters</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     ① 特殊情况处理,s为空,或者字符串长度为0;</span></span><br><span class="line"><span class="comment">     ② 特殊情况,s的长度为1,则没有必要后续的处理,则直接返回s;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> || <span class="built_in">strlen</span>(s) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(s) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//record数组,用来记录字符串s中每个字符未来会出现的次数;</span></span><br><span class="line">    <span class="type">char</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//申请一个字符串stack;(用栈的特性来进行stack字符串的数据进出)</span></span><br><span class="line">    <span class="type">char</span>* <span class="built_in">stack</span> = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="comment">//memset(void *s, int ch, size_t n) 将stack len*2*sizeof(char)长度范围的空间填充0;</span></span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">stack</span>, <span class="number">0</span>, len * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="comment">//stack 栈顶赋初值为-1;</span></span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.统计每个字符的频次</span></span><br><span class="line">    <span class="comment">//例如bcabc  recod[26] = &#123;1,2,2&#125;;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.遍历s,入栈</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//isExist 标记, 判断当前字符是否存在栈中;</span></span><br><span class="line">        <span class="type">int</span> isExist = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//①从0~top,遍历stack 判断当前字符s[i]是否存在于栈stack中</span></span><br><span class="line">        <span class="comment">//如果当前字符是否存在于栈的flag, 0表示不存在, 1表示存在</span></span><br><span class="line">        <span class="comment">//top指向栈顶(也是执行stack字符串最后一个字符的位置,表示字符串长度上限)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= top; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="built_in">stack</span>[j]) &#123;</span><br><span class="line">                isExist = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//② 如果存在,record[s[i]]位置上的出现次数减一，并继续遍历下一个字符</span></span><br><span class="line">        <span class="comment">//③ 如果不存在,则需要循环一个正确位置存储起来;</span></span><br><span class="line">        <span class="comment">//④ 如果不存在，跳过栈中所有比当前字符大、且后面还会出现的元素，然后将当前字符入栈</span></span><br><span class="line">        <span class="comment">// top &gt; -1表示栈非空</span></span><br><span class="line">        <span class="comment">//stack[top] &gt; s[i]表示栈顶元素比当前元素大</span></span><br><span class="line">        <span class="comment">//record[stack[top]] &gt; 1表示后面还会出现</span></span><br><span class="line">        <span class="comment">//例如b,c因为不符合以下条件会直接入栈.stack[] = &quot;bc&quot;,但是当当前字符是&quot;a&quot;时,由于bcabc,a不应该是在stack的顺序是&quot;bca&quot;,所以要把位置不符合的字符出栈;</span></span><br><span class="line">        <span class="comment">//top = 1,stack[top] &gt; s[i], c&gt;a; 并且stack[top] 在之后还会重复的出现,所以我们可以安心的把stack中的栈顶C出栈,所以stack[]=&quot;b&quot;,top减一后等于0; 同时也需要将record[c]出现次数减一;</span></span><br><span class="line">        <span class="comment">//top=0,stack[top]&gt;s[i],b&gt;a,并且stack[top] 在之后还会出现,所以stack把栈顶b出栈,所以此时栈stack[]=&quot;&quot;,top减一后等于-1, 此时栈中位置不正确的字符都已经移除;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isExist == <span class="number">1</span>) &#123;</span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">-1</span> &amp;&amp; <span class="built_in">stack</span>[top] &gt; s[i] &amp;&amp; record[<span class="built_in">stack</span>[top] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">               </span><br><span class="line">                <span class="comment">// 跳过该元素，频次要减一</span></span><br><span class="line">                record[<span class="built_in">stack</span>[top] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                <span class="comment">// 出栈</span></span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//⑤ 结束while 循环;</span></span><br><span class="line">            <span class="comment">//循环结束的3种可能性:(1)移动到栈底(top == -1) ; (2)栈顶元素小于当前元素(stack[top] &lt;= s[i]) (3)栈顶元素后面不出现(record[stack[top]] == 1)</span></span><br><span class="line">            <span class="comment">// 此时，当前元素要插入到top的下一个位置</span></span><br><span class="line">            <span class="comment">// top往上移动1位</span></span><br><span class="line">            top++;</span><br><span class="line">            <span class="comment">// 入栈</span></span><br><span class="line">            <span class="built_in">stack</span>[top] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束栈顶添加字符结束符</span></span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>试着执行一下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *s ;</span><br><span class="line">s = removeDuplicateLetters(<span class="string">&quot;zdzdaabc&quot;</span>);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/p/cc625709/001.png"></p><p>从 <code>zdzdaabc</code> &#x3D; &gt; <code>dzabc</code> ，符合要求 ✅</p><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p> leetcode 双百，可以可以</p><p><img src="/p/cc625709/002.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 去重 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（8）栈之算法题</title>
      <link href="/p/b0e10b1c.html"/>
      <url>/p/b0e10b1c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p><a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p><a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p><a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p><a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p><a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p><a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p></blockquote><h2 id="0-算法题解法"><a href="#0-算法题解法" class="headerlink" title="0. 算法题解法"></a>0. 算法题解法</h2><p>要进大厂，必须要迈过的一步，就是算法题，那么算法题的思路究竟是如何呢？</p><p>笔者总结了一下近十年工作中的精髓，思路如下：</p><blockquote><p>我们遇到什么困难也不要怕，微笑着面对它……奥利给！</p></blockquote><p>抱歉走错片场了……想说的真正意思上这样的：</p><h4 id="0-1-方法"><a href="#0-1-方法" class="headerlink" title="0.1 方法"></a>0.1 方法</h4><ol><li>充分阅读题目，了解题目背后的关键意思；</li><li>分析题目，涉及到哪些数据结构，对问题进行分类——到底属于链表问题、栈思想问题、字符串问题、二叉树问题、图相关问题、排序问题；与你之前所接触过的算法题有没有类似，找到问题的解题思路</li><li>实现算法。在算法的实现的过程，并不是一蹴而就，肯定是需要不断的调试、修改的。</li><li>验证算法正确性。</li><li>找到题源，看其他的开发者对齐的解决思路。</li><li>找到题解建议之后，对于其他优秀思路，分析它的优势，并且学习它的思路，并且写成其他解法的代码 </li><li>算法题的解题能力来自于2点：<ul><li>对于数据结构与算法核心问题是否夯实；</li><li>是否有足够多且足够耐心的积累；</li></ul></li></ol><h4 id="0-2-思想应用"><a href="#0-2-思想应用" class="headerlink" title="0.2 思想应用"></a>0.2 思想应用</h4><p>指的是利用栈的特性(先进后出)去解决问题,那么什么问题适合用栈思想解决了?</p><ol><li><p>数据是线性的。</p></li><li><p>问题中常常涉及到数据的来回比较，匹配问题；例如：每日温度、括号匹配、字符串解码、去掉重复字母等问题。</p></li><li><p>问题中涉及到数据的转置，例如进制问题、链表倒序打印问题等。</p></li><li><p>注意并不是说栈思想只是一个解决的的参考思想，并不是万能的。它适用于以上这样的情况下去解决问题；利用栈思想解决问题时，首先需要透彻的解析问题之后，找到问题解决的规律，才能使用它解决。思想只有指导作用，遇到不同的题目，需要个例分析。在基本思想上去找到解决问题之道;</p></li></ol><h4 id="0-3-推荐书单"><a href="#0-3-推荐书单" class="headerlink" title="0.3 推荐书单"></a>0.3 推荐书单</h4><p><img src="/p/b0e10b1c/001.jpg" alt="推荐书单"></p><h2 id="1-进制转换"><a href="#1-进制转换" class="headerlink" title="1. 进制转换"></a>1. 进制转换</h2><h4 id="Q-题目"><a href="#Q-题目" class="headerlink" title="Q: 题目"></a>Q: 题目</h4><p>如何将十进制转化为8进制的整形</p><h4 id="A-解答"><a href="#A-解答" class="headerlink" title="A: 解答"></a>A: 解答</h4><h5 id="1-初始化栈"><a href="#1-初始化栈" class="headerlink" title="1. 初始化栈"></a>1. 初始化栈</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SqStack S;</span><br><span class="line">SElemType e;</span><br><span class="line"><span class="comment">//1.初始化一个空栈S</span></span><br><span class="line">InitStack(&amp;S);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitStack</span><span class="params">(SqStack *S)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-压栈"><a href="#2-压栈" class="headerlink" title="2. 压栈"></a>2. 压栈</h5><p>循环取余，N 为除以8 的取余</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="keyword">while</span> (N) &#123;</span><br><span class="line">    PushData(&amp;S, N%<span class="number">8</span>);</span><br><span class="line">    N = N/<span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-出栈"><a href="#3-出栈" class="headerlink" title="3. 出栈"></a>3. 出栈</h5><p>当栈不为空，一直输出，<code>pop</code>出栈</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!StackEmpty(S)) &#123;</span><br><span class="line">    Pop(&amp;S, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-打印结果："><a href="#4-打印结果：" class="headerlink" title="4. 打印结果："></a>4. 打印结果：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    conversion(<span class="number">5201314</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/p/b0e10b1c/002.png" alt="运行结果"></p><h2 id="2-括号匹配检验"><a href="#2-括号匹配检验" class="headerlink" title="2. 括号匹配检验"></a>2. 括号匹配检验</h2><h4 id="Q-题目-1"><a href="#Q-题目-1" class="headerlink" title="Q: 题目"></a>Q: 题目</h4><p><strong>括号匹配检验（题源：<a href="https://leetcode-cn.com/problems/valid-parentheses">LeetCode</a>）</strong></p><p>给定一个只包括 <code>(</code>，<code>)</code>，<code>&#123;</code>，<code>&#125;</code>，<code>[</code>，<code>]</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p> <strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;()&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;(]&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;([)]&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;&#123;[]&#125;&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="A-解答-1"><a href="#A-解答-1" class="headerlink" title="A: 解答"></a>A: 解答</h4><h2 id="3-每日温度"><a href="#3-每日温度" class="headerlink" title="3. 每日温度"></a>3. 每日温度</h2><h2 id="4-杨辉三角"><a href="#4-杨辉三角" class="headerlink" title="4. 杨辉三角"></a>4. 杨辉三角</h2><h2 id="5-爬楼梯"><a href="#5-爬楼梯" class="headerlink" title="5. 爬楼梯"></a>5. 爬楼梯</h2><h2 id="6-字符串编码问题"><a href="#6-字符串编码问题" class="headerlink" title="6. 字符串编码问题"></a>6. 字符串编码问题</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【iOS进阶】-启动优化</title>
      <link href="/p/7bfd68ea.html"/>
      <url>/p/7bfd68ea.html</url>
      
        <content type="html"><![CDATA[<h4 id="零、引言"><a href="#零、引言" class="headerlink" title="零、引言"></a>零、引言</h4><p>用户在移动应用的世界里，第一印象至关重要。对于iOS应用而言，这意味着启动时间必须迅速且流畅。启动优化不仅是提升用户体验的关键，也是展示技术实力的窗口。本文将深入探讨iOS应用的启动过程，分析启动时间的重要性，并提供一系列实用的优化策略和技巧。</p><h4 id="一、iOS应用启动过程概述"><a href="#一、iOS应用启动过程概述" class="headerlink" title="一、iOS应用启动过程概述"></a>一、iOS应用启动过程概述</h4><h5 id="1-1-iOS应用启动的基本流程。"><a href="#1-1-iOS应用启动的基本流程。" class="headerlink" title="1.1 iOS应用启动的基本流程。"></a>1.1 iOS应用启动的基本流程。</h5><ol><li><strong>用户触发启动</strong>：<br> 当用户点击应用图标时，iOS系统开始启动过程。</li><li><strong>加载可执行文件</strong>：<br> 系统首先加载应用的可执行文件。这个阶段包括验证应用签名的安全性，以及将应用的可执行文件加载到内存中。</li><li><strong>运行时环境设置</strong>：<br> 接下来，系统为应用设置运行时环境。这包括分配必要的内存资源和设置应用所需的环境变量。</li><li><strong>调用main()函数</strong>：<br> 启动过程的下一个步骤是调用应用的main()函数。在标准iOS应用中，main()函数通常很简单，它的主要任务是调用UIApplicationMain()函数。</li><li>**执行UIApplicationMain()**：<br> UIApplicationMain()函数是启动过程中的关键部分。它创建了应用的UIApplication对象和应用的主UIWindow，并设置了应用的委托（AppDelegate）。</li><li><strong>加载和设置AppDelegate</strong>：<br> UIApplicationMain()会根据Info.plist文件中的设置，实例化AppDelegate类，并将其设置为UIApplication对象的代理。AppDelegate负责处理应用生命周期和UI事件。</li><li><strong>调用application:didFinishLaunchingWithOptions</strong>:<br> 一旦AppDelegate被创建和设置，application:didFinishLaunchingWithOptions:方法会被调用。这个方法是开发者自定义代码的主要入口点，用于设置应用的初始状态、创建UI界面、连接到数据库或执行其他必要的启动任务。</li><li><strong>渲染初始界面</strong>：<br> <code>application:didFinishLaunchingWithOptions</code>:执行完毕后，应用的初始界面（通常在Storyboard或通过代码设置）被加载和渲染，此时用户开始看到应用的UI。</li><li><strong>应用准备就绪</strong>：<br> 完成上述步骤后，应用变为活动状态，用户可以开始与其交互。</li></ol><h5 id="1-2-main-函数和UIApplicationMain的作用"><a href="#1-2-main-函数和UIApplicationMain的作用" class="headerlink" title="1.2 main()函数和UIApplicationMain的作用"></a>1.2 main()函数和UIApplicationMain的作用</h5><ul><li>main()函数<ul><li><strong>启动点</strong>：main()函数是iOS应用的入口点，是程序执行的第一站。它是每个C或Objective-C程序的标准入口点。</li><li><strong>简洁性</strong>：在标准的iOS应用中，main()函数通常非常简洁。它的主要任务是调用UIApplicationMain()函数。</li><li><strong>桥接角色</strong>：它作为程序运行和iOS应用框架之间的桥接，确保了iOS特有的应用生命周期和事件处理能夔正确启动。</li></ul></li><li>UIApplicationMain()函数<ul><li><strong>核心作用</strong>：UIApplicationMain()函数是iOS应用启动流程的核心。它负责创建应用的UIApplication对象和应用的主UIWindow。</li><li><strong>设置AppDelegate</strong>：此函数还设置应用的AppDelegate，并将其作为UIApplication对象的代理。这一步是关键，因为AppDelegate负责响应应用生命周期事件，如应用启动、进入后台等。</li><li><strong>运行循环</strong>：UIApplicationMain()还启动了主运行循环（main run loop），这对于处理用户界面事件和各种输入至关重要。</li><li><strong>事件处理</strong>：它处理用户的触摸事件、系统事件等，并将它们分发到应用中相应的处理程序。</li></ul></li></ul><p>总的来说，main()函数是应用启动的起点，而UIApplicationMain()是应用启动过程中最关键的函数，负责创建和设置应用的基础结构，并启动事件处理循环。这两个函数共同确保了iOS应用能够按照期望的方式启动和运行。</p><h5 id="1-3-didFinishLaunchingWithOptions方法的作用"><a href="#1-3-didFinishLaunchingWithOptions方法的作用" class="headerlink" title="1.3 didFinishLaunchingWithOptions方法的作用"></a>1.3 didFinishLaunchingWithOptions方法的作用</h5><ul><li><p><strong>应用初始化</strong>：<br>这个方法是在应用启动后首先被调用的点，用于执行应用级别的初始化操作。在这里，开发者可以设置应用的初始状态，配置全局变量等。</p></li><li><p><strong>界面设置</strong>：<br>  在application:didFinishLaunchingWithOptions:中，开发者通常会建立和配置应用的初始用户界面。这包括创建窗口（UIWindow），设置根视图控制器，以及可能的其他界面相关配置。</p></li><li><p><strong>集成服务</strong>：<br>这个方法也是集成各种服务和第三方库的理想位置。例如，可以在这里初始化数据库、配置分析工具、集成社交媒体SDK等。</p></li><li><p><strong>处理启动选项</strong>：<br>  该方法的参数launchOptions提供了应用启动的上下文信息，比如用户是通过点击通知、URL或者是从其他应用中启动的。这使得开发者可以根据不同的启动情况，执行相应的操作。</p></li><li><p><strong>性能优化</strong>：<br>  由于这个方法是在应用启动时调用的，因此在这里进行的所有操作都会直接影响应用的启动时间。因此，开发者需要谨慎处理这里的代码，避免执行耗时操作，以确保应用启动快速。</p></li><li><p>返回值：<br>  该方法最终返回一个布尔值，指示应用是否成功启动并准备好运行。通常在所有初始化操作成功完成后，返回true。</p></li></ul><h4 id="二、测量启动时间"><a href="#二、测量启动时间" class="headerlink" title="二、测量启动时间"></a>二、测量启动时间</h4><h5 id="2-1-Xcode-设置"><a href="#2-1-Xcode-设置" class="headerlink" title="2.1 Xcode 设置"></a>2.1 Xcode 设置</h5><ol><li>设置启动参数：<ul><li>在弹出的窗口中，选择“Run”（运行）选项卡。</li><li>导航到“Arguments”（参数）部分。</li><li>在“<code>Environment Variables</code>”（环境变量）区域中添加一个新的变量。名称设置为<code>DYLD_PRINT_STATISTICS</code>，值设置为<code>1</code>。这会在应用启动时打印出详细的加载统计信息。</li></ul></li><li>运行应用：<br>观察Xcode控制台输出。它会显示应用启动的时间统计，包括总启动时间和主要阶段的时间（例如，动态库加载时间）。</li></ol><h5 id="2-2-使用Instruments"><a href="#2-2-使用Instruments" class="headerlink" title="2.2 使用Instruments"></a>2.2 使用Instruments</h5><ol><li><p>打开Instruments：</p><ul><li>在Xcode中，选择“Xcode”菜单中的“Open Developer Tool”（打开开发者工具），然后选择“Instruments”。</li></ul></li><li><p>选择适当的模板：</p><ul><li>在Instruments中，选择“Time Profiler”（时间分析器）工具。</li></ul></li><li><p>配置记录设置：</p><ul><li>选择你的应用和目标设备。</li><li>设置适当的记录选项，例如记录的时间长度。</li></ul></li><li><p>开始记录：</p><ul><li>点击“Record”（记录）按钮开始捕捉数据。</li><li>启动你的应用。</li><li>让应用运行一段时间，然后停止记录。</li></ul></li><li><p>分析数据：</p><ul><li>查看捕获的数据，特别注意应用启动期间的CPU使用情况和函数调用时间。</li><li>使用Instruments的详细视图和过滤功能来定位可能导致延迟的代码。</li></ul></li></ol><h5 id="1-3-冷启动与热启动"><a href="#1-3-冷启动与热启动" class="headerlink" title="1.3 冷启动与热启动"></a>1.3 冷启动与热启动</h5><ol><li><p><strong>冷启动（Cold Launch）</strong></p><ul><li>场景：应用从完全关闭状态启动，不在内存中。</li><li>过程：包括加载应用到内存、初始化运行环境和设置。</li><li>性能影响：通常耗时更长，因为需要完整的加载和初始化过程。</li><li>优化焦点：减少初始化代码量，优化资源加载和应用大小。</li></ul></li><li><p><strong>热启动（Warm Launch</strong>）</p><ul><li>场景：应用已在内存中或之前运行过，但不在前台。</li><li>过程：主要涉及恢复到前台，部分资源可能仍在内存中。</li><li>性能影响：通常比冷启动快，因为省去了一些初始化步骤。</li><li>优化焦点：确保快速恢复和有效的状态管理。</li></ul><p> 总结来说，冷启动涉及完整的应用启动过程，而热启动则是从一种“休眠”状态恢复，两者在优化策略上有所不同。</p></li></ol><h4 id="三、优化启动时间的技巧和策略"><a href="#三、优化启动时间的技巧和策略" class="headerlink" title="三、优化启动时间的技巧和策略"></a>三、优化启动时间的技巧和策略</h4><ol><li>减少初始化代码：优化AppDelegate中的代码，延迟加载不必要的服务。<br><strong>举个例子：</strong> 假设我们有一个名为MyService的服务，需要在应用启动时初始化，但不是立即必需的。我们可以在AppDelegate中进行延迟加载。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class AppDelegate: UIResponder, UIApplicationDelegate &#123;</span><br><span class="line"></span><br><span class="line">    var window: UIWindow?</span><br><span class="line">    var myService: MyService?</span><br><span class="line"></span><br><span class="line">    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123;</span><br><span class="line">        // 设置UI和其他初始化代码...</span><br><span class="line"></span><br><span class="line">        // 延迟加载MyService</span><br><span class="line">        DispatchQueue.global(qos: .background).async &#123;</span><br><span class="line">            self.myService = MyService()</span><br><span class="line">            self.myService?.setup()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他AppDelegate方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyService &#123;</span><br><span class="line">    func setup() &#123;</span><br><span class="line">        // 长时间运行的设置或初始化代码...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>静态资源和资源预加载：管理静态资源的有效方法，以及预加载技巧。</li></ol><ul><li><strong>举例：</strong><br>假设我们有一组图像资源需要在应用中使用，但不需要在应用启动时立即加载。我们可以实现一个预加载机制，让这些资源在后台逐渐加载，以便在需要时立即使用。<figure class="highlight plaintext"><figcaption><span>UIKit</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class ResourcePreloader &#123;</span><br><span class="line">    private var images: [String: UIImage] = [:]</span><br><span class="line"></span><br><span class="line">    // 异步预加载图像</span><br><span class="line">    func preloadImages(named imageNames: [String]) &#123;</span><br><span class="line">        DispatchQueue.global(qos: .background).async &#123;</span><br><span class="line">            for imageName in imageNames &#123;</span><br><span class="line">                if let image = UIImage(named: imageName) &#123;</span><br><span class="line">                    self.images[imageName] = image</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取预加载的图像</span><br><span class="line">    func getPreloadedImage(named imageName: String) -&gt; UIImage? &#123;</span><br><span class="line">        return images[imageName]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AppDelegate: UIResponder, UIApplicationDelegate &#123;</span><br><span class="line">    var window: UIWindow?</span><br><span class="line">    let preloader = ResourcePreloader()</span><br><span class="line"></span><br><span class="line">    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123;</span><br><span class="line">        // 预加载图像资源</span><br><span class="line">        preloader.preloadImages(named: [&quot;image1&quot;, &quot;image2&quot;, &quot;image3&quot;])</span><br><span class="line">        </span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他AppDelegate方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><strong>代码解释</strong>：<ul><li><strong>资源预加载</strong>：ResourcePreloader类负责预加载和存储图像资源。preloadImages方法在后台线程中加载图像，这样就不会阻塞主线程。</li><li><strong>后台线程加载</strong>：使用DispatchQueue.global(qos: .background).async确保资源加载在后台进行，以减少对主线程和应用启动性能的影响。</li><li><strong>资源访问</strong>：getPreloadedImage方法提供了对预加载图像的访问。这使得在应用的其他部分中可以快速获取这些图像。</li><li><strong>启动时预加载</strong>：在AppDelegate的application(_:didFinishLaunchingWithOptions:)方法中调用预加载，以确保在应用启动时开始加载资源。</li></ul></li></ul><ol start="3"><li>并行和异步执行：利用并行编程和异步执行来加快启动速度。<ul><li>假设我们的应用需要在启动时执行两个耗时任务：一个是数据加载（loadData），另一个是复杂计算（performComplexCalculation）。我们将这些任务放在不同的后台线程上执行，以提高效率。<figure class="highlight plaintext"><figcaption><span>UIKit</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class AppDelegate: UIResponder, UIApplicationDelegate &#123;</span><br><span class="line"></span><br><span class="line">    var window: UIWindow?</span><br><span class="line"></span><br><span class="line">    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123;</span><br><span class="line">        // 设置UI和其他初始化代码...</span><br><span class="line"></span><br><span class="line">        // 异步加载数据</span><br><span class="line">        DispatchQueue.global(qos: .userInitiated).async &#123;</span><br><span class="line">            self.loadData()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 异步执行复杂计算</span><br><span class="line">        DispatchQueue.global(qos: .userInitiated).async &#123;</span><br><span class="line">            self.performComplexCalculation()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 模拟耗时的数据加载</span><br><span class="line">    private func loadData() &#123;</span><br><span class="line">        // 数据加载逻辑...</span><br><span class="line">        print(&quot;Data loaded.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 模拟复杂计算</span><br><span class="line">    private func performComplexCalculation() &#123;</span><br><span class="line">        // 复杂计算逻辑...</span><br><span class="line">        print(&quot;Complex calculation performed.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他AppDelegate方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><strong>代码解释</strong>：<ul><li><p><strong>异步任务</strong>：在<code>application(_:didFinishLaunchingWithOptions:)</code>方法中，我们使用<code>DispatchQueue.global(qos: .userInitiated).async</code>来异步执行<code>loadData</code>和<code>performComplexCalculation</code>方法。这使得这些任务在后台线程上并行运行。</p></li><li><p><strong>质量服务等级</strong>：通过设置<code>qos: .userInitiated</code>，我们告诉系统这些任务虽然是后台任务，但对用户体验有显著影响，因此应该较快处理。</p></li><li><p><strong>主线程保护</strong>：通过将耗时任务放在后台执行，我们避免了阻塞主线程，这对于保持应用的响应性至关重要，特别是在启动阶段。</p></li></ul></li></ul><ol start="4"><li>优化Storyboard和XIB文件：减少和优化界面资源的加载时间。</li></ol><ul><li><p>拆分复杂的Storyboard：<br> 如果你的Storyboard非常庞大和复杂，它可能会显著增加加载时间。拆分成多个较小的Storyboard可以加快加载速度。</p><ul><li>在Xcode中，可以通过创建新的Storyboard文件并将现有Storyboard中的一部分视图控制器移动到新的Storyboard来完成这一过程。</li><li>使用Storyboard Reference来在Storyboard之间进行导航。</li></ul></li></ul><ol><li><strong>优化视图层次结构</strong>    <ul><li>减少视图层次的深度可以减少渲染时间。</li><li>尽量使用较少的容器视图。</li><li>避免不必要的嵌套。例如，如果可以直接在父视图上实现所需的布局，则不需要额外的容器视图。</li></ul></li><li><strong>使用轻量级的视图和控件</strong><ul><li>某些视图和控件比其他的更加消耗资源。</li><li>当可能时，使用更简单的控件。例如，使用UILabel而不是UITextView来显示不可编辑的文本。</li><li>避免过度使用高成本的UI元素，如阴影、透明度和复杂的形状。</li></ul></li><li>延迟加载非关键内容<ul><li>对于不立即显示的视图和数据，可以考虑延迟加载。</li><li>使用代码而不是Storyboard来创建这些视图，并在需要时才加载它们。</li><li>对于TableView和CollectionView，使用惰性加载数据。</li></ul></li><li>精简资源文件<ul><li>减小Storyboard或XIB文件的大小也能提高加载速度。</li><li>移除不使用的视图控制器、视图和资源。</li><li>使用向量图形（如PDF）而不是位图图像，可以减少应用的大小，并且在不同屏幕尺寸上看起来更清晰。</li></ul></li><li>逐步特性加载：实现逐步加载应用特性的方法。<ul><li>假设我们的应用有多个功能模块，比如“用户资料”、“消息”和“设置”。我们将实现一个机制，在应用启动时不立即加载这些模块，而是根据用户的交互逐步加载它们,示例代码如下：<figure class="highlight plaintext"><figcaption><span>UIKit</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class AppModuleManager &#123;</span><br><span class="line">    static let shared = AppModuleManager()</span><br><span class="line"></span><br><span class="line">    private(set) var userProfileModule: UserProfileModule?</span><br><span class="line">    private(set) var messagesModule: MessagesModule?</span><br><span class="line">    private(set) var settingsModule: SettingsModule?</span><br><span class="line"></span><br><span class="line">    private init() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    func loadUserProfileModule() &#123;</span><br><span class="line">        if userProfileModule == nil &#123;</span><br><span class="line">            userProfileModule = UserProfileModule()</span><br><span class="line">            userProfileModule?.loadModule()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func loadMessagesModule() &#123;</span><br><span class="line">        if messagesModule == nil &#123;</span><br><span class="line">            messagesModule = MessagesModule()</span><br><span class="line">            messagesModule?.loadModule()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func loadSettingsModule() &#123;</span><br><span class="line">        if settingsModule == nil &#123;</span><br><span class="line">            settingsModule = SettingsModule()</span><br><span class="line">            settingsModule?.loadModule()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 示例模块类</span><br><span class="line">class UserProfileModule &#123;</span><br><span class="line">    func loadModule() &#123;</span><br><span class="line">        // 加载用户资料模块的相关资源和设置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MessagesModule &#123;</span><br><span class="line">    func loadModule() &#123;</span><br><span class="line">        // 加载消息模块的相关资源和设置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SettingsModule &#123;</span><br><span class="line">    func loadModule() &#123;</span><br><span class="line">        // 加载设置模块的相关资源和设置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在AppDelegate或其他合适的地方调用</span><br><span class="line">let moduleManager = AppModuleManager.shared</span><br><span class="line">moduleManager.loadUserProfileModule()  // 根据需要调用</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><strong>代码解释</strong>：<ul><li>模块化管理：创建AppModuleManager类来管理不同的功能模块。这个类用于加载和保存对应的模块实例。</li><li>延迟实例化：每个模块的加载方法首先检查相应模块是否已经实例化。如果尚未实例化，则创建并加载该模块。</li><li>按需加载：应用的其他部分可以根据需要调用这些加载方法，例如在用户点击某个功能的导航标签时。</li><li>资源和设置的加载：每个模块类有一个loadModule方法，用于执行该模块所需的资源加载和配置设置。</li></ul></li><li>通过这种逐步加载模块的方式，应用可以在启动时保持轻量级，同时按需加载所需的功能，从而提高整体性能和用户体验。</li></ul><h4 id="四、最佳实践和常见陷阱"><a href="#四、最佳实践和常见陷阱" class="headerlink" title="四、最佳实践和常见陷阱"></a>四、最佳实践和常见陷阱</h4><h5 id="4-1-最佳实践"><a href="#4-1-最佳实践" class="headerlink" title="4.1 最佳实践"></a>4.1 最佳实践</h5><ol><li><p>iOS应用启动优化的最佳实践包括一系列技术和策略，旨在提高应用的启动速度和用户体验。以下是一些关键的最佳实践：</p></li><li><p>精简AppDelegate的逻辑：在AppDelegate中仅执行必要的启动逻辑，避免过度拥挤和复杂的初始化代码。</p></li><li><p>延迟加载非关键服务：将不影响首次用户体验的服务和任务延迟加载，例如在后台线程中初始化数据库或第三方服务。</p></li><li><p>优化Storyboard和XIB文件：简化视图层次结构，移除不必要的视图和控件，减少Storyboard的复杂性。</p></li><li><p>使用代码而非Storyboard创建视图：当可能时，通过代码创建视图而不是Storyboard，以减少加载时间。</p></li><li><p>异步加载和并行处理：使用Grand Central Dispatch (GCD) 或其他并行编程技术来异步执行耗时操作。</p></li><li><p>资源预加载和缓存：提前加载和缓存关键资源，如图像和数据，以减少实际使用时的加载时间。</p></li><li><p>避免在启动时阻塞主线程：确保主线程专注于UI渲染和用户交互，避免在其中执行耗时操作。</p></li><li><p>逐步加载特性和模块：根据用户的交互逐步加载应用的特性，而不是一次性加载所有功能。</p></li><li><p>监控和分析启动性能：定期使用Xcode的性能分析工具（如Instruments）来监控启动时间，并识别优化机会。</p></li><li><p>精简应用大小：减少应用的总大小，包括可执行文件、资源和依赖库，以加快下载和加载速度。</p></li><li><p>利用新的API和技术：随着iOS系统的更新，利用最新的API和技术来优化启动时间，例如使用SwiftUI来创建更高效的界面。</p></li><li><p>避免不必要的网络请求：在启动过程中避免或推迟网络请求，尤其是在用户体验上不是立即必需的请求。</p></li></ol><h5 id="4-2-常见问题和陷阱。"><a href="#4-2-常见问题和陷阱。" class="headerlink" title="4.2 常见问题和陷阱。"></a>4.2 常见问题和陷阱。</h5><ol><li><p>过度优化：在追求启动速度时过度优化，可能会导致代码复杂度上升，降低可维护性。</p></li><li><p>忽视线程安全：在并行和异步执行代码时，忽略线程安全可能导致数据竞争和不稳定的应用行为。</p></li><li><p>滥用后台线程：过多地在后台线程执行任务可能会导致系统资源紧张，反而影响性能。</p></li><li><p>忽视用户体验：在优化过程中过分关注启动速度而牺牲用户体验，如延迟加载重要功能，可能会导致用户不满。</p></li><li><p>忽视内存使用：在启动时预加载大量资源可能会导致内存使用激增，从而影响应用性能。</p></li><li><p>依赖外部资源：在启动时依赖外部资源，如网络请求，可能会因为网络条件差导致启动延迟。</p></li><li><p>未适当处理冷启动和热启动：没有区分对待冷启动和热启动，可能会错过针对性的优化机会。</p></li><li><p>忽略测试和监控：没有定期进行性能测试和监控可能会导致优化效果不明显或引入新的性能问题。</p></li></ol><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>上面是总结得来的所有可行的方法，总的来说，优化iOS应用的启动时间对于提升用户体验至关重要。通过有效的策略和技巧，如逐步加载、并行处理和资源优化，可以显著加快启动速度，从而提升用户满意度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 启动优化 </tag>
            
            <tag> 调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（7）队列</title>
      <link href="/p/c0a767bd.html"/>
      <url>/p/c0a767bd.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p><a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p><a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p><a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p><a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p><a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p><a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p></blockquote><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><blockquote><p>队列 (<em>queue</em>) 是只允许在一端进行插入操作、而在另一端进行删除操作的线性表</p></blockquote><p>队列是一种<strong>先进先出</strong>（First In First Out）的线性表，简称<strong>FIFO</strong>。允许插入的一端称为队尾(<em>rear</em>)，允许删除的一端称为队头(<em>front</em>)。</p><p><img src="/p/c0a767bd/005.png" alt="队列结构"></p><h2 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h2><p>入队和出队：正如上文提到的，队列讲究的是先进先出的原则。队列的内部规则，好比大学上课时的占座位，先占到座位的总是前三排，来得晚的只能做到后面去了，等到下课了，先出去的也往往是前三排，也就是先来的那些同学。</p><p>给队列的进队入队画了个示意图如下：</p><p><img src="/p/c0a767bd/006.png" alt="队列的入队出队"></p><h2 id="三、循环队列"><a href="#三、循环队列" class="headerlink" title="三、循环队列"></a>三、循环队列</h2><h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h3><p>线性表有顺序存储和链式存储，队列作为线性表的一种，同样有循环队列的结构。</p><p>像上图中，当C3离开，相继加入了C4和C5，队尾指针就要指出到队列外了，这时就会报出数组越界的错误，但是可以看到队列下方0、1、2位都是空的，这种情况叫做“假溢出”。</p><p>为了解决这种前面空，后面满的情况，我们经常采用解决方案，就是头尾相连的循环。</p><blockquote><p>队列的头尾相连的循环结构称为循环队列</p></blockquote><p>引入循环队列的概念，是为了解决假溢出的现象，那么，究竟什么时候队列真正满了呢？</p><p>我们根据下图分析：</p><ul><li>当初始时，队列空：此时 <code>Q.front = Q.rear</code></li><li>当a、b、c 依次入队，front 不变，rear 指向到元素c后面</li><li>当<code>a</code>离开，front 下沉，指向<code>b</code></li><li>当d、e、f、g入队后，此时<code>rear</code>指向最后一个元素<code>b</code>，此时与<code>front</code>重合</li></ul><p>此时<code>rear</code>、 <code>front</code>再次重合，回到老路上了？</p><p><strong>解决办法</strong>是：预留一个元素位，防止重合。</p><p>也就是说当队列满时，还会有一个空闲的空间。如最后一张图所示，这样<code>rear</code>和<code>front</code> 不会重合。</p><p>所以判断队伍满的条件是：</p><ul><li>队列满：<code>Q.front = (Q.rear + 1) % MaxSize  </code></li></ul><p><img src="/p/c0a767bd/007.png" alt="循环队列的入队出队"></p><h3 id="3-2-顺序存储结构实现"><a href="#3-2-顺序存储结构实现" class="headerlink" title="3.2 顺序存储结构实现"></a>3.2 顺序存储结构实现</h3><h4 id="3-2-1-创建队列："><a href="#3-2-1-创建队列：" class="headerlink" title="3.2.1 创建队列："></a>3.2.1 创建队列：</h4><p>创建队列比较简单，只需要使得<code>rear</code>、<code>front</code> 都为0 即可</p><ol><li><p>初始化顺序结构的队列结构如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure></li><li><p>初始化一个空队列</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK      1;</span></span><br><span class="line"></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(SqQueue *q)</span>&#123;</span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-2-清空一个队列："><a href="#3-2-2-清空一个队列：" class="headerlink" title="3.2.2 清空一个队列："></a>3.2.2 清空一个队列：</h4><p>和创建队列基本相同</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ClearQueue</span><span class="params">(SqQueue *q)</span>&#123;</span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-判断是否是空队列："><a href="#3-2-3-判断是否是空队列：" class="headerlink" title="3.2.3 判断是否是空队列："></a>3.2.3 判断是否是空队列：</h4><p>只需查看<code>rear</code> 和<code>front </code>是否相等</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CheckIfEmpty</span><span class="params">(SqQueue *q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == q-&gt;rear ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-返回队列的长度："><a href="#3-5-返回队列的长度：" class="headerlink" title="3.5 返回队列的长度："></a>3.5 返回队列的长度：</h4><p>需要将尾部减去头部，因为有循环，所以最后要加上MAXSIZE 最后MAXSIZE取模</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">getLength</span><span class="params">(SqQueue q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q.rear - q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-获得队头的元素"><a href="#3-6-获得队头的元素" class="headerlink" title="3.6 获得队头的元素"></a>3.6 获得队头的元素</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR   0;</span></span><br><span class="line"></span><br><span class="line">Status <span class="title function_">getHeadItem</span><span class="params">(SqQueue q, QElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q.front == q.rear ) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = q.data[q.front];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-元素入队"><a href="#3-7-元素入队" class="headerlink" title="3.7 元素入队"></a>3.7 元素入队</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue *q, QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断队伍是否满了</span></span><br><span class="line">    <span class="keyword">if</span> ((q-&gt;rear + <span class="number">1</span>) % MAXSIZE == q-&gt;front)  &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;data[q-&gt;rear] = e;</span><br><span class="line">    q-&gt;rear = ( q-&gt;rear + <span class="number">1</span> ) %MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8-元素出队列"><a href="#3-8-元素出队列" class="headerlink" title="3.8 元素出队列"></a>3.8 元素出队列</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue *q, QElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先判断队伍是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == q-&gt;front) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = q-&gt;data[q-&gt;front];</span><br><span class="line">    q-&gt;front = (q-&gt;front + <span class="number">1</span> ) % MAXSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-9-遍历队列中的元素"><a href="#3-9-遍历队列中的元素" class="headerlink" title="3.9 遍历队列中的元素"></a>3.9 遍历队列中的元素</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ShowQueue</span><span class="params">(SqQueue q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (q.rear == q.front) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i =  q.front;</span><br><span class="line">    <span class="keyword">while</span> ((i + q.front) != q.rear) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q.data[i]);</span><br><span class="line">        i = (i + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上方法执行的业务代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化队列</span></span><br><span class="line">    Status j;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    QElemType d;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已经初始化队列&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列是否为空呢 %u(1:yes 0:no)&quot;</span>, CheckIfEmpty(Q));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元素入队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始往队列添加元素\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        EnQueue(&amp;Q, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历队列</span></span><br><span class="line">    ShowQueue(Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列是否为空呢 %u(1:yes 0:no)\n&quot;</span>, CheckIfEmpty(Q));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获队列的长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列的长度是 %d\n\n&quot;</span>, getLength(Q));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队\n&quot;</span>);</span><br><span class="line">    DeQueue(&amp;Q, &amp;d);</span><br><span class="line">    ShowQueue(Q);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取队列的头</span></span><br><span class="line">    j = getHeadItem(Q, d);</span><br><span class="line">    <span class="keyword">if</span> (j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;头元素是%d\n&quot;</span> , j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空队列</span></span><br><span class="line">    ClearQueue(&amp;Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;清空完成，现在队列打印长度为%d\n\n&quot;</span>, getLength(Q));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src="/p/c0a767bd/008.png" alt="打印结果"></p><h3 id="3-3-链式存储结构的实现"><a href="#3-3-链式存储结构的实现" class="headerlink" title="3.3 链式存储结构的实现"></a>3.3 链式存储结构的实现</h3><p>链式结构的队列结构图：</p><p><img src="/p/c0a767bd/009.png" alt="链式结构的队列"><img src="/p/c0a767bd/010.png" alt="链式结构的空队列"></p><p>操作实现如下：</p><h4 id="3-3-1-链队列结构："><a href="#3-3-1-链队列结构：" class="headerlink" title="3.3.1 链队列结构："></a>3.3.1 链队列结构：</h4><ol><li><p>队列结点结构如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *QueuePtr;</span><br></pre></td></tr></table></figure></li><li><p>队列结构如下: 只需创建2个指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    QueuePtr front, rear;</span><br><span class="line">&#125;QueueLinkList;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-3-2-创建队列"><a href="#3-3-2-创建队列" class="headerlink" title="3.3.2 创建队列"></a>3.3.2 创建队列</h4><p>创建链式结构的队列，只需要创建空间、将<code>front</code> 的<code>next</code> 指向空即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">createLink</span><span class="params">(QueueLinkList *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    q-&gt;front = q-&gt;rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueuePtr));</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-销毁队列"><a href="#3-3-3-销毁队列" class="headerlink" title="3.3.3 销毁队列"></a>3.3.3 销毁队列</h4><p>销毁队列的步骤只需要依次<code>free</code>队列中的元素，这里用<code>q-&gt;rear</code> 来临时保管<code>front</code> 指向的元素。</p><p>具体操作如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁</span></span><br><span class="line">Status <span class="title function_">destroyLink</span><span class="params">(QueueLinkList *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (q-&gt;rear) &#123;</span><br><span class="line">        q-&gt;rear = q-&gt;front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q-&gt;front);</span><br><span class="line">        q-&gt;front = q-&gt;rear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-4-清空一个队列"><a href="#3-3-4-清空一个队列" class="headerlink" title="3.3.4 清空一个队列"></a>3.3.4 清空一个队列</h4><p>主要分三步：</p><ol><li>将 <code>rear</code> 指向 <code>front</code>， 即使得首尾相等，名义上成为了空队列</li><li>保留front 的<code>next </code> 元素，断开<code>front</code> 的<code>next</code></li><li>依次释放队列中元素</li></ol><p>来看下代码的实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">clearLink</span><span class="params">(QueueLinkList *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建2个临时指针变量</span></span><br><span class="line">    QueuePtr p, q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将尾结点放到头结点</span></span><br><span class="line">    Q-&gt;rear = Q-&gt;front ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用q 临时接收 首元结点</span></span><br><span class="line">    q = Q-&gt;front-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将头结点与后面断开</span></span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环遍历，把接收到Q-&gt;front 后面的元素统统释放</span></span><br><span class="line">    <span class="keyword">while</span> (q) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-判断是否为空队列"><a href="#3-3-5-判断是否为空队列" class="headerlink" title="3.3.5 判断是否为空队列"></a>3.3.5 判断是否为空队列</h4><p>只需查看<code>rear</code> 和<code>front </code>是否相等</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CheckIfEmpty</span><span class="params">(SqQueue *q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == q-&gt;rear ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-6-返回队列的长度"><a href="#3-3-6-返回队列的长度" class="headerlink" title="3.3.6 返回队列的长度"></a>3.3.6 返回队列的长度</h4><p>定义一个递增变量，记下循环从 front 到 rear 的次数，即为长度</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">getLength</span><span class="params">(QueueLinkList Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义递增变量 i</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个指针指向 front</span></span><br><span class="line">    QueuePtr p = Q.front;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">while</span> (Q.rear != p) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-7-获取队头的元素"><a href="#3-3-7-获取队头的元素" class="headerlink" title="3.3.7 获取队头的元素"></a>3.3.7 获取队头的元素</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">getHead</span><span class="params">(QueueLinkList Q, QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) &#123; </span><br><span class="line">      <span class="keyword">return</span> ERROR;   </span><br><span class="line">    &#125;</span><br><span class="line">    e  = Q.front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-8-元素入队列"><a href="#3-3-8-元素入队列" class="headerlink" title="3.3.8 元素入队列"></a>3.3.8 元素入队列</h4><p>入队列的操作和顺序的类似，步骤有以下：</p><ol><li>创建新结点，并确保结果不为空</li><li>将新结点赋值，指向为NULL</li><li>将原链队列的<code>rear</code> 端指向新结点</li><li>将新结点作为原链队列的 <code>rear</code></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">enQueue</span><span class="params">(QueueLinkList *Q, QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueuePtr));</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    Q-&gt;rear-&gt;next = s;</span><br><span class="line">    Q-&gt;rear = s;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-9-元素出队列"><a href="#3-3-9-元素出队列" class="headerlink" title="3.3.9 元素出队列"></a>3.3.9 元素出队列</h4><p>出队列，需要先确认现有队列不为空，以及将现有的<code>front</code> 进行出队列操作</p><p>代码实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">deueue</span><span class="params">(QueueLinkList *Q, QElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;rear == Q-&gt;front) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    QueuePtr p ;</span><br><span class="line">    p = Q-&gt;front-&gt;next;</span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    </span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;rear == p) &#123;</span><br><span class="line">        Q-&gt;rear = Q-&gt;front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-10-遍历元素"><a href="#3-3-10-遍历元素" class="headerlink" title="3.3.10 遍历元素"></a>3.3.10 遍历元素</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">Status <span class="title function_">showLink</span><span class="params">(QueueLinkList Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    QueuePtr p = Q.front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-11-总结业务"><a href="#3-3-11-总结业务" class="headerlink" title="3.3.11 总结业务"></a>3.3.11 总结业务</h4><p>业务代码如下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    QueueLinkList Q;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始创建\n&quot;</span>);</span><br><span class="line">    <span class="built_in">createLink</span>(&amp;Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建成果，当前长度      %d\n&quot;</span>, <span class="built_in">getLength</span>(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;依次添加元素\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">enQueue</span>(&amp;Q, i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;添加成功，新队列元素为\n&quot;</span>);</span><br><span class="line">    <span class="built_in">showLink</span>(Q);</span><br><span class="line">    </span><br><span class="line">    QElemType head = <span class="number">0</span>;</span><br><span class="line">    Status j = <span class="built_in">getHead</span>(Q, head);</span><br><span class="line">    <span class="keyword">if</span> (j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该队头为%d\n\n&quot;</span>,j );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始出队\n&quot;</span>);</span><br><span class="line">    Status result = <span class="built_in">deueue</span>(&amp;Q, &amp;head);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队成功，新队列元素为\n&quot;</span>);</span><br><span class="line">        <span class="built_in">showLink</span>(Q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空队列</span></span><br><span class="line">    Status clearResult = <span class="built_in">clearLink</span>(&amp;Q);</span><br><span class="line">    <span class="keyword">if</span> (clearResult) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;清空成功，新队列元素为\n&quot;</span>);</span><br><span class="line">        <span class="built_in">showLink</span>(Q);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;清空失败\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 销毁队列</span></span><br><span class="line">    Status destroyResult = <span class="built_in">destroyLink</span>(&amp;Q);</span><br><span class="line">    <span class="keyword">if</span> (destroyResult) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;销毁成功，新队列元素为\n&quot;</span>);</span><br><span class="line">        <span class="built_in">showLink</span>(Q);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;销毁失败\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终结果如下: </p><p><img src="/p/c0a767bd/011.png" alt="打印结果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（6）栈</title>
      <link href="/p/7914b7d0.html"/>
      <url>/p/7914b7d0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p> <a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p> <a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p> <a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p> <a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p> <a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p> <a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p> <a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p></blockquote><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><blockquote><p>栈 (<em>stack</em>) 是限定仅在表尾进行插入和删除操作的线性表</p></blockquote><ul><li>栈的插入操作（<strong>push</strong>），叫作进栈、入栈。类似子弹入弹夹。</li><li>栈的删除操作（<strong>pop</strong>），叫作出栈，也有的叫做弹栈。</li><li>允许插入和删除的一段叫作栈顶 (<em>top</em>)，另一段底叫作栈底(<em>bottom&#x2F;rear</em>)</li></ul><h4 id="1-2-示意图"><a href="#1-2-示意图" class="headerlink" title="1.2 示意图"></a>1.2 示意图</h4><p><img src="/p/7914b7d0/001.png" alt="栈结构示意图"></p><h3 id="1-2-栈的顺序存储结构及实现"><a href="#1-2-栈的顺序存储结构及实现" class="headerlink" title="1.2 栈的顺序存储结构及实现"></a>1.2 栈的顺序存储结构及实现</h3><h4 id="1-2-1-顺序栈结构"><a href="#1-2-1-顺序栈结构" class="headerlink" title="1.2.1 顺序栈结构"></a>1.2.1 顺序栈结构</h4><p>顺序栈由一个<strong>数据数组</strong>和栈顶指针组成：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top; <span class="comment">/* 用于栈顶指针 */</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>和链式结构类似，指针<code>top</code> 永远指向下一个栈内元素。</p><h4 id="1-2-2-创建空栈"><a href="#1-2-2-创建空栈" class="headerlink" title="1.2.2 创建空栈"></a>1.2.2 创建空栈</h4><p>初始化栈，只需要将栈顶<code>top</code> 处于-1 即可，类似数组，有心数据进来就从0开始排列</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitStack</span><span class="params">(SqStack *S)</span>&#123;</span><br><span class="line">   </span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-清空一个栈"><a href="#1-2-3-清空一个栈" class="headerlink" title="1.2.3 清空一个栈"></a>1.2.3 清空一个栈</h4><p>清空栈也栈顶<code>top</code> 处于-1 即可。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ClearStack</span><span class="params">(SqStack *S)</span>&#123;</span><br><span class="line">    <span class="comment">// 只需要修改top标签 -1.</span></span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-判断栈是否为空"><a href="#1-2-4-判断栈是否为空" class="headerlink" title="1.2.4 判断栈是否为空"></a>1.2.4 判断栈是否为空</h4><p>由于栈内只要有有元素，栈顶<code>top</code>都会移动位置，所以只需要判断是否在-1 即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-5-返回栈的长度"><a href="#1-2-5-返回栈的长度" class="headerlink" title="1.2.5 返回栈的长度"></a>1.2.5 返回栈的长度</h4><p>由于栈顶从0开始排列起来，长度必须上<code>top</code>的序号+1</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StackLength</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-6-获取栈顶元素"><a href="#1-2-6-获取栈顶元素" class="headerlink" title="1.2.6 获取栈顶元素"></a>1.2.6 获取栈顶元素</h4><p>类似数组一样，栈定元素为最后一个元素，即<code>S.data[S.top]</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">GetTop</span><span class="params">(SqStack S,SElemType *e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *e = S.data[S.top];</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-7-插入元素e-为新栈顶元素（压栈）"><a href="#1-2-7-插入元素e-为新栈顶元素（压栈）" class="headerlink" title="1.2.7 插入元素e 为新栈顶元素（压栈）"></a>1.2.7 插入元素<code>e</code> 为新栈顶元素（压栈）</h4><p>压栈即把<code>top</code> 序号 位置提升1位，<code>top</code>位的元素为新元素。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">PushData</span><span class="params">(SqStack *S, SElemType e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//栈已满</span></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == MAXSIZE <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//栈顶指针+1;</span></span><br><span class="line">    S-&gt;top ++;</span><br><span class="line">    <span class="comment">//将新插入的元素赋值给栈顶空间</span></span><br><span class="line">    S-&gt;data[S-&gt;top] = e;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-2-8-删除栈定元素，并用e带回（出栈）"><a href="#1-2-8-删除栈定元素，并用e带回（出栈）" class="headerlink" title="1.2.8 删除栈定元素，并用e带回（出栈）"></a>1.2.8 删除栈定元素，并用e带回（出栈）</h4><p>出栈与入栈恰恰相反，将<code>top</code> 位的元素弹出，同时将<code>top</code> 序号减1</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack *S,SElemType *e)</span>&#123;</span><br><span class="line">    <span class="comment">//空栈,则返回error;</span></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将要删除的栈顶元素赋值给e</span></span><br><span class="line">    *e = S-&gt;data[S-&gt;top];</span><br><span class="line">    <span class="comment">//栈顶指针--;</span></span><br><span class="line">    S-&gt;top--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-9-从栈底到栈顶每个元素打印（遍历）"><a href="#1-2-9-从栈底到栈顶每个元素打印（遍历）" class="headerlink" title="1.2.9 从栈底到栈顶每个元素打印（遍历）"></a>1.2.9 从栈底到栈顶每个元素打印（遍历）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">StackTraverse</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此栈中所有元素&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=S.top) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,S.data[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-栈的链式存储结构及实现"><a href="#1-3-栈的链式存储结构及实现" class="headerlink" title="1.3 栈的链式存储结构及实现"></a>1.3 栈的链式存储结构及实现</h3><h4 id="1-3-1-示意图"><a href="#1-3-1-示意图" class="headerlink" title="1.3.1 示意图"></a>1.3.1 示意图</h4><p>栈道链式存储结构，简称<strong>链栈</strong>。</p><p>链栈的示意图和顺序结构很类似，如图所示了入栈和出栈的流程：</p><p><img src="/p/7914b7d0/002.png" alt="链式结构的栈——入栈"></p><p><img src="/p/7914b7d0/003.png" alt="链式结构的栈——出栈"></p><h4 id="1-3-2-链栈结构"><a href="#1-3-2-链栈结构" class="headerlink" title="1.3.2 链栈结构"></a>1.3.2 链栈结构</h4><p>链栈道结构和单链表很相似：</p><ul><li><p>节点的结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br></pre></td></tr></table></figure></li><li><p>链栈结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkStackPtr top;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-3-创建空栈"><a href="#1-3-3-创建空栈" class="headerlink" title="1.3.3 创建空栈"></a>1.3.3 创建空栈</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitStack</span><span class="params">(LinkStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;top=<span class="literal">NULL</span>;</span><br><span class="line">    S-&gt;count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-4-清空一个栈"><a href="#1-3-4-清空一个栈" class="headerlink" title="1.3.4 清空一个栈"></a>1.3.4 清空一个栈</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ClearStack</span><span class="params">(LinkStack *S)</span>&#123;</span><br><span class="line">    LinkStackPtr p,q;</span><br><span class="line">    p = S-&gt;top;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-5-判断栈是否为空"><a href="#1-3-5-判断栈是否为空" class="headerlink" title="1.3.5 判断栈是否为空"></a>1.3.5 判断栈是否为空</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">StackEmpty</span><span class="params">(LinkStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-6-返回栈的长度"><a href="#1-3-6-返回栈的长度" class="headerlink" title="1.3.6 返回栈的长度"></a>1.3.6 返回栈的长度</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StackLength</span><span class="params">(LinkStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-7-获取栈顶元素"><a href="#1-3-7-获取栈顶元素" class="headerlink" title="1.3.7 获取栈顶元素"></a>1.3.7 获取栈顶元素</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">GetTop</span><span class="params">(LinkStack S,SElemType *e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *e = S.top-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-8-插入元素e-为新栈顶元素（压栈）"><a href="#1-3-8-插入元素e-为新栈顶元素（压栈）" class="headerlink" title="1.3.8 插入元素e 为新栈顶元素（压栈）"></a>1.3.8 插入元素<code>e</code> 为新栈顶元素（压栈）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack *S, SElemType e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新结点temp</span></span><br><span class="line">    LinkStackPtr temp = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    temp-&gt;data = e;</span><br><span class="line">    <span class="comment">//把当前的栈顶元素赋值给新结点的直接后继, 参考图例第①步骤;</span></span><br><span class="line">    temp-&gt;next = S-&gt;top;</span><br><span class="line">    <span class="comment">//将新结点temp 赋值给栈顶指针,参考图例第②步骤;</span></span><br><span class="line">    S-&gt;top = temp;</span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-9-删除栈定元素，并用e带回（出栈）"><a href="#1-3-9-删除栈定元素，并用e带回（出栈）" class="headerlink" title="1.3.9 删除栈定元素，并用e带回（出栈）"></a>1.3.9 删除栈定元素，并用e带回（出栈）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack *S,SElemType *e)</span>&#123;</span><br><span class="line">    LinkStackPtr p;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(*S)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将栈顶元素赋值给*e</span></span><br><span class="line">    *e = S-&gt;top-&gt;data;</span><br><span class="line">    <span class="comment">//将栈顶结点赋值给p,参考图例①</span></span><br><span class="line">    p = S-&gt;top;</span><br><span class="line">    <span class="comment">//使得栈顶指针下移一位, 指向后一结点. 参考图例②</span></span><br><span class="line">    S-&gt;top= S-&gt;top-&gt;next;</span><br><span class="line">    <span class="comment">//释放p</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="comment">//个数--</span></span><br><span class="line">    S-&gt;count--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-10-从栈底到栈顶每个元素打印（遍历）"><a href="#1-3-10-从栈底到栈顶每个元素打印（遍历）" class="headerlink" title="1.3.10 从栈底到栈顶每个元素打印（遍历）"></a>1.3.10 从栈底到栈顶每个元素打印（遍历）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">StackTraverse</span><span class="params">(LinkStack S)</span>&#123;</span><br><span class="line">    LinkStackPtr p;</span><br><span class="line">    p = S.top;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-栈与递归"><a href="#1-4-栈与递归" class="headerlink" title="1.4 栈与递归"></a>1.4 栈与递归</h3><h4 id="1-4-1-递归的定义"><a href="#1-4-1-递归的定义" class="headerlink" title="1.4.1 递归的定义"></a>1.4.1 递归的定义</h4><blockquote><p>直接调用自己或通过一系列的调用语句间接地调用自己的函数，叫做递归函数。</p></blockquote><h4 id="1-4-2-递归的特点"><a href="#1-4-2-递归的特点" class="headerlink" title="1.4.2 递归的特点"></a>1.4.2 递归的特点</h4><blockquote><p>每个递归定义必须有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</p></blockquote><h4 id="1-4-3-递归与迭代的区别"><a href="#1-4-3-递归与迭代的区别" class="headerlink" title="1.4.3 递归与迭代的区别"></a>1.4.3 递归与迭代的区别</h4><ul><li><strong>迭代：</strong> 使用的是循环结构。</li><li>递归：使用的是选择结构。是程序结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。</li></ul><h4 id="1-4-4-递归的使用场景"><a href="#1-4-4-递归的使用场景" class="headerlink" title="1.4.4 递归的使用场景"></a>1.4.4 递归的使用场景</h4><ul><li>定义是递归的</li><li>数据结构是递归的</li><li>问题的解法是递归的</li></ul><h4 id="1-4-5-递归应用——斐波那契数列"><a href="#1-4-5-递归应用——斐波那契数列" class="headerlink" title="1.4.5 递归应用——斐波那契数列"></a>1.4.5 递归应用——斐波那契数列</h4><p><strong>问题：</strong>如果兔子2个月之后就会有繁殖能力，那么一对兔子每个月能生出一对兔子；假设所有的兔子都不死，那么n个月后能生出多杀只兔子呢？</p><p><strong>解法：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Fbi</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fbi(i<span class="number">-1</span>)+Fbi(i<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-6-递归过程与递归工作栈"><a href="#1-4-6-递归过程与递归工作栈" class="headerlink" title="1.4.6 递归过程与递归工作栈"></a>1.4.6 递归过程与递归工作栈</h4><p>我们日常使用函数时，常有函数内套用其他函数，而其他函数又会套用其他的函数，比如如下的代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> m, n;</span><br><span class="line">  first(m, n);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">first</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  second(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">second</span><span class="params">(<span class="type">int</span> d)</span>&#123;</span><br><span class="line">  <span class="type">int</span> x,y;</span><br><span class="line">  <span class="comment">// blablabla</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的结构，其实也是递归的应用，这种应用叫做递归工作站，其结构示意图如下:</p><p><img src="/p/7914b7d0/004.png" alt="递归过程与工作栈"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（5）链表面试题解析</title>
      <link href="/p/50518edc.html"/>
      <url>/p/50518edc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p> <a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p> <a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p> <a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p> <a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p> <a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p> <a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p> <a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p></blockquote><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>之前复习了一下数据结构以及线性表的基础，继续来做一些习题，巩固一下。</p><h3 id="Q1-链表合并"><a href="#Q1-链表合并" class="headerlink" title="Q1 链表合并"></a>Q1 链表合并</h3><h4 id="1-题目："><a href="#1-题目：" class="headerlink" title="1. 题目："></a>1. 题目：</h4><p>将两个递增的有序链表合并为一个有序链表；要求结果链表仍然是用两个链表的存储空间，不另外占用其他的存储空间；表中不允许有重复的数据</p><p>如<strong>La{1 ,2, 3}</strong>, <strong>Lb{3, 6, 9}</strong>, 合并成为 <strong>Lc{1, 2, 3, 6, 9}</strong></p><p><img src="/p/50518edc/001.png"></p><h4 id="2-分析："><a href="#2-分析：" class="headerlink" title="2. 分析："></a>2. 分析：</h4><p>本题要求如下：</p><ul><li>两个都是递增有序链表</li><li>不允许重复数据</li><li>结果要求保持递增关系，可以考虑后插法</li><li><strong>不占用额外空间</strong>，也不允许新建维持逻辑</li></ul><h4 id="3-算法思路："><a href="#3-算法思路：" class="headerlink" title="3. 算法思路："></a>3. 算法思路：</h4><ol><li>准备临时变量：头指针<code>Lc</code>——由于要求不占用额外空间，<code>Lc</code>指向（借用）<code>La</code> 的头结点</li><li>依次循环<code>La</code>、<code>Lb</code> ，<ol><li>比较<code>pa</code>、<code>pb</code>两者的 <code>data</code> 值大小，取较小者存到<code>Lc</code>里</li><li>比较较小者剩余链表，与较大者的<code>data</code>，循环往复</li></ol></li></ol><h4 id="4-代码实现："><a href="#4-代码实现：" class="headerlink" title="4. 代码实现："></a>4. 代码实现：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(ListNode* La, ListNode* Lb)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(La == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> Lb;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Lb == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> La;</span><br><span class="line">        </span><br><span class="line">        ListNode *Lc = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(La-&gt; data &lt; Lb-&gt; data)&#123;</span><br><span class="line">            Lc = La;</span><br><span class="line">            Lc-&gt;next = mergeTwoLists(La-&gt;next, Lb);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Lc = Lb;</span><br><span class="line">            Lc-&gt;next = mergeTwoLists(La, Lb-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Lc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-流程图解"><a href="#5-流程图解" class="headerlink" title="5. 流程图解"></a>5. 流程图解</h4><p><img src="/p/50518edc/002.png">  </p><h3 id="Q2-链表：求重"><a href="#Q2-链表：求重" class="headerlink" title="Q2 链表：求重"></a>Q2 链表：求重</h3><h4 id="1-题目：-1"><a href="#1-题目：-1" class="headerlink" title="1. 题目："></a>1. 题目：</h4><p>已知两个链表A和B分别表示两个集合.其元素递增排列. 设计一个算法,用于求出A与B的交集,并存储在A链表中;</p><p>例如:</p><p> La &#x3D; {2,4,6,8}; Lb &#x3D; {4,6,8,10};</p><p> Lc &#x3D; {4,6,8}</p><h4 id="2-分析：-1"><a href="#2-分析：-1" class="headerlink" title="2. 分析："></a>2. 分析：</h4><ul><li>需要比较相同元素，予以保留</li><li>比较后不同的元素，予以删除</li></ul><h4 id="3-算法思路"><a href="#3-算法思路" class="headerlink" title="3. 算法思路"></a>3. 算法思路</h4><p>这道题目与上道题恰恰相反，在依次循环后，<strong>留下相同的元素</strong>。</p><ol><li>准备临时变量：<ol><li>原始链表<code>La</code>、<code>Lb</code>、</li><li>链表 <code>La</code> 和 <code>Lb</code> 各自的首元结点指针<code>pa</code>、  <code>pb</code>、</li><li>头指针<code>Lc</code>——由于要求不占用额外空间，<code>Lc</code>指向（借用）<code>La</code> 的头结点</li></ol></li><li>依次循环<code>La</code>、<code>Lb</code> ，<ol><li>比较<code>pa</code>、<code>pb</code>两者的 <code>data</code> 值大小</li><li>若相等，把<code>pa</code>存到<code>Lc</code>里，释放<code>pb</code>指定结点</li><li>若不相等，释放掉较小的元素</li></ol></li><li>若循环至某一方为空，删除&#x2F;释放非空表所有元素</li></ol><h4 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Intersection</span><span class="params">(LinkList *La, LinkList *Lb, LinkList *Lc)</span>&#123;</span><br><span class="line">    <span class="comment">//目标: 求2个递增的有序链表La,Lb的交集, 使用头指针Lc指向带回;</span></span><br><span class="line">    LinkList pa,pb,pc,temp;</span><br><span class="line">    <span class="comment">//pa 是链表La的工作指针,pb 是链表Lb的工作指针, 初始化为首元结点;La的头结点作为Lc的头结点;</span></span><br><span class="line">    pa = (*La)-&gt;next;</span><br><span class="line">    pb = (*Lb)-&gt;next;</span><br><span class="line">    *Lc = pc = *La;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (pa &amp;&amp; pb) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pa-&gt;data == pb-&gt;data) &#123;</span><br><span class="line">            <span class="comment">//相等,交集并入结果链表中;</span></span><br><span class="line">            <span class="comment">//(1).取La中的元素,将pa链接到pc的后面,pa指针后移;</span></span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            <span class="comment">//(2)删除Lb中对应相等的元素</span></span><br><span class="line">            temp = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data &lt; pb-&gt;data)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//删除较小值La的元素;</span></span><br><span class="line">            temp = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//删除较小值Lb中的元素</span></span><br><span class="line">            temp = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Lb为空,删除非空表La中的所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (pa) &#123;</span><br><span class="line">       </span><br><span class="line">        temp = pa;</span><br><span class="line">        pa = pa-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//La为空,删除非空表Lb中的所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (pb) &#123;</span><br><span class="line">        temp = pb;</span><br><span class="line">        pb = pb-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    pc-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(*Lb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-流程图解-1"><a href="#5-流程图解-1" class="headerlink" title="5. 流程图解"></a>5. 流程图解</h4><h3 id="Q3-链表原地旋转【面试常有】"><a href="#Q3-链表原地旋转【面试常有】" class="headerlink" title="Q3 链表原地旋转【面试常有】"></a>Q3 链表原地旋转【面试常有】</h3><h4 id="1-题目：-2"><a href="#1-题目：-2" class="headerlink" title="1. 题目："></a>1. 题目：</h4><p>设计一个算法,将链表中所有节点的链接方向”原地旋转”，即要求<strong>仅仅利用原表的存储空间</strong>。换句话说,要求算法空间复杂度为O(1);</p><p>例如:L &#x3D; <em>{0,2,4,6,8,10}</em>, 逆转后: L &#x3D; <em>{10,8,6,4,2,0}</em>;</p><h4 id="2-分析：-2"><a href="#2-分析：-2" class="headerlink" title="2. 分析："></a>2. 分析：</h4><ul><li>不可以开辟空间</li><li>只能移动指针</li><li>首选<strong>头插法</strong></li></ul><h4 id="3-算法思路：-1"><a href="#3-算法思路：-1" class="headerlink" title="3. 算法思路："></a>3. 算法思路：</h4><ol><li>保持当前头结点的下个结点 </li><li>将当前头结点的指向指到上一个结点</li><li>把当前头结点保存为上一个结点</li><li>将头结点的下一个结点，设定为头结点</li></ol><h4 id="4-代码实现：-1"><a href="#4-代码实现：-1" class="headerlink" title="4. 代码实现："></a>4. 代码实现：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> LinkList* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> LinkList* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span> *<span class="title">preNode</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    </span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> preNode;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-流程图解-2"><a href="#5-流程图解-2" class="headerlink" title="5. 流程图解"></a>5. 流程图解</h4><p><img src="/p/50518edc/003.png"></p><h3 id="Q4-链表删除指定元素"><a href="#Q4-链表删除指定元素" class="headerlink" title="Q4 链表删除指定元素"></a>Q4 链表删除指定元素</h3><h4 id="1-题目：-3"><a href="#1-题目：-3" class="headerlink" title="1. 题目："></a>1. 题目：</h4><p>设计一个算法，删除递增有序链表中值大于等于<code>mink</code>且小于等于<code>maxk</code>（<code>mink, maxk</code>是给定的两个参数,其值可以和表中的元素相同,也可以不同）的所有元素;</p><h4 id="2-分析：-3"><a href="#2-分析：-3" class="headerlink" title="2. 分析："></a>2. 分析：</h4><ul><li>链表递增</li><li>给定上边界、下边界</li><li>上下边界找到后，桥接起来</li><li>边界中其他元素删除</li></ul><h4 id="3-算法思路：-2"><a href="#3-算法思路：-2" class="headerlink" title="3. 算法思路："></a>3. 算法思路：</h4><ol><li><code>mink</code>：循环链表1次，找到第一个大于<code>mink</code>的结点，记住其前驱结点<code>pre</code></li><li><code>maxk</code>：循环链表2次，找到大于等于maxk 的结点，用<code>p</code>标记</li><li>桥接：把 <code>pre -&gt; next</code> 指向结点<code>p</code></li><li>循环释放，释放<code>pre</code>、<code>p</code> 中间的结点</li></ol><h4 id="4-代码实现：-2"><a href="#4-代码实现：-2" class="headerlink" title="4. 代码实现："></a>4. 代码实现：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DeleteMinMax</span><span class="params">(LinkList *L, <span class="type">int</span> mink, <span class="type">int</span> maxk)</span>&#123;</span><br><span class="line">    <span class="comment">//目标: 删除递增有序链表L中值大于等于mink 和小于等于maxk的所有元素</span></span><br><span class="line">    </span><br><span class="line">    LinkList p,q,pre;</span><br><span class="line">    pre = *L;</span><br><span class="line">    LinkList temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//p指向首元结点</span></span><br><span class="line">    p = (*L)-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.查找第一值大于mink的结点</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data &lt; mink) &#123;</span><br><span class="line">        <span class="comment">//指向前驱结点</span></span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.查找第一个值大于等于maxk的结点</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data&lt;=maxk) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.修改待删除的结点指针</span></span><br><span class="line">    q = pre-&gt;next;</span><br><span class="line">    pre-&gt;next = p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q != p) &#123;</span><br><span class="line">        temp = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        q = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-流程图解-3"><a href="#5-流程图解-3" class="headerlink" title="5. 流程图解"></a>5. 流程图解</h4><h3 id="Q5-数组平移"><a href="#Q5-数组平移" class="headerlink" title="Q5 数组平移"></a>Q5 数组平移</h3><h4 id="1-题目：-4"><a href="#1-题目：-4" class="headerlink" title="1. 题目："></a>1. 题目：</h4><p>设将n(n&gt;1)个整数存放到一维数组R中, 试设计一个在时间和空间两方面都尽可能高效的算法;将R中保存的序列循环左移p个位置 <em>(0&lt;p&lt;n)</em> 个位置， 即将R中的数据由 <em>(x0,x1,……,xn-1)</em> 变换为*(xp,xp+1,…,xn-1,x0,x1,…,xp-1)*.</p><p> 例如: </p><blockquote><p>   pre[10] &#x3D; <em>{0,1,2,3,4,5,6,7,8,9},</em></p><p>   n &#x3D; 10,p &#x3D; 3;</p><p>   pre[10] &#x3D; <em>{3,4,5,6,7,8,9,0,1,2}</em></p></blockquote><h4 id="2-分析：-4"><a href="#2-分析：-4" class="headerlink" title="2. 分析："></a>2. 分析：</h4><ul><li>数组而非链表</li><li>往左移动，原左边的元素依次推到右边</li><li>本质上两个区块元素交换，可考虑先原地旋转</li><li>再将两个区块元素各自原地旋转</li></ul><h4 id="3-算法思路：-3"><a href="#3-算法思路：-3" class="headerlink" title="3. 算法思路："></a>3. 算法思路：</h4><ol><li>将原数组原地旋转，成为*[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]*</li><li>从后面第<code>p</code>位，将原数组断成为*[9, 8, 7, 6, 5, 4, 3]*, [2, 1, 0]</li><li>再将新的两个数组原地旋转*[3, 4, 5, 6, 7, 8, 9]*, <em>[0, 1, 2]</em></li><li>合并成为目标数组 <em>[3, 4, 5, 6, 7, 8, 9, 0, 1, 2]</em></li></ol><h4 id="4-代码实现：-3"><a href="#4-代码实现：-3" class="headerlink" title="4. 代码实现："></a>4. 代码实现：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">(<span class="type">int</span> *pre,<span class="type">int</span> left ,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将数组R中的数据原地逆置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i等于左边界left,j等于右边界right;</span></span><br><span class="line">    <span class="type">int</span> i = left,j = right;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换pre[i] 和 pre[j] 的值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        temp = pre[i];</span><br><span class="line">        pre[i] = pre[j];</span><br><span class="line">        pre[j] = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//i右移,j左移</span></span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LeftShift</span><span class="params">(<span class="type">int</span> *pre,<span class="type">int</span> n,<span class="type">int</span> p)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将长度为n的数组pre 中的数据循环左移p个位置</span></span><br><span class="line">    <span class="keyword">if</span> (p&gt;<span class="number">0</span> &amp;&amp; p&lt;n) &#123;</span><br><span class="line">        <span class="comment">//1. 将数组中所有元素全部逆置</span></span><br><span class="line">        Reverse(pre, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//2. 将前n-p个数据逆置</span></span><br><span class="line">        Reverse(pre, <span class="number">0</span>, n-p<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//3. 将后p个数据逆置</span></span><br><span class="line">        Reverse(pre, n-p, n<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-流程图解-4"><a href="#5-流程图解-4" class="headerlink" title="5. 流程图解"></a>5. 流程图解</h4><h3 id="Q6-链表查主元素"><a href="#Q6-链表查主元素" class="headerlink" title="Q6 链表查主元素"></a>Q6 链表查主元素</h3><h4 id="1-题目：-5"><a href="#1-题目：-5" class="headerlink" title="1. 题目："></a>1. 题目：</h4><p>已知一个整数序列A &#x3D; (a0,a1,a2,…an-1)，其中(0&lt;&#x3D; ai &lt;&#x3D;n),(0&lt;&#x3D; i&lt;&#x3D;n)。</p><p>若存在ap1&#x3D; ap2 &#x3D; …&#x3D; apm &#x3D; x，且m&gt;n&#x2F;2(0&lt;&#x3D;pk&lt;n,1&lt;&#x3D;k&lt;&#x3D;m)，则称x 为 A的主元素。</p><p>例如,A &#x3D; (0,5,5,3,5,7,5,5)，则5是主元素；若B &#x3D; (0,5,5,3,5,1,5,7)，则A 中没有主元素，假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法,找出数组元素中的主元素，若存在主元素则输出该元素，否则输出-1.</p><h4 id="2-分析：-5"><a href="#2-分析：-5" class="headerlink" title="2. 分析："></a>2. 分析：</h4><ul><li>递增数组</li><li>数组中可能有多次出现的元素</li><li>出现次数超过一半 &gt; <code>n/2</code> ，即为目标元素</li></ul><h4 id="3-算法思路：-4"><a href="#3-算法思路：-4" class="headerlink" title="3. 算法思路："></a>3. 算法思路：</h4><ol><li>假定一个<strong>候选主元素</strong> <code>key</code> </li><li>依次遍历循环数组，将<code>key</code> 与数组元素对比，记录其与其他元素相同的次数，记作<code>count</code>，<code>count</code> 初始值为<code>1</code></li><li>如果遇到相同元素，<code>count++</code> ，否则 <code>count++</code></li><li>循环中，如遇到<code>count</code> 为0，即重复次数达不到一半，将遇到的下一个元素设定为<code>key</code>, <code>count</code> 置<code>1</code>， 重新循环</li><li>再次循环数组，计算数组中元素与<code>key</code> 重合次数，如大于 <code>n/2</code>， 即为主元素，否则无主元素。</li></ol><h4 id="4-代码实现：-4"><a href="#4-代码实现：-4" class="headerlink" title="4. 代码实现："></a>4. 代码实现：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">MainElement</span><span class="params">(<span class="type">int</span> *A, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//目标: 求整数序列A中的主元素;</span></span><br><span class="line">    <span class="comment">//count 用来计数</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//key 用来保存候选主元素, 初始A[0]</span></span><br><span class="line">    <span class="type">int</span> key = A[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(1) 扫描数组,选取候选主元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//(2) 如果A[i]元素值 == key ,则候选主元素计数加1;</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] == key) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//(3) 当前元素A[i] 非候选主元素,计数减1;</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                count--;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//(4) 如果count 等于0,则更换候选主元素,重新计数</span></span><br><span class="line">                key = A[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果count &gt;0</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//(5)统计候选主元素的实际出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = count = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (A[i] == key) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(6)判断count&gt;n/2, 确认key是不是主元素</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; n/<span class="number">2</span>) <span class="keyword">return</span> key;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不存在主元素</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Q7-链表的元素删除"><a href="#Q7-链表的元素删除" class="headerlink" title="Q7 链表的元素删除"></a>Q7 链表的元素删除</h3><h4 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h4><p>用单链表保存m个整数, 结点的结构为*(data,link)<em>,且</em>|data|&lt;&#x3D;n*(n为正整数)。</p><p>现在要去设计一个时间复杂度尽可能高效的算法。对于链表中的data 绝对值相等的结点, 仅保留第一次出现的结点,而删除其余绝对值相等的结点。例如,链表A &#x3D; <em>{21,-15,15,-7,15}</em>, 删除后的链表 A &#x3D; <em>{21,-15,-7}</em>;</p><h4 id="2-分析：-6"><a href="#2-分析：-6" class="headerlink" title="2. 分析："></a>2. 分析：</h4><ul><li>时间复杂度高效</li><li>可用空间换时间——即开辟更多空间</li><li>循环原链表，若元素已经出现过，保存第一个，删除其他绝对值相等的元素</li></ul><h4 id="3-算法思路：-5"><a href="#3-算法思路：-5" class="headerlink" title="3. 算法思路："></a>3. 算法思路：</h4><ol><li>可额外开辟大小为 <code>n + 1</code> 的辅助数组，初始值为 0</li><li>从首元结点开始遍历链表，检查元素值，用<code>t[|data|]</code> 计算链表元素出现的次数：<ol><li>若元素<code>[｜data｜]</code> 为0，即首次出现，保留结点，使得 t[|data|] &#x3D; 1</li><li>若 <code>[|data|]</code> 不为 0， 则将该结点从链表中删除。</li></ol></li></ol><h4 id="x"><a href="#x" class="headerlink" title="x"></a>x</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DeleteEqualNode</span><span class="params">(LinkList *L,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//目标: 删除单链表中绝对值相等的结点;</span></span><br><span class="line">    <span class="comment">//1. 开辟辅助数组p.</span></span><br><span class="line">    <span class="type">int</span> *p = alloca(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">    LinkList r = *L;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//2.数组元素初始值置空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        *(p+i) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.指针temp 指向首元结点</span></span><br><span class="line">    LinkList temp = (*L)-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.遍历链表,直到temp = NULL;</span></span><br><span class="line">    <span class="keyword">while</span> (temp!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.如果该绝对值已经在结点上出现过,则删除该结点</span></span><br><span class="line">        <span class="keyword">if</span> (p[<span class="built_in">abs</span>(temp-&gt;data)] == <span class="number">1</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//临时指针指向temp-&gt;next</span></span><br><span class="line">            r-&gt;next = temp-&gt;next;</span><br><span class="line">            <span class="comment">//删除temp指向的结点</span></span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">            <span class="comment">//temp 指向删除结点下一个结点</span></span><br><span class="line">            temp = r-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//6. 未出现过的结点,则将数组中对应位置置为1;</span></span><br><span class="line">            p[<span class="built_in">abs</span>(temp-&gt;data)] = <span class="number">1</span>;</span><br><span class="line">            r = temp;</span><br><span class="line">            <span class="comment">//继续向后遍历结点</span></span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-复杂度"><a href="#5-复杂度" class="headerlink" title="5. 复杂度"></a>5. 复杂度</h4><ul><li>时间复杂度: O(m), 对长度为m的链表进行一趟遍历,则算法时间复杂度为O(m);</li><li>空间复杂度: O(n)</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 线性表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【底层探索】- 多线程(一)</title>
      <link href="/p/e318a7b3.html"/>
      <url>/p/e318a7b3.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、线程定义"><a href="#一、线程定义" class="headerlink" title="一、线程定义"></a>一、线程定义</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><blockquote><p><strong>线程（Thread）</strong>，有时被称为<strong>轻量级进程（Lightweight Progress, LWP）</strong>，是程序执行流的最小单位。</p></blockquote><p>一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级等资源（如打开文件和信号）。一个经典的线程与进程关系如图所示。</p><p><img src="/p/e318a7b3/001.png" alt="进程内的线程"></p><p>归纳一下总结一下。</p><ul><li>线程是进程的基本执行单元，一个进程的所有任务都在线程中执行</li><li>进程想要执行任务，必须得有线程，至少1条</li><li>程序启动时，会默认开启一条线程，这条线程称为主线程或UI 线程</li></ul><h3 id="1-2-线程的访问权限"><a href="#1-2-线程的访问权限" class="headerlink" title="1.2 线程的访问权限"></a>1.2 线程的访问权限</h3><p>线程实际上也拥有自己的私有存储空间，包括一下方面</p><ul><li>栈</li><li>线程局部存储（TLS，Thread Local Storage）。线程局部存储是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。</li><li>寄存器。寄存器是执行流的基本数据，因此为线程私有。</li></ul><p>从C 程序角度看，数据在线程之间是否私有如下所示：</p><p><img src="/p/e318a7b3/002.png"></p><h2 id="二、进程的定义"><a href="#二、进程的定义" class="headerlink" title="二、进程的定义"></a>二、进程的定义</h2><p>进程时指在系统中正在进行的一个应用程序。每个进程之间时独立的内存空间和地址</p><h3 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h3><p>每个iOS App 有几个进程，为何这样设计？</p><p>iPhone 从早起1G 开始就显得比安卓系统更流畅，是因为它采用了<strong>单一进程</strong> 的策略。</p><p>这样避免了进程的来回切换，CPU 消耗大大降低；另外在数据安全性上，才用单一沙盒机制，隔离文件，保证App 的独立性，提高安全系数。</p><h2 id="三、线程与进程关系"><a href="#三、线程与进程关系" class="headerlink" title="三、线程与进程关系"></a>三、线程与进程关系</h2><p>他们的关系主要从以下几个方面考虑</p><ul><li>地址空间：<ul><li><strong>线程：</strong> 同一地址的线程共享本进程的地址空间</li><li><strong>进程：</strong>进程之间是独立的地址空间</li></ul></li><li>资源拥有<ul><li><strong>线程：</strong>同一进程哪都线程共享本进程的资源，如内存空间、I&#x2F;O、CPU 等</li><li><strong>进程：</strong>进程之间的资源上独立的</li></ul></li><li>健壮性——多进程比多线程健壮<ul><li><strong>线程：</strong>进程内任意线程崩溃，会导致整个进程瘫痪。</li><li><strong>进程：</strong>进程崩扩后，在保护模式下不会对其他进程发生影响。</li></ul></li><li>资源消耗<ul><li><strong>线程：</strong>进程切换时，消耗的资源大，效率高</li><li><strong>进程：</strong>线程无法切换，只能互相通信，消耗的资源较小</li></ul></li><li>执行过程<ul><li><strong>线程：</strong>不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</li><li><strong>进程：</strong>每个独立的进程都有一个程序运行的入口、顺序执行序列和程序入口。</li></ul></li><li>基本属性。<ul><li><strong>线程：</strong>是处理器调度的基本单位。</li><li><strong>进程：</strong>并不是。</li></ul></li></ul><h2 id="四、多线程"><a href="#四、多线程" class="headerlink" title="四、多线程"></a>四、多线程</h2><h3 id="4-1-多线程的原理"><a href="#4-1-多线程的原理" class="headerlink" title="4.1 多线程的原理"></a>4.1 多线程的原理</h3><blockquote><p>CPU 在单位时间片里快速在各个线程之间切换</p></blockquote><p>不论是在多处理器的计算机上还是在单处理器的计算机上，线程总是”并发”执行的。当线程数量小于等于处理器数量时（并且操作系统支持多处理器），线程的并发是真正的并发，不同的线程运行在不同的处理器上，彼此之间互不相干。但对于线程数量大于处理器数量的情况，线程的并发会收到一些阻碍，因为此时至少有一个处理器会运行多个线程。</p><p>在单处理器对应多线程的情况下，并发是一种模拟出来的状态。操作系统会让这些多线程程序轮流执行，每次进执行一小段时间（通常是几十到几百毫秒），这样每个线程就”看起来“在同事执行。</p><p>处于运行中线程拥有一段可以执行的时间，这段时间称为<strong>时间片（Time Slice）</strong>。当时间片用尽，该进程将进入就绪状态。</p><h3 id="4-2-多线程的好处"><a href="#4-2-多线程的好处" class="headerlink" title="4.2 多线程的好处"></a>4.2 多线程的好处</h3><ul><li>多线程能改进应用的响应机制</li><li>多线程能改进多核系统下的应用的实时表现</li></ul><h3 id="4-3-线程的生命周期"><a href="#4-3-线程的生命周期" class="headerlink" title="4.3 线程的生命周期"></a>4.3 线程的生命周期</h3><p>多线程的生命周期，一般有以下几个</p><ul><li>新建</li><li><strong>运行 Running</strong>。此时线程正在执行</li><li><strong>就绪 Ready</strong>。此时线程可以立即运行，但是CPU 已经被占用</li><li><strong>堵塞 BLocked</strong>。此时CPU 正在执行sleep 方法&#x2F;锁等占用动作，此时其他线程无法执行。</li><li>死亡。任务完成，或者强制退出线程</li></ul><p><img src="/p/e318a7b3/003.png"> </p><h3 id="4-4-线程池的原理"><a href="#4-4-线程池的原理" class="headerlink" title="4.4 线程池的原理"></a>4.4 线程池的原理</h3><h4 id="4-4-1-执行流程"><a href="#4-4-1-执行流程" class="headerlink" title="4.4.1 执行流程"></a>4.4.1 执行流程</h4><ol><li>判断线程池大小是否小于核心线程池等大小<ol><li>如果否，继续判断工作队列是否已满<ol><li>如果否，提交任务到工作队列</li><li>创建线程去执行任务</li></ol></li><li>如归是，线程队列已满，判断线程池是否都已在工作<ol><li>如果是，交给饱和策略</li><li>如果否，创建线程去执行任务</li></ol></li></ol></li><li>如果小与，此时可以直接创建线程去执行任务</li></ol><p><img src="/p/e318a7b3/004.png"></p><h4 id="4-4-2-策略"><a href="#4-4-2-策略" class="headerlink" title="4.4.2 策略"></a>4.4.2 策略</h4><p>这里需要找一下 Oracle <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html">关于线程池执行器</a>的一些解释</p><table><thead><tr><th>类型</th><th>策略名</th></tr></thead><tbody><tr><td>static class</td><td><strong><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html"> ThreadPoolExecutor.AbortPolicy</a></strong><br>抛出RejectedExecutionException 的异常，并阻止系统运行</td></tr><tr><td>static class</td><td><strong><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html">ThreadPoolExecutor.CallerRunsPolicy</a></strong><br>拒绝任务，并在执行方法的调用线程里运行该拒绝任务，除非执行者被关闭，此时任务也会被弃用。</td></tr><tr><td>static class</td><td><strong><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html">ThreadPoolExecutor.DiscardOldestPolicy</a></strong><br>放弃执行最早的未完成请求，并尝试执行任务</td></tr><tr><td>static class</td><td><strong><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html">ThreadPoolExecutor.DiscardPolicy</a></strong><br>任务被拒绝添加时，线程池丢弃被拒绝的任务</td></tr></tbody></table><h3 id="4-5-线程和runloop-的关系"><a href="#4-5-线程和runloop-的关系" class="headerlink" title="4.5 线程和runloop 的关系"></a>4.5 线程和runloop 的关系</h3><p>概念上，主要有以下几个</p><ol><li>runloop 与线程是一一对应的，一个runloop 对应一个核心进程（因为runloop 是可以嵌套的，但是核心的只有一个），他们的关系保存在一个全局的字典里。</li><li>runloop 是来管理线程的，当线程的runloop 被开启后，线程会在执行完任务后进入休眠状态，有了任务就会被唤醒去执行任务。</li><li>runloop 在第一次获取时被创建，在线程时被销毁</li><li>对于主线程来说，runloop 在程序一启动就默认创建好了</li><li>对于子线程来说，runloop 是懒加载的，只有当我们使用的时候才会创建。所以在子线程用定时器要注意：确保子线程的runloop 被创建，不然定时器不会回调。</li></ol><h3 id="4-6-iOS-中的多线程"><a href="#4-6-iOS-中的多线程" class="headerlink" title="4.6 iOS 中的多线程"></a>4.6 iOS 中的多线程</h3><p>iOS 中一般有以下多线程</p><ul><li><p>GCD</p><p>就是我们最常使用的Grand Central Dispatch。底层由C 语言写成，由苹果公司开发的一种用于多核处理器的应用优化技术，初始使用在Mac OS X 10.6 以及移动端的iOS 4 上。GCD 的名字起源于位于美国纽约曼哈顿中城的<a href="https://baike.baidu.com/item/%E5%A4%A7%E4%B8%AD%E5%A4%AE%E8%BD%A6%E7%AB%99/5354562?fr=aladdin">大中央总站</a>。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (IBAction)analyzeDocument:(NSButton *)sender &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        NSDictionary *stats = [myDoc analyze];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">            [myModel setDict:stats];</span><br><span class="line">            [myStatsView setNeedsDisplay:YES];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>NSThread</p><p>是苹果公司基于GCD 包装的一种面向对象的管理线程的方式，可以由程序员自行创建线程及退出。</p></li><li><p>pThread</p><p>即<strong>POSIX线程</strong>。POSIX 线程提供了一个基于C 语言的接口来创建线程。如果你不是在写Cocoa 应用，这恐怕是最理想的创建线程的选择。POSIX 接口相当简单也足够灵活的配置你的线程。</p></li><li><p>NSOperation</p></li></ul><h2 id="五、线程间的通讯"><a href="#五、线程间的通讯" class="headerlink" title="五、线程间的通讯"></a>五、线程间的通讯</h2><p>这个也是面试题经常会问到的，无论是中级还是高级的面试题。</p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW2">苹果官方</a> 线程相关的文档是这样介绍的，线程间的通讯如下：</p><p><img src="/p/e318a7b3/005.png"></p><p>一共有7种方式:</p><ul><li><p><strong>直接传递消息</strong>：可以从一个线程往任意一个线程发送消息。这种能力意味着一个线程能从根本上在任意一个其他的线程执行某方法。因为他们被执行在目标线程的环境下，在该线程下消息被自动连续的发送。</p><p>比较常见的就是<code>performSelector</code></p></li><li><p><strong>全局变量：</strong>共享内存及共享对象，尽管共享变量快捷而渐变，但相比<strong>直接传递消息</strong>他们也更加不稳定。使用共享变量得用所活着其他同步机制格外小心的保护，以确保代码的准确性。一旦使用不当容易引起<strong>竞态条件</strong>、数据改变或者<strong>崩溃</strong>。</p></li><li><p><strong>Conditions</strong>：当一个线程执行了特定的部分代码，同步工具可以用来控制。你可以想象<code>conditions</code> 当作门卫，只有当状态条件满足的情况下，线程才允许执行。</p></li><li><p><strong>Runloop 资源</strong>：自定义runloop 资源用来在线程里接受应用特定的信息。因为他们是事件驱动，runloop 资源会在无任务时将你的线程休眠，改进线程的效率。</p></li><li><p><strong>端口与套接字：</strong>基于端口的通讯是一种在两个线程通讯更精密的方式，也是一种可靠的技术。更重要的是，端口和套接字能用来与外部实体进行通讯，例如其他进程和服务。为了效率期间，端口通过使用runloop 资源来实现，因此等待端口无事可做时，线程也会被休眠。</p></li><li><p><strong>消息队列：</strong>经典的多处理器服务为来管理进出的数据，制定了一个先进先出队列（FIFO）概念。尽管消息队列简单而方便，他们也不像其他通讯技术那样高效。</p></li><li><p><strong>对象分发：</strong>对象分发是一种Cocoa 技术，提供了基于端口高级实现。尽管在线程内使用这门技术也能用，但鉴于使用它会带来的性能开支，高度不建议使用。分发对象更适合于进程间的通信，尤其是当进程消耗已经很高的情况下（虱子多了不咬，债多了不愁）。</p></li></ul><h2 id="六、线程的关闭"><a href="#六、线程的关闭" class="headerlink" title="六、线程的关闭"></a>六、线程的关闭</h2><p>建议在创建线程的时候，就设计好响应取消和退出线程的消息。对于长任务来说，这可能意味着周期性的停止工作而查看是否有消息到达。如果确实有消息进来——要求线程退出，线程可能接下来可以实现一些必须的清理工作，然后优雅的退出；否则继续工作。</p><p>响应取消消息的方法是使用Runloop，看看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)threadMainRoutine</span><br><span class="line">&#123;</span><br><span class="line">    BOOL moreWorkToDo = YES;</span><br><span class="line">    BOOL exitNow = NO;</span><br><span class="line">    NSRunLoop* runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Add the exitNow BOOL to the thread dictionary.</span></span><br><span class="line">    NSMutableDictionary* threadDict = [[NSThread currentThread] threadDictionary];</span><br><span class="line">    [threadDict setValue:[NSNumber numberWithBool:exitNow] forKey:@<span class="string">&quot;ThreadShouldExitNow&quot;</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Install an input source.</span></span><br><span class="line">    [self myInstallCustomInputSource];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (moreWorkToDo &amp;&amp; !exitNow)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Do one chunk of a larger body of work here.</span></span><br><span class="line">        <span class="comment">// Change the value of the moreWorkToDo Boolean when done.</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Run the run loop but timeout immediately if the input source isn&#x27;t waiting to fire.</span></span><br><span class="line">        [runLoop runUntilDate:[NSDate date]];</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Check to see if an input source handler changed the exitNow value.</span></span><br><span class="line">        exitNow = [[threadDict valueForKey:@<span class="string">&quot;ThreadShouldExitNow&quot;</span>] boolValue];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【底层探索】- 多线程(二)GCD应用</title>
      <link href="/p/bd5c42bb.html"/>
      <url>/p/bd5c42bb.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、面试题解析"><a href="#一、面试题解析" class="headerlink" title="一、面试题解析"></a>一、面试题解析</h2><h3 id="1-1-第一题"><a href="#1-1-第一题" class="headerlink" title="1.1 第一题"></a>1.1 第一题</h3><h4 id="A、提问："><a href="#A、提问：" class="headerlink" title="A、提问："></a>A、提问：</h4><p>以下代码，会打印什么？</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span> queue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;lj&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;<span class="comment">//block1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;<span class="comment">//block2</span></span><br><span class="line">        <span class="built_in">NSLog</span>(@<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;5&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="B、思路："><a href="#B、思路：" class="headerlink" title="B、思路："></a>B、思路：</h4><ol><li>创建的事串行队列，所以队列依次进行</li><li>先执行 <code>NSLog(@&quot;1&quot;);</code>，<strong>打印1</strong></li><li>接下来的异步函数<code>dispatch_async(queue, ^&#123;//block1&#125;);</code> 需要耗时，所以先跳过</li><li>执行 <code>NSLog(@&quot;5&quot;);</code>，<strong>打印5</strong></li><li>回头来执行第3步<strong>异步函数</strong>内部的代码。<ol><li>先执行<code>NSLog(@&quot;2&quot;);</code>， <strong>打印2</strong></li><li>接下来执行<strong>同步函数</strong> <code>dispatch_sync(queue, ^&#123;xxx&#125;);</code>， 此时<strong>阻塞</strong>线程。</li><li>后面的<code>NSLog(@&quot;4&quot;);</code> 需等待上一步同步函数执行完才能执行，无法执行打印。</li><li>异步函数内部<code>NSLog(@&quot;3&quot;);</code> 新创建，但是属于好事操作，需等待外部流程——即<code>NSLog(@&quot;4&quot;);</code> 这一代码执行完。</li><li>上面两部互为等待，形成死锁。无法执行，会导致崩溃。</li></ol></li></ol><p>原理图可以这样看待：</p><p><img src="/p/bd5c42bb/002.png"></p><h4 id="C、回答："><a href="#C、回答：" class="headerlink" title="C、回答："></a>C、回答：</h4><p><strong>打印1,5,2。以及崩溃</strong></p><h4 id="D、验证："><a href="#D、验证：" class="headerlink" title="D、验证："></a>D、验证：</h4><p><img src="/p/bd5c42bb/001.png"></p><h3 id="1-2-第二题（美团）"><a href="#1-2-第二题（美团）" class="headerlink" title="1.2 第二题（美团）"></a>1.2 第二题（美团）</h3><h4 id="A、提问：-1"><a href="#A、提问：-1" class="headerlink" title="A、提问："></a>A、提问：</h4><p>以下代码，会打印什么</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__block <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;a = %d \n&quot;</span>, a);</span><br></pre></td></tr></table></figure><h4 id="B、思路：-1"><a href="#B、思路：-1" class="headerlink" title="B、思路："></a>B、思路：</h4><ol><li>首先执行的是异步函数，决定了每个任务都是<strong>独立</strong>、无<strong>线程阻塞</strong>、<del>放飞自我的</del></li><li>执行在全局并发队列里，即各自分别执行，会频繁读取<code>a++</code>，线程并不安全</li><li>上面第1、第2步决定了，当a自增到10时，跳出while 循环，但是打印的时候，很可能某1个或者多个任务还在异步执行，此时有两种情况<ol><li>打印前a++ ：此时很能有1个或多个任务在抢占资源，进行<code>a++</code>， 那么多次打印后<strong>打印 大于10</strong></li><li>打印后a++ ：即此时打印函数这个任务，成功抢占资源，先打印成功 则<strong>打印了10</strong></li></ol></li></ol><p>流程请参考图</p><p><img src="/p/bd5c42bb/004.png"></p><h4 id="C、回答：-1"><a href="#C、回答：-1" class="headerlink" title="C、回答："></a>C、回答：</h4><p>打印结果 &gt;&#x3D; 10</p><h4 id="D、验证"><a href="#D、验证" class="headerlink" title="D、验证"></a>D、验证</h4><p><img src="/p/bd5c42bb/003.png"></p><h2 id="二、GCD-简介"><a href="#二、GCD-简介" class="headerlink" title="二、GCD 简介"></a>二、GCD 简介</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><blockquote><p>GCD 全称是Grand Central Dispatch，是苹果公司为多核的并行运算提出的解决方案，一种纯C 语言写成的框架，提供了非常多强大的函数</p></blockquote><h3 id="2-2-GCD-的优点"><a href="#2-2-GCD-的优点" class="headerlink" title="2.2 GCD 的优点"></a>2.2 GCD 的优点</h3><p>主要有以下几点</p><ul><li>GCD 会自动利用更多的CPU 内核（双核、四核等）</li><li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。程序员只需要告诉GCD 执行的任务，不需要编写任何线程管理代码。</li></ul><h3 id="2-3-GCD-的函数"><a href="#2-3-GCD-的函数" class="headerlink" title="2.3 GCD 的函数"></a>2.3 GCD 的函数</h3><p>GCD 的函数使用过程为：将任务添加到队列，并且制定执行任务的函数</p><ul><li>任务使用 <code>block</code> 封装</li><li>任务的<code>block</code> 没有参数也没有返回值</li><li>函数的类型有异步函数和同步函数</li></ul><h4 id="2-3-1-异步函数-dispatch-async"><a href="#2-3-1-异步函数-dispatch-async" class="headerlink" title="2.3.1 异步函数 dispatch_async"></a>2.3.1 异步函数 dispatch_async</h4><ul><li>不用等当前语句执行完毕，就可以执行下一条语句</li><li>会开启线程执行 block 的任务</li><li>异步是多线程的代名词</li></ul><h4 id="2-3-2-同步函数-dispatch-sync"><a href="#2-3-2-同步函数-dispatch-sync" class="headerlink" title="2.3.2 同步函数 dispatch_sync"></a>2.3.2 同步函数 dispatch_sync</h4><ul><li>必须等待当前语句执行完毕，才会执行下一条语句（俗称<strong>阻塞线程</strong>）</li><li>不会开启线程</li><li>在当前执行block 的任务</li></ul><h3 id="2-4-队列"><a href="#2-4-队列" class="headerlink" title="2.4. 队列"></a>2.4. 队列</h3><p>队列通常有并行队列和串行队列，顾名思义，并行队列队列宽度足够，互不干扰，各自为政；串行队列宽度只有1，每次只能执行同一个任务。</p><ul><li><p>串行队列（Seiral Dispatch Queue）:</p><p>每次只有一个任务被执行，任务一个接一个地执行。（只开启1个线程，一个任务执行完毕后，在执行下一个任务）</p></li><li><p>并发队列（Concurrent Dispatch Queue）：</p><p>可以多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）。</p></li></ul><p><strong>注意：</strong>并发队列的并发功能只有在<strong>异步函数（async）</strong>下有效。</p><p>如下图所示</p><p><img src="/p/bd5c42bb/006.png"></p><p>队列的概念主要两个重要的队列：</p><h4 id="2-4-1-主队列"><a href="#2-4-1-主队列" class="headerlink" title="2.4.1 主队列"></a>2.4.1 主队列</h4><ul><li>主队列专门用来在主线程上调度任务的队列，并不会开启线程</li><li>才用先进先出（FIFO）原则，主线程空闲时才会呆㷣度队列中的任务在主线程中执行</li><li>如果当前主线程正在有任务执行，那么无论主队列中当前被添加了什么任务，都<strong>不会被调度</strong>。</li></ul><p>主队列的获取代码为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span> queue = <span class="built_in">dispatch_get_main_queue</span>();</span><br></pre></td></tr></table></figure><p>平时开发中的 UI 操作，都必须在主线程的主队列中进行。</p><h4 id="2-4-2-全局队列"><a href="#2-4-2-全局队列" class="headerlink" title="2.4.2 全局队列"></a>2.4.2 全局队列</h4><p>为了方便程序员自行使用其他队列，苹果提供了全局队列：<code>dispatch_get_global_queue(0, 0)</code>，</p><p>而且<strong>全局队列是一个并发队列</strong>。</p><p>在使用多线程开发时，如果对队列没有特殊需求，在执行异步任务时，可以直接使用全局队列。</p><h3 id="2-5-函数与队列"><a href="#2-5-函数与队列" class="headerlink" title="2.5 函数与队列"></a>2.5 函数与队列</h3><p>函数（同步、异步）和队列（串行、并发）的组合一共有4种，主要有以下特点：</p><ul><li>同步函数串行队列：<ul><li>不会开启线程，在当前线程执行任务</li><li>任务串行执行，one by one</li><li>会产生<strong>线程阻塞</strong></li></ul></li><li>同步函数并发队列<ul><li>不会开启线程，在当前线程执行任务</li><li>任务一个接一个，<strong>无阻塞</strong></li></ul></li><li>异步函数串行队列<ul><li>开启一条新线程</li><li>任务一个接一个</li></ul></li><li>异步函数并发队列<ul><li>开启<strong>多个</strong>线程，在当前新线程执行任务</li><li>任务异步执行，没有顺序，由CPU 调度</li></ul></li></ul><p><img src="/p/bd5c42bb/009.png"></p><h3 id="2-6-死锁"><a href="#2-6-死锁" class="headerlink" title="2.6 死锁"></a>2.6 死锁</h3><p>主线程因为同步函数强制执行当前任务的特性，会让后面的任务等待。</p><p>而主队列等待主线程的任务执行完毕，才能执行自己的任务，最后导致主队列和主线程相互等待，造成死锁</p><p>举例如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">dispatch_queue_t</span> q = <span class="built_in">dispatch_get_main_queue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;!!!!&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(q, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文中代码，主队列必须执行<code>dispatch_sync</code>了之后 才能继续执行后面的代码  但是主线程有任务在执行——正在执行<code>test</code></p><p>解决方案：将任务同步添加到主队列当中：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">dispatch_queue_t</span> q = <span class="built_in">dispatch_get_main_queue</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(q, ^&#123;</span><br><span class="line">                   <span class="built_in">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,[NSThread currentThread]);</span><br><span class="line">               &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、GCD-栅栏函数"><a href="#三、GCD-栅栏函数" class="headerlink" title="三、GCD 栅栏函数"></a>三、GCD 栅栏函数</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><p>栅栏函数的作用，是控制任务执行的顺序，它是一种同步函数。</p><h3 id="3-2-使用"><a href="#3-2-使用" class="headerlink" title="3.2 使用"></a>3.2 使用</h3><p>一般有同步和异步两种</p><ul><li>异步： <code>dispatch_barrier_async</code> 代码以前的任务执行完，才会执行以后的任务</li><li>同步：<code>dispatch_barrier_sync</code> 作用相同，但是执行这个会阻塞线程，影响后面的任务执行。</li></ul><p>可见，同步的栅栏函数，也是另一种<strong>加锁</strong>的方式</p><h3 id="3-3-举例"><a href="#3-3-举例" class="headerlink" title="3.3 举例"></a>3.3 举例</h3><ul><li><p>同步栅栏函数</p><p><img src="/p/bd5c42bb/007.png"></p></li><li><p>异步栅栏函数</p><p><img src="/p/bd5c42bb/008.png"></p></li></ul><h3 id="3-4-注意点"><a href="#3-4-注意点" class="headerlink" title="3.4 注意点"></a>3.4 注意点</h3><ul><li><p>栅栏函数主要作用是同步效果</p></li><li><p>提高代码的安全性能，线程安全</p></li><li><p>基本原理是阻塞队列</p></li><li><p>使用自定义的队列，不可使用全局的，否则进程都会阻塞</p></li><li><p>使用同一并发队列，即目标与栅栏函数在同一个队列里。</p><p>比如AFN ，他会自行实现了一个内部的队列，保证代码的内聚。</p></li></ul><h2 id="四、GCD-调度组"><a href="#四、GCD-调度组" class="headerlink" title="四、GCD 调度组"></a>四、GCD 调度组</h2><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>调度组的作用是：控制任务的执行顺序</p><h3 id="4-2-调度"><a href="#4-2-调度" class="headerlink" title="4.2 调度"></a>4.2 调度</h3><ol><li>创建组：<code>dispatch_group_create</code></li><li>进组任务： <code>dispatch_group_async</code>。规则为先进组、后出组<ol><li>进组：<code>dispatch_group_enter</code></li><li>出组：<code>dispatch_group_leave</code></li></ol></li><li>进组任务执行完毕通知：<code>dispatch_group_notify</code></li><li>进组任务执行等待时机：<code>dispatch_group_wait</code></li></ol><h3 id="4-3-使用"><a href="#4-3-使用" class="headerlink" title="4.3 使用"></a>4.3 使用</h3><p>在日常业务开发中，可以将多个异步进行的事件放入<code>group</code> 中( 进组)，待各自完成（出组）后，实现最终结果——是不是很熟悉，有时候多个token 进行拼接获取，最终得到可以使用的，这个流程就可以通过调度组实现。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test3&#123;</span><br><span class="line">    <span class="type">dispatch_group_t</span> group = <span class="built_in">dispatch_group_create</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">dispatch_queue_t</span> queue = <span class="built_in">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    __block <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    __block <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dispatch_group_async</span>(group, queue, ^&#123;</span><br><span class="line">        a += <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">dispatch_group_enter</span>(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_group_leave</span>(group);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_group_async</span>(group, queue, ^&#123;</span><br><span class="line">        b += <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">dispatch_group_enter</span>(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_group_leave</span>(group);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dispatch_group_notify</span>(group, queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(@<span class="string">&quot;当前a + b = %d&quot;</span>, a + b);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">02.479083</span>+<span class="number">0800</span> ttttt[<span class="number">12127</span>:<span class="number">739541</span>] 当前a + b = <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="五、信号量"><a href="#五、信号量" class="headerlink" title="五、信号量"></a>五、信号量</h2><p>如何准确的打印第一题的数值，达到10的结果呢？</p><p>可以使用信号量，可以有效的避免异步函数造成任务不可控。主要流程有如下几点</p><ul><li>创建信号量  </li><li>信号等待，即锁住线程。信号量–</li><li>执行业务，解锁开关，即业务不执行完，线程无法往后走。信号量++</li></ul><p>如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 1. 创建信号量</span></span><br><span class="line"><span class="type">dispatch_semaphore_t</span> sem = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  __block <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">          a++;</span><br><span class="line">          NSLog(@<span class="string">&quot;a = %d \n&quot;</span>, a);</span><br><span class="line">          <span class="comment">// 解锁线程</span></span><br><span class="line">          dispatch_semaphore_signal(sem);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 等待信号、锁住线程</span></span><br><span class="line">      dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>成功打印结果如下：</p><p><img src="/p/bd5c42bb/005.png"></p><h2 id="五、GCD-的Dispatch-source"><a href="#五、GCD-的Dispatch-source" class="headerlink" title="五、GCD 的Dispatch_source"></a>五、GCD 的Dispatch_source</h2><h3 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h3><blockquote><p>An object that coordinates the processing of specific low-level system events, such as file-system events, timers, and UNIX signals.</p><p>Gispatch source 是一种协调特定的低级别系统事件，如文件系统事件、Timer以及UNIX 信号。</p></blockquote><h3 id="5-2-特点"><a href="#5-2-特点" class="headerlink" title="5.2 特点"></a>5.2 特点</h3><ul><li><p>CPU 符合非常小，不占用资源</p></li><li><p>联合体，结构简洁，使用更高效</p></li></ul><h3 id="5-3-使用"><a href="#5-3-使用" class="headerlink" title="5.3 使用"></a>5.3 使用</h3><ol><li><p><strong>创建源</strong> : 创建一个dispatch source 来监测低级别的系统事件。具体实现为</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">dispatch_source_t</span> <span class="title function_">dispatch_source_create</span><span class="params">(<span class="type">dispatch_source_type_t</span> type, <span class="type">uintptr_t</span> handle, <span class="type">unsigned</span> <span class="type">long</span> mask, <span class="type">dispatch_queue_t</span> <span class="built_in">queue</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>type - dispatch source 的类型。举个例子，创建 定时器source，指定为  <a href="https://developer.apple.com/documentation/dispatch/dispatch_source_type_timer?language=objc"><code>DISPATCH_SOURCE_TYPE_TIMER</code></a></li><li>handle - 监控回调的句柄</li><li>mask - 决定哪些事件是需要的flags 的掩码。</li><li>queue - 事件回调block 需要提交的目标队列</li></ul></li><li><p>管理事件回调 </p><p>代码水岸为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dispatch_source_set_event_handler</span><span class="params">(<span class="type">dispatch_source_t</span> source, <span class="type">dispatch_block_t</span> handler)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取源 属性</p><p>合并数据到一个分发的源，并提交它的事件回调block 到自己的目标队列中。</p><p>代码实现为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dispatch_source_merge_data</span><span class="params">(<span class="type">dispatch_source_t</span> source, <span class="type">unsigned</span> <span class="type">long</span> value)</span>;</span><br></pre></td></tr></table></figure></li><li><p>取消源</p><p>使用方式为</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dispatch_source_cancel</span><span class="params">(<span class="type">dispatch_source_t</span> source)</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-4-应用"><a href="#5-4-应用" class="headerlink" title="5.4 应用"></a>5.4 应用</h3><h4 id="5-4-1-代码实现"><a href="#5-4-1-代码实现" class="headerlink" title="5.4.1 代码实现"></a>5.4.1 代码实现</h4><ol><li><p>创建队列</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">self.<span class="built_in">queue</span> = dispatch_queue_create(<span class="string">&quot;lj&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建源</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br></pre></td></tr></table></figure></li><li><p>配置事件回调</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dispatch_source_set_event_handler(self.source, ^&#123;</span><br><span class="line">    NSUInteger value = dispatch_source_get_data(self.source);</span><br><span class="line">    NSLog(@<span class="string">&quot;获取到       %lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>激活源</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dispatch_resume(self.source);</span><br></pre></td></tr></table></figure></li><li><p>提交时间回调到目标队列中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    self.value += <span class="number">1</span>;</span><br><span class="line">    dispatch_source_merge_data(self.source, self.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="5-4-2-运行查看"><a href="#5-4-2-运行查看" class="headerlink" title="5.4.2 运行查看"></a>5.4.2 运行查看</h4><p>由于是点击事件触发，所以依次增加，结果为:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2020-05-12 15:37:25.606845+0800 ttttt[12489:768578] 获取到       1</span><br><span class="line">2020-05-12 15:37:26.336439+0800 ttttt[12489:768578] 获取到       2</span><br><span class="line">2020-05-12 15:37:26.936856+0800 ttttt[12489:768578] 获取到       3</span><br><span class="line">2020-05-12 15:37:27.689042+0800 ttttt[12489:768578] 获取到       4</span><br><span class="line">2020-05-12 15:37:29.186446+0800 ttttt[12489:768578] 获取到       5</span><br><span class="line"></span><br><span class="line">**</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>在这一章节，主要复习了GCD 的各种应用，认识了队列与函数，以及各种加锁的方式（栅栏函数等），这里有个小小的练习：自定义的source 写的Timer，供参考。</p><p><a href="https://github.com/newjia/LJTimer">Github Demo地址</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【底层探索】- KVO（下）自定义KVO</title>
      <link href="/p/fe949d29.html"/>
      <url>/p/fe949d29.html</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>上文中，初步探索了KVO的使用以及背后的实现原理，这次来自己实现一个KVO，一方面在过程中加深理解，另一方面可以感受一下使用场景。</p><p>根据上文总结，KVO的实现一共有3部分：</p><ul><li>添加KVO监听方法</li><li>KVO 通知实现方法</li><li>KVO 移除方法</li></ul><p>下面一步一步来进行实现</p><h2 id="一、添加KVO监听"><a href="#一、添加KVO监听" class="headerlink" title="一、添加KVO监听"></a>一、添加KVO监听</h2><h3 id="1-0-创建自定义方法"><a href="#1-0-创建自定义方法" class="headerlink" title="1.0 创建自定义方法"></a>1.0 创建自定义方法</h3><p>仿照KVO 方法之前，先看一下原生的方法，从中做一下借鉴：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable <span class="type">void</span> *)context;</span><br></pre></td></tr></table></figure><p>可见一共有4个重要参数</p><ul><li>观察者 - observer - NSObject 类型</li><li>检测关键键 - keyPath - NSString 类型</li><li>选项 - options - NSKeyValueObservingOptions 类型</li><li>上下文 - 用来定位键值 -  (void*) 指针类型</li></ul><p>明白之后，写一个对NSObject 的分类，在分类里进行方法扩展，创建一个自定义的监听方法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="function">interface <span class="title">NSObject</span> <span class="params">(LJKVO)</span></span></span><br><span class="line"><span class="function">- <span class="params">(<span class="type">void</span>)</span>lj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(LJKeyValueObservingOptions)options context:(nullable void *)context;</span></span><br></pre></td></tr></table></figure><p>可见在<code>options</code> 做了自定义，可以简单的自定义一下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, LJKeyValueObservingOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LJKeyValueObservingOptionNew = <span class="number">0x01</span>,</span><br><span class="line">    LJKeyValueObservingOptionOld = <span class="number">0x02</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-1-验证传入setter-有效性"><a href="#1-1-验证传入setter-有效性" class="headerlink" title="1.1 验证传入setter 有效性"></a>1.1 验证传入setter 有效性</h3><p>第一件事就是判断当前对象的类里，是否有与这个<code>keyPath</code>匹配<code>setter</code> 方法，得过了这一关，才允许添加观察，否则会抛出异常。</p><p>判断步骤如下：</p><ol><li><p>拿到当前对象的类</p></li><li><p>获取<code>keyPath</code> 对应的<code>setter</code>方法编号。</p><p>这里有个细节的地方是，setter 方法是首字母大写，比如属性是<code>name</code>，它的setter 方法变成<code>setName</code>，所以需要对字符串做一下调整——添加<code>set</code>、首字母大写——这些在代码里可以看见。</p></li><li><p>去当前对象的父类——也就是类对象查找<code>keyPath</code> 对应的方法实现，</p></li><li><p>判断<code>setter</code>方法实现是否存在：</p><ol><li>如果实现，则通过；</li><li>找不到，即抛出异常</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)judgeSetterMethodFromKeyPath:(NSString *)keyPath&#123;</span><br><span class="line">    <span class="comment">/*Step 1*/</span></span><br><span class="line">    Class superClass    = <span class="built_in">object_getClass</span>(self);</span><br><span class="line">    <span class="comment">/*Step 2*/</span></span><br><span class="line">    SEL setterSeletor   = <span class="built_in">NSSelectorFromString</span>(<span class="built_in">setterForGetter</span>(keyPath));</span><br><span class="line">    <span class="comment">/*Step 3*/</span></span><br><span class="line">    Method setterMethod = <span class="built_in">class_getInstanceMethod</span>(superClass, setterSeletor);</span><br><span class="line">    <span class="comment">/*Step 4*/</span></span><br><span class="line">    <span class="keyword">if</span> (!setterMethod) &#123;</span><br><span class="line">        @<span class="keyword">throw</span> [NSException exceptionWithName:NSInvalidArgumentException reason:[NSString stringWithFormat:@<span class="string">&quot;没有当前%@的setter&quot;</span>,keyPath] userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对setter 方法进行字符串微调</span></span><br><span class="line"><span class="comment">   1、添加set字符</span></span><br><span class="line"><span class="comment">   2、首字母大写</span></span><br><span class="line"><span class="comment">   如name 属性，其setter方法为 setName</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> NSString *<span class="title">setterForGetter</span><span class="params">(NSString *getter)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (getter.length &lt;= <span class="number">0</span>) &#123; <span class="keyword">return</span> nil;&#125;</span><br><span class="line">    </span><br><span class="line">    NSString *firstString = [[getter substringToIndex:<span class="number">1</span>] uppercaseString];</span><br><span class="line">    NSString *leaveString = [getter substringFromIndex:<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [NSString stringWithFormat:@<span class="string">&quot;set%@%@:&quot;</span>,firstString,leaveString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-动态生成自定义子类"><a href="#1-2-动态生成自定义子类" class="headerlink" title="1.2 动态生成自定义子类"></a>1.2 动态生成自定义子类</h3><p>大家知道原生的类添加KVO之后，会动态生成<code>NSKVONotifying</code> 的类，这个类继承自原来的类，有<code>class</code> 以及对属性的setter 方法、dealloc 方法等等。但是对我们自己写的——新诞生的动态子类，目前是光溜溜的来，但是自定义的步骤里面，它几乎是啥也没有，类似孙悟空从石头缝里蹦出来的一样。那么在这里，我们的流程是这样的：</p><ul><li>动态生成类</li><li>注册类</li><li>给类添加<code>class</code> 方法，即指向原类的方法</li><li>给类添加<code>setter</code> 方法，基于<code>keyPath</code></li></ul><h4 id="1-2-1-拼接子类名"><a href="#1-2-1-拼接子类名" class="headerlink" title="1.2.1 拼接子类名"></a>1.2.1 拼接子类名</h4><p>还记得系统生成的动态子类，是以NSKVONotifying_ 作为前缀，我们也做一个类似的类如下</p><ul><li>获取当前对象的类：</li><li>将自定义的拼接到前面</li><li>根据字符串生成子类</li></ul><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NSString *oldClassName = <span class="built_in">NSStringFromClass</span>([self <span class="keyword">class</span>]);</span><br><span class="line">NSString *newClassName = [NSString stringWithFormat:@<span class="string">&quot;%@%@&quot;</span>,@<span class="string">&quot;LJKVONotifying_&quot;</span>,oldClassName];</span><br><span class="line">Class newClass = <span class="built_in">NSClassFromString</span>(newClassName);</span><br></pre></td></tr></table></figure><p>得到的类，原来的类为<code>Dog</code>， 新类将会是<code>LJKVONotifying_Dog</code></p><h4 id="1-2-2-判断是否存在动态子类"><a href="#1-2-2-判断是否存在动态子类" class="headerlink" title="1.2.2 判断是否存在动态子类"></a>1.2.2 判断是否存在动态子类</h4><p>也要先判断这个类是否已经存在，以防止重复添加。如果已经存在就退出</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防止重复创建生成新类</span></span><br><span class="line"><span class="keyword">if</span> (newClass) <span class="keyword">return</span> newClass;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-申请动态子类内存空间"><a href="#1-2-3-申请动态子类内存空间" class="headerlink" title="1.2.3 申请动态子类内存空间"></a>1.2.3 申请动态子类内存空间</h4><p>这个比较简单，使用的是<code>objc_allocateClassPair</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">newClass = <span class="built_in">objc_allocateClassPair</span>([self <span class="keyword">class</span>], newClassName.UTF8String, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="1-3-4-注册该动态子类"><a href="#1-3-4-注册该动态子类" class="headerlink" title="1.3.4 注册该动态子类"></a>1.3.4 注册该动态子类</h4><p>也就是讲这个新的 <code>NSKVONotifying_xx</code> 的类注册到（非元）类的散列表中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">objc_registerClassPair</span>(newClass);</span><br></pre></td></tr></table></figure><h4 id="1-3-5-添加class-方法。即给新的动态子类，添加class-方法"><a href="#1-3-5-添加class-方法。即给新的动态子类，添加class-方法" class="headerlink" title="1.3.5 添加class 方法。即给新的动态子类，添加class 方法"></a>1.3.5 添加class 方法。即给新的动态子类，添加<code>class</code> 方法</h4><p>首先是给这个类添加自定义的<code>lj_class</code> 方法，即使得该动态子类继承自原类。</p><p>这里涉及到给当前的动态子类的父类——即原来的类，建立联系</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Class <span class="title">lj_class</span><span class="params">(id self, SEL _cmd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">class_getSuperclass</span>(<span class="built_in">object_getClass</span>(self));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，接下来，将这个类方法，添加到子类的方法列表里:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SEL classSEL = <span class="built_in">NSSelectorFromString</span>(@<span class="string">&quot;class&quot;</span>);</span><br><span class="line">Method classMethod = <span class="built_in">class_getInstanceMethod</span>([self <span class="keyword">class</span>], classSEL);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *classTypes = <span class="built_in">method_getTypeEncoding</span>(classMethod);</span><br><span class="line"><span class="built_in">class_addMethod</span>(newClass, classSEL, (IMP)lj_class, classTypes);</span><br></pre></td></tr></table></figure><h4 id="1-3-6-添加自定义的setter-方法。"><a href="#1-3-6-添加自定义的setter-方法。" class="headerlink" title="1.3.6 添加自定义的setter 方法。"></a>1.3.6 添加自定义的<code>setter</code> 方法。</h4><p>由于KVO 主要观察的是 <code>setter</code> 方法，所以需要写一个自定义的 <code>setter</code> 方法。</p><p>setter 方法的核心是，当这个动态子类接收到消息后，转发给原来的类——也就是其父类，告知它，现在属性有变化了，具体的实现，是把改动的值<code>change</code> 通过消息发送（objc_msgSend） 发送过去。</p><p>好的，下面来完成这个<code>lj_setter</code> 方法</p><ol><li><p>从 <code>setter</code> 方法，获得完整的方法名<code>keyPath</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">lj_setter</span><span class="params">(id self, id newValue)</span></span>&#123;</span><br><span class="line">NSString *keyPath = <span class="built_in">getterForSetter</span>(<span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line"><span class="comment">/****/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> NSString *<span class="title">getterForSetter</span><span class="params">(NSString *setter)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (setter.length &lt;= <span class="number">0</span> || ![setter hasPrefix:@<span class="string">&quot;set&quot;</span>] || ![setter hasSuffix:@<span class="string">&quot;:&quot;</span>]) &#123; <span class="keyword">return</span> nil;&#125;</span><br><span class="line">    </span><br><span class="line">    NSRange range = <span class="built_in">NSMakeRange</span>(<span class="number">3</span>, setter.length<span class="number">-4</span>);</span><br><span class="line">    NSString *getter = [setter substringWithRange:range];</span><br><span class="line">    NSString *firstString = [[getter substringToIndex:<span class="number">1</span>] lowercaseString];</span><br><span class="line">    <span class="keyword">return</span>  [getter stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:firstString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>向父类发送新的值，此时需要自定义一个结构体，然后使用objc_msgSendSuper 发送</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">id oldValue       = [self valueForKey:keyPath];</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*lj_msgSendSuper)(<span class="type">void</span> *,SEL , id) = (<span class="type">void</span> *)objc_msgSendSuper;</span><br><span class="line"><span class="comment">// void /* struct objc_super *super, SEL op, ... */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_super</span> superStruct = &#123;</span><br><span class="line">    .receiver = self,</span><br><span class="line">    .super_class = <span class="built_in">class_getSuperclass</span>(<span class="built_in">object_getClass</span>(self)),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//objc_msgSendSuper(&amp;superStruct,_cmd,newValue)</span></span><br><span class="line"><span class="built_in">lj_msgSendSuper</span>(&amp;superStruct,_cmd,newValue);</span><br></pre></td></tr></table></figure></li><li><p>获取观察者。这里的观察者，为了避免全局冗余参数参数，提前使用<strong>关联对象</strong>与本类进行绑定，这一点在后面会介绍。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NSMutableArray *observerArr = <span class="built_in">objc_getAssociatedObject</span>(self, (__bridge <span class="type">const</span> <span class="type">void</span> * _Nonnull)(kLJKVOAssiociateKey));</span><br></pre></td></tr></table></figure></li><li><p>接下来，处理新的旧的值，将<code>newValue</code>的改变 该遍赋值给<code>change</code>，并发送给类，完成消息的发送</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (LJKVOInfo *info in observerArr) &#123;</span><br><span class="line">       <span class="keyword">if</span> ([info.keyPath isEqualToString:keyPath]) &#123;</span><br><span class="line">           <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">               NSMutableDictionary&lt;NSKeyValueChangeKey,id&gt; *change = [NSMutableDictionary dictionaryWithCapacity:<span class="number">1</span>];</span><br><span class="line">               <span class="comment">// 对新旧值进行处理</span></span><br><span class="line">               <span class="keyword">if</span> (info.options &amp; LJKeyValueObservingOptionNew) &#123;</span><br><span class="line">                   [change setObject:newValue forKey:NSKeyValueChangeNewKey];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (info.options &amp; LJKeyValueObservingOptionOld) &#123;</span><br><span class="line">                   [change setObject:@<span class="string">&quot;&quot;</span> forKey:NSKeyValueChangeOldKey];</span><br><span class="line">                   <span class="keyword">if</span> (oldValue) &#123;</span><br><span class="line">                       [change setObject:oldValue forKey:NSKeyValueChangeOldKey];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 2: 消息发送给观察者</span></span><br><span class="line">               SEL observerSEL = @<span class="built_in">selector</span>(lj_observeValueForKeyPath:ofObject:change:context:);</span><br><span class="line">               <span class="built_in">objc_msgSend</span>(info.observer,observerSEL,keyPath,self,change,<span class="literal">NULL</span>);</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到观察者使用了<code>LJKVOInfo</code>, 这里我对观察者，做了模型的处理，更方便接耦。</p><p>里面包含了众多参数如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface LJKVOInfo : NSObject</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, weak) NSObject  *observer;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, copy) NSString    *keyPath;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, assign) LJKeyValueObservingOptions options;</span><br></pre></td></tr></table></figure><p>注意⚠️，这里有个坑点，是关于<code>observer</code>！</p><p>由于原对象持有observer，observer 在添加关联对象时又持有self，self 又持有原对象，会导致循环引用——所以这里observer <strong>必须使用weak</strong> 弱引用，防止循环引用</p></li></ol><p>好了，现在的<code>setter</code> 方法的步骤已经完成，把它添加到动态子类里</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SEL setterSEL = <span class="built_in">NSSelectorFromString</span>(<span class="built_in">setterForGetter</span>(keyPath));</span><br><span class="line">Method setterMethod = <span class="built_in">class_getInstanceMethod</span>([self <span class="keyword">class</span>], setterSEL);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *setterTypes = <span class="built_in">method_getTypeEncoding</span>(setterMethod);</span><br><span class="line"><span class="built_in">class_addMethod</span>(newClass, setterSEL, (IMP)lj_setter, setterTypes);</span><br></pre></td></tr></table></figure><h3 id="1-3-isa-转向"><a href="#1-3-isa-转向" class="headerlink" title="1.3 isa 转向"></a>1.3 isa 转向</h3><p>还记得原生的对象添加了KVO后，会将<code>isa swizzling</code> ，将<code>isa</code> 偷偷指向新的动态子类，委托后者对键值的变化进行消息发送，我们现在就是要做这个。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object_setClass</span>(self, newClass);</span><br></pre></td></tr></table></figure><p>一行代码搞定……</p><h3 id="1-4-保存观察者信息"><a href="#1-4-保存观察者信息" class="headerlink" title="1.4 保存观察者信息"></a>1.4 保存观察者信息</h3><p>好了，动态子类也生成类，<code>isa</code> 也转向了，是不是大功告成了？不，还少了一步，把当前的监控者保存一下，不然以后无法找到他进行消息传递</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LJKVOInfo *info = [[LJKVOInfo alloc] initWitObserver:observer forKeyPath:keyPath options:options];</span><br><span class="line">NSMutableArray *observerArr = <span class="built_in">objc_getAssociatedObject</span>(self, (__bridge <span class="type">const</span> <span class="type">void</span> * _Nonnull)(kLJKVOAssiociateKey));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!observerArr) &#123;</span><br><span class="line">    observerArr = [NSMutableArray arrayWithCapacity:<span class="number">1</span>];</span><br><span class="line">    [observerArr addObject:info];</span><br><span class="line">    <span class="built_in">objc_setAssociatedObject</span>(self, (__bridge <span class="type">const</span> <span class="type">void</span> * _Nonnull)(kLJKVOAssiociateKey), observerArr, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、实现KVO监听方法"><a href="#二、实现KVO监听方法" class="headerlink" title="二、实现KVO监听方法"></a>二、实现KVO监听方法</h2><p>这部分是最简单的，由开发者根据业务实现内容； </p><p>还是打印一下我写的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)lj_observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable <span class="type">void</span> *)context&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;change      %@&quot;</span>, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、移除KVO-监听"><a href="#三、移除KVO-监听" class="headerlink" title="三、移除KVO 监听"></a>三、移除KVO 监听</h2><p>移除KVO 与添加KVO 的进程是相反的，主要工作有：从观察者群里移除指定<code>keyPath</code> 的观察者、isa 转向（指回原类）</p><h3 id="3-1-获取观察者群体"><a href="#3-1-获取观察者群体" class="headerlink" title="3.1 获取观察者群体"></a>3.1 获取观察者群体</h3><p>还是用关联对象获取</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NSMutableArray *observerArr = <span class="built_in">objc_getAssociatedObject</span>(self, (__bridge <span class="type">const</span> <span class="type">void</span> * _Nonnull)(kljKVOAssiociateKey));</span><br><span class="line"><span class="keyword">if</span> (observerArr.count&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-移除观察者"><a href="#3-1-移除观察者" class="headerlink" title="3.1 移除观察者"></a>3.1 移除观察者</h3><p>这里移除观察者，是根据<code>remove</code> 方法传入的keyPath 进行匹配，如果匹配一致，则进行移除</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (LJKVOInfo *info in observerArr) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([info.keyPath isEqualToString:keyPath]) &#123;</span><br><span class="line">        [observerArr removeObject:info];</span><br><span class="line">        <span class="built_in">objc_setAssociatedObject</span>(self, (__bridge <span class="type">const</span> <span class="type">void</span> * _Nonnull)(kLJKVOAssiociateKey), observerArr, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-isa-转向"><a href="#3-2-isa-转向" class="headerlink" title="3.2 isa 转向"></a>3.2 isa 转向</h3><p>通过<code>object_setClass</code> 将<code>isa</code> 指回去</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (observerArr.count&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 指回给父类</span></span><br><span class="line">    Class superClass = [self <span class="keyword">class</span>];</span><br><span class="line">    <span class="built_in">object_setClass</span>(self, superClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、改进——函数式编程"><a href="#四、改进——函数式编程" class="headerlink" title="四、改进——函数式编程"></a>四、改进——函数式编程</h2><p>上述的步骤基本完成了自定义的KVO，但是使用起来太过冗余，每次使用，都得调用 addObserver、observeValueForKeyPath以及removeObserver 三个函数，使用起来非常的冗余，是否有改进的空间呢？</p><p>这里，使用<code>block</code> 的思想，使得更加函数的调用的聚合</p><h3 id="4-1-定义block函数类型"><a href="#4-1-定义block函数类型" class="headerlink" title="4.1 定义block函数类型"></a>4.1 定义block函数类型</h3><p>我们把添加的四大要素，都加入到block类型里，以供业务代码调用，具体如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(^LJKVOBlock)</span><span class="params">(id observer,NSString *keyPath,id oldValue,id newValue)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-2-改进添加观察者方法"><a href="#4-2-改进添加观察者方法" class="headerlink" title="4.2 改进添加观察者方法"></a>4.2 改进添加观察者方法</h3><ul><li><p>先把观察者模型的初始化方法，改进称为<code>block</code>， 方便回调</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (instancetype)initWitObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath handleBlock:(LJKVOBlock)block&#123;</span><br><span class="line">    <span class="keyword">if</span> (self=[super init]) &#123;</span><br><span class="line">        _observer = observer;</span><br><span class="line">        _keyPath  = keyPath;</span><br><span class="line">        _handleBlock = block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)lj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(LJKVOBlock)block;</span><br></pre></td></tr></table></figure></li><li><p>函数实现改进如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)lj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(LJKVOBlock)block&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1: 验证是否存在setter方法 : 不让实例进来</span></span><br><span class="line">    [self judgeSetterMethodFromKeyPath:keyPath];</span><br><span class="line">    <span class="comment">// 2: 动态生成子类</span></span><br><span class="line">    Class newClass = [self createChildClassWithKeyPath:keyPath];</span><br><span class="line">    <span class="comment">// 3: isa的指向 : ljKVONotifying_ljPerson</span></span><br><span class="line">    <span class="built_in">object_setClass</span>(self, newClass);</span><br><span class="line">    <span class="comment">// 4: 保存信息</span></span><br><span class="line">    ljInfo *info = [[ljInfo alloc] initWitObserver:observer forKeyPath:keyPath handleBlock:block];</span><br><span class="line">    NSMutableArray *mArray = <span class="built_in">objc_getAssociatedObject</span>(self, (__bridge <span class="type">const</span> <span class="type">void</span> * _Nonnull)(kljKVOAssiociateKey));</span><br><span class="line">    <span class="keyword">if</span> (!mArray) &#123;</span><br><span class="line">        mArray = [NSMutableArray arrayWithCapacity:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">objc_setAssociatedObject</span>(self, (__bridge <span class="type">const</span> <span class="type">void</span> * _Nonnull)(kljKVOAssiociateKey), mArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    [mArray addObject:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-具体使用"><a href="#4-3-具体使用" class="headerlink" title="4.3 具体使用"></a>4.3 具体使用</h3><p>使用起来，就很简洁了，一个<code>block</code>搞定</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">self.d = [[Dog alloc] init];</span><br><span class="line">[self.d lj_addObserver:self forKeyPath:@<span class="string">&quot;petName&quot;</span> block:^(id  _Nonnull observer, NSString * _Nonnull keyPath, id  _Nonnull oldValue, id  _Nonnull newValue) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;%@-%@&quot;</span>,oldValue,newValue);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="五、自动销毁机制"><a href="#五、自动销毁机制" class="headerlink" title="五、自动销毁机制"></a>五、自动销毁机制</h2><p>上面第四部实现了block 引用，的确大大提升了业务代码的使用效率，但是还是需要自动执行移除观察，以及isa 的转向回去。</p><p>是否有更多优化的空间，将移动观察做的更加高效呢？</p><p>当然可以！还记得动态子类生成后，也动态添加了dealloc 方法，那么，还是做dealloc 方法上做文章吧。</p><p>思路：自定义一个dalloc ，在里面实现对对象的KVO移除，在<code>load</code> 时将其与系统dealloc 进行方法交换</p><h3 id="5-1-写自定义dealloc"><a href="#5-1-写自定义dealloc" class="headerlink" title="5.1 写自定义dealloc"></a>5.1 写自定义dealloc</h3><p>自己写一个dealloc，主要实现<code>isa</code> 的转向，在系统dealloc 进行之前，将当前对象的<code>isa</code> 指向原来的类。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)myDealloc&#123;</span><br><span class="line"></span><br><span class="line">    Class superClass = [self <span class="keyword">class</span>];</span><br><span class="line">    <span class="built_in">object_setClass</span>(self, superClass);</span><br><span class="line">    [self myDealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-将新旧方法进行交换"><a href="#5-2-将新旧方法进行交换" class="headerlink" title="5.2 将新旧方法进行交换"></a>5.2 将新旧方法进行交换</h3><p>这里依然使用runtime 的method swizzling 进行。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+ (BOOL)kc_hookOrigInstanceMenthod:(SEL)oriSEL newInstanceMenthod:(SEL)swizzledSEL &#123;</span><br><span class="line">    Class cls = self;</span><br><span class="line">    Method oriMethod = <span class="built_in">class_getInstanceMethod</span>(cls, oriSEL);</span><br><span class="line">    Method swiMethod = <span class="built_in">class_getInstanceMethod</span>(cls, swizzledSEL);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!swiMethod) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!oriMethod) &#123;</span><br><span class="line">        <span class="built_in">class_addMethod</span>(cls, oriSEL, <span class="built_in">method_getImplementation</span>(swiMethod), <span class="built_in">method_getTypeEncoding</span>(swiMethod));</span><br><span class="line">        <span class="built_in">method_setImplementation</span>(swiMethod, <span class="built_in">imp_implementationWithBlock</span>(^(id self, SEL _cmd)&#123; &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BOOL didAddMethod = <span class="built_in">class_addMethod</span>(cls, oriSEL, <span class="built_in">method_getImplementation</span>(swiMethod), <span class="built_in">method_getTypeEncoding</span>(swiMethod));</span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        <span class="built_in">class_replaceMethod</span>(cls, swizzledSEL, <span class="built_in">method_getImplementation</span>(oriMethod), <span class="built_in">method_getTypeEncoding</span>(oriMethod));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">method_exchangeImplementations</span>(oriMethod, swiMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-在load-中执行hook-方法及交换"><a href="#5-3-在load-中执行hook-方法及交换" class="headerlink" title="5.3 在load 中执行hook 方法及交换"></a>5.3 在load 中执行hook 方法及交换</h3><p>由于dealloc 为系统方法，在ARC 不允许通过 <code>@selector(dealloc)</code> 写入</p><p><img src="/p/fe949d29/001.png"></p><p>那么还是使用<strong>runtime</strong>  特性，使用<code>NSSelectorFromString(@&quot;dealloc&quot;)</code> 来拿到，并进行交换。</p><p>这些交换，写到<code>load</code> 里面，编译时即可完成</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (void)load&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">        [self kc_hookOrigInstanceMenthod:NSSelectorFromString(@&quot;dealloc&quot;) newInstanceMenthod:@selector(myDealloc)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>总的来说，自定义的KVO 和自定义的KVC 很类似，一步一步，生成子类，完善方法，isa 转向；而移除时，倒叙进行，isa 指回去之后，移除观察就可以了，而动态子类会保留，以便下次使用。</p><p>关于自定义KVO 的Demo 已经上传至<a href="https://github.com/newjia/rewriteKVO">我的Github</a> ，欢迎下载参考</p>]]></content>
      
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> KVO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（4）双向链表和双向循环链表</title>
      <link href="/p/56790.html"/>
      <url>/p/56790.html</url>
      
        <content type="html"><![CDATA[<blockquote><p> <a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p> <a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p> <a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p> <a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p> <a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p> <a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p> <a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p></blockquote><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p><strong>双向链表</strong>：</p><blockquote><p>是在单链表的每个节点中，再设置一个指向其前驱结点的指针域。</p></blockquote><p>所以在双向链表中的结点有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><p><img src="/p/56790/001.png" alt="双向链表"></p><p>双向循环链表：</p><p>与双向链表相比，双向循环链表的尾结点的<code>next</code>指向头结点，头结点的prior 指向尾结点，形成一个循环。如下图所示：</p><p><img src="/p/56790/005.png" alt="双向链表"></p><p>创建代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">prior</span>/*直接前驱指针*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">next</span>/*直接后继指针*/</span></span><br><span class="line"><span class="class">&#125; <span class="title">DulNode</span>, *<span class="title">DuLinkList</span>;</span></span><br></pre></td></tr></table></figure><h2 id="二、双向链表的操作"><a href="#二、双向链表的操作" class="headerlink" title="二、双向链表的操作"></a>二、双向链表的操作</h2><h3 id="2-1-创建链表"><a href="#2-1-创建链表" class="headerlink" title="2.1 创建链表"></a>2.1 创建链表</h3><p>创建双向链表的步骤如下：</p><ol><li>创建空链表<code>L</code>，以及结点<code>*L</code></li><li>指定一个尾结点为<code>p</code></li><li>创建临时结点<code>temp</code>，并进行数值给定</li><li>将当前尾结点<code>p</code>与<code>temp</code>进行双线链接链接<ol><li><code>temp</code> 是 <code>p</code> 的后继</li><li><code>p</code> 是 <code>temp</code> 的前驱</li></ol></li><li>将<code>temp</code> 赋值给<code>p</code>，<code>p</code>依然为链表的尾结点。</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ① 创建*L 指向头结点</span></span><br><span class="line">*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="keyword">if</span> (*L == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">(*L)-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">(*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">(*L)-&gt;data = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//② 新建一个尾结点 p</span></span><br><span class="line">LinkList p = *L;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ③ 创建1个临时的结点</span></span><br><span class="line">    LinkList temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    temp-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;data = i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ④ 为新增的结点建立双向链表关系</span></span><br><span class="line">      <span class="comment">// 1  temp 是p的后继</span></span><br><span class="line">    p-&gt;next = temp;</span><br><span class="line">      <span class="comment">// 2 temp 的前驱是p</span></span><br><span class="line">    temp-&gt;prior = p;</span><br><span class="line"> <span class="comment">// ⑤ p 要记录最后的结点的位置,方便下一次插入 </span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-增加结点"><a href="#2-2-增加结点" class="headerlink" title="2.2 增加结点"></a>2.2 增加结点</h3><p>向双向链表种添加结点的步骤和单向链表添加结点类似，只是多了一步链接前驱的工作。</p><p>步骤如下：</p><ol><li>新建目标结点<code>temp</code></li><li>创建指针 <code>p</code> ，指向链表的头结点</li><li>通过循环便利，将 <code>p</code> 向后移，找到插入位置 <code>i</code> 的结点<ol><li>【判断】如果插入位置超出链表本身长度，跳出</li><li>【判断】如果 <code>p</code> 为链表尾部，只需做 <code>p</code> 与<code>temp</code>首尾相连</li></ol></li><li>找到<code>i</code> 结点后，分两步对<code>p</code> 与<code>temp</code> 进行首尾相连<ol><li>将原<code>p</code> 的<code>next </code>的 <strong>prior</strong> 指向 目标结点<code>temp</code></li><li>将目标结点的<code>next</code> 指向 <code>p</code> 的 <code>next</code></li><li>将 <code>p</code> 的<code>next</code> 指向目标结点 <code>temp</code></li><li>将 目标结点 <code>temp</code> 的 <code>prior</code> 指向 <code>p</code></li></ol></li></ol><p><strong>注意：</strong>这里的第四步中，第1，2两步必须先于3，4两步执行，否则先将<code>p</code> 与 <code>temp</code>，关联上，会导致原<code>p</code> 的<code>next</code> 丢失，成为野指针。</p><p>画个图表示一下流程：</p><p><img src="/p/56790/002.png" alt="双向链表-插入结点"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList *L, <span class="type">int</span> i, ElemType data)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 插入的位置不合法 为0或者为负数</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 新建结点</span></span><br><span class="line">    LinkList temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    temp-&gt;data = data;</span><br><span class="line">    temp-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.将p指向头结点!</span></span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 找到插入位置i直接的结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i &amp;&amp; p;j++)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 如果插入的位置超过链表本身的长度</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. 判断插入位置是否为链表尾部;</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        p-&gt;next = temp;</span><br><span class="line">        temp-&gt;prior = p;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1️⃣ 将p-&gt;next 结点的前驱prior = temp</span></span><br><span class="line">        p-&gt;next-&gt;prior = temp;</span><br><span class="line">        <span class="comment">//2️⃣ 将temp-&gt;next 指向原来的p-&gt;next</span></span><br><span class="line">        temp-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="comment">//3️⃣ p-&gt;next 更新成新创建的temp</span></span><br><span class="line">        p-&gt;next = temp;</span><br><span class="line">        <span class="comment">//4️⃣ 新创建的temp前驱 = p</span></span><br><span class="line">        temp-&gt;prior = p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-删除结点"><a href="#2-3-删除结点" class="headerlink" title="2.3 删除结点"></a>2.3 删除结点</h3><p>删除链表中的结点分两种：删除指定位置结点和删除指定元素的结点。其思路都是一致的，遍历链表中的元素，找到指定元素，并进行删除。主要流程与删除单向链表的逻辑类似，只是多了一个移除前驱结点的操作。</p><p>删除结点的<strong>通俗理解</strong>：就好比员工离职前，必要的一步就是工作交接，告诉大家接下来工作时谁来接手，锅该由谁来背，公司才能正常运行；否则你一拍屁股删库跑路了，公司可就热闹了，大家都抓瞎了，这样就乱套了。</p><h4 id="2-3-1-删除指定位置结点"><a href="#2-3-1-删除指定位置结点" class="headerlink" title="2.3.1 删除指定位置结点"></a>2.3.1 删除指定位置结点</h4><p>流程如下：</p><ol><li>给定一个工具结点<code>p</code>，指向链表的头结点</li><li>依次循环查找，将 <code>p</code> 指向删除位的前一个</li><li>创建临时结点 <code>temp</code> 指向要删除的结点，并把该结点 <code>data</code> 赋值给返回的 <code>*e</code></li><li>待删除结点上一结点的 <code>next</code> 指向 <code>temp</code> 的后一个结点</li><li>待删除结点是否链尾结点？<ul><li>并非链尾：将待删除结点 <code>temp</code> 的下一结点的 <code>prior</code> 指向工具结点<code>p</code></li><li>是链尾：不作处理</li></ul></li><li>释放待删除结点 <code>temp</code></li></ol><p>总结一下，<strong>核心操作</strong>就两步：</p><ul><li>将目标上一个结点的 <code>next</code> 指给下一个</li><li>将目标的下一个结点的 <code>prior</code> 指给上个结点</li></ul><p>有图有真相：</p><p><img src="/p/56790/003.png" alt="双向链表-删除指定位置结点"> </p><p>贴一下实操的代码如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DeleteVeryNode</span><span class="params">(LinkList *L, <span class="type">int</span> i, ElemType *e)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    LinkList p = (*L);</span><br><span class="line">    <span class="comment">//1.判断双向链表是否为空,如果为空则返回ERROR;</span></span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 将指针p移动到删除元素位置前一个</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; i &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.如果k&gt;i 或者 p == NULL 则返回ERROR</span></span><br><span class="line">    <span class="keyword">if</span> (k&gt;i || p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.创建临时指针temp 指向要删除的结点,并将要删除的结点的data 赋值给*e,带回到main函数</span></span><br><span class="line">    LinkList temp = p-&gt;next;</span><br><span class="line">    *e = temp-&gt;data;</span><br><span class="line">    <span class="comment">//5. p-&gt;next 等于要删除的结点的下一个结点</span></span><br><span class="line">    p-&gt;next = temp-&gt;next;</span><br><span class="line">    <span class="comment">//6. 如果删除结点的下一个结点不为空,则将将要删除的下一个结点的前驱指针赋值p;</span></span><br><span class="line">    <span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp-&gt;next-&gt;prior = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.删除temp结点</span></span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-删除指定元素的结点"><a href="#2-3-2-删除指定元素的结点" class="headerlink" title="2.3.2 删除指定元素的结点"></a>2.3.2 删除指定元素的结点</h4><p>删除指定元素的结点，会更简单，只需要遍历循环，找到相应的结点后，依次对前驱点和后继点进行重新配置。</p><p><strong>步骤如下：</strong></p><ol><li>创建链表<code>L</code>， 将<code>p</code> 指向首结点。</li><li>遍历链表<code>L</code>，判断给定元素 <code>data</code> 与 <code>p-&gt; data</code>是否相等，相等即找到目标结点</li><li>修改目标结点的<strong>前驱结点</strong>的<strong>后继指针</strong>，指向目标结点下一个结点（交代后事….）</li><li><strong>若删除结点非尾结点</strong>：修改目标结点后继结点的前驱指针 <code>prior</code>，指向目标的上一个结点。</li><li>释放被删除的结点 <code>p</code></li></ol><p><img src="/p/56790/004.png" alt="双向链表-删除指定元素结点"></p><p>贴一下实操的代码如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DeleteDefinedNode</span><span class="params">(LinkList *L, <span class="type">int</span> data)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建链表，以及头结点 p</span></span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    <span class="comment">//1.遍历双向循环链表</span></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="comment">//2.判断当前结点的数据域和data是否相等,若相等则删除该结点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == data) &#123;</span><br><span class="line">            <span class="comment">//修改被删除结点的前驱结点的后继指针</span></span><br><span class="line">            p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="comment">//修改被删除结点的后继结点的前驱指针</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放被删除结点p</span></span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="comment">//退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有找到该结点,则继续移动指针p</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-查询结点"><a href="#2-4-查询结点" class="headerlink" title="2.4 查询结点"></a>2.4 查询结点</h3><ol><li>创建链表<code>L</code>， 将<code>p</code> 指向首结点。</li><li>遍历链表<code>L</code>，判断给定元素 <code>data</code> 与 <code>p-&gt; data</code>是否相等，<ol><li>相等即找到目标结点，跳出。</li><li>否则继续循环，将 <code>p</code> 移动到下一个结点</li></ol></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">selectElem</span><span class="params">(LinkList L,ElemType elem)</span>&#123;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == elem) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-更新结点"><a href="#2-5-更新结点" class="headerlink" title="2. 5 更新结点"></a>2. 5 更新结点</h3><p>更新结点，只需要遍历循环链表，找到序号内的结点，将其数据域 <code>data</code> 替换为新的数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">replaceLinkList</span><span class="params">(LinkList *L,<span class="type">int</span> index,ElemType newElem)</span>&#123;</span><br><span class="line">    LinkList p = (*L)-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p-&gt;data = newElem;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、双向循环链表的操作"><a href="#三、双向循环链表的操作" class="headerlink" title="三、双向循环链表的操作"></a>三、双向循环链表的操作</h2><h3 id="3-1-创建链表"><a href="#3-1-创建链表" class="headerlink" title="3.1 创建链表"></a>3.1 创建链表</h3><p>双向循环链表的创建步骤，与双向链表类似。差别在于：多了将尾结点的 <code>next</code> 指向 头结点，而头结点的 <code>prior</code> 指向 尾结点。</p><p>具体步骤：</p><ol><li>创建空链表<code>L</code>，以及结点<code>*L</code>，使得其<strong>前驱和后继都指向自己</strong></li><li>指定一个尾结点为<code>p</code></li><li>创建临时结点<code>temp</code>，并进行数值给定</li><li>将当前尾结点<code>p</code>与<code>temp</code>进行双线链接链接<ol><li><code>temp</code> 是 <code>p</code> 的后继</li><li><code>p</code> 是 <code>temp</code> 的前驱</li><li><code>temp</code> 的后继是 <code>p</code></li><li><code>p</code>  的前驱是新建的 <code>temp</code></li></ol></li><li>将<code>temp</code> 赋值给<code>p</code>，<code>p</code>依然为链表的尾结点，<strong>方便下次插入新结点</strong>。</li></ol><p>实现源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">creatCircularLinkList</span><span class="params">(LinkList *L)</span>&#123;</span><br><span class="line">    <span class="comment">// 1 创建空链表</span></span><br><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next = (*L);</span><br><span class="line">    (*L)-&gt;prior = (*L);</span><br><span class="line">    <span class="comment">// 指定一个尾结点为 p</span></span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//1.创建1个临时的结点</span></span><br><span class="line">        LinkList temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        temp-&gt;data = i;</span><br><span class="line">        <span class="comment">//2.为新增的结点建立双向链表关系</span></span><br><span class="line">        <span class="comment">//① temp 是p的后继</span></span><br><span class="line">        p-&gt;next = temp;</span><br><span class="line">        <span class="comment">//② temp 的前驱是p</span></span><br><span class="line">        temp-&gt;prior = p;</span><br><span class="line">        <span class="comment">//③ temp的后继是*L</span></span><br><span class="line">        temp-&gt;next = (*L);</span><br><span class="line">        <span class="comment">//④ p 的前驱是新建的temp</span></span><br><span class="line">        p-&gt;prior = temp;</span><br><span class="line">        <span class="comment">//⑤ p 要记录最后的结点的位置,方便下一次插入</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-增加结点"><a href="#3-2-增加结点" class="headerlink" title="3.2 增加结点"></a>3.2 增加结点</h3><p>与双向链表相似，区别在于双向循环链表由于有首位域，在找到指定位置后，需要先将插入结点的<code>prior</code> 和 <code>next</code> 与 前后建立关系，之后再考虑前结点的 <code>next</code>链接，最后考虑的是 目标结点的<code>next</code></p><p>具体步骤如下：</p><ol><li>新建目标结点<code>temp</code></li><li>创建指针 <code>p</code> ，指向链表的头结点</li><li>通过循环便利，将 <code>p</code> 向后移，找到插入位置 <code>i</code> 的结点<ol><li>【判断】如果插入位置超出链表本身长度，跳出</li><li>【判断】如果 <code>p</code> 为<code>next</code>指向 头结点跳出</li></ol></li><li>找到<code>i</code> 结点后，分两步对<code>p</code> 与<code>temp</code> 进行首尾相连<ol><li>将<code>temp</code> 的 <code>prior</code> 指向 <code>p</code></li><li>将 <code>temp</code> 的 <code>next</code> 指向 <code>p</code> 的 <code>next</code></li><li>将 <code>p</code> 的<code>next</code> 指向目标结点 <code>temp</code></li><li>判断 <code>temp</code> 是否是尾结点<ol><li>如果是：将头结点的 <code>prior</code> 指向 <code>temp</code></li><li>如果否：将目标结点 <code>temp</code> 的 <code>prior</code> 指向 <code>p</code></li></ol></li></ol></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">LinkCircularListInsert</span><span class="params">(LinkList *L, <span class="type">int</span> index, ElemType e)</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//1. 创建指针p,指向双向链表头</span></span><br><span class="line">    LinkList p = (*L);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.双向循环链表为空,则返回error</span></span><br><span class="line">    <span class="keyword">if</span>(*L == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//3.找到插入前一个位置上的结点p</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; index &amp;&amp; p-&gt;next != *L) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.如果i&gt;index 则返回error</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; index)  <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.创建新结点temp</span></span><br><span class="line">    LinkList temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.temp 结点为空,则返回error</span></span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.将生成的新结点temp数据域赋值e.</span></span><br><span class="line">    temp-&gt;data = e;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8.将结点temp 的前驱结点为p;</span></span><br><span class="line">    temp-&gt;prior = p;</span><br><span class="line">    <span class="comment">//9.temp的后继结点指向p-&gt;next;</span></span><br><span class="line">    temp-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="comment">//10.p的后继结点为新结点temp;</span></span><br><span class="line">    p-&gt;next = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果temp 结点不是最后一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (*L != temp-&gt;next) &#123;</span><br><span class="line">        <span class="comment">//11.temp节点的下一个结点的前驱为temp 结点</span></span><br><span class="line">        temp-&gt;next-&gt;prior = temp;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        (*L)-&gt;prior = temp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-删除结点"><a href="#3-3-删除结点" class="headerlink" title="3.3 删除结点"></a>3.3 删除结点</h3><p>双向循环链表的结点删除，比双向链表的简单，因为链表首尾相连的特性，不需要考虑是否为尾结点或者头结点。</p><p>流程如下：</p><ol><li>给定一个工具结点<code>p</code>，指向链表的头结点</li><li>依次循环查找，将 <code>p</code> 指向删除位的前一个</li><li>创建临时结点 <code>temp</code> 指向要删除的结点，并把该结点 <code>data</code> 赋值给返回的 <code>*e</code></li><li>待删除结点上一结点的 <code>next</code> 指向 <code>temp</code> 的后一个结点</li><li>释放待删除结点 <code>temp</code></li></ol><p>总结一下，<strong>核心操作</strong>就两步：</p><ul><li>将目标上一个结点的 <code>next</code> 指给下一个</li><li>将目标的下一个结点的 <code>prior</code> 指给上个结点</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">LinkListDelete</span><span class="params">(LinkList *L,<span class="type">int</span> index,ElemType *e)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    LinkList temp = (*L)-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//①.如果删除到只剩下首元结点了,则直接将*L置空;</span></span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;next == *L)&#123;</span><br><span class="line">        <span class="built_in">free</span>(*L);</span><br><span class="line">        (*L) = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.找到要删除的结点</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; index) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.给e赋值要删除结点的数据域</span></span><br><span class="line">    *e = temp-&gt;data;</span><br><span class="line">    <span class="comment">//3.修改被删除结点的前驱结点的后继指针 </span></span><br><span class="line">    temp-&gt;prior-&gt;next = temp-&gt;next;</span><br><span class="line">    <span class="comment">//4.修改被删除结点的后继结点的前驱指针</span></span><br><span class="line">    temp-&gt;next-&gt;prior = temp-&gt;prior;</span><br><span class="line">    <span class="comment">//5. 删除结点temp</span></span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-查询结点"><a href="#3-4-查询结点" class="headerlink" title="3.4 查询结点"></a>3.4 查询结点</h3><p>与双向链表相同，更新结点，只需要遍历循环链表，找到序号内的结点，将其数据域 <code>data</code> 替换为新的数据</p><p>代码参见 2.5</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="4-1-线性表结构"><a href="#4-1-线性表结构" class="headerlink" title="4.1 线性表结构"></a>4.1 线性表结构</h3><p><img src="/p/56790/006.png" alt="线性表·结构"></p><h3 id="4-2-顺序表与链表比较"><a href="#4-2-顺序表与链表比较" class="headerlink" title="4.2 顺序表与链表比较"></a>4.2 顺序表与链表比较</h3><p>顺序结构的线性表与链式结构的线性表比较起来，</p><p><strong>从空间性能上比较</strong>：</p><ol><li><p>存储空间分配</p></li><li><p>存储密度的大小</p><p>存储密度 &#x3D; $\frac{数据元素本身占用存储量}{结点结构占用的存储量}$</p></li></ol><p>时间性能比较：</p><ol><li>存储元素的效率</li><li>插入和删除操作的效率</li></ol><h3 id="4-3-其他"><a href="#4-3-其他" class="headerlink" title="4.3 其他"></a>4.3 其他</h3><p>双向链表比起单向链表来说，增加了<code>prior</code> 这一指针域，可以在查找和删除时，极其迅速的操作，无须做更多的判断，极大地提高了运算效率。同时在操作时，需要注意指针修改顺序，以免形成野指针。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【底层探索】- KVO（上）</title>
      <link href="/p/78de752a.html"/>
      <url>/p/78de752a.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、KVO-初探"><a href="#一、KVO-初探" class="headerlink" title="一、KVO 初探"></a>一、KVO 初探</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><blockquote><p>Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects.</p><p>键值观察（KVO）是一种机制，允许对象在其他对象的特定属性改变后得到通知。</p></blockquote><p>KVO 概念，参看 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">苹果开放文档</a></p><h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h3><ul><li><p>注册监听</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">addObserver</span>(<span class="keyword">_</span> <span class="params">observer</span>: <span class="type">NSObject</span>, </span><br><span class="line">      <span class="params">forKeyPath</span> <span class="params">keyPath</span>: <span class="type">String</span>, </span><br><span class="line">         <span class="params">options</span>: <span class="type">NSKeyValueObservingOptions</span> <span class="operator">=</span> [], </span><br><span class="line">         <span class="params">context</span>: <span class="type">UnsafeMutableRawPointer</span>?)</span><br></pre></td></tr></table></figure></li><li><p>实现键值变换的通知</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(NSString *)keyPath </span><br><span class="line">                      ofObject:(id)object </span><br><span class="line">                        change:(NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change </span><br><span class="line">                       context:(<span class="type">void</span> *)context;</span><br></pre></td></tr></table></figure></li><li><p>移除监听，当不再需要监听事件时</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">removeObserver</span>(<span class="keyword">_</span> <span class="params">observer</span>: <span class="type">NSObject</span>, </span><br><span class="line">         <span class="params">forKeyPath</span> <span class="params">keyPath</span>: <span class="type">String</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-1-context-的作用"><a href="#1-1-context-的作用" class="headerlink" title="1.1 context 的作用"></a>1.1 context 的作用</h3><h4 id="1-1-1-介绍"><a href="#1-1-1-介绍" class="headerlink" title="1.1.1 介绍"></a>1.1.1 介绍</h4><p>添加KVO 的关键方法为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable <span class="type">void</span> *)context;</span><br></pre></td></tr></table></figure><ol><li>objserver - 观察者</li><li>keyPath - 关键路径，即观察的重点，如属性</li><li>options - 键值观察的策略选项。</li><li>context - 观察上下文。</li></ol><h4 id="1-1-2-原因："><a href="#1-1-2-原因：" class="headerlink" title="1.1.2 原因："></a>1.1.2 原因：</h4><p>苹果文档 在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOBasics.html#//apple_ref/doc/uid/20002252-SW4">context 这一小节</a> 写到：</p><blockquote><p>A safer and more extensible approach is to use the context to ensure notifications you receive are destined for your observer and not a superclass.</p><p>更安全和扩展性更好的获取方式，就是使用<code>context</code>来确保你收到的通知被指向你的观察者，而不是父类。</p></blockquote><p>可见上下文指针（<code>context</code>） 是用来区分多个对象同时使用使用相同的<code>keyPath</code>，这样无需区分不同对象，减少判断嵌套，提高性能。</p><blockquote><p>可以快速定位观察键，是的区分观察对象更加便利、安全、直接。</p><p><strong>类似标签区别</strong></p></blockquote><h4 id="1-1-3-使用"><a href="#1-1-3-使用" class="headerlink" title="1.1.3 使用"></a>1.1.3 使用</h4><p>context 使用静态地址指针，用法如下：</p><ul><li><p>创建 context 指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *PersonAccountBalanceContext = &amp;PersonAccountBalanceContext;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *PersonAccountInterestRateContext = &amp;PersonAccountInterestRateContext;</span><br></pre></td></tr></table></figure></li><li><p>将不同的context 注册在相同对象的观察者中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)registerAsObserverForAccount:(Account*)account &#123;</span><br><span class="line">    [account addObserver:self</span><br><span class="line">              forKeyPath:@<span class="string">&quot;balance&quot;</span></span><br><span class="line">                 options:(NSKeyValueObservingOptionNew |</span><br><span class="line">                          NSKeyValueObservingOptionOld)</span><br><span class="line">                 context:PersonAccountBalanceContext];</span><br><span class="line"> </span><br><span class="line">    [account addObserver:self</span><br><span class="line">              forKeyPath:@<span class="string">&quot;interestRate&quot;</span></span><br><span class="line">                 options:(NSKeyValueObservingOptionNew |</span><br><span class="line">                          NSKeyValueObservingOptionOld)</span><br><span class="line">                  context:PersonAccountInterestRateContext];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-2-移除观察者的重要性"><a href="#1-2-移除观察者的重要性" class="headerlink" title="1.2 移除观察者的重要性"></a>1.2 移除观察者的重要性</h3><blockquote><p>会触发隐藏的崩溃</p></blockquote><p>移除观察者，通常会使用这个方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure><p>如果不移除，当被观察者被dealloc 后，观察者还在苦苦的观察它，长此以往，找不到对象</p><p>会形成野指针，造成崩溃。</p><p><del>类似女同事们默默喜欢关注吴尊好多年，结果突然你告诉我他早就脱单结婚了，女儿都八岁了，能不崩溃吗。</del></p><h3 id="1-3-手动-自动观察开关"><a href="#1-3-手动-自动观察开关" class="headerlink" title="1.3 手动&#x2F;自动观察开关"></a>1.3 手动&#x2F;自动观察开关</h3><p>有些业务场景，经常需要变换对键的观察，由于需求的变换，可能之前一直在观察的值，这个版本就不需要在观察了，那么再去删除大量的观察代码肯定不是一件明智的事情（谁知道产品经理下一步会不会回退需求呢？）。</p><p>可以通过开关<strong>自动观察指定键的对象按钮</strong>来实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key;</span><br></pre></td></tr></table></figure><ul><li><p>当需要手动来操作时，返回NO</p><p>此时对需要改动的键值，手动添加<code>willChangeValueForKey</code> 和<code>didChangeValueForKey</code> 两个方法，这样是的被观察对象的观察策略生效。</p><p>代码如下：</p><p>业务代码对对象进行观察以及改变</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">   </span><br><span class="line">    [self.person willChangeValueForKey:@<span class="string">&quot;name&quot;</span>];</span><br><span class="line">    self.person.name  = @<span class="string">&quot;haha&quot;</span>;</span><br><span class="line">    [self.person didChangeValueForKey:@<span class="string">&quot;name&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的实现下，关闭自动</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动开关</span></span><br><span class="line">+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当需要自动观察指定的键时，返回YES</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动开关</span></span><br><span class="line">+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123;</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-路径集合"><a href="#1-4-路径集合" class="headerlink" title="1.4 路径集合"></a>1.4 路径集合</h3><p>在某些场景下，观察对象手多个外接属性&#x2F;变量影响，也可以使用KVO。</p><p>一个典型的场景，是在音乐&#x2F;电视剧下载时，由于某些专辑有多首歌曲，某些时候下载过程中，会有新的关联专辑加入进来，此时下载进度条可能满了之后会会退（奇怪的需求）。</p><ul><li><p>给对象添加一个下载进度的KVO 监测</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[self.person addObserver:self forKeyPath:@<span class="string">&quot;downloadProgress&quot;</span> options:(NSKeyValueObservingOptionNew) context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure></li><li><p>业务层，对简洁相关联的属性，进行增减。比如这里，使用到的是下载进度相关的”已写入数据”和”总数据”，当点击时，他们会依次添加</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">self.person.writtenData += <span class="number">10</span>;</span><br><span class="line">self.person.totalData += <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>最后，在集合关联键值方法里，给他们<strong>绑定上关系</strong>。</p><p>此时有3个关键键了，分别上：<strong>downloadProgress</strong>、<strong>totalData</strong>、<strong>writtenData</strong></p><p>他们之间的关系是： 下载进度 &#x3D; 当前下载量 &#x2F; 总量 （downloadProgress &#x3D; writtenData &#x2F; totalData）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123;</span><br><span class="line">    </span><br><span class="line">    NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:@<span class="string">&quot;downloadProgress&quot;</span>]) &#123;</span><br><span class="line">        NSArray *affectingKeys = @[@<span class="string">&quot;totalData&quot;</span>, @<span class="string">&quot;writtenData&quot;</span>];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5-集合数组观察"><a href="#1-5-集合数组观察" class="headerlink" title="1.5 集合数组观察"></a>1.5 集合数组观察</h3><ul><li><p>比如对某个数组添加观察。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[self.person addObserver:self forKeyPath:@<span class="string">&quot;dateArray&quot;</span> options:(NSKeyValueObservingOptionNew) context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure></li><li><p>对数组进行改动。此时需要将其先改成可变数组，才能改动</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[[self.person mutableArrayValueForKey: @<span class="string">&quot;dateArray&quot;</span>] addObject: @<span class="string">&quot;hello&quot;</span>];</span><br></pre></td></tr></table></figure></li></ul><p>原因：因为数组没有遵循KVC，并没有使用setter 方法</p><h3 id="1-6-观察类型枚举"><a href="#1-6-观察类型枚举" class="headerlink" title="1.6 观察类型枚举"></a>1.6 观察类型枚举</h3><ul><li>NSKeyValueChangeSetting</li><li>NSKeyValueChangeInsertion</li><li>NSKeyValueChangeRemoval</li><li>NSKeyValueChangeReplacement</li></ul><h2 id="二、KVO-原理"><a href="#二、KVO-原理" class="headerlink" title="二、KVO 原理"></a>二、KVO 原理</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><blockquote><p>Automatic key-value observing is implemented using a technique called <em>isa-swizzling</em>.</p><p>自动KVO 使用isa 改变的技术来实现</p></blockquote><h3 id="2-2-动态生成子类"><a href="#2-2-动态生成子类" class="headerlink" title="2.2 动态生成子类"></a>2.2 动态生成子类</h3><p>为了分析所谓的动态生成子类，先写一段代码，生成一个<code>Dog</code> 的类，对其<code>name</code> 属性添加观察，并打印实例<code>d</code> 观察前和观察后的类名。代码如下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Dog *d = [[Dog alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;添加前-:    %s\n&quot;</span>, <span class="built_in">object_getClassName</span>(d));</span><br><span class="line">[d addObserver:self forKeyPath:@<span class="string">&quot;name&quot;</span> options:(NSKeyValueObservingOptionNew) context:<span class="literal">NULL</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;添加后-:    %s&quot;</span>, <span class="built_in">object_getClassName</span>(d));</span><br></pre></td></tr></table></figure><p>运行，打印结果如下:</p><ul><li></li></ul><p><img src="/p/78de752a/001.png"></p><p><strong>如何判断</strong>是子类呢，可以写个方法来打印当前<code>Dog</code> 类的子类列表</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册类的总数</span></span><br><span class="line"><span class="type">int</span> count = <span class="built_in">objc_getClassList</span>(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 创建一个数组， 其中包含给定对象</span></span><br><span class="line">NSMutableArray *mArray = [NSMutableArray arrayWithObject:[d <span class="keyword">class</span>]];</span><br><span class="line"><span class="comment">// 获取所有已注册的类</span></span><br><span class="line">Class* classes = (Class*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Class)*count);</span><br><span class="line"><span class="built_in">objc_getClassList</span>(classes, count);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([d <span class="keyword">class</span>] == <span class="built_in">class_getSuperclass</span>(classes[i])) &#123;</span><br><span class="line">        [mArray addObject:classes[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(classes);</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;classes = %@&quot;</span>, mArray);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印结果如下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-07</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">32.770527</span>+<span class="number">0800</span> MyKVO[<span class="number">8567</span>:<span class="number">500364</span>] 添加前-:    Dog</span><br><span class="line"></span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-07</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">32.771302</span>+<span class="number">0800</span> MyKVO[<span class="number">8567</span>:<span class="number">500364</span>] 添加后-:    NSKVONotifying_Dog</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-07</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">32.788208</span>+<span class="number">0800</span> MyKVO[<span class="number">8567</span>:<span class="number">500364</span>] classes = (</span><br><span class="line">    Dog,</span><br><span class="line">    <span class="string">&quot;NSKVONotifying_Dog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>果然生成了一个<code>NSKVONotifying_Dog</code> 基于<code>Dog</code> 类的子类</p><blockquote><p>当对某个对象实用KVO，会动态生成子类 NSKeyValueNotifying__XXX，这个类的isa 指向对象的类</p></blockquote><h3 id="2-3-键值观察的是setter方法"><a href="#2-3-键值观察的是setter方法" class="headerlink" title="2.3 键值观察的是setter方法"></a>2.3 键值观察的是setter方法</h3><p>我们知道KVO 是对属性做的键值观察，那么为什么不是成员变量呢？为了解决这个问题，不妨生成一个成员变量，对他做一下检测试试。</p><ol><li><p>先给类<code>Dog</code> 新增一个成员变量<code>age</code>，记得添加<code>@public</code>, 这样才能在外部访问</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface Dog : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @<span class="keyword">public</span></span><br><span class="line">    NSString *age;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="built_in">property</span> (copy, nonatomic) NSString *petName;</span><br></pre></td></tr></table></figure></li><li><p>接下来给狗狗对象<code>d</code> 添加属性<code>petName</code>、成员变量<code>age</code> 的KVO方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[self.d addObserver:self forKeyPath:@<span class="string">&quot;petName&quot;</span> options:(NSKeyValueObservingOptionNew) context:<span class="literal">NULL</span>];</span><br><span class="line">[self.d addObserver:self forKeyPath:@<span class="string">&quot;age&quot;</span> options:(NSKeyValueObservingOptionNew) context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure></li><li><p>添加一个改变属性的点击事件。当点击屏幕，给d 的属性和成员变量赋值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    self.d.petName = @<span class="string">&quot;Jacob&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;self.petName-%@&quot;</span>, self.d.petName);</span><br><span class="line">    </span><br><span class="line">    self.d-&gt;age = @<span class="string">&quot;18&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;self.age-%@&quot;</span>, self.d-&gt;age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行，点击屏幕，监控键值变化如下：</p><p><img src="/p/78de752a/002.png"></p></li></ol><p>可见打印结果中，<code>self.petName</code> 的值变化，得到了打印验证；而 <code>self.d-&gt;age</code> 作为公开出来的成员变量，并不会在其值发生改变打印。为什么呢?</p><p>我们都知道属性创建之后，系统会自动配置setter 方法和getter 方法；</p><p>而成员变量，则是需要手动添加setter&#x2F;getter 方法，区别就在setter 方法未实现。</p><p>所以我们得知，<strong>KVO 监控的是变量的setter 方法</strong></p><h3 id="2-4-动态子类会重写方法"><a href="#2-4-动态子类会重写方法" class="headerlink" title="2.4 动态子类会重写方法"></a>2.4 动态子类会重写方法</h3><p>在上文得知，会动态生成<code>NSKeyValueNotifying__XXX</code> 的子类后，不免想要看看这个新的类，究竟实现了那些内容。</p><p>先看看类里面有哪些方法，写一个遍历类的方法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - 遍历方法-ivar-property</span></span><br><span class="line">- (<span class="type">void</span>)printClassAllMethod:(Class)cls&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;*********************&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Method *methodList = <span class="built_in">class_copyMethodList</span>(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        SEL sel = <span class="built_in">method_getName</span>(method);</span><br><span class="line">        IMP imp = <span class="built_in">class_getMethodImplementation</span>(cls, sel);</span><br><span class="line">        <span class="built_in">NSLog</span>(@<span class="string">&quot;%@-%p&quot;</span>,<span class="built_in">NSStringFromSelector</span>(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入这个新的类：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[self printClassAllMethod: <span class="built_in">NSClassFromString</span>(@<span class="string">&quot;NSKVONotifying_Dog&quot;</span>)];</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src="/p/78de752a/003.png"></p><p>可见实现的类有如下:</p><ul><li>set 方法 ——setPetName</li><li>class 方法</li><li>dealloc 方法</li><li>_isKVOA 键的标识</li></ul><h3 id="2-5-KVO移除时操作"><a href="#2-5-KVO移除时操作" class="headerlink" title="2.5 KVO移除时操作"></a>2.5 KVO移除时操作</h3><p>当对一个对象的监控结束后，会移除KVO 监控，这时候会发生什么呢？</p><h4 id="2-5-1-isa-指回原类"><a href="#2-5-1-isa-指回原类" class="headerlink" title="2.5.1 isa 指回原类"></a>2.5.1 isa 指回原类</h4><p>试验一下，在<code>dealloc</code> 方法，添加移除方法，并在前后打印类的名字</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSLog(@&quot;移除前，类名为:    %s&quot;, object_getClassName(self.d));</span><br><span class="line">[self.d removeObserver:self  forKeyPath:@&quot;petName&quot;];</span><br><span class="line">[self.d removeObserver:self  forKeyPath:@&quot;age&quot;];</span><br><span class="line">NSLog(@&quot;移除后，类名为:    %s\n&quot;, object_getClassName(self.d));</span><br></pre></td></tr></table></figure><p><img src="/p/78de752a/004.png"></p><p>在这里可以清晰的看到，当移除KVO 观测属性值后，这个动态子类，又变回了<code>Dog</code>类，即isa 指向又从动态子类，指向了原来的类</p><h4 id="2-5-2-动态子类会缓存"><a href="#2-5-2-动态子类会缓存" class="headerlink" title="2.5.2 动态子类会缓存"></a>2.5.2 动态子类会缓存</h4><p>那么移除KVO 后，动态子类是否销毁？</p><p>打印一下当前<code>d </code> 的类的子类即可，先定义一个打印方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)printClasses:(Class)cls&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册类的总数</span></span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">objc_getClassList</span>(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建一个数组， 其中包含给定对象</span></span><br><span class="line">    NSMutableArray *mArray = [NSMutableArray arrayWithObject:cls];</span><br><span class="line">    <span class="comment">// 获取所有已注册的类</span></span><br><span class="line">    Class* classes = (Class*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Class)*count);</span><br><span class="line">    <span class="built_in">objc_getClassList</span>(classes, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cls == <span class="built_in">class_getSuperclass</span>(classes[i])) &#123;</span><br><span class="line">            [mArray addObject:classes[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(classes);</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;classes = %@&quot;</span>, mArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行对<code>self.d</code> 的打印</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;*************移除前&quot;</span>);</span><br><span class="line">    [self printClasses:[self.d <span class="keyword">class</span>]];</span><br><span class="line">    [self.d removeObserver:self  forKeyPath:@<span class="string">&quot;petName&quot;</span>];</span><br><span class="line">    [self.d removeObserver:self  forKeyPath:@<span class="string">&quot;age&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;*************移除后&quot;</span>);</span><br><span class="line">    [self printClasses:[self.d <span class="keyword">class</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果如下：</p><p><img src="/p/78de752a/005.png"></p><p>很显然，这里的NSKVONotifying_Dog， 依旧存在，我们可以大胆推断，这里应该是缓存下来，方便下次再进行调用。</p><p>原理图如下：</p><p><img src="/p/78de752a/006.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> KVO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（3）循环链表(单向)</title>
      <link href="/p/54688.html"/>
      <url>/p/54688.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p><a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p><a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p><a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p><a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p><a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p><a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p></blockquote><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><blockquote><p>将单链表中终点结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相连的单链表称为单循环链表，简称循环链表（<em>circular linked list</em>）。</p></blockquote><p>我们先讨论的是单向循环链表，示意图如下所示:</p><p><img src="/p/54688/001.png" alt="单向循环链表结构图"></p><h3 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h3><h4 id="2-1-创建单向循环链表"><a href="#2-1-创建单向循环链表" class="headerlink" title="2.1 创建单向循环链表"></a>2.1 创建单向循环链表</h4><p>创建逻辑主要有下面的步骤:</p><p>先判断是否<strong>第一次</strong>创建？</p><ol><li>是（空链表）：创建一个结点，使新结点next 指向自身</li><li>否：使尾节点的next&#x3D;新节点。新节点的next指向头节点</li></ol><p>下面用代码解释一下：</p><ol><li>先定义一个结点(结构体)，定一个别名：</li></ol>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建一些变量，以供环境使用：</li></ol>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateList</span><span class="params">(LinkList *L)</span>&#123;</span><br><span class="line"><span class="type">int</span> item;</span><br><span class="line">    LinkList temp = <span class="literal">NULL</span>;</span><br><span class="line">    LinkList target = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>接下来判断这个链表<code>*L</code> 是否为空：</li></ol>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(*L==<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>如果输入的链表是空的</strong>——则创建一个结点，使它的<code>next</code>指向自己：</li></ol>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateList</span><span class="params">(LinkList *L)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入节点的值，输入0结束\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">        <span class="keyword">if</span>(item==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">          <span class="comment">//如果输入的链表是空。则创建一个新的节点，使其next指针指向自己  (*head)-&gt;next=*head;</span></span><br><span class="line">        <span class="keyword">if</span>(*L==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">            <span class="keyword">if</span>(!L)<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            (*L)-&gt;data=item;</span><br><span class="line">            (*L)-&gt;next=*L;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>如果链表不为空</strong>——则去<strong>寻找链表的尾结点</strong>。</li></ol><p>  这里寻找尾结点可以有两种实现方式：</p><ol><li><p>遍历尾结点，根据<strong>尾结点指针会指向首元结点</strong>来定位到尾结点。</p><ul><li>1、使得尾结点的next 指向新结点。</li><li>2、新结点的next 指向头结点。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (target = *L; target-&gt;next != *L; target = target-&gt;next);</span><br><span class="line"><span class="comment">// 为新结点开辟内存空间            </span></span><br><span class="line">temp=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="comment">// 如开辟失败，返回错误            </span></span><br><span class="line"><span class="keyword">if</span>(!temp) <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="comment">// 新结点写入数据            </span></span><br><span class="line">temp-&gt;data=item;</span><br><span class="line">temp-&gt;next=*L;  <span class="comment">//新节点指向头节点</span></span><br><span class="line">target-&gt;next=temp;<span class="comment">//尾节点指向新节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个工具结点<code>r</code>，用它来灵活处理以后一个结点（<strong>后插法</strong>）</p></li></ol><pre><code> 1. 新建一个 `r`    <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList r = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure> 2. 在该链表创建时，将唯一的结点赋值给`r`    <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一次创建</span></span><br><span class="line"><span class="keyword">if</span>(*L == <span class="literal">NULL</span>)&#123;       </span><br><span class="line">   *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">   <span class="keyword">if</span>(!*L) <span class="keyword">return</span> ERROR;</span><br><span class="line">   (*L)-&gt;data = item;</span><br><span class="line">   (*L)-&gt;next = *L;</span><br><span class="line">   r = *L;</span><br></pre></td></tr></table></figure> 3. 创建新的结点，进行赋值，`next`指向原链表首结点    <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="keyword">if</span>(!temp) <span class="keyword">return</span>  ERROR;</span><br><span class="line">temp-&gt;data = item;</span><br><span class="line">temp-&gt;next = *L;</span><br></pre></td></tr></table></figure> 4. 把原最后一个结点的尾结点指向新结点，以及新结点赋值给工具结点`r`    <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r-&gt;next = temp;</span><br></pre></td></tr></table></figure> 这样，闭环完成，整个过程示意图可以用下面的图实现：</code></pre><p>  <img src="/p/54688/002.png"></p><h4 id="2-2-单向循环链表插入数据"><a href="#2-2-单向循环链表插入数据" class="headerlink" title="2.2 单向循环链表插入数据"></a>2.2 单向循环链表插入数据</h4><p>分两种情况，插入点是否为首元结点</p><h5 id="2-2-1-插入点位首元结点"><a href="#2-2-1-插入点位首元结点" class="headerlink" title="2.2.1 插入点位首元结点"></a>2.2.1 插入点位首元结点</h5><ol><li>创建新结点并进行赋值</li><li>找到链表最后的结点——尾结点</li><li>让新结点的<code>next</code> 指向头结点</li><li>让尾结点的 <code>next </code> 指向新的头结点</li><li>让头结点指向<code>temp</code> ——临时的新结点</li></ol><p>具体代码实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;data = num;</span><br><span class="line"><span class="keyword">for</span> (target = *L; target-&gt;next != *L; target = target-&gt;next);</span><br><span class="line">temp-&gt;next = *L;</span><br><span class="line">target-&gt;next = temp;</span><br><span class="line">*L = temp;</span><br></pre></td></tr></table></figure><p>如图所示：<br><img src="/p/54688/003.png"></p><h5 id="2-2-2-插入点非首元结点"><a href="#2-2-2-插入点非首元结点" class="headerlink" title="2.2.2 插入点非首元结点"></a>2.2.2 插入点非首元结点</h5><ol><li>创建新结点 <code>temp</code>，并判断成功与否</li><li>找到插入的位置，如果超过链表长度，则自动插入队尾</li><li>通过工具<code>target</code> 找到要插入位置的前一个结点，让 <code>target-&gt;next = temp</code></li><li>插入结点的前一个结点<code>next</code> 指向新结点，新结点<code>next</code>指向<code>target</code>原来的next 位</li></ol><p>具体代码实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;data = num;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">1</span>,target = *L; target-&gt;next != *L &amp;&amp; i != place - <span class="number">1</span>; target = target-&gt;next,i++) ;</span><br><span class="line">temp-&gt;next = target-&gt;next;</span><br><span class="line">target-&gt;next = temp;</span><br></pre></td></tr></table></figure><p><img src="/p/54688/004.png"></p><h4 id="2-3-单向循环链表的删除"><a href="#2-3-单向循环链表的删除" class="headerlink" title="2.3 单向循环链表的删除"></a>2.3 单向循环链表的删除</h4><p>单向循环链表的删除，与顺序表的删除很类似，步骤都是先确定需要删除的位置，通过判断是否首元结点，做不同的操作。具体操作步骤如下：</p><h5 id="2-3-1-删除点为首元结点"><a href="#2-3-1-删除点为首元结点" class="headerlink" title="2.3.1 删除点为首元结点"></a>2.3.1 删除点为首元结点</h5><ul><li><p>如果本链表只剩首元结点，则直接将*L 置为空；</p><p>实施代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((*L)-&gt;next == (*L))&#123;</span><br><span class="line">    (*L) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果本链表还剩其他结点</p><ol><li>找到尾结点 <code>target</code></li><li>尾结点 <code>next</code> 指向原来首元结点的下一个结点，即 <code>target-&gt;next = (*L)-&gt;next</code></li><li>用 <code>temp</code> 临时接收首元结点</li><li>新结点为首元结点</li><li>释放之前的接收的首元结点 <code>temp</code></li></ol><p>实施代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤 1⃣️</span></span><br><span class="line"><span class="keyword">for</span> (target = *L; target-&gt;next != *L; target = target-&gt;next);</span><br><span class="line"><span class="comment">// 步骤 2⃣️</span></span><br><span class="line">temp = *L;</span><br><span class="line"><span class="comment">// 步骤 3⃣️</span></span><br><span class="line">*L = (*L)-&gt;next;</span><br><span class="line"><span class="comment">// 步骤 4⃣️</span></span><br><span class="line">target-&gt;next = *L;</span><br><span class="line"><span class="comment">// 步骤 5⃣️</span></span><br><span class="line"><span class="built_in">free</span>(temp);</span><br></pre></td></tr></table></figure></li></ul><p><img src="/p/54688/005.png"></p><h5 id="2-3-2-删除点为非首元结点"><a href="#2-3-2-删除点为非首元结点" class="headerlink" title="2.3.2 删除点为非首元结点"></a>2.3.2 删除点为非首元结点</h5><ol><li>找到需要删除结点的上一个结点，用<code>target</code>表示</li><li>用<code>temp</code>临时接受需要删除的结点</li><li><code>target</code> 的<code>next</code> 指之前指向的下一个结点</li><li>释放<code>temp</code>结点</li></ol><p>实施代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤 1⃣️</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>,target = *L;target-&gt;next != *L &amp;&amp; i != place <span class="number">-1</span>;target = target-&gt;next,i++);</span><br><span class="line"><span class="comment">// 步骤 2⃣️</span></span><br><span class="line">temp = target-&gt;next;</span><br><span class="line"><span class="comment">// 步骤 3⃣️</span></span><br><span class="line">target-&gt;next = temp-&gt;next;</span><br><span class="line"><span class="comment">// 步骤 4⃣️</span></span><br><span class="line"><span class="built_in">free</span>(temp);</span><br></pre></td></tr></table></figure><p>示意图如下：</p><p><img src="/p/54688/006.png"></p><h4 id="2-4-单向链表的查询"><a href="#2-4-单向链表的查询" class="headerlink" title="2.4 单向链表的查询"></a>2.4 单向链表的查询</h4><p>这里仅仅讨论下简单的链表查询，步骤如下：</p><ol><li>循环查找链表中给定值的结点</li><li>若查询的结点指向首元结点，并且此时尾结点值也不为所需，跳出</li></ol><p>实施代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"> LinkList p;</span><br><span class="line"> p = L;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1⃣️ 寻找链表中的结点 data == value</span></span><br><span class="line"> <span class="keyword">while</span> (p-&gt;data != value &amp;&amp; p-&gt;next != L) &#123;</span><br><span class="line">     i++;</span><br><span class="line">     p = p-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2⃣️ 当尾结点指向头结点就会直接跳出循环,所以要额外增加一次判断尾结点的data == value;</span></span><br><span class="line"> <span class="keyword">if</span> (p-&gt;next == L &amp;&amp; p-&gt;data != value) &#123;</span><br><span class="line">     <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h3><p>单向循环链表与顺序表有些许相似，但是不同点在于，它并非是按照序号排列，而是通过<strong>指针的指向</strong>进行连接，而且有首尾相连的特点。</p>]]></content>
      
      
      <categories>
          
          <category> ios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【底层探索】- KVC原理分析</title>
      <link href="/p/f704cb0c.html"/>
      <url>/p/f704cb0c.html</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><h3 id="思考拓展题"><a href="#思考拓展题" class="headerlink" title="思考拓展题"></a>思考拓展题</h3><p>为什么先进入<code>objc_setProperty_atomic_copy</code> 方法，而不是<code>setName:</code>?</p><h3 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h3><p><strong>通用原则</strong>。即面向不同的数据类型，采用统一的属性设值的方法，会更加的高效，符合<u><strong>高内聚</strong></u>的原则。</p><h2 id="一、概念及常见使用"><a href="#一、概念及常见使用" class="headerlink" title="一、概念及常见使用"></a>一、概念及常见使用</h2><h3 id="1-0-概念"><a href="#1-0-概念" class="headerlink" title="1.0 概念"></a>1.0 概念</h3><blockquote><p>KVC(Key-Value coding) 是一个由<code>NSKeyValueCoding</code> 协议触发的机制，允许对象通过该机制获取他们的属性。当一个对象符合KVC 原则，它的属性就可以用字符串通过一个简洁、相同的信息接口快捷访问到。</p><p>这种简洁访问机制，借助实例变量量和关联存取方法补充了对象直接访问的机制。</p></blockquote><p>相关链接：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html">关于KVC(Apple Opensource)</a></p><h3 id="1-1-简单使用"><a href="#1-1-简单使用" class="headerlink" title="1.1 简单使用"></a>1.1 简单使用</h3><p>假设有类<code>BankAccount</code>，有众多属性如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface BankAccount : NSObject</span><br><span class="line"> </span><br><span class="line">@<span class="built_in">property</span> (nonatomic) NSNumber* currentBalance;              <span class="comment">// An attribute</span></span><br><span class="line">@<span class="built_in">property</span> (nonatomic) Person* owner;                         <span class="comment">// A to-one relation</span></span><br><span class="line">@<span class="built_in">property</span> (nonatomic) NSArray&lt; Transaction* &gt;* transactions; <span class="comment">// A to-many relation</span></span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>给起通过KVC属性赋值，如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[myAccount setValue:@(<span class="number">100.0</span>) forKey:@<span class="string">&quot;currentBalance&quot;</span>];</span><br></pre></td></tr></table></figure><h3 id="1-2-集合类型"><a href="#1-2-集合类型" class="headerlink" title="1.2 集合类型"></a>1.2 集合类型</h3><p>对数组进行修改：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">person.array = [@<span class="string">&quot;1&quot;</span>, @<span class="string">&quot;2&quot;</span>, @<span class="string">&quot;3&quot;</span>];</span><br></pre></td></tr></table></figure><ul><li>方法一、创建新的数组（普通方法）</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NSArray *array = [person valueForKey:@<span class="string">&quot;array&quot;</span>];</span><br><span class="line"><span class="comment">// 用 array 的值创建一个新的数组</span></span><br><span class="line">array = @[@<span class="string">&quot;100&quot;</span>,@<span class="string">&quot;2&quot;</span>,@<span class="string">&quot;3&quot;</span>];</span><br><span class="line">[person setValue:array forKey:@<span class="string">&quot;array&quot;</span>];</span><br></pre></td></tr></table></figure><ul><li>方法二、通过可变数组赋值（KVC）</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NSMutableArray *ma = [person mutableArrayValueForKey:@<span class="string">&quot;array&quot;</span>];</span><br><span class="line">ma[<span class="number">0</span>] = @<span class="string">&quot;100&quot;</span>;</span><br></pre></td></tr></table></figure><p>可见可变数组实行KVC 方法，更为简洁</p><h3 id="1-3-集合操作符"><a href="#1-3-集合操作符" class="headerlink" title="1.3 集合操作符"></a>1.3 集合操作符</h3><p>集合操作符如下：</p><p><img src="/p/f704cb0c/002.jpg"></p><p>比如某个模型结构如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface Transaction : NSObject</span><br><span class="line"> </span><br><span class="line">@<span class="built_in">property</span> (nonatomic) NSString* payee;   <span class="comment">// To whom</span></span><br><span class="line">@<span class="built_in">property</span> (nonatomic) NSNumber* amount;  <span class="comment">// How much</span></span><br><span class="line">@<span class="built_in">property</span> (nonatomic) NSDate* date;      <span class="comment">// When</span></span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>想要获取多个<code>Transaction</code> 的<code>payee</code> 属性的结合，可以用集合运算符</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NSArray *distinctPayees = [self.transactions valueForKeyPath:@<span class="string">&quot;@distinctUnionOfObjects.payee&quot;</span>];</span><br></pre></td></tr></table></figure><p>可见，集合运算符主要在于获取对象的值</p><h3 id="1-4-访问非对象属性"><a href="#1-4-访问非对象属性" class="headerlink" title="1.4 访问非对象属性"></a>1.4 访问非对象属性</h3><blockquote><p>问题：如何访问结构体？</p></blockquote><p>这个问题经常出现在C、C++混编的环境下出现，解决的防范也比较简单，由于结构体并不遵循Key-Value Coding，可以先将其转为遵循KVC的<code>NSValue</code> 类型，然后通过KVC 对其进行存取。</p><p>给一个结构体<code>ThreeFloats</code>，作为<code>Person</code> 的属性出现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">float</span> x, y, z;</span><br><span class="line">&#125; ThreeFloats;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject&#123;&#125;</span><br><span class="line"></span><br><span class="line">@<span class="built_in">property</span> (nonatomic)         ThreeFloats       threeFloats;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li><p>转换为NSValue</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ThreeFloats floats = &#123;<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>&#125;;</span><br><span class="line">NSValue *value  = [NSValue valueWithBytes:&amp;floats objCType:@<span class="built_in">encode</span>(ThreeFloats)];</span><br></pre></td></tr></table></figure></li><li><p>存其值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[person setValue:value forKey:@<span class="string">&quot;threeFloats&quot;</span>];</span><br><span class="line">NSValue *reslut = [person valueForKey:@<span class="string">&quot;threeFloats&quot;</span>];</span><br></pre></td></tr></table></figure></li><li><p>取其值 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ThreeFloats th;</span><br><span class="line">[reslut getValue:&amp;th] ;</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;%f - %f - %f&quot;</span>,th.x,th.y,th.z);</span><br></pre></td></tr></table></figure></li></ul><p>打印结果如下：</p><p><img src="/p/f704cb0c/001.png"></p><h3 id="1-5-通过keyPath-实现多级访问"><a href="#1-5-通过keyPath-实现多级访问" class="headerlink" title="1.5 通过keyPath 实现多级访问"></a>1.5 通过keyPath 实现多级访问</h3><p>这种情况出现在多级对象属性的情况下，如下面：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface Person : NSObject&#123;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong) LGStudent         *student;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface Student : NSObject</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, copy)   NSString          *name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Student *student = [[Student alloc] init];</span><br><span class="line">student.subject    = @<span class="string">&quot;iOS&quot;</span>;</span><br><span class="line">person.student     = student;</span><br></pre></td></tr></table></figure><ul><li><p>存值</p><p>通过keyPath 设置值的方式如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[person setValue:@&quot;大师班&quot; forKeyPath:@&quot;student.subject&quot;];</span><br></pre></td></tr></table></figure><p>这里用到了<code>student.subject</code> 实现多级别访问</p></li><li><p>取值</p><p>也通过<code>student.subject</code> 实现多级别访问</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,[person valueForKeyPath:@<span class="string">&quot;student.subject&quot;</span>]);</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、KVC-原理剖析"><a href="#二、KVC-原理剖析" class="headerlink" title="二、KVC 原理剖析"></a>二、KVC 原理剖析</h2><h3 id="2-1-分析Setter-调用过程"><a href="#2-1-分析Setter-调用过程" class="headerlink" title="2.1 分析Setter 调用过程"></a>2.1 分析Setter 调用过程</h3><p>对对象对实例变量赋值的流程如下：</p><ol><li>查找setter 方法，如果存在，赋值成功</li><li>查看 accessInstanceVariablesDirectly （直接访问成员遍历）是否开启<ol><li>若开启，查找 _<key>, _is<Key>, <key>, or is<Key></Key></key></Key></key></li><li>若未开启，直接给变量赋值</li></ol></li><li>若以上都没执行，会报错，结果位 <code>setValue:forUndefinedKey</code></li></ol><h3 id="2-2-分析Getter-取值过程"><a href="#2-2-分析Getter-取值过程" class="headerlink" title="2.2 分析Getter 取值过程"></a>2.2 分析Getter 取值过程</h3><ol><li><p>先查找Getter 方法，如果存在，取值成功。</p><p>采用的是标准的getter 方法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">get&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;, or _&lt;key&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果非集合类型：查看 accessInstanceVariablesDirectly （直接访问成员遍历）是否开启</p><ol><li>如果开启——通过 _<key>, _is<Key>, <key>, or is<Key> 查找实现取值</Key></key></Key></key></li><li>如果关闭——其他查找</li></ol></li><li><p>如果没有，直接赋值</p></li><li><p>报错 <code>valueForUndefinedKey</code></p></li></ol><h2 id="三、自定义KVC-方法"><a href="#三、自定义KVC-方法" class="headerlink" title="三、自定义KVC 方法"></a>三、自定义KVC 方法</h2><p>上面理解了KVC 的设值与取值过程，尝试自定义一个KVC。其实分析完上面的设值与取值，仿造的过程也是依样画葫芦。具体步骤如下：</p><h3 id="3-1-Setter-方法"><a href="#3-1-Setter-方法" class="headerlink" title="3.1 Setter 方法"></a>3.1 Setter 方法</h3><ol><li><p>创建一个类的分类。在分类里创建取值和赋值的方法，有如下方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)lg_setValue:(nullable id)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure></li><li><p>判断key 的有效性</p></li></ol>   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!key) || key.length == <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>找到相应的的 set<Key>、 _set<Key>、setIs<Key> 方法，主要看本类是否相应对应名字的方法，实现如下：</Key></Key></Key></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *Key = key.capitalizedString;</span><br><span class="line">// 拼接方法</span><br><span class="line">NSString *setKey = [NSString stringWithFormat:@&quot;set%@:&quot;,Key];</span><br><span class="line">NSString *_setKey = [NSString stringWithFormat:@&quot;_set%@:&quot;,Key];</span><br><span class="line">NSString *setIsKey = [NSString stringWithFormat:@&quot;setIs%@:&quot;,Key];</span><br><span class="line"></span><br><span class="line">if ([self lg_performSelectorWithMethodName:setKey value:value]) &#123;</span><br><span class="line">    NSLog(@&quot;*********%@**********&quot;,setKey);</span><br><span class="line">    return;</span><br><span class="line">&#125;else if ([self lg_performSelectorWithMethodName:_setKey value:value]) &#123;</span><br><span class="line">    NSLog(@&quot;*********%@**********&quot;,_setKey);</span><br><span class="line">    return;</span><br><span class="line">&#125;else if ([self lg_performSelectorWithMethodName:setIsKey value:value]) &#123;</span><br><span class="line">    NSLog(@&quot;*********%@**********&quot;,setIsKey);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   看是否响应该方法</p>   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (BOOL)lg_performSelectorWithMethodName:(NSString *)methodName value:(id)value&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ([self respondsToSelector:<span class="built_in">NSSelectorFromString</span>(methodName)]) &#123;</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Warc-performSelector-leaks&quot;</span></span></span><br><span class="line">        [self performSelector:<span class="built_in">NSSelectorFromString</span>(methodName) withObject:value];</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>判断是否能直接赋值实例变量</p><ol><li>这是一个重要的开关.开启，则可以通过手动设值，跳到5</li><li>如果关闭，则由于本类不相应对应的setter 方法，无法有效赋值，会进行异常抛出如下：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (![self.<span class="keyword">class</span> accessInstanceVariablesDirectly] ) &#123;</span><br><span class="line">        @<span class="keyword">throw</span> [NSException exceptionWithName:@<span class="string">&quot;LGUnknownKeyException&quot;</span> reason:[NSString stringWithFormat:@<span class="string">&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;</span>,self] userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>找到相应的实例变量进行复制</p><ol><li><p>定义一个收集实例变量的的可变数组</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NSMutableArray *mArray = [self getIvarListName];</span><br><span class="line"><span class="comment">// _&lt;key&gt; _is&lt;Key&gt; &lt;key&gt; is&lt;Key&gt;</span></span><br><span class="line">NSString *_key = [NSString stringWithFormat:@<span class="string">&quot;_%@&quot;</span>,key];</span><br><span class="line">NSString *_isKey = [NSString stringWithFormat:@<span class="string">&quot;_is%@&quot;</span>,Key];</span><br><span class="line">NSString *isKey = [NSString stringWithFormat:@<span class="string">&quot;is%@&quot;</span>,Key];</span><br></pre></td></tr></table></figure></li><li><p>获取相应的 ivar</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([mArray containsObject:_key]) &#123;</span><br><span class="line">        <span class="comment">// 4.2 获取相应的 ivar</span></span><br><span class="line">       Ivar ivar = <span class="built_in">class_getInstanceVariable</span>([self <span class="keyword">class</span>], _key.UTF8String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对相应的ivar 设置值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.3 对相应的 ivar 设置值</span></span><br><span class="line"><span class="built_in">object_setIvar</span>(self , ivar, value);</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>找不到相应的实例——报错处理</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">throw</span> [NSException exceptionWithName:@<span class="string">&quot;UnknownKeyException&quot;</span> reason:[NSString stringWithFormat:@<span class="string">&quot;****[%@ %@]: this class is not key value coding-compliant for the key name.****&quot;</span>,self,<span class="built_in">NSStringFromSelector</span>(_cmd)] userInfo:nil];</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-Getter-方法"><a href="#3-2-Getter-方法" class="headerlink" title="3.2 Getter 方法"></a>3.2 Getter 方法</h3><p>getter 方法与 Setter 方法相仿，继续进行一下</p><ol><li><p>设置自定义的getter 方法。代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (id)lj_valueForKey: (NSString *)key;</span><br></pre></td></tr></table></figure></li><li><p>判断key，保证不为空</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key == nil  || key.length == <span class="number">0</span>) </span><br><span class="line">   <span class="keyword">return</span> nil;</span><br></pre></td></tr></table></figure></li><li><p>找到对应的get<Key>、<key>、countOf<Key> 、objectIn<Key>AtIndex 等直接取值的方法。后两种一般是集合类型（数组等）用到的方法。</Key></Key></key></Key></p><ol><li><p>先对键<code>Key</code> 进行大写转换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// key 要大写</span><br><span class="line">NSString *Key = key.capitalizedString;</span><br></pre></td></tr></table></figure></li><li><p>用get、countOf、objectIn 等方法，对key拼接</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 拼接方法</span></span><br><span class="line">NSString *getKey = [NSString stringWithFormat:@<span class="string">&quot;get%@&quot;</span>,Key];</span><br><span class="line">NSString *countOfKey = [NSString stringWithFormat:@<span class="string">&quot;countOf%@&quot;</span>,Key];</span><br><span class="line">NSString *objectInKeyAtIndex = [NSString stringWithFormat:@<span class="string">&quot;objectIn%@AtIndex:&quot;</span>,Key];</span><br></pre></td></tr></table></figure></li><li><p>判断本类是否相应对应的get<Key>、countOf<Key>、objectIn<Key>AtIndex 方法，如果有，就执行该方法，直接获取到对应的值。</Key></Key></Key></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Warc-performSelector-leaks&quot;</span></span></span><br><span class="line">    <span class="keyword">if</span> ([self respondsToSelector:<span class="built_in">NSSelectorFromString</span>(getKey)]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [self performSelector:<span class="built_in">NSSelectorFromString</span>(getKey)];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([self respondsToSelector:<span class="built_in">NSSelectorFromString</span>(key)])&#123;</span><br><span class="line">        <span class="keyword">return</span> [self performSelector:<span class="built_in">NSSelectorFromString</span>(key)];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([self respondsToSelector:<span class="built_in">NSSelectorFromString</span>(countOfKey)])&#123;</span><br><span class="line">        <span class="keyword">if</span> ([self respondsToSelector:<span class="built_in">NSSelectorFromString</span>(objectInKeyAtIndex)]) &#123;</span><br><span class="line">            <span class="type">int</span> num = (<span class="type">int</span>)[self performSelector:<span class="built_in">NSSelectorFromString</span>(countOfKey)];</span><br><span class="line">            NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;num<span class="number">-1</span>; i++) &#123;</span><br><span class="line">                num = (<span class="type">int</span>)[self performSelector:<span class="built_in">NSSelectorFromString</span>(countOfKey)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j&lt;num; j++) &#123;</span><br><span class="line">                id objc = [self performSelector:<span class="built_in">NSSelectorFromString</span>(objectInKeyAtIndex) withObject:@(num)];</span><br><span class="line">                [mArray addObject:objc];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mArray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>此时判断能否直接赋值实例变量。用到的是该类的<code>accessInstanceVariablesDirectly</code> 属性是否开启。</p><ul><li><p>如果已打开，则表示可以通过取其 _<key>、_is<Key>、<key>、is<Key> 来取值，跳到5</Key></key></Key></key></p></li><li><p>若未打开，抛出异常，表示找不到该键对应值</p><p>相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (![self.<span class="keyword">class</span> accessInstanceVariablesDirectly] ) &#123;</span><br><span class="line">        @<span class="keyword">throw</span> [NSException exceptionWithName:@<span class="string">&quot;LGUnknownKeyException&quot;</span> reason:[NSString stringWithFormat:@<span class="string">&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;</span>,self] userInfo:nil];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>找到实例变量，进行取值</p><ul><li><p>定义一个收集实例变量的可变数组：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">Ivar *ivars = <span class="built_in">class_copyIvarList</span>([self <span class="keyword">class</span>], &amp;count);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">    Ivar ivar = ivars[i];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ivarNameChar = <span class="built_in">ivar_getName</span>(ivar);</span><br><span class="line">    NSString *ivarName = [NSString stringWithUTF8String:ivarNameChar];</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;ivarName == %@&quot;</span>,ivarName);</span><br><span class="line">    [mArray addObject:ivarName];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(ivars);</span><br></pre></td></tr></table></figure></li><li><p>依次判断该数组是否包含键关键字，其顺序为 _key——&gt; _isKey——&gt; key——&gt; isKey，通过找到的关键字，进行取值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NSString *_key = [NSString stringWithFormat:@<span class="string">&quot;_%@&quot;</span>,key];</span><br><span class="line">NSString *_isKey = [NSString stringWithFormat:@<span class="string">&quot;_is%@&quot;</span>,Key];</span><br><span class="line">NSString *isKey = [NSString stringWithFormat:@<span class="string">&quot;is%@&quot;</span>,Key];</span><br><span class="line"><span class="keyword">if</span> ([mArray containsObject:_key]) &#123;</span><br><span class="line">    Ivar ivar = <span class="built_in">class_getInstanceVariable</span>([self <span class="keyword">class</span>], _key.UTF8String);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getIvar</span>(self, ivar);;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">    Ivar ivar = <span class="built_in">class_getInstanceVariable</span>([self <span class="keyword">class</span>], _isKey.UTF8String);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getIvar</span>(self, ivar);;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> ([mArray containsObject:key]) &#123;</span><br><span class="line">    Ivar ivar = <span class="built_in">class_getInstanceVariable</span>([self <span class="keyword">class</span>], key.UTF8String);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getIvar</span>(self, ivar);;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> ([mArray containsObject:isKey]) &#123;</span><br><span class="line">    Ivar ivar = <span class="built_in">class_getInstanceVariable</span>([self <span class="keyword">class</span>], isKey.UTF8String);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getIvar</span>(self, ivar);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="四、KVC-实用小技巧"><a href="#四、KVC-实用小技巧" class="headerlink" title="四、KVC 实用小技巧"></a>四、KVC 实用小技巧</h2><h3 id="4-1-自动转换类型"><a href="#4-1-自动转换类型" class="headerlink" title="4.1 自动转换类型"></a>4.1 自动转换类型</h3><blockquote><p>KVC 具备自动转换数据类型的功能</p></blockquote><p>当我们对Int 类型的属性，添加字符串的类型，正常是这样的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface LGPerson : NSObject </span><br><span class="line">@<span class="built_in">property</span> (nonatomic, assign) <span class="type">int</span>  age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">[person setValue:@<span class="number">18</span> forKey:@<span class="string">&quot;age&quot;</span>];</span><br></pre></td></tr></table></figure><p>那么下面这种方式能成功吗? </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[person setValue:@<span class="string">&quot;20&quot;</span> forKey:@<span class="string">&quot;age&quot;</span>]; </span><br></pre></td></tr></table></figure><p><img src="/p/f704cb0c/003.png"></p><p>可见是可以执行的，在通过KVC 设置之后，自动转换成了<code>int</code>类型，整个数据成为了NSCFNumber。可见其灵活程度！</p><h3 id="4-2-空值报警"><a href="#4-2-空值报警" class="headerlink" title="4.2 空值报警"></a>4.2 空值报警</h3><p>总有些时候，设置值可能会异常为空，那怎么办呢？可以通过重写空值报警来避免异常</p><ul><li><p>设值为空重写</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setNilValueForKey:(NSString *)key&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;报告! 设置 %@ 是空值&quot;</span>,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取值为空重写</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (id)valueForUndefinedKey:(NSString *)key&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;报告!!!: %@ 没有这个key - 给你一个其他的吧,别奔溃了!&quot;</span>,key);</span><br><span class="line">    <span class="keyword">return</span> @<span class="string">&quot;Master 牛逼&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-键值验证"><a href="#4-3-键值验证" class="headerlink" title="4.3 键值验证"></a>4.3 键值验证</h3><p>当类对应的键的值还是找不到，即将要报错了，我们还是可以自行挽救一下——先验证对应的键值是否成功，如果不成功，自行报错并写补救方法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NSError *error;</span><br><span class="line">    NSString *name = @<span class="string">&quot;Good&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (![person validateValue:&amp;name forKey:@<span class="string">&quot;names&quot;</span> error:&amp;error]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,error);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,[person valueForKey:@<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现方法里，可以这样写</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: - 键值验证 - 容错 - 派发 - 消息转发</span></span><br><span class="line"></span><br><span class="line">- (BOOL)validateValue:(inout id  _Nullable __autoreleasing *)ioValue forKey:(NSString *)inKey error:(out NSError *__autoreleasing  _Nullable *)outError&#123;</span><br><span class="line">    <span class="keyword">if</span>([inKey isEqualToString:@<span class="string">&quot;name&quot;</span>])&#123;</span><br><span class="line">        [self setValue:[NSString stringWithFormat:@<span class="string">&quot;里面修改一下: %@&quot;</span>,*ioValue] forKey:inKey];</span><br><span class="line">        <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    *outError = [[NSError alloc]initWithDomain:[NSString stringWithFormat:@<span class="string">&quot;%@ 不是 %@ 的属性&quot;</span>,inKey,self] code:<span class="number">10088</span> userInfo:nil];</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>总的来说，KVC 是比较简单的一个章节，其原理是对类内部逐级查验，从set 方法、直接赋值开关、isKey 等键的取值实现赋值和取值的过程。而实现自定义KVC，则是依照逻辑一步一步写成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> KVC </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（2）线性表基础</title>
      <link href="/p/43366.html"/>
      <url>/p/43366.html</url>
      
        <content type="html"><![CDATA[<blockquote><p> <a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p> <a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p> <a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p> <a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p> <a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p> <a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p> <a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p></blockquote><h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p>上文学到了数据结构和算法的一些基础知识，接下来从最基础的概念，线性表说起。</p><h2 id="一、线性表的定义和特点"><a href="#一、线性表的定义和特点" class="headerlink" title="一、线性表的定义和特点"></a>一、线性表的定义和特点</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><blockquote><p>定义：零个或多个数据元素的有限序列</p></blockquote><p>线性表，顾名思义，就是有着和线一样特性的表。比如我们乘坐的火车，通常是由许多节车厢组成，车厢首尾相连，最终形成一辆火车。这样的结构，就可以成为线性表。</p><h3 id="1-2-线性表的抽象数据类型"><a href="#1-2-线性表的抽象数据类型" class="headerlink" title="1.2 线性表的抽象数据类型"></a>1.2 线性表的抽象数据类型</h3><p>线性表的抽象类型定义如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADT 线性表（List）</span><br><span class="line"></span><br><span class="line">Data：线性表的数据对象集合为&#123;a1,a2,......an&#125;,每个元素的类型均为DataType. 其中,除了第一个元素a1外,每一个元素有且只有一个直接前驱元素,除了最后一个元素an外,每个元素有且只有一个直接后继元素. 数据元素之间的关系是一对一的关系.</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line"></span><br><span class="line">InitList(*L) :初始化操作，建立一个空的线性表L&lt;sub&gt;0&lt;/sub&gt;</span><br><span class="line">ListEmpty(L) :    若线性表已存在，返回`true`; 否则返回`false`</span><br><span class="line">ClearList(*L):     将线性表清空</span><br><span class="line">GetElem(L, i, &amp;e): 将线性表L 中的第 i 个位置元素值返回给 e</span><br><span class="line">LocateElm（L，e）：在线性表L 中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回 0 表示失败</span><br><span class="line">ListInsert(*L, i, e): 在线性表L 中第 i 个位置插入新元素e</span><br><span class="line">ListDelete(*L, i, *e): 删除线性表L 中第 i 个位置元素，并用 e 返回其值</span><br><span class="line">ListLength(L):    返回线性表L 的元素个数</span><br><span class="line"></span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="1-3-线性表的顺序存储结构"><a href="#1-3-线性表的顺序存储结构" class="headerlink" title="1.3 线性表的顺序存储结构"></a>1.3 线性表的顺序存储结构</h3><h4 id="1-3-1-顺序存储定义"><a href="#1-3-1-顺序存储定义" class="headerlink" title="1.3.1 顺序存储定义"></a>1.3.1 顺序存储定义</h4><p>先来看看线性表两种物理结构的第一种：顺序存储结构</p><blockquote><p>定义：线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p></blockquote><p>示意图如下：</p><p><img src="/p/43366/001.png" alt="顺序存储示意图"> </p><h4 id="1-3-2-顺序存储方式"><a href="#1-3-2-顺序存储方式" class="headerlink" title="1.3.2 顺序存储方式"></a>1.3.2 顺序存储方式</h4><p>线性表的顺序存储结构，就是在内存中找了个空间，通过展位的方式，把一定内存空间给占了，然后把相同数据类型的数据元素一次存放在这块空地中。既然线性表的每个数据元素类型都相同，所以可以用C 语言的一维数组来实现顺序存储结构。</p><p>看看线性表的顺序存储的结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data[MaxSize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;Sqlist;</span><br></pre></td></tr></table></figure><p>通过观察可以发现，描述顺序存储结构需要三个属性：</p><ul><li>存储空间的起始位置：数组<code>data</code>，它的存储位置就是存储空间的存储位置。</li><li>线性表的最大存储容量：数组长度<code>MaxSize</code></li><li>线性表的当前长度: <code>length</code></li></ul><h4 id="1-3-3-数据长度与线性表长度区别"><a href="#1-3-3-数据长度与线性表长度区别" class="headerlink" title="1.3.3 数据长度与线性表长度区别"></a>1.3.3 数据长度与线性表长度区别</h4><ul><li>数组长度时存放线性表的存储空间的长度，存储分配后这个量<strong>一般是不变的</strong>。</li><li>线性表的长度时线性表中数据元素的个数，随着线性表的插入和删除操作的进行，这个量<strong>是变化的</strong>。</li><li>在任意时刻，线性表的长度应该<strong>小于等于</strong>数组的长度。</li></ul><h3 id="1-4-顺序表的基本操作"><a href="#1-4-顺序表的基本操作" class="headerlink" title="1.4 顺序表的基本操作"></a>1.4 顺序表的基本操作</h3><h4 id="1-4-1-顺序表的初始化"><a href="#1-4-1-顺序表的初始化" class="headerlink" title="1.4.1 顺序表的初始化"></a>1.4.1 顺序表的初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitList</span><span class="params">(Sqlist *L)</span>&#123;</span><br><span class="line">    <span class="comment">//为顺序表分配一个大小为MAXSIZE 的数组空间</span></span><br><span class="line">    L-&gt;data =  <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * MAXSIZE);</span><br><span class="line">    <span class="comment">//存储分配失败退出</span></span><br><span class="line">    <span class="keyword">if</span>(!L-&gt;data) <span class="built_in">exit</span>(ERROR);</span><br><span class="line">    <span class="comment">//空表长度为0</span></span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-顺序表的插入"><a href="#1-4-2-顺序表的插入" class="headerlink" title="1.4.2 顺序表的插入"></a>1.4.2 顺序表的插入</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 初始条件：顺序线性表L已存在,1≤i≤ListLength(L);</span></span><br><span class="line"><span class="comment"> 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(Sqlist *L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i值不合法判断</span></span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>) || (i&gt;L-&gt;length+<span class="number">1</span>)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="comment">//存储空间已满</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length == MAXSIZE) <span class="keyword">return</span> ERROR;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//插入数据不在表尾,则先移动出空余位置</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt;= L-&gt;length)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = L-&gt;length<span class="number">-1</span>; j&gt;=i<span class="number">-1</span>;j--)&#123;</span><br><span class="line">       </span><br><span class="line">            <span class="comment">//插入位置以及之后的位置后移动1位</span></span><br><span class="line">            L-&gt;data[j+<span class="number">1</span>] = L-&gt;data[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将新元素e 放入第i个位置上</span></span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>] = e;</span><br><span class="line">    <span class="comment">//长度+1;</span></span><br><span class="line">    ++L-&gt;length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-3-顺序表的取值"><a href="#1-4-3-顺序表的取值" class="headerlink" title="1.4.3 顺序表的取值"></a>1.4.3 顺序表的取值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">GetElem</span><span class="params">(Sqlist L,<span class="type">int</span> i, ElemType *e)</span>&#123;</span><br><span class="line">    <span class="comment">//判断i值是否合理, 若不合理,返回ERROR</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span>  ERROR;</span><br><span class="line">    <span class="comment">//data[i-1]单元存储第i个数据元素.</span></span><br><span class="line">    *e = L.data[i<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-3-顺序表的删除"><a href="#1-4-3-顺序表的删除" class="headerlink" title="1.4.3 顺序表的删除"></a>1.4.3 顺序表的删除</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 初始条件：顺序线性表L已存在，1≤i≤ListLength(L)</span></span><br><span class="line"><span class="comment"> 操作结果: 删除L的第i个数据元素,L的长度减1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(Sqlist *L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线性表为空</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length == <span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i值不合法判断</span></span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>) || (i&gt;L-&gt;length+<span class="number">1</span>)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; L-&gt;length;j++)&#123;</span><br><span class="line">        <span class="comment">//被删除元素之后的元素向前移动</span></span><br><span class="line">        L-&gt;data[j<span class="number">-1</span>] = L-&gt;data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表长度-1;</span></span><br><span class="line">    L-&gt;length --;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-5-清空顺序表"><a href="#1-4-5-清空顺序表" class="headerlink" title="1.4.5 清空顺序表"></a>1.4.5 清空顺序表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */</span></span><br><span class="line">Status <span class="title function_">ClearList</span><span class="params">(Sqlist *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-6-判断顺序表清空"><a href="#1-4-6-判断顺序表清空" class="headerlink" title="1.4.6 判断顺序表清空"></a>1.4.6 判断顺序表清空</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */</span></span><br><span class="line">Status <span class="title function_">ListEmpty</span><span class="params">(Sqlist L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-7-获取顺序表长度"><a href="#1-4-7-获取顺序表长度" class="headerlink" title="1.4.7 获取顺序表长度"></a>1.4.7 获取顺序表长度</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ListEmpty元素个数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(Sqlist L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-8-顺序输出List"><a href="#1-4-8-顺序输出List" class="headerlink" title="1.4.8 顺序输出List"></a>1.4.8 顺序输出List</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在 */</span></span><br><span class="line"><span class="comment">/* 操作结果：依次对L的每个数据元素输出 */</span></span><br><span class="line">Status <span class="title function_">TraverseList</span><span class="params">(Sqlist L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,L.data[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-9-顺序表查找元素并返回位置"><a href="#1-4-9-顺序表查找元素并返回位置" class="headerlink" title="1.4.9 顺序表查找元素并返回位置"></a>1.4.9 顺序表查找元素并返回位置</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在 */</span></span><br><span class="line"><span class="comment">/* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 */</span></span><br><span class="line"><span class="comment">/* 若这样的数据元素不存在，则返回值为0 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(Sqlist L,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (L.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i]==e)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(i&gt;=L.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-顺序存储结构表的优缺点"><a href="#1-5-顺序存储结构表的优缺点" class="headerlink" title="1.5 顺序存储结构表的优缺点"></a>1.5 顺序存储结构表的优缺点</h3><ul><li><strong>优点</strong><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li><li>可以快速地存取表中任意位置的元素</li></ul></li><li><strong>缺点</strong><ul><li>插入和删除操作需要移动大量元素</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的“碎片”</li></ul></li></ul><h3 id="1-5-线性表的链式存储结构"><a href="#1-5-线性表的链式存储结构" class="headerlink" title="1.5 线性表的链式存储结构"></a>1.5 线性表的链式存储结构</h3><h4 id="1-5-1-定义"><a href="#1-5-1-定义" class="headerlink" title="1.5.1 定义"></a>1.5.1 定义</h4><p>上文提到，顺序存储结构哦的线性表，最大的特点就是插入和删除时，需要移动大量元素，这显然需要耗费时间。</p><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的人一位置。</p><p><img src="/p/43366/002.png"></p><p>以前在顺序结构中，每个数据元素只要存数据元素信息就可以了。现在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。</p><ul><li><p>我们把存储数据元素信息的域成为<strong>数据域</strong>。</p></li><li><p>把存储直接后继位置的域称为<strong>指针域</strong>。</p></li><li><p>指针域中存储的信息称做<strong>指针</strong>或<strong>链</strong>，这两部分信息组成数据元素的存储映像，称为<strong>结点</strong>（Node）</p></li><li><p>n个结点链接成一个链表，成为线性表的链式存储结构，因为此链表的每个节点中只包含一个指针域，所以叫<strong>单链表</strong>。</p></li><li><p>链表中第一个结点的存储位置叫做<strong>头指针</strong>。</p></li><li><p>单链表的第一个结点前附设一个结点，称为<strong>头结点</strong>。</p></li></ul><p><img src="/p/43366/003.png"></p><p>而单链表的逻辑结构如下:</p><p><img src="/p/43366/004.png"></p><h4 id="1-5-2-头指针与头结点的异同"><a href="#1-5-2-头指针与头结点的异同" class="headerlink" title="1.5.2 头指针与头结点的异同"></a>1.5.2 头指针与头结点的异同</h4><table><thead><tr><th>头指针</th><th>头结点</th></tr></thead><tbody><tr><td>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</td><td>头结点是为了操作的统一和方便设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</td></tr><tr><td>头指针具有标示作用，所以常用头指针冠以链表的名字</td><td>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了</td></tr><tr><td>无论链表是否为空，头指针均不为空。头指针式链表的必要元素</td><td>头结点不一定是链表必须要素</td></tr></tbody></table><h5 id="1-5-3-为什么要添加头结点"><a href="#1-5-3-为什么要添加头结点" class="headerlink" title="1.5.3 为什么要添加头结点"></a>1.5.3 为什么要添加头结点</h5><ul><li>便于首元结点处理</li><li>便于空表和非空表的统一处理</li></ul><h3 id="1-6-单链表"><a href="#1-6-单链表" class="headerlink" title="1.6 单链表"></a>1.6 单链表</h3><h4 id="1-6-1-单链表取值"><a href="#1-6-1-单链表取值" class="headerlink" title="1.6.1 单链表取值"></a>1.6.1 单链表取值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.3 单链表取值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 初始条件: 顺序线性表L已存在,1≤i≤ListLength(L);</span></span><br><span class="line"><span class="comment"> 操作结果：用e返回L中第i个数据元素的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType *e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//j: 计数.</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">//声明结点p;</span></span><br><span class="line">    LinkList p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将结点p 指向链表L的第一个结点;</span></span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="comment">//j计算=1;</span></span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//p不为空,且计算j不等于i,则循环继续</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j&lt;i) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//p指向下一个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果p为空或者j&gt;i,则返回error</span></span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//e = p所指的结点的data</span></span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-2-单链表的插入"><a href="#1-6-2-单链表的插入" class="headerlink" title="1.6.2 单链表的插入"></a>1.6.2 单链表的插入</h4><p>单链表的插入操作，分为两种：</p><h5 id="1-6-2-1-前插法"><a href="#1-6-2-1-前插法" class="headerlink" title="1.6.2.1 前插法"></a>1.6.2.1 前插法</h5><p>将新结点插入在链表头结点前面，成为前插法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 随机产生n个元素值,建立带表头结点的单链线性表L(前插法)*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateListHead</span><span class="params">(LinkList *L, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//建立1个带头结点的单链表</span></span><br><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环前插入随机数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//生成新结点</span></span><br><span class="line">        p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//i赋值给新结点的data</span></span><br><span class="line">        p-&gt;data = i;</span><br><span class="line">        <span class="comment">//p-&gt;next = 头结点的L-&gt;next</span></span><br><span class="line">        p-&gt;next = (*L)-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将结点P插入到头结点之后;</span></span><br><span class="line">        (*L)-&gt;next = p;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.1 前插法整理创建链表L</span></span><br><span class="line">iStatus = ClearList(&amp;L);</span><br><span class="line">CreateListHead(&amp;L, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;整理创建L的元素(前插法):\n&quot;</span>);</span><br><span class="line">ListTraverse(L);</span><br></pre></td></tr></table></figure><h5 id="1-6-2-2-后插法"><a href="#1-6-2-2-后插法" class="headerlink" title="1.6.2.2 后插法"></a>1.6.2.2 后插法</h5><p>将新结点插入在链表的尾结点后面，称为后插法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 随机产生n个元素值,建立带表头结点的单链线性表L(后插法)*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateListTail</span><span class="params">(LinkList *L, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList p,r;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//建立1个带头结点的单链表</span></span><br><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="comment">//r指向尾部的结点</span></span><br><span class="line">    r = *L;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成新结点</span></span><br><span class="line">        p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将表尾终端结点的指针指向新结点</span></span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        <span class="comment">//将当前的新结点定义为表尾终端结点</span></span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将尾指针的next = null</span></span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//3.2 后插法整理创建链表L</span><br><span class="line">iStatus = ClearList(&amp;L);</span><br><span class="line">CreateListTail(&amp;L, 20);</span><br><span class="line">printf(&quot;整理创建L的元素(后插法):\n&quot;);</span><br><span class="line">ListTraverse(L);</span><br></pre></td></tr></table></figure><h4 id="1-6-3-单链表的删除"><a href="#1-6-3-单链表的删除" class="headerlink" title="1.6.3 单链表的删除"></a>1.6.3 单链表的删除</h4><p>要删除单链表中指定元素，通插入元素一样，应该先找到该位置的钱去结点。</p><p>  <img src="/p/43366/005.png" alt="单链表删除"></p><p>用C代码实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.4 单链表删除元素</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 初始条件：顺序线性表L已存在，1≤i≤ListLength(L)</span></span><br><span class="line"><span class="comment"> 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(LinkList *L,<span class="type">int</span> i,ElemType *e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p = (*L)-&gt;next;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找第i-1个结点,p指向该结点</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; j&lt;(i<span class="number">-1</span>)) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当i&gt;n 或者 i&lt;1 时,删除位置不合理</span></span><br><span class="line">    <span class="keyword">if</span> (!(p-&gt;next) || (j&gt;i<span class="number">-1</span>)) <span class="keyword">return</span>  ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//q指向要删除的结点</span></span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    <span class="comment">//将q的后继赋值给p的后继</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="comment">//将q结点中的数据给e</span></span><br><span class="line">    *e = q-&gt;data;</span><br><span class="line">    <span class="comment">//让系统回收此结点,释放内存;</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 线性表 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> iOS </tag>
            
            <tag> 理论 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【类的加载】-（3）loading_images</title>
      <link href="/p/6283d578.html"/>
      <url>/p/6283d578.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自 <a href="https://opensource.apple.com/tarballs/objc4">Apple 开源文档</a></p></blockquote><blockquote><p><strong>类的加载探寻系列:</strong><br>1、<a href="https://nilsli.com/p/29664.html">【类的加载】-（1）类的启动</a></p><p>2、<a href="https://nilsli.com/p/38312.html">【类的加载】-（2）懒加载类与分类</a></p><p>3、<a href="https://nilsli.com/p/6283d578.html">【类的加载】-（3）loading_images</a></p></blockquote><h2 id="一、加载镜像load-images"><a href="#一、加载镜像load-images" class="headerlink" title="一、加载镜像load_images"></a>一、加载镜像load_images</h2><p>前两篇文章学习了objc_init 中的主要方法<code>map_images</code> ，接下来学习加载镜像，先把源码摆出来：</p><p>通过注视可以看到，主要执行了2件事务：</p><ul><li>找到 load 方法</li><li>调用load 方法。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">load_images</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path __unused, <span class="type">const</span> <span class="keyword">struct</span> mach_header *mh)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="type">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">recursive_mutex_locker_t</span> <span class="title function_">lock</span><span class="params">(loadMethodLock)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">mutex_locker_t</span> <span class="title function_">lock2</span><span class="params">(runtimeLock)</span>;</span><br><span class="line">        prepare_load_methods((<span class="type">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中找到load 方法，是通过先找到其背后的类或者分类。</p><h3 id="1-1-准备类"><a href="#1-1-准备类" class="headerlink" title="1.1 准备类"></a>1.1 准备类</h3><p>下面这行代码表示类</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">prepare_load_methods</span><span class="params">(<span class="type">const</span> headerType *mhdr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="type">classref_t</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Swift class extensions and categories on Swift &quot;</span></span><br><span class="line">                        <span class="string">&quot;classes are not allowed to have +load methods&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>找到类的列表：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">classref_t</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br></pre></td></tr></table></figure></li><li><p>准备load 方法，把类添加到可load 列表，将类标记为可执行</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">schedule_class_load</span><span class="params">(Class cls)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>把类添加到可加载列表的实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don&#x27;t bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>把分类添加到可加载列表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_category_to_loadable_list</span><span class="params">(Category cat)</span></span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = _category_getLoadMethod(cat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t bother if cat has no +load method</span></span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;LOAD: category &#x27;%s(%s)&#x27; scheduled for +load&quot;</span>, </span><br><span class="line">                     _category_getClassName(cat), _category_getName(cat));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_categories_used == loadable_categories_allocated) &#123;</span><br><span class="line">        loadable_categories_allocated = loadable_categories_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_categories = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_categories,</span><br><span class="line">                              loadable_categories_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">    loadable_categories[loadable_categories_used].method = method;</span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Class cls = remapClass(cat-&gt;cls);</span><br></pre></td></tr></table></figure><p>这行代码，重映射了分类的类，即帮分类把懒加载的类进行了实现，否则分类无法找到可以依附的主类。</p></li></ul><h3 id="1-2-调用-load-方法"><a href="#1-2-调用-load-方法" class="headerlink" title="1.2 调用 load 方法"></a>1.2 调用 load 方法</h3><p>源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br></pre></td></tr></table></figure><h4 id="1-2-1-调用类的load-方法"><a href="#1-2-1-调用类的load-方法" class="headerlink" title="1.2.1 调用类的load 方法"></a>1.2.1 调用类的load 方法</h4><ol><li>列举可加载的类</li><li>循环找到类的对应load 方法的method 函数</li><li>向类发送该method 函数，完成调用</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">call_class_loads</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//(1)</span></span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> =</span> loadable_classes;</span><br><span class="line">    <span class="type">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">      <span class="comment">//(2)</span></span><br><span class="line">        <span class="type">load_method_t</span> load_method = (<span class="type">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;LOAD: +[%s load]\n&quot;</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(3)</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-调用分类的load-方法"><a href="#1-2-2-调用分类的load-方法" class="headerlink" title="1.2.2 调用分类的load 方法"></a>1.2.2 调用分类的load 方法</h4><ol><li><p>列举可加载的分类</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Detach current loadable list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">loadable_category</span> *<span class="title">cats</span> =</span> loadable_categories;</span><br><span class="line"><span class="type">int</span> used = loadable_categories_used;</span><br><span class="line"><span class="type">int</span> allocated = loadable_categories_allocated;</span><br><span class="line">loadable_categories = nil;</span><br><span class="line">loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">loadable_categories_used = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>循环找到分类的对应load 方法的method 函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">    Category cat = cats[i].cat;</span><br><span class="line">    <span class="type">load_method_t</span> load_method = (<span class="type">load_method_t</span>)cats[i].method;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>向分类发送该method 函数，完成调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*load_method)(cls, SEL_load);</span><br></pre></td></tr></table></figure></li><li><p>释放可执行分类列表，保证程序启动<strong>只调用一次</strong>该加载。</p><p>这里通过一个叫做<code>loadable_categories_used</code> 和<code>used</code> 的标识，来决定是否加载，并进行摧毁。</p><p>把使用过的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> used = loadable_categories_used;</span><br><span class="line"><span class="comment">/****/</span></span><br><span class="line">    shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Destroy the new list.</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories) <span class="built_in">free</span>(loadable_categories);</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、类的扩展-extension"><a href="#二、类的扩展-extension" class="headerlink" title="二、类的扩展-extension"></a>二、类的扩展-extension</h2><p>扩展的特性如下</p><ul><li>作为匿名的分类</li><li>可以添加属性和方法</li><li>生成时间：编译时作为类的一部分（ro）一起被编译</li><li>如果有与主类同名扩展方法，会先执行扩展方法，因为attachList 内存前插，所以造成覆盖原方法的假象。</li></ul><h2 id="三、runtime-关联对象"><a href="#三、runtime-关联对象" class="headerlink" title="三、runtime 关联对象"></a>三、runtime 关联对象</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><h4 id="3-1-1-概念"><a href="#3-1-1-概念" class="headerlink" title="3.1.1 概念"></a>3.1.1 概念</h4><blockquote><p>associatedObject又称关联对象。顾名思义，就是把一个对象关联到另外一个对象身上。</p></blockquote><h4 id="3-1-2-应用场景"><a href="#3-1-2-应用场景" class="headerlink" title="3.1.2 应用场景"></a>3.1.2 应用场景</h4><ul><li><p>为分类添加属性时，用到添加setter和getter方法，在实现里需要将类与属性关联</p></li><li><p>给某个类添加一个临时的属性</p></li></ul><h3 id="3-2-关联对象的使用"><a href="#3-2-关联对象的使用" class="headerlink" title="3.2 关联对象的使用"></a>3.2 关联对象的使用</h3><ol><li><p>添加关联。</p><p>主要用到<code>void objc_setAssociatedObject</code>  函数，</p><p>源码的实现是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">objc_setAssociatedObject</span><span class="params">(id object, </span></span><br><span class="line"><span class="params">                              <span class="type">const</span> <span class="type">void</span> *key, </span></span><br><span class="line"><span class="params">                              id value, </span></span><br><span class="line"><span class="params">                              objc_AssociationPolicy policy)</span> &#123;</span><br><span class="line">    _object_set_associative_reference(object, (<span class="type">void</span> *)key, value, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>参数一：id object : 给哪个对象添加属性，这里要给自己添加属性，用self。</p></li><li><p>参数二：void * &#x3D;&#x3D; id key : 属性名，根据key获取关联对象的属性的值，在objc_getAssociatedObject中通过次key获得属性的值并返回。</p></li><li><p>参数三：id value : 关联的值，也就是set方法传入的值给属性去保存。</p></li><li><p>参数四：objc_AssociationPolicy policy : 策略，属性以什么形式保存。</p><p><img src="/p/6283d578/001.png" alt="关联策略"></p></li></ul><p>业务上，比如给当前的类把cate_name 作为属性绑定，业务代码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-(<span class="type">void</span>)setCate_name:(NSString *)cate_name&#123;</span><br><span class="line"></span><br><span class="line">    objc_setAssociatedObject(self, @<span class="string">&quot;name&quot;</span>,cate_name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取关联属性</p><p>主要函数为：<code>objc_getAssociatedObject</code>方法</p><p>查看源码的实现是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id <span class="title function_">objc_getAssociatedObject</span><span class="params">(id object, <span class="type">const</span> <span class="type">void</span> *key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _object_get_associative_reference(object, (<span class="type">void</span> *)key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里两个参数：</p><p> 参数一：id object : 获取哪个对象里面的关联的属性。</p><p> 参数二：void * &#x3D;&#x3D; id key : 什么属性，与objc_setAssociatedObject中的key相对应，即通过key值取出value。</p><p><strong>业务实现</strong>：去除当前类中 name属性，作为cate_name 返回</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-(NSString *)cate_name&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(self, @<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-1-关联对象关联原理"><a href="#3-1-关联对象关联原理" class="headerlink" title="3.1 关联对象关联原理"></a>3.1 关联对象关联原理</h3><ul><li>程序运行时创建一个大大Hash 表</li><li>通过manager 进入迭代器对每个类表查找</li><li>如果找到，对新添加的属性进行绑定</li><li>如果找不到，创建一个，进行绑定存储</li></ul><ol><li><p>通过manager 管理</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关联对象的管理类</span></span><br><span class="line">        AssociationsManager manager;</span><br></pre></td></tr></table></figure></li><li><p>获取关联的 HashMap -&gt; 存储当前关联对象</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AssociationsHashMap &amp;<span class="title function_">associations</span><span class="params">(manager.associations())</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取 AssociationsHashMap 的迭代器 - (对象的) 进行遍历</p></li></ol>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br></pre></td></tr></table></figure><ol start="4"><li><p>根据key去获取关联属性的迭代器</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据key去获取关联属性的迭代器</span></span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    <span class="comment">// 替换设置新值</span></span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 到最后了 - 直接设置新值</span></span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></li><li><p>没有对象的关联信息情况。创建map，通过key-value 存入</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">  <span class="comment">/** 存在该对象，查找遍历，略过*/</span> </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-关联对象查找原理"><a href="#3-2-关联对象查找原理" class="headerlink" title="3.2 关联对象查找原理"></a>3.2 关联对象查找原理</h3><p>主要有以下几个步骤：</p><ol><li><p>生成关联对象的管理类</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AssociationsManager manager;</span><br><span class="line">AssociationsHashMap &amp;<span class="title function_">associations</span><span class="params">(manager.associations())</span>;</span><br></pre></td></tr></table></figure></li><li><p>生成伪装地址。处理参数 object 地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br></pre></td></tr></table></figure></li><li><p>生成Hash表中所有对象的额迭代器</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br></pre></td></tr></table></figure></li><li><p>对象内部继续生称迭代器，准备迭代属性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="comment">// 内部对象的迭代器</span></span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找——找到 - 把值和策略读取出来</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部对象的迭代器</span></span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                <span class="comment">// 找到 - 把值和策略读取出来</span></span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value();</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                <span class="comment">// OBJC_ASSOCIATION_GETTER_RETAIN - 就会持有一下</span></span><br><span class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</span><br><span class="line">                    objc_retain(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ol><li><p>如果找到，就进行持有</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</span><br><span class="line">                       objc_retain(value);</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>完整的查找过程的源码如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, <span class="type">void</span> *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    <span class="type">uintptr_t</span> policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 关联对象的管理类</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;<span class="title function_">associations</span><span class="params">(manager.associations())</span>;</span><br><span class="line">        <span class="comment">// 生成伪装地址。处理参数 object 地址</span></span><br><span class="line">        <span class="type">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="comment">// 所有对象的额迭代器</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="comment">// 内部对象的迭代器</span></span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                <span class="comment">// 找到 - 把值和策略读取出来</span></span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value();</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                <span class="comment">// OBJC_ASSOCIATION_GETTER_RETAIN - 就会持有一下</span></span><br><span class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</span><br><span class="line">                    objc_retain(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        objc_autorelease(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-实战"><a href="#3-3-实战" class="headerlink" title="3.3 实战"></a>3.3 实战</h3><h4 id="3-3-1-目标"><a href="#3-3-1-目标" class="headerlink" title="3.3.1 目标"></a>3.3.1 目标</h4><p>给<code>UIAlertController</code> 添加一个block 回调</p><h4 id="3-3-2-添加前"><a href="#3-3-2-添加前" class="headerlink" title="3.3.2 添加前"></a>3.3.2 添加前</h4><p>添加钱，每个UIAlertAction 处理自己的逻辑，如果逻辑较多，业务分离开，不方便阅读。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *SIGNALERTCONTROLLER = <span class="string">&quot;SIGNALERTCONTROLLER&quot;</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)askUserAQuestion &#123;</span><br><span class="line">    UIAlertController *ac = [UIAlertController alertControllerWithTitle:@<span class="string">&quot;hai&quot;</span> message:@<span class="string">&quot;hey&quot;</span> preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    UIAlertAction *aa = [UIAlertAction actionWithTitle:@<span class="string">&quot;aaa&quot;</span> style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        [self doFirst];</span><br><span class="line">    &#125;] ;</span><br><span class="line">    UIAlertAction *bb = [UIAlertAction actionWithTitle:@<span class="string">&quot;bb&quot;</span> style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        [self doSecond];</span><br><span class="line"></span><br><span class="line">    &#125;] ;</span><br><span class="line">    UIAlertAction *cc = [UIAlertAction actionWithTitle:@<span class="string">&quot;cc&quot;</span> style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;cancel&quot;</span>);</span><br><span class="line">    &#125;] ;</span><br><span class="line">    [ac addAction:aa];</span><br><span class="line">    [ac addAction:bb];</span><br><span class="line">    [ac addAction:cc];</span><br><span class="line">    [self presentViewController:ac animated:YES completion:^&#123;&#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-3-添加后"><a href="#3-3-3-添加后" class="headerlink" title="3.3.3 添加后"></a>3.3.3 添加后</h4><p>统一在block 中处理业务，逻辑更集中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *SIGNALERTCONTROLLER = <span class="string">&quot;SIGNALERTCONTROLLER&quot;</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)askUserAQuestion &#123;</span><br><span class="line">    UIAlertController *ac = [UIAlertController alertControllerWithTitle:@<span class="string">&quot;hai&quot;</span> message:@<span class="string">&quot;hey&quot;</span> preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    UIAlertAction *aa = [UIAlertAction actionWithTitle:@<span class="string">&quot;aaa&quot;</span> style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        <span class="type">void</span> (^block) (NSInteger) = objc_getAssociatedObject(ac, SIGNALERTCONTROLLER );</span><br><span class="line">        block(<span class="number">0</span>);</span><br><span class="line">    &#125;] ;</span><br><span class="line">    UIAlertAction *bb = [UIAlertAction actionWithTitle:@<span class="string">&quot;bb&quot;</span> style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        <span class="type">void</span> (^block) (NSInteger) = objc_getAssociatedObject(ac, SIGNALERTCONTROLLER );</span><br><span class="line">        block(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;] ;</span><br><span class="line">    UIAlertAction *cc = [UIAlertAction actionWithTitle:@<span class="string">&quot;cc&quot;</span> style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        <span class="type">void</span> (^block) (NSInteger) = objc_getAssociatedObject(ac, SIGNALERTCONTROLLER );</span><br><span class="line">        block(<span class="number">2</span>);</span><br><span class="line">    &#125;] ;</span><br><span class="line">    [ac addAction:aa];</span><br><span class="line">    [ac addAction:bb];</span><br><span class="line">    [ac addAction:cc];</span><br><span class="line">    <span class="type">void</span> (^block)(NSInteger) = ^(NSInteger index)&#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;index---&gt;   %ld&quot;</span>, (<span class="type">long</span>)index);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            [self doFirst];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>)&#123;</span><br><span class="line">            [self doSecond];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NSLog(@<span class="string">&quot;cancel&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    objc_setAssociatedObject(ac,</span><br><span class="line">                             SIGNALERTCONTROLLER,</span><br><span class="line">                             block,</span><br><span class="line">                             OBJC_ASSOCIATION_COPY);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [self presentViewController:ac animated:YES completion:^&#123;&#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)doFirst&#123;&#125;</span><br><span class="line">- (<span class="type">void</span>)doSecond&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、initialize-的调用"><a href="#四、initialize-的调用" class="headerlink" title="四、initialize 的调用"></a>四、initialize 的调用</h2><p>调用步骤如下</p><ul><li><p>lookUpImpOrForward</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123;</span><br><span class="line">    cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">    <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If sel == initialize, class_initialize will send +initialize and </span></span><br><span class="line">    <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">    <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">    <span class="comment">// from the messenger then it won&#x27;t happen. 2778172</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>initializeAndLeaveLocked</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Locking: caller must hold runtimeLock; this may drop and re-acquire it</span></span><br><span class="line"><span class="type">static</span> Class <span class="title function_">initializeAndLeaveLocked</span><span class="params">(Class cls, id obj, <span class="type">mutex_t</span>&amp; lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> initializeAndMaybeRelock(cls, obj, lock, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>initializeAndMaybeRelock</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtimeLock is now unlocked, for +initialize dispatch</span></span><br><span class="line">assert(nonmeta-&gt;isRealized());</span><br><span class="line">initializeNonMetaClass(nonmeta);</span><br></pre></td></tr></table></figure></li><li><p>initializeNonMetaClass</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    callInitialize(cls);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;</span>,</span><br><span class="line">                     pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>callInitialize(cls);</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callInitialize</span><span class="params">(Class cls)</span></span><br><span class="line">&#123;</span><br><span class="line">    ((<span class="type">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、面试题-load-与initialize-的区别"><a href="#五、面试题-load-与initialize-的区别" class="headerlink" title="五、面试题 load 与initialize 的区别"></a>五、面试题 load 与initialize 的区别</h2><h4 id="5-1-调用方式："><a href="#5-1-调用方式：" class="headerlink" title="5.1 调用方式："></a>5.1 调用方式：</h4><ul><li>load 根据函数地址调用</li><li>initialize 通过objc_msgSend 调用</li></ul><h4 id="5-2-调用时刻"><a href="#5-2-调用时刻" class="headerlink" title="5.2 调用时刻"></a>5.2 调用时刻</h4><ul><li>load 属于runtime 加载类、分类的时候，只会调用一次</li><li>initialize 方法上类第一次收到消息时，每个类调用一次，而父类的initialize 可能会调用多次</li></ul><h4 id="5-3-调用顺序："><a href="#5-3-调用顺序：" class="headerlink" title="5.3 调用顺序："></a>5.3 调用顺序：</h4><ul><li>load：<ul><li>先编译那个类就先调用它的load，父类的load 方法优先。</li><li>分类中也是先主类执行，后分类执行</li></ul></li><li>initialize：和普通方法一样，因为执行的是objc_msgSend 。<ul><li>先执行子类的initialize，如果没有，执行父类的。</li><li>分类部分，如果分类有，执行分类，不执行主类的</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 类 </tag>
            
            <tag> 加载 </tag>
            
            <tag> load </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-（1）基础篇</title>
      <link href="/p/43384.html"/>
      <url>/p/43384.html</url>
      
        <content type="html"><![CDATA[<blockquote><p> <a href="https://nilsli.com/p/43384.html">【数据结构与算法】-（1）基础篇</a></p><p> <a href="https://nilsli.com/p/43366.html">【数据结构与算法】-（2）线性表基础</a></p><p> <a href="https://nilsli.com/p/54688.html">【数据结构与算法】-（3）循环链表（单向）</a></p><p> <a href="https://nilsli.com/p/56790.html">【数据结构与算法】-（4）双向链表和双向循环链表</a></p><p> <a href="https://nilsli.com/p/50518edc.html">【数据结构与算法】-（5）链表面试题解析</a></p><p> <a href="https://nilsli.com/p/7914b7d0.html">【数据结构与算法】-（6）栈</a></p><p> <a href="https://nilsli.com/p/c0a767bd.html">【数据结构与算法】-（7）队列</a></p></blockquote><h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><h3 id="1-数据结构的起源"><a href="#1-数据结构的起源" class="headerlink" title="1 数据结构的起源"></a>1 数据结构的起源</h3><p>早期人们都把计算机理解为数值计算工具，就是感觉计算机当然是用来计算的，所以计算机解决问题，应该是先从具体问题中抽象出一个适当的数据模型，设计出一个解此数据类型的算法，然后再编写程序，得到一个实际的软件。</p><p>可现实中，我们更多的不是解决数值计算的问题，而是需要一些更科学有效的手段（比如表、树和图等数据结构）等帮助，才能更好地解决问题。</p><p>所以</p><blockquote><p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。</p></blockquote><h3 id="2-术语概念"><a href="#2-术语概念" class="headerlink" title="2 术语概念"></a>2 术语概念</h3><p>说到数据结构是什么，我们得先来谈谈什么叫做数据。</p><p>数据结构中，有5个基本概念：数据、数据元素、数据项、数据对象和数据结构。</p><p>他们之间的关系如下图所示：</p><p><img src="/p/43384/001.png" alt="基本数据单位"></p><p>具体到代码上，参考如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span>&#123;</span>     <span class="comment">//一种数据结构</span></span><br><span class="line">    <span class="type">char</span> *name;     <span class="comment">//数据项--名字</span></span><br><span class="line">    <span class="type">char</span> *title;    <span class="comment">//数据项--职称</span></span><br><span class="line">    <span class="type">int</span>  age;       <span class="comment">//数据项--年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> <span class="title">t1</span>;</span>     <span class="comment">//数据元素;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> <span class="title">tArray</span>[10];</span> <span class="comment">//数据对象;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-1数据"><a href="#1-2-1数据" class="headerlink" title="1.2.1数据"></a>1.2.1数据</h4><blockquote><p>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实数等数值类型，还包括字符及声音、图像、视频等非数值类型类型。</p><p>——《大话数据结构》</p></blockquote><p>比如我们平时使用搜索殷勤，有网页、mp3、图片、视频等分类。MP3 就是声音数据</p><p><strong>数据的特点</strong>:  </p><ul><li>可以输入到计算机  </li><li>可以被计算机程序处理</li></ul><h4 id="1-2-2-数据元素"><a href="#1-2-2-数据元素" class="headerlink" title="1.2.2 数据元素"></a>1.2.2 数据元素</h4><blockquote><p>组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。</p></blockquote><p>比如，在人类中，人就是数据元素。</p><p>而在动物类中，牛、马、羊、鸡等动物就是动物类的数据元素了。</p><h4 id="1-2-3-数据项"><a href="#1-2-3-数据项" class="headerlink" title="1.2.3 数据项"></a>1.2.3 数据项</h4><blockquote><p>一个数据元素由若干数据项组成。</p></blockquote><p>比如人这样的数据元素，可以有眼耳鼻舌口这些数据项，也有姓名、年龄、性别、出生地址、电话等数据项。</p><blockquote><p>数据项上数据不可分割的最小单位。</p></blockquote><h4 id="1-2-4-数据对象"><a href="#1-2-4-数据对象" class="headerlink" title="1.2.4 数据对象"></a>1.2.4 数据对象</h4><blockquote><p>性质相同的数据元素的集合，是数据的子集。</p></blockquote><p>性质相同的意思，是指数据元素具有相同数量和类型的数据项，比如，人都有姓名、生日、性别等相同的数据项。</p><h4 id="1-2-5-数据结构"><a href="#1-2-5-数据结构" class="headerlink" title="1.2.5 数据结构"></a>1.2.5 数据结构</h4><blockquote><p>是相互之间存在一种或多种特定关系的数据元素的集合。</p></blockquote><p>在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。而在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据之间存在的一种或多种特定关系，也就是数据的组织形式。</p><h3 id="3-逻辑结构与物理结构"><a href="#3-逻辑结构与物理结构" class="headerlink" title="3 逻辑结构与物理结构"></a>3 逻辑结构与物理结构</h3><p>按照观点的不同，我们把数据结构分为逻辑结构和物理结构。</p><h4 id="3-1-逻辑结构"><a href="#3-1-逻辑结构" class="headerlink" title="3.1 逻辑结构"></a>3.1 逻辑结构</h4><blockquote><p>是指数据对象中数据元素之间的相互关系</p></blockquote><p>逻辑关系按照类别分为线性结构与非线性结构：</p><h5 id="1-3-1-线性结构"><a href="#1-3-1-线性结构" class="headerlink" title="1.3.1 线性结构"></a>1.3.1 线性结构</h5><blockquote><p>线性结构中的数据元素是一对一的关系</p></blockquote><p><img src="/p/43384/002.png" alt="线性结构"></p><ol><li>线性表</li><li>栈和队列</li><li>字符串</li></ol><h5 id="1-3-2-非线性结构"><a href="#1-3-2-非线性结构" class="headerlink" title="1.3.2 非线性结构"></a>1.3.2 非线性结构</h5><blockquote><p>非线性结构中的数据元素是一对多或多对多的关系。</p></blockquote><ol><li>集合结构<br>集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。<br><img src="/p/43384/003.png" alt="集合结构"></li><li>树形结构<br>树形结构中的数据元素之间存在一种一对多的层次关系。<br><img src="/p/43384/004.png" alt="树形结构"></li><li>图形结构<br>图形结构中的数据元素是多对多的关系<br><img src="/p/43384/005.png" alt="图形结构"></li></ol><h4 id="3-2-物理结构"><a href="#3-2-物理结构" class="headerlink" title="3.2 物理结构"></a>3.2 物理结构</h4><blockquote><p>是指数据的逻辑结构在计算机中的存储形式。</p></blockquote><p>数据元素的存储形式有两种：顺序存储和链式存储。</p><h5 id="3-2-1-顺序存储结构"><a href="#3-2-1-顺序存储结构" class="headerlink" title="3.2.1 顺序存储结构"></a>3.2.1 顺序存储结构</h5><blockquote><p>把数据元素存放在抵制连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</p></blockquote><p>如下图所示：</p><p><img src="/p/43384/006.png" alt="顺序存储结构"></p><h5 id="3-2-2-链式存储结构"><a href="#3-2-2-链式存储结构" class="headerlink" title="3.2.2 链式存储结构"></a>3.2.2 链式存储结构</h5><blockquote><p>把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</p></blockquote><p>数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置，如图所示：</p><p><img src="/p/43384/007.png" alt="链式存储结构"></p><h3 id="4-抽象数据类型"><a href="#4-抽象数据类型" class="headerlink" title="4 抽象数据类型"></a>4 抽象数据类型</h3><h4 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h4><blockquote><p>数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p></blockquote><p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量的表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p><p>在C语言中，按照趣致的不同，数据类型可以分为两类：</p><ul><li>原子类型：不可以再分解的基本类型。包括整型、浮点型、字符类型等</li><li>结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。</li></ul><h4 id="4-2-抽象数据类型"><a href="#4-2-抽象数据类型" class="headerlink" title="4.2 抽象数据类型"></a>4.2 抽象数据类型</h4><p><strong>抽象是指抽出事物具有的普遍型的本质</strong>。我们对已有的数据类型进行抽象，就有了抽象数据类型。</p><blockquote><p>抽象数据类型（Abstract Data Type：ADT）：</p><p>是指一个数学模型及定义在该模型上的一组操作。</p></blockquote><p>抽象的意义在于数据类型的数字抽象特性。</p><p>抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。</p><h2 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><blockquote><p>是解决特定问题对求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p></blockquote><p>什么是算法？算法是<strong>描述解决问题的方法</strong>。</p><p>自唐代以来，历代更有许多专门论述“算法”的专著：</p><ul><li>唐代：《一位算法》 一卷，《算法》 一卷；</li><li>宋代：《算法绪论》 一卷、《算法秘诀》 一卷；最著名的是<a href="https://zh.wikipedia.org/wiki/%E6%9D%A8%E8%BE%89">杨辉</a>的《<a href="https://zh.wikipedia.org/wiki/%E6%9D%A8%E8%BE%89%E7%AE%97%E6%B3%95">杨辉算法</a>》；</li><li>元代：《<a href="https://zh.wikipedia.org/wiki/%E4%B8%81%E5%B7%A8%E7%AE%97%E6%B3%95">丁巨算法</a>》；</li><li>明代：<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%A4%A7%E4%BD%8D">程大位</a> 《<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95%E7%B5%B1%E5%AE%97">算法统宗</a>》</li><li>清代：《开平算法》、《算法一得》、《<a href="https://zh.wikipedia.org/w/index.php?title=%E7%AE%97%E6%B3%95%E5%85%A8%E4%B9%A6&action=edit&redlink=1">算法全书</a>》。</li></ul><p>而英文名称“algorithm”来自于9世纪<a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E6%96%AF">波斯</a>数学家<a href="https://zh.wikipedia.org/wiki/%E8%8A%B1%E6%8B%89%E5%AD%90%E7%B1%B3">花拉子米</a>（比阿勒·霍瓦里松，波斯语：خوارزمی ‎，拉丁转写：al-Khwarizmi），因为比阿勒·霍瓦里松在<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6">数学</a>上提出了算法这个概念。“算法”原为“algorism”，即“al-Khwarizmi”的音转，意思是“<a href="https://zh.wikipedia.org/wiki/%E8%8A%B1%E6%8B%89%E5%AD%90%E7%B1%B3">花拉子米</a>”的运算法则，在18世纪演变为“algorithm”。</p><p><a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">欧几里得算法</a>被人们认为是史上第一个算法。</p><h3 id="2-2-特性"><a href="#2-2-特性" class="headerlink" title="2.2 特性"></a>2.2 特性</h3><p>算法具有五个基本特征：输入、输出、有穷性、确定性和可行性。</p><ol><li>有穷性<br>指算法在执行有限的步骤之后，自动结束而不会出现无限循环，而且每一个步骤在可接受的时间内完成。</li><li>确定性<br>算法的每一步骤都具有确定的含义，不会出现二义性。</li><li>可行性<br>算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成</li><li>输入输出<br>算法具有零个或多个输入</li></ol><h3 id="2-3-算法设计的要求"><a href="#2-3-算法设计的要求" class="headerlink" title="2.3 算法设计的要求"></a>2.3 算法设计的要求</h3><h4 id="2-3-1-正确性"><a href="#2-3-1-正确性" class="headerlink" title="2.3.1 正确性"></a>2.3.1 正确性</h4><blockquote><p>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反应问题的需求、能够得到问题的正确答案。</p></blockquote><p>大概分为以下四个层次：</p><ol><li>算法程序没有语法错误。</li><li>算法程序对于合法的输入数据能够产生满足要求的输出结果。</li><li>算法程序对于非法的输入数据能够得出满足规格说明的结果。</li><li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</li></ol><p>以上这四层含义里，层次1 要求最低，而层次4 时最困难的，实际开发中，我们几乎不可能逐一验证所有的输入都能得到正确的结果。</p><h4 id="2-3-2-可读性"><a href="#2-3-2-可读性" class="headerlink" title="2.3.2 可读性"></a>2.3.2 可读性</h4><blockquote><p>算法设计的另一目的是为了便于阅读、理解和交流。</p></blockquote><p>可读性时算法（也包括实现它的代码）好坏很重要的标志。</p><h4 id="2-3-3-健壮性"><a href="#2-3-3-健壮性" class="headerlink" title="2.3.3 健壮性"></a>2.3.3 健壮性</h4><blockquote><p>当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</p></blockquote><h4 id="2-3-4-时间效率高和存储量低"><a href="#2-3-4-时间效率高和存储量低" class="headerlink" title="2.3.4 时间效率高和存储量低"></a>2.3.4 时间效率高和存储量低</h4><blockquote><p>设计算法应该尽量满足时间效率高和存储量低的特点。</p></blockquote><p>在生活中，人们都希望花最少的钱，用最短的时间，办最大的事，算法也是一样的思想，最好用最少的存储空间，办成同样的事——就是好的算法。</p><h3 id="2-4-效率的度量方法"><a href="#2-4-效率的度量方法" class="headerlink" title="2.4 效率的度量方法"></a>2.4 效率的度量方法</h3><p>通过对算法的数据测试，利用计算机的计时功能，来计算不同算法的效率是高还是低。</p><h4 id="2-4-1-事后统计方法"><a href="#2-4-1-事后统计方法" class="headerlink" title="2.4.1 事后统计方法"></a>2.4.1 事后统计方法</h4><blockquote><p>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编织的程序的运行时间进行比较，从而确定算法效率的高低。</p></blockquote><h4 id="2-4-2-事前统计方法"><a href="#2-4-2-事前统计方法" class="headerlink" title="2.4.2 事前统计方法"></a>2.4.2 事前统计方法</h4><blockquote><p>在计算机程序编制前，依据统计方法对算法进行估算。</p></blockquote><p>我们发现，一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：</p><ol><li>算法采用的策略、方法</li><li>编译产生的代码质量</li><li>问题的输入规模</li><li>机器执行指令的速度</li></ol><p>抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，<strong>依赖于算法的好坏和问题的输入规模</strong>。所谓<strong>问题输入规模是指输入量的多少</strong>。</p><p>我们看看两种求和的算法：</p><ul><li><p>第一种算法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span> n = <span class="number">100</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">/* 执行 n + 1 次*/</span></span><br><span class="line">&#123;</span><br><span class="line">sum += i;<span class="comment">/* 执行 n 次*/</span></span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">/* 执行 1 次*/</span></span><br></pre></td></tr></table></figure></li><li><p>第二种算法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">/* 执行 1次*/</span></span><br></pre></td></tr></table></figure></li></ul><p>显然，第一种算法，执行了 1 + (n+1) + n + 1 次 &#x3D; 2n + 3 次</p><p>而第二种算法是1+1+1 &#x3D; 3 次。算法好坏显而易见。</p><p>最终，在分析程序的运行时间时，最重要的是吧程序看成是独立于程序设计语言的算法或一系列步骤。</p><h3 id="2-5-算法时间复杂度"><a href="#2-5-算法时间复杂度" class="headerlink" title="2.5 算法时间复杂度"></a>2.5 算法时间复杂度</h3><h4 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1 定义"></a>2.5.1 定义</h4><blockquote><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n) 随n 的变化情况并确定T(n) 的数量级。</p><p>算法的时间复杂度，也就是算法的时间量度，记作：T(n) &#x3D; O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n) 是问题规模 n 的某个函数。</p></blockquote><p>大写O() 来体现算法复杂度的激发，我们称之为大O记法。</p><p>上面求和算法的时间复杂度，分别为O(n) 和 O(1)</p><h4 id="2-5-2-推导大O-阶方法"><a href="#2-5-2-推导大O-阶方法" class="headerlink" title="2.5.2 推导大O 阶方法"></a>2.5.2 推导大O 阶方法</h4><ol><li>用常数1 取代运行时间中的所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li></ol><h4 id="2-5-3-常数阶"><a href="#2-5-3-常数阶" class="headerlink" title="2.5.3 常数阶"></a>2.5.3 常数阶</h4><p>下面这个算法，就是刚刚的第二个算法（高斯算法）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">/* 执行 1次*/</span></span><br></pre></td></tr></table></figure><p>这个算法的运行次函数是 f(n) &#x3D; 3。根据我们推导大O阶的方法，第一步就是把常数3 改为1，再加上它没有最高阶项，所以这个算法的时间复杂度为O(1)</p><p>如果这里的第二行 sum &#x3D; (1 + n) * n &#x2F; 2 有10句，会是怎么样？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;<span class="comment">/* 执行 1次*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">/* 执行 1次*/</span></span><br></pre></td></tr></table></figure><p>事实上，无论n 为多少，上面的代码就说3次和12次执行的差异。这种与问题的大小无关（n） 的多少，执行时间恒定的算法，我们称之为具有 O(1) 的时间复杂度</p><h4 id="2-5-4-线性阶"><a href="#2-5-4-线性阶" class="headerlink" title="2.5.4 线性阶"></a>2.5.4 线性阶</h4><p>我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。</p><p>下面这段代码，它的循环的时间复杂度为O(n)，因为循环体中的代码须要执行 n 次</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">/ *</span><br><span class="line">时间复杂度为O（<span class="number">1</span>）的程序步骤序列</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-5-对数阶"><a href="#2-5-5-对数阶" class="headerlink" title="2.5.5 对数阶"></a>2.5.5 对数阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">count = count * <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* 时间复杂度为 O(1) 的程序步骤序列*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这行代码，由于每次 count 乘以 2 以后，就距离 n 更近了一份。</p><p>也就是说，有多少个2 相乘后大于 n，则会推出循环。</p><p>由 2<sup>x</sup>&#x3D; n 得到 x &#x3D; log<sub>2</sub>n 。所以这个循环的时间复杂度为O(logn)。</p><h4 id="2-5-6-平方阶"><a href="#2-5-6-平方阶" class="headerlink" title="2.5.6 平方阶"></a>2.5.6 平方阶</h4><p>下面的例子说一个循环嵌套，它的内循环时间复杂度为O(n)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">in i,j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"> / * 时间复杂度为 O(<span class="number">1</span>) 的程序步骤序列*/</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于外层的循环，不过是内部这个时间复杂度 O(n) 的语句，再循环 n 次。所以这段代码的时间复杂度为 O(n<sup>2</sup>)。</p><h3 id="2-6-常见的时间复杂度"><a href="#2-6-常见的时间复杂度" class="headerlink" title="2.6 常见的时间复杂度"></a>2.6 常见的时间复杂度</h3><p>常见的时间复杂度如表所示</p><table><thead><tr><th>执行次数函数</th><th>阶</th><th>非正式术语</th></tr></thead><tbody><tr><td>12</td><td>O(1)</td><td>常数阶</td></tr><tr><td>2n + 3</td><td>O(<em>n</em>)</td><td>线性阶</td></tr><tr><td>3n<sup>2</sup> + 2n + 1</td><td>O(<em>n</em><sup>2</sup>)</td><td>平方阶</td></tr><tr><td>5 log<sub>2</sub>n + 20</td><td>O(log<em>n</em>)</td><td>对数阶</td></tr><tr><td>2n + 3n log<sub>2</sub>n + 19</td><td>O(nlog<em>n</em>)</td><td>nlogn 阶</td></tr><tr><td>6n<sup>3</sup> + 2 n<sup>2</sup> + 3n + 4</td><td>O(<em>n</em><sup>3</sup>)</td><td>立方阶</td></tr><tr><td>2 <sup>n</sup></td><td>O(2<sup>n</sup>)</td><td>指数阶</td></tr></tbody></table><p>常用的时间复杂度所消耗的时间从小到大依次是:</p><p>O(1) &lt; O(log*n*) &lt; O(*n*) &lt;  O(*n*log*n*) &lt; O(*n*<sup>2</sup>) &lt; O(*n*<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p><h3 id="2-7-最坏情况与平均情况"><a href="#2-7-最坏情况与平均情况" class="headerlink" title="2.7 最坏情况与平均情况"></a>2.7 最坏情况与平均情况</h3><p>我们查找一个由 n 个随机数字数组中的某个数组，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的复杂度为O(n)，这是最坏的一种情况了。</p><p>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏时间的运行时间。</p><p>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，我们运行一段程序代码时，实习完看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。</p><p>对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。</p><p>另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。<strong>一般在没有特殊说明的情况下，都是指最坏时间复杂度。</strong></p><h3 id="2-8-算法空间复杂度"><a href="#2-8-算法空间复杂度" class="headerlink" title="2.8 算法空间复杂度"></a>2.8 算法空间复杂度</h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) &#x3D; O(&fnof;(n))，其中，n 为问题的规模，&fnof;(n) 为语句关于 n 所占存储空间的函数。</p><p>通常，我们都适用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> iOS </tag>
            
            <tag> 理论 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【类的加载】-（2）懒加载类与分类</title>
      <link href="/p/38312.html"/>
      <url>/p/38312.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自 <a href="https://opensource.apple.com/tarballs/objc4">Apple 开源文档</a></p></blockquote><blockquote><p><strong>类的加载探寻系列:</strong><br>1、<a href="https://nilsli.com/p/29664.html">【类的加载】-（1）类的启动</a></p><p>2、<a href="https://nilsli.com/p/38312.html">【类的加载】-（2）懒加载类与分类</a></p><p>3、<a href="https://nilsli.com/p/6283d578.html">【类的加载】-（3）loading_images</a></p></blockquote><h2 id="一、懒加载类"><a href="#一、懒加载类" class="headerlink" title="一、懒加载类"></a>一、懒加载类</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><blockquote><p><em>懒加载(lazy loading)又称为延迟加载，它是指系统不会在初始化是就加载某个对象，而是在第一次调用（使用 get 方法）时才加载这个对象到内存。它的实现方法实质上就是覆写该对象的 get 方法，并将该对象在初始化时需要实现的代码在 get 方法中实现。</em></p></blockquote><p>而对于数据结构而言，惰性加载是指从一个数据对象通过方法获得里面的一个属性对象时，这个对应对象实际并没有随其父数据对象创建时一起保存在运行空间中，而是在其读取方法第一次被调用时才从其他数据源中加载到运行空间中，这样可以避免过早地导入过大的数据对象但并没有使用的空间占用浪费。</p><h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ul><li>不需要在 viewDidLoad 中实例化对象，简化代码，使结构清晰</li><li>提升初始化加载速度</li><li>减少内存占用</li></ul><h3 id="1-2-区分"><a href="#1-2-区分" class="headerlink" title="1.2 区分"></a>1.2 区分</h3><p>通过 <code>load()</code> 方法，在编译器就已经处理好类</p><h4 id="1-2-1-非载类的加载步骤："><a href="#1-2-1-非载类的加载步骤：" class="headerlink" title="1.2.1 非载类的加载步骤："></a>1.2.1 非载类的加载步骤：</h4><ul><li><p>找到类的指针：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">classref_t</span> *classlist = </span><br><span class="line">           _getObjc2NonlazyClassList(hi, &amp;count);</span><br></pre></td></tr></table></figure></li><li><p>强转为<code>Class</code>类实例</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          Class cls = remapClass(classlist[i])</span><br></pre></td></tr></table></figure></li><li><p>添加到内存：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">addClassTableEntry</span>(cls);</span><br></pre></td></tr></table></figure></li><li><p>实现非懒加载类——实例化类的信息，如<code>rw</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">realizeClassWithoutSwift</span>(cls);</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-2-懒加载类的加载步骤"><a href="#1-2-2-懒加载类的加载步骤" class="headerlink" title="1.2.2 懒加载类的加载步骤"></a>1.2.2 懒加载类的加载步骤</h4><ul><li><p>查找懒加载类的方法</p><p>向类发送消息，方法查找该类 <code>lookUpImpOrForward</code></p><p>系统向一个没有实现的类的方法发送消息，通过<code>isa</code>查找方法缓存失败后，会进入到<strong>慢速查找</strong> 方法<code>lookUpImpOrForward</code> 里面，类是否实现过的判断：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">bool</span> initialize, <span class="type">bool</span> cache, <span class="type">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    <span class="type">bool</span> triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="built_in">assertUnlocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        imp = <span class="built_in">cache_getImp</span>(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during isRealized and isInitialized checking</span></span><br><span class="line">    <span class="comment">// to prevent races against concurrent realization.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during method search to make</span></span><br><span class="line">    <span class="comment">// method-lookup + cache-fill atomic with respect to method addition.</span></span><br><span class="line">    <span class="comment">// Otherwise, a category could be added but ignored indefinitely because</span></span><br><span class="line">    <span class="comment">// the cache was re-filled with the old value after the cache flush on</span></span><br><span class="line">    <span class="comment">// behalf of the category.</span></span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="built_in">checkIsKnownClass</span>(cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">        cls = <span class="built_in">realizeClassMaybeSwiftAndLeaveLocked</span>(cls, runtimeLock);</span><br><span class="line">        <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>对方法进行实现</p><p>接下来，<code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法的实现会落实到<code>realizeClassMaybeSwiftMaybeRelock </code>这个方法，会返回真实的类的结构：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Class</span></span><br><span class="line"><span class="function"><span class="title">realizeClassMaybeSwiftAndLeaveLocked</span><span class="params">(Class cls, <span class="type">mutex_t</span>&amp; lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">realizeClassMaybeSwiftMaybeRelock</span>(cls, lock, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Class</span></span><br><span class="line"><span class="function"><span class="title">realizeClassMaybeSwiftMaybeRelock</span><span class="params">(Class cls, <span class="type">mutex_t</span>&amp; lock, <span class="type">bool</span> leaveLocked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;<span class="built_in">isSwiftStable_ButAllowLegacyForNow</span>()) &#123;</span><br><span class="line">        <span class="comment">// Non-Swift class. Realize it now with the lock still held.</span></span><br><span class="line">        <span class="comment">// fixme wrong in the future for objc subclasses of swift classes</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls);</span><br><span class="line">        <span class="keyword">if</span> (!leaveLocked) lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Swift class. We need to drop locks and call the Swift</span></span><br><span class="line">        <span class="comment">// runtime to initialize it.</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cls = <span class="built_in">realizeSwiftClass</span>(cls);</span><br><span class="line">        <span class="built_in">assert</span>(cls-&gt;<span class="built_in">isRealized</span>());    <span class="comment">// callback must have provoked realization</span></span><br><span class="line">        <span class="keyword">if</span> (leaveLocked) lock.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在这个类里面，进到<code>!cls-&gt;isSwiftStable_ButAllowLegacyForNow</code> 这个选择，也就是非swift 类的情况下，对类<code>cls</code>进行了方法属性的实现，对的，没错，实现放方法，就放在<code>realizeClassWithoutSwift</code>里，这也是之前讨论过的非懒加载来初次实现的方法。</p></li></ul><h2 id="二、分类及其加载"><a href="#二、分类及其加载" class="headerlink" title="二、分类及其加载"></a>二、分类及其加载</h2><h3 id="2-1-分类的结构"><a href="#2-1-分类的结构" class="headerlink" title="2.1 分类的结构"></a>2.1 分类的结构</h3><p>为了搞清楚分类在底层的特点，先用代码一步一步来摸索</p><p>生成一个分类：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="function">interface <span class="title">NSObject</span> <span class="params">(Eat)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">- <span class="params">(<span class="type">void</span>)</span>eat</span>;</span><br><span class="line">- (<span class="type">void</span>)swallow;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>输入编译代码，得到相应的.cpp 文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -<span class="built_in">arch</span> arm64 -rewrite-objc NSObject+Eat.m</span><br></pre></td></tr></table></figure><p>得到对应的cpp文件</p><p><img src="/p/38312/000.png"> </p><p>打开这份.cpp 文件，熟悉的内容扑面而来</p><p><img src="/p/38312/001.png" alt="类的结构"></p><p>下面看到的是分类的结构：</p><p><img src="/p/38312/002.png" alt="分类的结构"></p><p>其中包含了 </p><ul><li>name - 主类的名字</li><li>cls - 分类的名字</li><li>instanceMethods - <strong>实例方法列表</strong></li><li>classMethods -  <strong>类方法列表</strong></li><li>protocols - 分类遵循的<strong>协议列表</strong></li><li>properties - <strong>属性列表</strong></li></ul><p>接下来看其中方法<code>method_list</code>的结构：</p><p><img src="/p/38312/003.png" alt="分类方法的结构"></p><p>得到了两个结构体，原结构体如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> method_count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[2];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面实现的结构体为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_OBJC_$_CATEGORY_INSTANCE_METHODS_NSObject_$_Eat __attribute__ ((used, section (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line"><span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line">&#123;&#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">&quot;eat&quot;</span>, <span class="string">&quot;v16@0:8&quot;</span>, (<span class="type">void</span> *)_I_NSObject_Eat_eat&#125;,</span><br><span class="line">&#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">&quot;swallow&quot;</span>, <span class="string">&quot;v16@0:8&quot;</span>, (<span class="type">void</span> *)_I_NSObject_Eat_swallow&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个结构体，其实是一一对应关系</p><ul><li><p>占用内存：entsize —— sizeof(_objc_method)</p></li><li><p>方法数量：method_count - 2</p></li><li><p>方法列表：method_list - </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">&quot;eat&quot;</span>, <span class="string">&quot;v16@0:8&quot;</span>, (<span class="type">void</span> *)_I_NSObject_Eat_eat&#125;,</span><br><span class="line">&#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">&quot;swallow&quot;</span>, <span class="string">&quot;v16@0:8&quot;</span>, (<span class="type">void</span> *)_I_NSObject_Eat_swallow&#125;</span><br></pre></td></tr></table></figure><p>即 eat 和 swallow 两个方法</p></li></ul><p>继续往下看，可以看到分类 <code>_OBJC_$_CATEGORY_NSObject_$_Eat.cls</code> 这个类指针指向了 主类<code>OBJC_CLASS_$_NSObject</code> 的地址</p><p><img src="/p/38312/004.png" alt="分类方法的结构"></p><p>查询<a href="https://opensource.apple.com/tarballs/objc4">源码762</a>，分类的结构如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">category_t</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">classref_t</span> cls;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">method_list_t</span> *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">method_list_t</span> *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">protocol_list_t</span> *protocols;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">property_list_t</span> *instanceProperties;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">property_list_t</span> *_classProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="type">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="type">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-2-分类的加载流程"><a href="#2-2-分类的加载流程" class="headerlink" title="2.2 分类的加载流程"></a>2.2 分类的加载流程</h3><h4 id="2-3-1-初始化"><a href="#2-3-1-初始化" class="headerlink" title="2.3.1 初始化"></a>2.3.1 初始化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _objc_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    <span class="built_in">environ_init</span>();</span><br><span class="line">    <span class="built_in">tls_init</span>();</span><br><span class="line">    <span class="built_in">static_init</span>();</span><br><span class="line">    <span class="built_in">lock_init</span>();</span><br><span class="line">    <span class="built_in">exception_init</span>();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-处理dyld镜像"><a href="#2-3-2-处理dyld镜像" class="headerlink" title="2.3.2 处理dyld镜像"></a>2.3.2 处理dyld镜像</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">map_images</span><span class="params">(<span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> paths[],</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> <span class="keyword">struct</span> mach_header * <span class="type">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map_images_nolock</span>(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-3-4-解锁处理镜像"><a href="#2-3-4-解锁处理镜像" class="headerlink" title="2.3.4 解锁处理镜像"></a>2.3.4 解锁处理镜像</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">map_images_nolock</span><span class="params">(<span class="type">unsigned</span> mhCount, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> mhPaths[],</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="keyword">struct</span> mach_header * <span class="type">const</span> mhdrs[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/*** 省去许多 ***/</span></span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    firstTime = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到读取镜像后，核心业务代码为<code>_read_images</code> 这个方法， 处理了所有的类。</p><h3 id="2-3-5-实现分类方法"><a href="#2-3-5-实现分类方法" class="headerlink" title="2.3.5 实现分类方法"></a>2.3.5 实现分类方法</h3><p>进到<code>_read_images</code> 方法，看到关于分类的在这里</p><p><img src="/p/38312/005.png"></p><p>这里逐一解释做了什么操作：</p><ol><li><p>将分类与类表中存储。使用的是<strong>addUnattachedCategoryForClass</strong> 方法，看看具体如何实现的：</p><p><img src="/p/38312/006.png"></p><p>如图所示，分别是：获取存放分类的表、分类扩容、分类插入表里。</p><p>而分类插入到表里，是 分类——类进行key-value 对应存入的，具体的函数为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">NXMapInsert</span><span class="params">(NXMapTable *table,</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="type">void</span> *key,</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="type">void</span> *value)</span></span><br></pre></td></tr></table></figure></li><li><p>对方法的重新实现：<strong>remethodizeClass</strong>，来看看这个方法的实现</p><p><img src="/p/38312/007.png"></p><p>这是啥？脚趾头都知道，核心业务方法是 <code>attachCategories(cls, cats, true /*flush caches*/);</code>，点开继续看。</p></li><li><p>往类里添加分类 - attachCategories</p><p><img src="/p/38312/008.png"></p><p>所要做的，都写在上面了，就是做了3件事情：</p><ul><li>开辟内存空间</li><li>遍历分类列表，把方法、属性、协议写到3组数组里</li><li>通过attatchList 方法， 依次写入到类的rw 的methods、properties、protocols 里</li></ul></li><li><p>attachLists方法 - 粘贴方法&#x2F;属性&#x2F;协议的具体实现：</p></li></ol><p>   具体的代码如下：</p><p>   <img src="/p/38312/009.png"></p><p>   这里可以看到，往类里添加分类的方法、属性、协议，一般有3种情况，处理如下：</p><ul><li>多对多。处理方式是为新内容创建空间，将旧内容<strong>平移</strong>到后面，将新内容<strong>拷贝</strong>放置最前面。 </li><li>0对1。即之前没有方法、属性或协议。这种比较简单，直接插入即可。</li><li>一对多。这种和多对多类似，将新的内容拷贝放入内存最前面</li></ul><ol start="5"><li><p><strong>内存移动和拷贝</strong></p><p>这里着重分析一下，平移，与拷贝。在C函数里，他们是这样的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dst ： destination ：目标地址</span></span><br><span class="line"><span class="comment"> src：source：被移动的内存首地址</span></span><br><span class="line"><span class="comment"> n： 被移动的内存长度</span></span><br><span class="line"><span class="comment"> memmove将 src内存中移动 len长度部分到 dest</span></span><br><span class="line"><span class="comment"> memcpy将 src内存中拷贝 n 长度部分到 dest</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *__dst, <span class="type">const</span> <span class="type">void</span> *__src, <span class="type">size_t</span> __n)</span>;</span><br><span class="line"><span class="type">void</span>*<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *__dst, <span class="type">const</span> <span class="type">void</span> *__src, <span class="type">size_t</span> __len)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>第一步平移操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                    oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure><ul><li>dst：array()-&gt;lists + addedCount，即总数组的长度</li><li>src：被移动的数组为原内容（方法列表、属性、协议）</li><li>n：移动了的部分：array()-&gt;lists，即偏移原来的部分</li></ul></li><li><p>第二步操作 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure><ul><li>dst：array()-&gt;lists + addedCount，即总数组的长度</li><li>src：被拷贝的数组为原内容（方法列表、属性、协议）</li><li>len：拷贝了的部分：array()-&gt;lists，即偏移原来的部分</li></ul></li></ul><p><img src="/p/38312/010.png" alt="009"></p><p>从这张图，可以清晰的看出，分类中的方法、属性和协议的添加次序，都是讲旧的移走，新的方法排最前面。</p><p>这也解释了为何分类会覆盖类原有的方法，原理是因为相应的方法、属性和协议，在内存段中，排列靠前。</p></li></ol><h3 id="2-3-分类与懒加载的搭配"><a href="#2-3-分类与懒加载的搭配" class="headerlink" title="2.3 分类与懒加载的搭配"></a>2.3 分类与懒加载的搭配</h3><h4 id="2-2-1-分类实现load-方法（非懒分类）"><a href="#2-2-1-分类实现load-方法（非懒分类）" class="headerlink" title="2.2.1 分类实现load 方法（非懒分类）"></a>2.2.1 分类实现load 方法（非懒分类）</h4><ul><li><p>懒加载的类 + 非懒加载的分类</p><ol><li><p>先实现非懒加载类的分类</p><p>具体是读取镜像 <code>read_images</code> </p><p>以及： <code>addUnattachedCategoryForClass</code> 将读到的分类插入到分类的表里，备用</p><p>请见代码实现：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addUnattachedCategoryForClass</span><span class="params">(<span class="type">category_t</span> *cat, Class cls, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          header_info *catHeader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead</span></span><br><span class="line">    NXMapTable *cats = <span class="built_in">unattachedCategories</span>();</span><br><span class="line">    category_list *list;</span><br><span class="line"></span><br><span class="line">    list = (category_list *)<span class="built_in">NXMapGet</span>(cats, cls);</span><br><span class="line">    <span class="keyword">if</span> (!list) &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            <span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(*list) + <span class="built_in">sizeof</span>(list-&gt;list[<span class="number">0</span>]), <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            <span class="built_in">realloc</span>(list, <span class="built_in">sizeof</span>(*list) + <span class="built_in">sizeof</span>(list-&gt;list[<span class="number">0</span>]) * (list-&gt;count + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;list[list-&gt;count++] = (<span class="type">locstamped_category_t</span>)&#123;cat, catHeader&#125;;</span><br><span class="line">    <span class="built_in">NXMapInsert</span>(cats, cls, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分类督促懒加载类实现，不然分类无处依附。</p><p>这里使用的是<code>prepare_load_methods</code>方法</p></li><li><p>实现主类后，将分类粘贴到主类上</p><p>先进行 <code>realizeClassWithoutSwift</code>，然后 <code>unattachedCategoriesForClass</code> 贴到主类上</p><p>具体的实现步骤如下：</p><ol><li><code>read_images</code></li><li><code>prepare_load_methods</code></li><li><code>realizeClassWithoutSwift</code></li><li><code>unattachedCategoriesForClass</code></li></ol></li></ol></li><li><p>非懒加载的类 + 非懒加载的分类</p><p><strong>直接编译获取到</strong>。</p><p>这种情况是最普遍的，就是直接取 class 里的data()-&gt;ro，在ro 里找到对应的方法</p><p>获取到过程是：</p><ul><li>read_images - 读取镜像</li><li>realizeClassWithoutSwift（实现非懒加载类）</li><li>methodizedClass - 实现方法</li><li>unattachedCategoriesForClass - 把内存里的类插入到表里</li><li>attachCategories - 往类后面粘贴分类结构</li></ul></li></ul><h4 id="2-2-分类未实现load-方法（懒分类）"><a href="#2-2-分类未实现load-方法（懒分类）" class="headerlink" title="2.2 分类未实现load  方法（懒分类）"></a>2.2 分类未实现load  方法（懒分类）</h4><p>如果分类并不主动实现 +load() 方法，就由编译时实现类与分类的查找实现</p><ul><li><p>非懒加载类 + 懒加载的分类</p><p>通过镜像来查找实现</p><ol><li>读取镜像  read_images</li><li>realizeClassWithoutSwift（实现非懒加载类）</li><li>methodizedClass </li><li>读取类里的 data-&gt;ro 信息</li></ol></li><li><p>懒加载的类 + 懒加载的分类</p><p>因为懒加载的类在编译时并不会主动实现，所以通过方法查找一步一步找到</p><ol><li>方法查找的消息传递 - lookupimporforward </li><li>realizeClassWithoutSwift</li><li>methodizedClass</li></ol></li></ul><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><ul><li><p>懒加载的分类: 编译时就已经决定处理好。</p></li><li><p>非懒加载分类：运行时再来处理。</p></li></ul><p>以上和懒加载的类是刚刚相反。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 底层，源码，懒加载，分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【底层探索】- runtime面试题集</title>
      <link href="/p/41032.html"/>
      <url>/p/41032.html</url>
      
        <content type="html"><![CDATA[<h2 id="〇、引言"><a href="#〇、引言" class="headerlink" title="〇、引言"></a>〇、引言</h2><p>前面一步步学习了对象、类、方法、类的加载等，这些其实都是Runtime 的基础，而Runtime 又是iOS开发语言 Objective C 的精髓，因此关于Runtime 的面试题举不胜举。</p><p>下面就简单的介绍几个，并提供解题思路，希望可以帮读者更清晰的理解Runtime。</p><h2 id="一、什么是Runtime"><a href="#一、什么是Runtime" class="headerlink" title="一、什么是Runtime"></a>一、什么是Runtime</h2><p>这个问题，问的是对Runtime 的基础理解。</p><blockquote><p>Runtime是由C和C++汇编实现的一套<strong>API</strong>，为 OC 语言加入了面向对象，运行时的功能。</p><p>运行时（Runtime） 是指将数据类型确定推迟到了运行时。</p></blockquote><p>举个例子：</p><p>关于类——<strong>类的扩展</strong>，在编译时作为类的一部分（ro）就已经确定好了，所以可以添加分类；而<strong>分类</strong>由于是运行时加载，只能添加属性以及对应的setter 和getter 方法，来达到模拟属性的目的。</p><h2 id="二、方法的本质是什么？"><a href="#二、方法的本质是什么？" class="headerlink" title="二、方法的本质是什么？"></a>二、方法的本质是什么？</h2><blockquote><p>方法的本质，就是发送消息&#x2F;消息传递</p></blockquote><p>让一个类（对象&#x2F;类）执行一个方法的过程，就是向它发送消息，它便开始消息查找的过程。主要包含以下几个过程：</p><ol><li><strong>快速查找</strong>（<strong>objc_msgSend</strong>），主要向类 cache_t 查找缓存的过的方法。</li><li><strong>慢速查找</strong>：执行 <strong>lookUpImpOrForward</strong> 方法，递归自己，以及自己的父类，属性 <code>rw</code> 里的<code>methodlist</code> 中查找方法。</li><li><strong>动态方法加解析（还是查找不到）</strong>：<strong>resolveInstanceMethod</strong> 方法，看是否自定义实现过</li><li>消息转发阶段：<ol><li>快速转发—— <strong>forwardingTargetForSelector</strong> 寻找特定对象来执行方法</li><li>慢速转发—— <strong>methodSignatureForSelector</strong>（获取方法的签名）以及生成相应的invocation，由 <strong>forwardInvocation</strong> 方法进行消息分发，让有能力执行的类来执行该方法。</li></ol></li></ol><h2 id="三、简述SEL-和IMP和之间关系"><a href="#三、简述SEL-和IMP和之间关系" class="headerlink" title="三、简述SEL 和IMP和之间关系"></a>三、简述SEL 和IMP和之间关系</h2><blockquote><p>定义：SEL是内存中方法编号，IMP 是方法的具体实现</p></blockquote><p>两者个点关系就好比一本书：SEL 是目录页里的 章节标题，而IMP 则是文章的页码，通过页码，可以看到具体内容。</p><p>SEL 是由read_images 就已经加载注册到内存表里。</p><h2 id="四、能否往已注册的类添加成员变量？"><a href="#四、能否往已注册的类添加成员变量？" class="headerlink" title="四、能否往已注册的类添加成员变量？"></a>四、能否往已注册的类添加成员变量？</h2><h3 id><a href="#" class="headerlink" title></a></h3><p>Q：已经注册好的类，能否再动态添加成员变量？为什么？</p><p><strong>答案是不可以。</strong></p><p>我们通过Runtime还原一下场景。</p><p>注册好的类，实现的方法是，注册到内存里：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">objc_registerClassPair</span>(LGPerson);</span><br></pre></td></tr></table></figure><p>而实现<code>objc_registerClassPair</code> 这个方法，又实现了下面的内容:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// Clear &quot;under construction&quot; bit, set &quot;done constructing&quot; bit</span></span><br><span class="line">cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">changeInfo</span>(RW_CONSTRUCTED, RW_CONSTRUCTING | RW_REALIZING);</span><br><span class="line">cls-&gt;<span class="built_in">changeInfo</span>(RW_CONSTRUCTED, RW_CONSTRUCTING | RW_REALIZING);</span><br></pre></td></tr></table></figure><p>即对类更改了状态，更改了什么状态？<strong>RW_CONSTRUCTED</strong>这个状态，即让类处于内存开辟&amp;注册到内存中——</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class allocated and registered</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_CONSTRUCTED        (1&lt;&lt;25)</span></span><br></pre></td></tr></table></figure><p>接下来，根据创建成员变量的函数为<code>addIvar</code>，创建业务代码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">class_addIvar</span>(LGPerson, <span class="string">&quot;lgName&quot;</span>, <span class="built_in">sizeof</span>(NSString *), <span class="built_in">log2</span>(<span class="built_in">sizeof</span>(NSString *)), <span class="string">&quot;@&quot;</span>);</span><br></pre></td></tr></table></figure><p>在源码中找到相对应的函数：</p><p><img src="/p/41032/001.png" alt="001"></p><p>走到这一步，就戛然而止了……添加ivars 被拒绝——因为内存已固定，无法再添加新属性了。</p><blockquote><p>原因：因为注册好的类，内存容量已经固定，无法动态添加了。</p></blockquote><h2 id="五、isKindOFClass-和-isMemberOfClass-的区别"><a href="#五、isKindOFClass-和-isMemberOfClass-的区别" class="headerlink" title="五、isKindOFClass 和 isMemberOfClass 的区别"></a>五、isKindOFClass 和 isMemberOfClass 的区别</h2><h3 id="5-1-题目"><a href="#5-1-题目" class="headerlink" title="5.1 题目"></a>5.1 题目</h3><p>关于这两个函数，我们知道他们各自概念是：</p><blockquote><p>isKindOfClass——某个对象是否是类的成员，或者继承自该类的成员（即父子关系）</p><p>isMemberOfClass——某个对象是否当前类的成员，并不考虑回溯的父子类关系。</p></blockquote><p>这里有一道面试题，题目如下，要求回答各打印结果：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL re1 = [(id)[NSObject <span class="keyword">class</span>] isKindOfClass:[NSObject <span class="keyword">class</span>]];<span class="comment">//1</span></span><br><span class="line">BOOL re2 = [(id)[NSObject <span class="keyword">class</span>] isMemberOfClass:[NSObject <span class="keyword">class</span>]];<span class="comment">// 0</span></span><br><span class="line">BOOL re3 = [(id)[Person <span class="keyword">class</span>] isKindOfClass:[Person <span class="keyword">class</span>]];<span class="comment">//0</span></span><br><span class="line">BOOL re4 = [(id)[Person <span class="keyword">class</span>] isMemberOfClass:[Person <span class="keyword">class</span>]];<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot; re1 :%hhd\n re2 :%hhd\n re3 :%hhd\n re4 :%hhd\n&quot;</span>,re1,re2,re3,re4);</span><br><span class="line"></span><br><span class="line">BOOL re5 = [(id)[NSObject alloc] isKindOfClass:[NSObject <span class="keyword">class</span>]];<span class="comment">//1</span></span><br><span class="line">BOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject <span class="keyword">class</span>]];<span class="comment">// 1</span></span><br><span class="line">BOOL re7 = [(id)[Person alloc] isKindOfClass:[Person <span class="keyword">class</span>]];<span class="comment">//1</span></span><br><span class="line">BOOL re8 = [(id)[Person alloc] isMemberOfClass:[Person <span class="keyword">class</span>]];<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot; re5 :%hhd\n re6 :%hhd\n re7 :%hhd\n re8 :%hhd\n&quot;</span>,re5,re6,re7,re8);</span><br></pre></td></tr></table></figure><p>答案是什么呢？先别忙，先冷静分析一下</p><h3 id="5-2-概念分析"><a href="#5-2-概念分析" class="headerlink" title="5.2 概念分析"></a>5.2 概念分析</h3><h4 id="5-2-1-类方法的区别分析"><a href="#5-2-1-类方法的区别分析" class="headerlink" title="5.2.1 类方法的区别分析"></a>5.2.1 类方法的区别分析</h4><p>很明显，上半部4个判断，是判断类与类的归属，执行的是类方法判断，先看一下涉及到的两个方法的源码：</p><p>类方法的区别</p><p>+(void)isKindOfClass** 的实现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls == cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>+(BOOL)isMemberOfClass</strong> 的实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass((id)self) == cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码分析，可以看出，isKindOfClass 多了一步 <code>tcls = tcls-&gt;superclass</code> 的循环，即如果当前类不等于目标类，向上查找父类，看看父类与目标是否相等。</p><h4 id="5-2-2-实例方法的区别"><a href="#5-2-2-实例方法的区别" class="headerlink" title="5.2.2 实例方法的区别"></a>5.2.2 实例方法的区别</h4><ul><li><p><strong>-(void)isKindOfClass</strong> 的实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [self <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤为：先判断对象的类，看是否与目标类相同；否则通过<code>tcls = tcls-&gt;superclass</code>，递归寻找父类及其父类，是否与本类相等</p></li><li><p><strong>-(void)isMemberOfClass</strong> 的实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [self class] == cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤为：判断对象指向的类，是否与目标类相同</p></li></ul><h4 id="5-2-3-答题"><a href="#5-2-3-答题" class="headerlink" title="5.2.3 答题"></a>5.2.3 答题</h4><p>好的，根据这个，一个一个来进行解答。</p><ol><li><p><strong>返回1</strong>：因为根元类的父类&#x3D;根元类</p><p>左边的<code>NSObject class </code> 为 NSObject 的元类，判断是否与本类NSobject 相等？</p><p>答案是不一致。</p><p>但是此时会进入<code>tcls = tcls-&gt;superclass</code> 这个循环，查找本类的父类，而我们知道 NSObject 的元类的父类就是NSObject ，见下图。所以绕了一圈回来，NSObject &#x3D; NSObject</p><p><img src="/p/41032/002.png"></p></li><li><p><strong>返回0</strong>：因为元类与本类不相等</p><p>和上一个问题一样，但是<code>isMemberOfClass</code> 在第一步就停下了，<code>object_getClass((id)self) == cls</code> 这里问到元类与本类是否相等，当然是否。</p></li><li><p><strong>返回0</strong>：因为普通类的元类的父类与本类是不相等的</p><p>我们看右边是 Person Class </p><p>左边的 Person Class </p><p>判断条件是 <code>isKindOfClass</code></p><p>所以，Person 开始找它的元类，看是否等于本类。我们看isa 的指向图可以得出，它的元类递归查找父类，一直都与本类不相等。所以返回为0</p><p><img src="/p/41032/003.png"></p></li><li><p><strong>返回为0</strong>。因为 元类不等于本类</p><p>这个和第2条是一样的</p></li><li><p>**返回为1： ** 因为本类等于本类</p><p>给出的判断代码为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[(id)[NSObject alloc] isKindOfClass:[NSObject <span class="keyword">class</span>]]</span><br></pre></td></tr></table></figure><p>其中左边的[NSObject alloc] ，创建了一个 NSObject 的对象，而对他指向 isKindOfClass 即执行以下方法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建的 <code>Class tcls = [self class]</code> ，其中<strong>tcls</strong> 即为 其父类 NSObject，取其与 NSObject 相比，相等，所以返回为1。</p></li><li><p><strong>返回为1：</strong> 因为本类等于本类，同第5 题</p></li><li><p><strong>返回为1：</strong>同第5题</p></li><li><p><strong>返回为1：</strong> 同第5题</p></li></ol><h2 id="五、-self-class-与-super-class-区别"><a href="#五、-self-class-与-super-class-区别" class="headerlink" title="五、[self class] 与[super class] 区别"></a>五、[self class] 与[super class] 区别</h2><h3 id="5-1-提问：以下打印什么？"><a href="#5-1-提问：以下打印什么？" class="headerlink" title="5.1 提问：以下打印什么？"></a>5.1 提问：以下打印什么？</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/message.h&gt;</span></span></span><br><span class="line">@implementation Student</span><br><span class="line"></span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    <span class="keyword">if</span> (self) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,<span class="built_in">NSStringFromClass</span>([self <span class="keyword">class</span>]));</span><br><span class="line">        <span class="built_in">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,<span class="built_in">NSStringFromClass</span>([super <span class="keyword">class</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-源码分析"><a href="#5-2-源码分析" class="headerlink" title="5.2 源码分析"></a>5.2 源码分析</h3><p>因为问题都涉及到了 <code>class</code> 这个方法，在NSObject.mm 这个类里找一下，方法实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class <span class="title function_">object_getClass</span><span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以见到，在<code>object_getClass</code> 方法里，如果给的对象<code>self</code> ——<code>obj</code> 存在，返回的是它的元类，指针指向的是它的类，所以打印应该是 <code>Student</code>。</p><p>而第一行中，向<code>super</code> 发送消息了。</p><ul><li>[self class] 方法，是向 对象（<code>self</code>）发送消息（<code>class</code>），走的流程是 objc_msgSend</li><li>[super class]，是向 对象（<code>self</code>）发送消息（<code>class</code>），走的流程是 objc_msgSendSuper</li></ul><p>那继续探寻<code>objc_msgSendSuper</code> 这个方法，可以看到他的结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">objc_msgSendSuper(<span class="type">void</span> <span class="comment">/* struct objc_super *super, SEL op, ... */</span> )</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><p>可见它执行的是 <code>struct objc_super </code> 类型的super，</p><blockquote><p> 原因：<strong>在OC中，super只是个符号标识符</strong>，objc_msgSendSuper最终接受对象还是 <code>self</code></p></blockquote><h3 id="5-3-解答"><a href="#5-3-解答" class="headerlink" title="5.3 解答"></a>5.3 解答</h3><p>打印都是NSObject</p><h2 id="六、weak-是什么及其实现原理"><a href="#六、weak-是什么及其实现原理" class="headerlink" title="六、weak 是什么及其实现原理"></a>六、weak 是什么及其实现原理</h2><h3 id="6-1-分析"><a href="#6-1-分析" class="headerlink" title="6.1 分析"></a>6.1 分析</h3><p>在OC语言到开发中，我们经常对对象前面添加 <code>weak</code> 来实现弱引用，从而达到避免循环引用造成的内存泄漏。那么这个weak 究竟实现了什么，作为高级开发者，不得不仔细探究一下。</p><h4 id="6-1-1-代码创建"><a href="#6-1-1-代码创建" class="headerlink" title="6.1.1 代码创建"></a>6.1.1 代码创建</h4><p>为了搞清楚weak 创建对象时内部的实现，创建一个weak 对象，打印试试，这时要把汇编断点打开</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NSArray *arr = @[@<span class="string">&quot;jack&quot;</span>, @<span class="string">&quot;tiga&quot;</span>, @<span class="string">&quot;jade&quot;</span>, @<span class="string">&quot;obu&quot;</span>];</span><br><span class="line">id __weak abc = arr;</span><br></pre></td></tr></table></figure><p><img src="/p/41032/004.png"></p><p>可以看到运行后，执行了这行代码：</p><p><img src="/p/41032/005.png"></p><p>可见创建后执行了关键代码 <code>objc_initWeak</code>，贴到源码里查看，实现如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">id</span></span><br><span class="line"><span class="function"><span class="title">objc_initWeak</span><span class="params">(id *location, id newObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回到时<code>storeWeak(id *location, objc_object *newObj)</code>这个函数，依稀可以看出来，是一个将<code>newObj</code> 储存到<code>location</code> 的动作。继续往下分析如下：</p><h4 id="6-1-2-源码解读-storeWeak"><a href="#6-1-2-源码解读-storeWeak" class="headerlink" title="6.1.2 源码解读 storeWeak"></a>6.1.2 源码解读 <code>storeWeak</code></h4><ol><li><p>如果有新对象，创建新的散列表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">   newTable = &amp;SideTables()[newObj];</span><br></pre></td></tr></table></figure><p>散列表结构如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SideTable</span> &#123;</span><br><span class="line">    <span class="type">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="type">weak_table_t</span> weak_table;</span><br><span class="line">  <span class="comment">/*精简以后的内容*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见散列表中有重要的3个属性</p><ul><li><p>slock —— 自旋锁</p></li><li><p>refcnts——引用计数表，这里是App 维护的一张全局表，类型是</p></li><li><p>weak_table —— 全局的弱引用表，存储所有的弱引用对象，把对象当作<code>key</code> 来保持，打开看看，它的结构体实现是这样的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The global weak references table. Stores object ids as keys,</span></span><br><span class="line"><span class="comment"> * and weak_entry_t structs as their values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_table_t</span> &#123;</span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries;</span><br><span class="line">    <span class="type">size_t</span>    num_entries;</span><br><span class="line">    <span class="type">uintptr_t</span> mask;</span><br><span class="line">    <span class="type">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>共包含了整个应用里，弱引用实体和数量。</p></li></ul></li><li><p>如果当前是创建的新弱引用<code>haveNew</code>，添加弱引用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br></pre></td></tr></table></figure></li><li><p>记录弱引用实体保存的内存地址：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">weak_entry_t</span> *entry;</span><br><span class="line">    <span class="keyword">if</span> ((entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent))) &#123;</span><br><span class="line">        <span class="built_in">append_referrer</span>(entry, referrer);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure></li><li><p>插入对象到弱引用过程如下：</p><ol><li><p>创建数组，插入到weak 表里</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">weak_entry_t</span> <span class="title">new_entry</span><span class="params">(referent, referrer)</span></span>;</span><br><span class="line">        <span class="built_in">weak_grow_maybe</span>(weak_table);</span><br><span class="line">        <span class="built_in">weak_entry_insert</span>(weak_table, &amp;new_entry);</span><br></pre></td></tr></table></figure></li><li><p><strong>循环弱引用表，将引用实体插入，弱引用的计数增加</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">weak_entry_insert</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, <span class="type">weak_entry_t</span> *new_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    <span class="built_in">assert</span>(weak_entries != nil);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> begin = <span class="built_in">hash_pointer</span>(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (weak_entries[index].referent != nil) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) <span class="built_in">bad_weak_table</span>(weak_entries);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entries[index] = *new_entry;</span><br><span class="line">    weak_table-&gt;num_entries++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">        weak_table-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>将弱引用的位值，存放在引用计数表里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>并对isa 的weak引用属性设置为TRUE</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">newisa.weakly_referenced = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>添加到计数表的方法如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">objc_object::sidetable_setWeaklyReferenced_nolock</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">    table.refcnts[this] |= SIDE_TABLE_WEAKLY_REFERENCED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最终返回存储的内存地址的指针，指向这个新的对象</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*location = (id)newObj;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-3-weak-的释放"><a href="#6-3-weak-的释放" class="headerlink" title="6.3 weak 的释放"></a>6.3 weak 的释放</h3><h4 id="6-1-查看-dealloc"><a href="#6-1-查看-dealloc" class="headerlink" title="6.1 查看 dealloc"></a>6.1 查看 dealloc</h4><p>我们知道，对象的销毁，一般是在类的dealloc 后进行，所以目光放在 dealloc 的方法是先上</p><p>查看NSObject.mm 中，得知dealloc 如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续探寻</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_objc_rootDealloc(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续继续，得到一个内联函数如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootDealloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(!<span class="built_in">sidetable_present</span>());</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">object_dispose</span>((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标放在<code>object_dispose((id)this);</code> 这一行，函数的名字——销毁对象，即当前对象的isa还有些弱引用（<code>isa.weakly_referenced</code>）或者关联对象（<code>isa.has_assoc</code>）未处理的业务，会比较复杂，需要特别处理。继续探寻如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">id </span></span><br><span class="line"><span class="function"><span class="title">object_dispose</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">objc_destructInstance</span>(obj);    </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查看解构过程<code>objc_destructInstance(obj)</code> 这个函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="type">bool</span> cxx = obj-&gt;<span class="built_in">hasCxxDtor</span>();</span><br><span class="line">        <span class="type">bool</span> assoc = obj-&gt;<span class="built_in">hasAssociatedObjects</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) <span class="built_in">object_cxxDestruct</span>(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;<span class="built_in">clearDeallocating</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>if (cxx) object_cxxDestruct(obj);</strong> —— 处理析构C++ 的对象</li><li><strong>_object_remove_assocations(obj);</strong> ——移除类的关联对象</li></ul><p>那么要找寻如何移除弱引用，把目光放在<code>obj-&gt;clearDeallocating();</code> 这行代码——<br>又是一个内联函数，解释了如何dealloc 对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_object::clearDeallocating</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        <span class="built_in">sidetable_clearDeallocating</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">slowpath</span>(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        <span class="built_in">clearDeallocating_slow</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">sidetable_present</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显 <code>clearDeallocating_slow()</code>  才是需要找的，因为注释已经解释的很清楚：</p><blockquote><p>Slow path for non-pointer isa with weak refs and&#x2F;or side table data.</p><p>带弱引用或散列表数据的非指针的isa 慢速路径</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NEVER_INLINE <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::clearDeallocating_slow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = <span class="built_in">SideTables</span>()[<span class="keyword">this</span>];</span><br><span class="line">    table.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        <span class="built_in">weak_clear_no_lock</span>(&amp;table.weak_table, (id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.<span class="built_in">erase</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 分析关键代码：</p><ol><li><p>如果当前isa 有弱引用，在弱引用表中，<strong>弱引用表清除当前的弱引用</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        <span class="built_in">weak_clear_no_lock</span>(&amp;table.weak_table, (id)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>weak_clear_no_lock</code> 这个核心函数，具体做了什么工作，继续探究一下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">weak_clear_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, id referent_id)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    <span class="type">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;<span class="built_in">out_of_line</span>()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = <span class="built_in">TABLE_SIZE</span>(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">weak_entry_remove</span>(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看上去业务挺多，其实核心也就两个:</p><ul><li><p>移除指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>移除实体：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">weak_entry_remove(weak_table, entry);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove entry from the zone&#x27;s table of weak references.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_entry_remove</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, <span class="type">weak_entry_t</span> *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// remove entry</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) <span class="built_in">free</span>(entry-&gt;referrers);</span><br><span class="line">    bzero(entry, <span class="keyword">sizeof</span>(*entry));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;num_entries--;</span><br><span class="line"></span><br><span class="line">    weak_compact_maybe(weak_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果当前对象有引用计数存表不为0，<strong>引用计数表清楚本对象</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.<span class="built_in">erase</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-3-回答"><a href="#6-3-回答" class="headerlink" title="6.3 回答"></a>6.3 回答</h3><blockquote><p>weak 的创建，在内存的散列表中的弱引用表里，存储关于该对象的弱引用，按照key-value 存入。</p><p>weak 的创建，正好相反，中dealloc 里，去弱引用表格里，找到引用进行弱引用实体销毁，以及弱引用的引用计数减少。</p></blockquote><h2 id="七、黑魔法·方法交换（Method-Swizzling）坑点"><a href="#七、黑魔法·方法交换（Method-Swizzling）坑点" class="headerlink" title="七、黑魔法·方法交换（Method Swizzling）坑点"></a>七、黑魔法·方法交换（Method Swizzling）坑点</h2><h3 id="7-1-一般使用"><a href="#7-1-一般使用" class="headerlink" title="7.1 一般使用"></a>7.1 一般使用</h3><p>如下所示，对数组越界做保护：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;NSArray+Empty.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line">@<span class="function">implementation <span class="title">NSArray</span> <span class="params">(Empty)</span></span></span><br><span class="line"><span class="function">+ <span class="params">(<span class="type">void</span>)</span>load</span>&#123;</span><br><span class="line">    Method oriMethod = <span class="built_in">class_getInstanceMethod</span>(<span class="built_in">NSClassFromString</span>(@<span class="string">&quot;__NSArrayI&quot;</span>), @<span class="built_in">selector</span>(objectAtIndex:));</span><br><span class="line">    Method swiMethod = <span class="built_in">class_getInstanceMethod</span>([self <span class="keyword">class</span>], @<span class="built_in">selector</span>(lj_objectAtIndex:));</span><br><span class="line">    <span class="built_in">method_exchangeImplementations</span>(oriMethod, swiMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)lj_objectAtIndex: (NSUInteger)index&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; self.count <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(@<span class="string">&quot;朋友，数组越界了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [self lj_objectAtIndex:index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试验一下结果如何：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NSArray *arr = @[@<span class="string">&quot;jack&quot;</span>, @<span class="string">&quot;tiga&quot;</span>, @<span class="string">&quot;jade&quot;</span>, @<span class="string">&quot;obu&quot;</span>];</span><br><span class="line">NSString *name =  [arr objectAtIndex:<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p> 打印结果如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-03</span> <span class="number">23</span>:<span class="number">52</span>:<span class="number">50.759731</span>+<span class="number">0800</span> SWZ[<span class="number">7438</span>:<span class="number">461811</span>] 朋友，数组越界了</span><br></pre></td></tr></table></figure><p>可以看到，经过方法交换，本来使用 <code>objectAtIndex</code> 的方法，它的实现被交换了，被交换到 <code>lj_objectAtIndex</code> 的实现里，执行了越界保护，保证了代码的鲁棒性。</p><h3 id="7-2-坑点1-重复使用"><a href="#7-2-坑点1-重复使用" class="headerlink" title="7.2 坑点1 - 重复使用"></a>7.2 坑点1 - 重复使用</h3><p>以上是方法交换的一个简单的例子，对NSArray 添加方法实现方法交换。</p><h4 id="7-2-1-症状"><a href="#7-2-1-症状" class="headerlink" title="7.2.1 症状"></a>7.2.1 症状</h4><p>那么会不会有什么漏洞呢？留意到方法实现是在 load 方法就实现，假设在实现方法之前，主动加载一次load 会怎么样？</p><p>假设是这样：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NSArray *arr = @[@<span class="string">&quot;jack&quot;</span>, @<span class="string">&quot;tiga&quot;</span>, @<span class="string">&quot;jade&quot;</span>, @<span class="string">&quot;obu&quot;</span>];</span><br><span class="line">[NSArray load];</span><br><span class="line">NSString *name =  [arr objectAtIndex:<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>结果，出现了越界崩溃</p><p><img src="/p/41032/006.png"></p><h4 id="7-2-2-追踪分析"><a href="#7-2-2-追踪分析" class="headerlink" title="7.2.2 追踪分析"></a>7.2.2 追踪分析</h4><p>往核心方法load 里添加一段打印标记，看看是否与他有关：</p><p><img src="/p/41032/007.png"></p><p>通过追踪，得知load 方法，执行了2次。想一想，执行load 本来是为了交换方法，那执行2次，意思是将原本交换过的方法实现，又交换回去了——白干了，这也是出现越界崩溃的原因。</p><h4 id="7-2-3-解决"><a href="#7-2-3-解决" class="headerlink" title="7.2.3 解决"></a>7.2.3 解决</h4><p>解决的方法很简单，将该方法设置成单例，通过 onceToken 来保证交换过程只会走一次：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)load&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;执行load!&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">            Method oriMethod = <span class="built_in">class_getInstanceMethod</span>(<span class="built_in">NSClassFromString</span>(@<span class="string">&quot;__NSArrayI&quot;</span>), @<span class="built_in">selector</span>(objectAtIndex:));</span><br><span class="line">        Method swiMethod = <span class="built_in">class_getInstanceMethod</span>([self <span class="keyword">class</span>], @<span class="built_in">selector</span>(lj_objectAtIndex:));</span><br><span class="line">        <span class="built_in">method_exchangeImplementations</span>(oriMethod, swiMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，继续执行虽然执行2次<code>load</code>, 但是内部的交换实现，只会执行一次。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-04</span> <span class="number">00</span>:<span class="number">13</span>:<span class="number">53.061523</span>+<span class="number">0800</span> SWZ[<span class="number">7778</span>:<span class="number">482862</span>] 执行load!</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-04</span> <span class="number">00</span>:<span class="number">13</span>:<span class="number">56.011281</span>+<span class="number">0800</span> SWZ[<span class="number">7778</span>:<span class="number">482862</span>] 执行load!</span><br></pre></td></tr></table></figure><p>结果如下，虽然load 执行2次，交换方法只执行1次</p><p><img src="/p/41032/008.png"></p><h3 id="7-3-坑点2-待交换子类未实现"><a href="#7-3-坑点2-待交换子类未实现" class="headerlink" title="7.3 坑点2 - 待交换子类未实现"></a>7.3 坑点2 - 待交换子类未实现</h3><h4 id="7-3-1-症状"><a href="#7-3-1-症状" class="headerlink" title="7.3.1 症状"></a>7.3.1 症状</h4><p>先创建一个案发现场，如下：</p><ul><li>父类某方法A并实现</li><li>子类继承父类</li><li>其他业务向子类交换该A方法</li><li>执行父类该方法A，查看结果</li></ul><p>如下所示：</p><ol><li><p>创建父类<code>Animal</code>，以及子类<code>Dog</code>， 其中父类拥有并实现<code>run</code> 的类方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface Animal : NSObject</span><br><span class="line">- (<span class="type">void</span>)run;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@interface Dog : Animal</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>其他业务场景，向子类申请交换了 run 的实现，run 换成了play，在Dog.m 执行：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)load&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Method oriMethod = <span class="built_in">class_getInstanceMethod</span>(self, @<span class="built_in">selector</span>(run));</span><br><span class="line">        Method swiMethod = <span class="built_in">class_getInstanceMethod</span>(self, @<span class="built_in">selector</span>(play));</span><br><span class="line">        <span class="built_in">method_exchangeImplementations</span>(oriMethod, swiMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)play&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>检查此时子类与父类的的run 方法</p></li></ol><p>   生成两个实例，执行<code>run</code> 方法</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Animal *a = [[Animal alloc] init];</span><br><span class="line">[a run];</span><br><span class="line"></span><br><span class="line">Dog *d = [[Dog alloc ] init];</span><br><span class="line">[d run];</span><br></pre></td></tr></table></figure><p>   结果如下：</p>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-04</span> <span class="number">00</span>:<span class="number">51</span>:<span class="number">33.474658</span>+<span class="number">0800</span> SWZ[<span class="number">8188</span>:<span class="number">509782</span>] -[Dog(Exchange) play]</span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-04</span> <span class="number">00</span>:<span class="number">51</span>:<span class="number">33.474795</span>+<span class="number">0800</span> SWZ[<span class="number">8188</span>:<span class="number">509782</span>] -[Dog(Exchange) play]</span><br></pre></td></tr></table></figure><p><strong>总结：可见子类方法执行了新方法<code>play</code>，但是同时父类的run 方法也给换走了，执行了新的play方法</strong></p><h4 id="7-3-2-追踪分析"><a href="#7-3-2-追踪分析" class="headerlink" title="7.3.2. 追踪分析"></a>7.3.2. 追踪分析</h4><p>在分析之前，先明白现在的场景：</p><ul><li>父类有该方法及其实现</li><li>子类并无该方法极其实现</li></ul><p>可见，业务场景向子类交换了该方法，子类查询方法并未找到，于是递归向父类查找，在父类的方法列表里查找成功，进而完成了交换过程。而父类下次调用该方法，结果使用了交换来的新方法。</p><p>好一个坑爹滴子类……</p><h4 id="7-3-3-解决"><a href="#7-3-3-解决" class="headerlink" title="7.3.3 解决"></a>7.3.3 解决</h4><p>面对如此坑爹的子类，解决方法只有一个，方法没有——自己实现。</p><p>当子类需要交换某方法的时候，尝试向自己添加待交换走的方法，以防自己未实现，不得不去找父类交换：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL success = class_addMethod([Dog class], oriSEL, swiIMP, method_getTypeEncoding(oriMethod));</span><br></pre></td></tr></table></figure><p>然后，如果添加成功，即自身本来并未实现，借着添加的机会实现了。</p><p>接下来做的就是，将新添加的方法与目标方法交换：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (success) </span><br><span class="line">     <span class="built_in">class_replaceMethod</span>([Dog <span class="keyword">class</span>],</span><br><span class="line">                         swiSEL,</span><br><span class="line">                         oriIMP,</span><br><span class="line">                         <span class="built_in">method_getTypeEncoding</span>(oriMethod)</span><br><span class="line">                         );</span><br></pre></td></tr></table></figure><p>当然， 如果添加失败，即原本就有，那么按原来的逻辑，直接交换两种方法即可</p><p>贴一下完整的完善的逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)load&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">        SEL oriSEL = @<span class="built_in">selector</span>(run);</span><br><span class="line">        SEL swiSEL = @<span class="built_in">selector</span>(play);</span><br><span class="line"></span><br><span class="line">        Method oriMethod = <span class="built_in">class_getInstanceMethod</span>(self, @<span class="built_in">selector</span>(run));</span><br><span class="line">        Method swiMethod = <span class="built_in">class_getInstanceMethod</span>(self, @<span class="built_in">selector</span>(play));</span><br><span class="line"></span><br><span class="line">        IMP oriIMP = <span class="built_in">method_getImplementation</span>(oriMethod);</span><br><span class="line">        IMP swiIMP = <span class="built_in">method_getImplementation</span>(swiMethod);</span><br><span class="line"></span><br><span class="line">        BOOL success = <span class="built_in">class_addMethod</span>([Dog <span class="keyword">class</span>], oriSEL, swiIMP, <span class="built_in">method_getTypeEncoding</span>(oriMethod));</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            <span class="built_in">class_replaceMethod</span>([Dog <span class="keyword">class</span>],</span><br><span class="line">                                swiSEL,</span><br><span class="line">                                oriIMP,</span><br><span class="line">                                <span class="built_in">method_getTypeEncoding</span>(oriMethod)</span><br><span class="line">                                );</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">method_exchangeImplementations</span>(oriMethod, swiMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-坑点2-待交换子类父类实现"><a href="#7-4-坑点2-待交换子类父类实现" class="headerlink" title="7.4 坑点2 - 待交换子类父类实现"></a>7.4 坑点2 - 待交换子类父类实现</h3><h4 id="7-4-1-症状"><a href="#7-4-1-症状" class="headerlink" title="7.4.1 症状"></a>7.4.1 症状</h4><p>上面的代码，解决了子类未实现不得不向父类索取，并拿出来交换的弊端。</p><p>那么如果该方法，父类都没实现呢？就是将父类的 <code>run</code>方法实现注释，会如何，再走一遍——</p><p><img src="/p/41032/009.png"></p><p>不出意外，瘪犊子了。</p><h4 id="7-4-2-追踪分析"><a href="#7-4-2-追踪分析" class="headerlink" title="7.4.2 追踪分析"></a>7.4.2 追踪分析</h4><p>这里很明白得出结论是，想要像某个类交换方法，结果该类以及向上的父类都没实现，毫无意外会造成崩溃。该怎么办呢？</p><p>先看一下一级一级的关系：</p><ul><li>交换方法——&gt;找当前类要<ul><li>找不到当前类的方法实现——找父类要<ul><li>找不到父类的方法实现——崩溃</li></ul></li></ul></li></ul><p>结合<strong>7.4</strong> 里的逻辑，追根溯源，是父类没有实现，那么需要做的是，先给父类添加一个<strong>空的实现</strong>，以避免崩溃。</p><p>然后在子类交换方法的过程中，子类会完善自身的添加方法实现，再去交换方法（这部分的逻辑是7.3）</p><h4 id="7-4-3-解决"><a href="#7-4-3-解决" class="headerlink" title="7.4.3 解决"></a>7.4.3 解决</h4><p>在交换方法时，先判断原方法是否存在，如果不存在，添加一个空方法实现。</p><p>添加部分如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!oriIMP) &#123;</span><br><span class="line">    class_addMethod(self, oriSEL, swiIMP, method_getTypeEncoding(swiMethod));</span><br><span class="line">    method_setImplementation(swiMethod, imp_implementationWithBlock(^(id self, SEL _cmd)&#123;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全文如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (void)load&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">        SEL oriSEL = @selector(run);</span><br><span class="line">        SEL swiSEL = @selector(play);</span><br><span class="line"></span><br><span class="line">        Method oriMethod = class_getInstanceMethod(self, @selector(run));</span><br><span class="line">        Method swiMethod = class_getInstanceMethod(self, @selector(play));</span><br><span class="line">        </span><br><span class="line">        IMP oriIMP = method_getImplementation(oriMethod);</span><br><span class="line">        IMP swiIMP = method_getImplementation(swiMethod);</span><br><span class="line"></span><br><span class="line">        if (!oriIMP) &#123;</span><br><span class="line">            class_addMethod(self, oriSEL, swiIMP, method_getTypeEncoding(swiMethod));</span><br><span class="line">            method_setImplementation(swiMethod, imp_implementationWithBlock(^(id self, SEL _cmd)&#123;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BOOL success = class_addMethod(self, oriSEL, swiIMP, method_getTypeEncoding(oriMethod));</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            class_replaceMethod([Dog class],</span><br><span class="line">                                swiSEL,</span><br><span class="line">                                oriIMP,</span><br><span class="line">                                method_getTypeEncoding(oriMethod)</span><br><span class="line">                                );</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            method_exchangeImplementations(oriMethod, swiMethod);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Z、总结"><a href="#Z、总结" class="headerlink" title="Z、总结"></a>Z、总结</h2><p>在这篇文章，初步汇总了一下关于Runtime 几个典型的问题，比如基础的SEL、IMP 的关系，以及self 和super 的区别，以及后面深一点的weak 的底层实现，还有业务上用得最多的黑魔法——方法交换使用过程中的几点坑，如果深刻理解了其内部实现，自然能避开这些坑。</p><p>希望在日后更深刻的理会这些原理，欢迎大家有问题留言交流。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 类 </tag>
            
            <tag> 2020 </tag>
            
            <tag> runtime </tag>
            
            <tag> 面试 </tag>
            
            <tag> 成员变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【类的加载】-（1）类的启动</title>
      <link href="/p/29664.html"/>
      <url>/p/29664.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自 <a href="https://opensource.apple.com/tarballs/objc4">Apple 开源文档</a></p></blockquote><blockquote><p><strong>类的加载探寻系列:</strong><br>1、<a href="https://nilsli.com/p/29664.html">【类的加载】-（1）类的启动</a></p><p>2、<a href="https://nilsli.com/p/38312.html">【类的加载】-（2）懒加载类与分类</a></p><p>3、<a href="https://nilsli.com/p/6283d578.html">【类的加载】-（3）loading_images</a></p></blockquote><h2 id="1、objc-init-流程"><a href="#1、objc-init-流程" class="headerlink" title="1、objc_init 流程"></a>1、objc_init 流程</h2><p>类的加载，初始化来自dyld 中的objc_init 这个步骤，查看一下源码，得到</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _objc_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    <span class="built_in">environ_init</span>();</span><br><span class="line">    <span class="built_in">tls_init</span>();</span><br><span class="line">    <span class="built_in">static_init</span>();</span><br><span class="line">    <span class="built_in">lock_init</span>();</span><br><span class="line">    <span class="built_in">exception_init</span>();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>源代码</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td>environ_init()</td><td>环境变量、帮助文档配置</td></tr><tr><td>2</td><td>tls_init()</td><td>线程key 的绑定</td></tr><tr><td>3</td><td>static_init</td><td>C++ 静态构造函数</td></tr><tr><td>4</td><td>lock_init()</td><td>锁配置</td></tr><tr><td>5</td><td>exception_init()</td><td>异常初始化</td></tr><tr><td>6</td><td>_dyld_objc_notify_register</td><td>Dyld 通知注册</td></tr></tbody></table><h3 id="1-1-environ-init"><a href="#1-1-environ-init" class="headerlink" title="1.1 environ_init"></a>1.1 environ_init</h3><blockquote><p>在函数<code>void environ_init(void) </code> 里，读取环境变量 <code>env</code>  以及帮助注释 <code>help</code>，</p></blockquote><p>相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(Settings)/<span class="built_in">sizeof</span>(Settings[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">option_t</span> *opt = &amp;Settings[i];            </span><br><span class="line">    <span class="keyword">if</span> (PrintHelp) _objc_inform(<span class="string">&quot;%s: %s&quot;</span>, opt-&gt;env, opt-&gt;help);</span><br><span class="line">    <span class="keyword">if</span> (PrintOptions &amp;&amp; *opt-&gt;var) _objc_inform(<span class="string">&quot;%s is set&quot;</span>, opt-&gt;env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，在控制台可以得到环境变量参数表：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_IMAGES: log image <span class="keyword">and</span> library names as they are loaded</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_IMAGE_TIMES: measure duration of image loading steps</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_LOAD_METHODS: log calls to <span class="keyword">class</span> <span class="title class_">and</span> category +load methods</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_INITIALIZE_METHODS: log calls to <span class="keyword">class</span> +initialize methods</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_RESOLVED_METHODS: log methods created by +resolveClassMethod: <span class="keyword">and</span> +resolveInstanceMethod:</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_CLASS_SETUP: log progress of <span class="keyword">class</span> <span class="title class_">and</span> category setup</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_PROTOCOL_SETUP: log progress of protocol setup</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_IVAR_SETUP: log processing of non-fragile ivars</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_VTABLE_SETUP: log processing of <span class="keyword">class</span> <span class="title class_">vtables</span></span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_VTABLE_IMAGES: print vtable images showing overridden methods</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_CACHE_SETUP: log processing of method caches</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_FUTURE_CLASSES: log use of future classes <span class="keyword">for</span> toll-free bridging</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_PREOPTIMIZATION: log preoptimization courtesy of dyld shared cache</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_CXX_CTORS: log calls to C++ ctors <span class="keyword">and</span> dtors <span class="keyword">for</span> instance variables</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_EXCEPTIONS: log exception handling</span><br><span class="line">objc[<span class="number">27076</span>]: OBJC_PRINT_EXCEPTION_THROW: <span class="function">log backtrace of every <span class="title">objc_exception_throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">objc[27076]: OBJC_PRINT_ALT_HANDLERS: log processing of exception alt handlers</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_PRINT_REPLACED_METHODS: log methods replaced by category implementations</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_PRINT_DEPRECATION_WARNINGS: warn about calls to deprecated runtime functions</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_PRINT_POOL_HIGHWATER: log high-water marks for autorelease pools</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_PRINT_CUSTOM_RR: log classes with un-optimized custom retain/release methods</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_PRINT_CUSTOM_AWZ: log classes with un-optimized custom allocWithZone methods</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_PRINT_RAW_ISA: log classes that require raw pointer isa fields</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DEBUG_UNLOAD: warn about poorly-behaving bundles when unloaded</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DEBUG_FRAGILE_SUPERCLASSES: warn about subclasses that may have been broken by subsequent changes to superclasses</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DEBUG_NIL_SYNC: warn about @synchronized(nil), which does no synchronization</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DEBUG_NONFRAGILE_IVARS: capriciously rearrange non-fragile ivars</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DEBUG_ALT_HANDLERS: record more info about bad alt handler use</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DEBUG_MISSING_POOLS: warn about autorelease with no pool in place, which may be a leak</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DEBUG_POOL_ALLOCATION: halt when autorelease pools are popped out of order, and allow heap debuggers to track autorelease pools</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DEBUG_DUPLICATE_CLASSES: halt when multiple classes with the same name are present</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DEBUG_DONT_CRASH: halt the process by exiting instead of crashing</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DISABLE_VTABLES: disable vtable dispatch</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DISABLE_PREOPTIMIZATION: disable preoptimization courtesy of dyld shared cache</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DISABLE_TAGGED_POINTERS: disable tagged pointer optimization of NSNumber et al.</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DISABLE_TAG_OBFUSCATION: disable obfuscation of tagged pointers</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DISABLE_NONPOINTER_ISA: disable non-pointer isa fields</span></span><br><span class="line"><span class="function">objc[<span class="number">27076</span>]: OBJC_DISABLE_INITIALIZE_FORK_SAFETY: disable safety checks for +initialize after fork</span></span><br></pre></td></tr></table></figure><h3 id="1-2-tls-init"><a href="#1-2-tls-init" class="headerlink" title="1.2 tls_init()"></a>1.2 tls_init()</h3><blockquote><p>对线程的Key 的绑定。</p></blockquote><p>这部分不展开讨论</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tls_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    _objc_pthread_key = TLS_DIRECT_KEY;</span><br><span class="line">    <span class="built_in">pthread_key_init_np</span>(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = <span class="built_in">tls_create</span>(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-static-init"><a href="#1-3-static-init" class="headerlink" title="1.3 static_init"></a>1.3 static_init</h3><blockquote><p>实现系统级别的 C++ 静态构造函数。</p></blockquote><p><strong>相关源码</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> inits = <span class="built_in">getLibobjcInitializers</span>(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        inits[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-lock-init"><a href="#1-4-lock-init" class="headerlink" title="1.4 lock_init"></a>1.4 lock_init</h3><blockquote><p>锁的初始化，这里并没有进行实现，意味着可以进行重写，自定义一些操作。</p></blockquote><p><strong>相关源码：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* Lock management</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="type">mutex_t</span> runtimeLock;</span><br><span class="line"><span class="type">mutex_t</span> selLock;</span><br><span class="line"><span class="type">mutex_t</span> cacheUpdateLock;</span><br><span class="line"><span class="type">recursive_mutex_t</span> loadMethodLock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-exception-init"><a href="#1-5-exception-init" class="headerlink" title="1.5 exception_init"></a>1.5 exception_init</h3><blockquote><p><strong>异常的初始化：</strong>libobjc 的异常回调系统初始化，由map_images 调用。</p></blockquote><p>即注册监听回调。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* exception_init</span></span><br><span class="line"><span class="comment">* Initialize libobjc&#x27;s exception handling system.</span></span><br><span class="line"><span class="comment">* Called by map_images().</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exception_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    old_terminate = std::<span class="built_in">set_terminate</span>(&amp;_objc_terminate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个c++ 函数 <code>set_terminate</code> 会初始化静态的 异常回调。在OC 环境下，所有的异常抛出，都会到<code>(*old_terminate)();</code> 这行代码里。</p><p>相关源码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(*old_terminate)</span><span class="params">(<span class="type">void</span>)</span> </span>= nil;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _objc_terminate(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PrintExceptions) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;EXCEPTIONS: terminating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! __cxa_current_exception_type()) &#123;</span><br><span class="line">        <span class="comment">// No current exception.</span></span><br><span class="line">        (*old_terminate)();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// There is a current exception. Check if it&#x27;s an objc exception.</span></span><br><span class="line">        @<span class="keyword">try</span> &#123;</span><br><span class="line">            __cxa_rethrow();</span><br><span class="line">        &#125; @<span class="built_in">catch</span> (id e) &#123;</span><br><span class="line">            <span class="comment">// It&#x27;s an objc object. Call Foundation&#x27;s handler, if any.</span></span><br><span class="line">            (*uncaught_handler)((id)e);</span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125; @<span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            <span class="comment">// It&#x27;s not an objc object. Continue to C++ terminate.</span></span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在业务代码里执行一个报错的方法：</p><ul><li><p>类声明与实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface Dog : NSObject</span><br><span class="line">- (<span class="type">void</span>)bark;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>使用类执行为实现的方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Dog *d = [Dog alloc];</span><br><span class="line">[d bark];</span><br></pre></td></tr></table></figure></li><li><p>异常抛出如下图所示：</p><p><img src="/p/29664/001.png" alt="objc_terminate 异常抛出"></p></li></ul><h3 id="1-6-dyld-objc-notify-register（核心）"><a href="#1-6-dyld-objc-notify-register（核心）" class="headerlink" title="1.6 _dyld_objc_notify_register（核心）"></a>1.6 _dyld_objc_notify_register（核心）</h3><blockquote><ol><li>objc 特有方法</li><li>注册回调。当镜像文件被映射(mapped)、未被映射(unmapped)、初始化(initialized) 使调用。</li><li>该方法由dyld 声明。</li><li>镜像文件加载完后，dyld 会回调”映射”函数，内容为一个包含objc-image-info 数据段的数组。</li></ol></blockquote><p>注册方法<strong>源码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br></pre></td></tr></table></figure><p> 这里主要关注 <code>map_images</code> 的这个对象，其实现代码为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">map_images</span><span class="params">(<span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> paths[],</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> <span class="keyword">struct</span> mach_header * <span class="type">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map_images_nolock</span>(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读取镜像文件</strong></p><p>继续探索 <code>map_images_nolock</code> 这个函数，读取镜像文件的关键行为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，这一部分到此就结束了，关于images 的流程，另外单独分析。</p><h2 id="2、read-images-读镜像文件"><a href="#2、read-images-读镜像文件" class="headerlink" title="2、read_images - 读镜像文件"></a>2、read_images - 读镜像文件</h2><h4 id="2-1-初次进来-创建容器哈希表"><a href="#2-1-初次进来-创建容器哈希表" class="headerlink" title="2.1 初次进来: 创建容器哈希表"></a>2.1 初次进来: 创建容器哈希表</h4><p>根据源码，得知读取镜像的主要函数为<code>read_image</code> ，其函数具体为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _read_images(header_info **hList, <span class="type">uint32_t</span> hCount, <span class="type">int</span> totalClasses, <span class="type">int</span> unoptimizedTotalClasses)&#123;&#125;</span><br></pre></td></tr></table></figure><p>读取镜像后，最先需要做的是，为这些景象里的内容找一个家——容器，也就是开辟表结构。</p><p>在源码里，这里分别通过<code>NXCreateMapTable</code>、<code>NXCreateHashTable</code>开辟了2个表，主要存储以下的内容：</p><ul><li><p>未共享缓存的类 <code>gdb_objc_realized_classes</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gdb_objc_realized_classes =</span><br><span class="line">    <span class="built_in">NXCreateMapTable</span>(NXStrValueMapPrototype, namedClassesSize);</span><br></pre></td></tr></table></figure></li><li><p>开辟内存空间类 - <code>allocatedClasses</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">allocatedClasses = <span class="built_in">NXCreateHashTable</span>(NXPtrPrototype, <span class="number">0</span>, nil);</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-类的处理"><a href="#2-2-类的处理" class="headerlink" title="2.2 类的处理"></a>2.2 类的处理</h4><blockquote><p>从编译后的类列表中，取出所有的类，并进行下一步操作。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="type">classref_t</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>取出系统类</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class cls = (Class)classlist[i]；</span><br></pre></td></tr></table></figure></li><li><p>读取类 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class newCls = <span class="built_in">readClass</span>(cls, headerIsBundle, headerIsPreoptimized);</span><br></pre></td></tr></table></figure></li><li><p>懒加载相关，条件为 <code>newCls != cls &amp;&amp; newCls</code>， 即两个类不相等时</p><ol><li><p>初始化懒加载所需内存空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">resolvedFutureClasses = (Class *)</span><br><span class="line">                    <span class="built_in">realloc</span>(resolvedFutureClasses, </span><br><span class="line">                            (resolvedFutureClassCount+<span class="number">1</span>) * <span class="built_in">sizeof</span>(Class));</span><br></pre></td></tr></table></figure></li><li><p>懒加载的类添加到数组中来</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="2-3-方法编号处理"><a href="#2-3-方法编号处理" class="headerlink" title="2.3 方法编号处理"></a>2.3 方法编号处理</h4><blockquote><p>把未注册的方法名进行注册到一张HASH表里，形成方法名与方法的映射</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> UnfixedSelectors;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="type">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">      <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">          <span class="keyword">if</span> (hi-&gt;<span class="built_in">isPreoptimized</span>()) <span class="keyword">continue</span>;</span><br><span class="line">          </span><br><span class="line">          <span class="type">bool</span> isBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">          SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">          UnfixedSelectors += count;</span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">              <span class="type">const</span> <span class="type">char</span> *name = <span class="built_in">sel_cname</span>(sels[i]);</span><br><span class="line">              <span class="comment">// 注册SEL的操作</span></span><br><span class="line">              sels[i] = <span class="built_in">sel_registerNameNoLock</span>(name, isBundle);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注册到的表名为<code>namedSelectors</code>， 具体的实现在这里</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NXMapInsert</span>(namedSelectors, <span class="built_in">sel_getName</span>(result), result);</span><br></pre></td></tr></table></figure><h4 id="2-4-协议处理"><a href="#2-4-协议处理" class="headerlink" title="2.4 协议处理"></a>2.4 协议处理</h4><blockquote><p>找到类遵守的协议，修复协议的引用。</p><p>关键字: readProtocol 、remapProtocolRef</p></blockquote><p>相关源码，如下所示:</p><p><strong>找到协议：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">        NXMapTable *protocol_map = <span class="built_in">protocols</span>();</span><br><span class="line">        <span class="type">protocol_t</span> **protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="built_in">readProtocol</span>(protolist[i], cls, protocol_map,</span><br><span class="line">                         isPreoptimized, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>修复协议引用（重映射）：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="type">protocol_t</span> **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="built_in">remapProtocolRef</span>(&amp;protolist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-非懒加载处理"><a href="#2-5-非懒加载处理" class="headerlink" title="2.5 非懒加载处理"></a>2.5 非懒加载处理</h4><blockquote><p>初始化所有非懒加载类，进行 <code>rw</code> <code>ro</code> 操作</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">      <span class="type">classref_t</span> *classlist =</span><br><span class="line">          _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">      <span class="built_in">addClassTableEntry</span>(cls);</span><br><span class="line">      <span class="built_in">realizeClassWithoutSwift</span>(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-待处理的类"><a href="#2-6-待处理的类" class="headerlink" title="2.6 待处理的类"></a>2.6 待处理的类</h4><blockquote><p>找到最新特征的类，以备CoreFoundation 需要操作它</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">            Class cls = resolvedFutureClasses[i];</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Swift class is not allowed to be future&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">realizeClassWithoutSwift</span>(cls);</span><br><span class="line">            cls-&gt;<span class="built_in">setInstancesRequireRawIsa</span>(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(resolvedFutureClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-分类处理"><a href="#2-7-分类处理" class="headerlink" title="2.7 分类处理"></a>2.7 分类处理</h4><blockquote><p>对非类进行处理，包括<code>Class</code> 的和<code>metaClass</code> 的</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">       <span class="type">category_t</span> **catlist =</span><br><span class="line">           _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">       <span class="type">bool</span> hasClassProperties = hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">hasCategoryClassProperties</span>();</span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="type">category_t</span> *cat = catlist[i];</span><br><span class="line">           Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、类方法重点"><a href="#3、类方法重点" class="headerlink" title="3、类方法重点"></a>3、类方法重点</h2><h3 id="3-1-类的读取readClasses"><a href="#3-1-类的读取readClasses" class="headerlink" title="3.1 类的读取readClasses"></a>3.1 类的读取<code>readClasses</code></h3><h4 id="3-1-1-判断是否是未来处理的类-（popFutureNamedClass）"><a href="#3-1-1-判断是否是未来处理的类-（popFutureNamedClass）" class="headerlink" title="3.1.1 判断是否是未来处理的类 （popFutureNamedClass）"></a>3.1.1 <strong>判断是否是未来处理的类</strong> （<code>popFutureNamedClass</code>）</h4><p>如果是，就读取data，设置rw 和 ro</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Class newCls = <span class="built_in">popFutureNamedClass</span>(mangledName)) &#123;</span><br><span class="line">        <span class="comment">// This name was previously allocated as a future class.</span></span><br><span class="line">        <span class="comment">// Copy objc_class to future class&#x27;s struct.</span></span><br><span class="line">        <span class="comment">// Preserve future&#x27;s rw data block.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (newCls-&gt;<span class="built_in">isAnySwift</span>()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Can&#x27;t complete future class request for &#x27;%s&#x27; &quot;</span></span><br><span class="line">                        <span class="string">&quot;because the real class is too big.&quot;</span>, </span><br><span class="line">                        cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里，读取data(), 并进行设置 rw /ro</span></span><br><span class="line">        <span class="type">class_rw_t</span> *rw = newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">class_ro_t</span> *old_ro = rw-&gt;ro;</span><br><span class="line">        <span class="built_in">memcpy</span>(newCls, cls, <span class="built_in">sizeof</span>(objc_class));</span><br><span class="line">        rw-&gt;ro = (<span class="type">class_ro_t</span> *)newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">        newCls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">        <span class="built_in">freeIfMutable</span>((<span class="type">char</span> *)old_ro-&gt;name);</span><br><span class="line">        <span class="built_in">free</span>((<span class="type">void</span> *)old_ro);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">addRemappedClass</span>(cls, newCls);</span><br><span class="line">        </span><br><span class="line">        replacing = cls;</span><br><span class="line">        cls = newCls;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-添加命名过的类"><a href="#3-1-2-添加命名过的类" class="headerlink" title="3.1.2 添加命名过的类"></a>3.1.2 添加命名过的类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">addNamedClass</span>(cls, mangledName, replacing);</span><br></pre></td></tr></table></figure><h4 id="3-1-3-把类插入到包含所有类的表里"><a href="#3-1-3-把类插入到包含所有类的表里" class="headerlink" title="3.1.3 把类插入到包含所有类的表里"></a>3.1.3 把类插入到包含所有类的表里</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">addClassTableEntry</span>(cls);</span><br></pre></td></tr></table></figure><p>具体的实现为如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addClassTableEntry</span><span class="params">(Class cls, <span class="type">bool</span> addMeta = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This class is allowed to be a known class via the shared cache or via</span></span><br><span class="line">    <span class="comment">// data segments, but it is not allowed to be in the dynamic table already.</span></span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">NXHashMember</span>(allocatedClasses, cls));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isKnownClass</span>(cls))</span><br><span class="line">        <span class="built_in">NXHashInsert</span>(allocatedClasses, cls);</span><br><span class="line">    <span class="keyword">if</span> (addMeta)</span><br><span class="line">        <span class="built_in">addClassTableEntry</span>(cls-&gt;<span class="built_in">ISA</span>(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-realizeClassWithoutSwift"><a href="#3-2-realizeClassWithoutSwift" class="headerlink" title="3.2 realizeClassWithoutSwift"></a>3.2 realizeClassWithoutSwift</h3><blockquote><p>实现类的初次初始化，包括开辟rw数据的内存空间。</p></blockquote><h4 id="3-2-1-取出类里的-ro-部分（data）"><a href="#3-2-1-取出类里的-ro-部分（data）" class="headerlink" title="3.2.1 取出类里的 ro 部分（data）"></a>3.2.1 取出类里的 ro 部分（data）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ro = (<span class="type">const</span> <span class="type">class_ro_t</span> *)cls-&gt;<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure><h4 id="3-2-2-开辟rw-内存空间"><a href="#3-2-2-开辟rw-内存空间" class="headerlink" title="3.2.2 开辟rw 内存空间"></a>3.2.2 开辟rw 内存空间</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">rw = (<span class="type">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">rw-&gt;ro = ro;</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">cls-&gt;<span class="built_in">setData</span>(rw);</span><br></pre></td></tr></table></figure><p>最终通过<code>cls-&gt;setData(rw)</code> , 将rw 作为data赋值给类 cls。</p><p>但是到这里，cls 仅仅是对数据部分做了<strong>初始化</strong>，里面的方法都没有写入。</p><p>如何验证？</p><p>通过lldb 来进行验证吧：</p><ol><li>通过p&#x2F;x 获取cls指针</li><li>偏移16位获得bits 的指针</li><li>将bits 强转为<code>class_data_bits_t</code> 的类型$2</li><li>读取$2点data() 方法。</li></ol><p>过程可见下图，methods 属性下的list 为空，并没有方法列表的写入。</p><p><img src="/p/29664/002.png" alt="通过lldb 得到的rw 部分"></p><p>可见该过程，仅仅对<code>cls</code> 下<code>rw</code> 的属性的<code>ro</code> 、<code>flags</code>进行了赋值，而<code>rw</code> 并没有得到赋值</p><h4 id="3-2-3-实现父类和元类关联"><a href="#3-2-3-实现父类和元类关联" class="headerlink" title="3.2.3 实现父类和元类关联"></a>3.2.3 实现父类和元类关联</h4><h5 id="3-2-3-1-子类链接父类"><a href="#3-2-3-1-子类链接父类" class="headerlink" title="3.2.3.1 子类链接父类"></a>3.2.3.1 子类链接父类</h5><p>上面的流程都是在初始化类的各种属性后，而类的结构最重要的一点是它与父类的关联，以及与元类的isa 指向。</p><p>所以下面的操作是</p><ul><li>通过<code>remapClass(cls-&gt;superclass)</code>对父类进行映射查找</li><li>通过<code>remapClass(cls-&gt;ISA)</code>对元类进行查找</li></ul><p>然后通过<code>realizeClassWithoutSwift</code> 进行递归，逐步得到相应的<code>supercls</code>以及<code>metacls</code> 的指针。</p><p>步骤依然是：<strong>类——元类——根元类——NSObject——nil</strong>（跳出）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">supercls = <span class="built_in">realizeClassWithoutSwift</span>(<span class="built_in">remapClass</span>(cls-&gt;superclass));</span><br><span class="line">metacls = <span class="built_in">realizeClassWithoutSwift</span>(<span class="built_in">remapClass</span>(cls-&gt;<span class="built_in">ISA</span>()));</span><br></pre></td></tr></table></figure><p>这两个失踪人口进行搜寻成功后，就可以将其指针对类进行关联</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Update superclass and metaclass in case of remapping</span></span><br><span class="line">cls-&gt;superclass = supercls;</span><br><span class="line">cls-&gt;<span class="built_in">initClassIsa</span>(metacls);</span><br></pre></td></tr></table></figure><h5 id="3-2-3-2-父类链接子类"><a href="#3-2-3-2-父类链接子类" class="headerlink" title="3.2.3.2 父类链接子类"></a>3.2.3.2 父类链接子类</h5><p>如果找到父类，在父类添加双向链表的引用，将子类引用添加到父类的子类列表里，最终实现父类和子类建立关联</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Connect this class to its superclass&#x27;s subclass lists</span><br><span class="line">if (supercls) &#123;</span><br><span class="line">    addSubclass(supercls, cls);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    addRootClass(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论是：子类里添加父类链接，父类里也添加子类链接，你中有我，我中有你。</p><p><img src="/p/29664/003.png" alt="子类——父类关联图"></p><p>接下来看一下父类链接的具体实现：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addSubclass</span><span class="params">(Class supercls, Class subcls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  subcls) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(supercls-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="built_in">assert</span>(subcls-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">        subcls-&gt;<span class="built_in">data</span>()-&gt;nextSiblingClass = supercls-&gt;<span class="built_in">data</span>()-&gt;firstSubclass;</span><br><span class="line">        supercls-&gt;<span class="built_in">data</span>()-&gt;firstSubclass = subcls;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supercls-&gt;<span class="built_in">hasCxxCtor</span>()) &#123;</span><br><span class="line">            subcls-&gt;<span class="built_in">setHasCxxCtor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supercls-&gt;<span class="built_in">hasCxxDtor</span>()) &#123;</span><br><span class="line">            subcls-&gt;<span class="built_in">setHasCxxDtor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supercls-&gt;<span class="built_in">hasCustomRR</span>()) &#123;</span><br><span class="line">            subcls-&gt;<span class="built_in">setHasCustomRR</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supercls-&gt;<span class="built_in">hasCustomAWZ</span>()) &#123;</span><br><span class="line">            subcls-&gt;<span class="built_in">setHasCustomAWZ</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Special case: instancesRequireRawIsa does not propagate </span></span><br><span class="line">        <span class="comment">// from root class to root metaclass</span></span><br><span class="line">        <span class="keyword">if</span> (supercls-&gt;<span class="built_in">instancesRequireRawIsa</span>()  &amp;&amp;  supercls-&gt;superclass) &#123;</span><br><span class="line">            subcls-&gt;<span class="built_in">setInstancesRequireRawIsa</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现为：</p><p>父类的第一个子类，赋值给子类的下一个兄弟类：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">subcls-&gt;<span class="built_in">data</span>()-&gt;nextSiblingClass = supercls-&gt;<span class="built_in">data</span>()-&gt;firstSubclass;</span><br></pre></td></tr></table></figure><p>子类赋值给父类的第一个子类：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">supercls-&gt;<span class="built_in">data</span>()-&gt;firstSubclass = subcls;</span><br></pre></td></tr></table></figure><p>同时，子类继承父类的各种能力</p><ul><li>hasCxxCtor</li><li>hasCxxDtor</li><li>hasCustomRR</li><li>hasCustomAWZ</li><li>instancesRequireRawIsa（适用NONPOINTER_ISA）</li></ul><h4 id="3-2-4-methodizeClass-rw-内容的填充"><a href="#3-2-4-methodizeClass-rw-内容的填充" class="headerlink" title="3.2.4 methodizeClass - rw 内容的填充"></a>3.2.4 methodizeClass - rw 内容的填充</h4><blockquote><ol><li><p>对之前创建的rw 进行方法、属性，协议的填充实现</p></li><li><p>对分类的实现</p></li></ol></blockquote><ul><li><p>方法的填充实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">method_list_t</span> *list = ro-&gt;<span class="built_in">baseMethods</span>();</span><br><span class="line"><span class="keyword">if</span> (list) &#123;</span><br><span class="line">    <span class="built_in">prepareMethodLists</span>(cls, &amp;list, <span class="number">1</span>, YES, <span class="built_in">isBundleClass</span>(cls));</span><br><span class="line">    rw-&gt;methods.<span class="built_in">attachLists</span>(&amp;list, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性填充实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line"><span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">    rw-&gt;properties.<span class="built_in">attachLists</span>(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>协议填充实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line"><span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">    rw-&gt;protocols.<span class="built_in">attachLists</span>(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根元类额外的实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cls-&gt;<span class="built_in">isRootMetaclass</span>()) &#123;</span><br><span class="line">        <span class="comment">// root metaclass</span></span><br><span class="line">        <span class="built_in">addMethod</span>(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, <span class="string">&quot;&quot;</span>, NO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>添加分类</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Attach categories.</span></span><br><span class="line">category_list *cats = <span class="built_in">unattachedCategoriesForClass</span>(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</span><br><span class="line"><span class="built_in">attachCategories</span>(cls, cats, <span class="literal">false</span> <span class="comment">/*don&#x27;t flush caches*/</span>);</span><br></pre></td></tr></table></figure></li></ul><p>提一下上面的方法实现中添加的机制，究竟是如何的？继续看源码，可以看到添加情况有3种</p><ul><li><p>多对多 - 方法原已有多个，在需要添加多个</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">hasArray</span>()) &#123;</span><br><span class="line">    <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">    <span class="type">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">    <span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">    <span class="built_in">setArray</span>((<span class="type">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="type">array_t</span>::<span class="built_in">byteSize</span>(newCount)));</span><br><span class="line">    <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">    <span class="built_in">memmove</span>(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">            oldCount * <span class="built_in">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">           addedCount * <span class="built_in">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里经历了3个步骤：</p><ul><li>获取原方法数： <code>array()-&gt;count</code></li><li>获取原方法数+新方法的总方法数： <code>oldCount + addedCount</code></li><li>内存扩容：<code>realloc</code></li><li>字节移动：内存中原方法平移：<code>memmove</code></li><li>字节移动：新方法拷贝进入：<code>memcpy</code></li></ul></li><li><p>0 对多 - 方法原没有，在需要添加多个</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list = addedLists[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></li><li><p>1 对多</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">List* oldList = list;</span><br><span class="line"><span class="type">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line"><span class="built_in">setArray</span>((<span class="type">array_t</span> *)<span class="built_in">malloc</span>(<span class="type">array_t</span>::<span class="built_in">byteSize</span>(newCount)));</span><br><span class="line"><span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line"><span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="built_in">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>另外，可以观察到无论是方法<code>methods</code>、属性<code>properties</code>、协议<code>protocols</code>，在添加时，使用的同样的方法<code>attachLists</code>， 这是因为作为同为<code>class_rw_t</code>类型下的属性，他们拥有同样的数据结构：二维数组。</p><p>其中方法列表和属性列表的根类型，均为<code>entsize_list_tt</code></p><p>方法列表结构：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">method_array_t</span> : </span><br><span class="line">    <span class="keyword">public</span> list_array_tt&lt;<span class="type">method_t</span>, <span class="type">method_list_t</span>&gt;</span><br></pre></td></tr></table></figure><p>属性列表结构：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">property_array_t</span> : <span class="keyword">public</span> list_array_tt&lt;<span class="type">property_t</span>, <span class="type">property_list_t</span>&gt;</span><br></pre></td></tr></table></figure><p>协议列表结构：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">protocol_array_t</span> : </span><br><span class="line">    <span class="keyword">public</span> list_array_tt&lt;<span class="type">protocol_ref_t</span>, <span class="type">protocol_list_t</span>&gt;</span><br></pre></td></tr></table></figure><p>方法列表设计成二维数组，方便分类方法的批量插入：</p><p><img src="/p/29664/004.png" alt="method_array_t 结构图"></p><h2 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h2><blockquote><p>类的加载，流程分为环境的启动配置、加载镜像、读取类方法、对类内存空间初始化、子类-父类建立连接，以及最终rw填充方法，并对分类方法加入进行实现。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> iOS </tag>
            
            <tag> 源码 </tag>
            
            <tag> Class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【底层探索】dyld浅析</title>
      <link href="/p/62973.html"/>
      <url>/p/62973.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime">GITHUB</a></p></blockquote><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>前文研究了对象、方法的基础，知道了对象&#x2F;类的结构，类方法的生成和传递原理。下面该进入到核心环节，就是类的加载了，在这一个模块，需要了解的有下面几点：</p><ul><li>OC 的库</li><li>app 的加载流程</li><li>image 的结构</li><li>回调函数</li><li>image 的加载流程</li></ul><h2 id="二、库"><a href="#二、库" class="headerlink" title="二、库"></a>二、库</h2><h3 id="2-1、静态库"><a href="#2-1、静态库" class="headerlink" title="2.1、静态库"></a>2.1、静态库</h3><blockquote><p>是一个外部函数与变量的集合体</p><p>iOS 在<strong>编译时</strong>执行静态库，链接到相应代码</p></blockquote><p>静态库的文件内容，通常包含一堆程序员自定的变量与函数，其内容不像动态链接库那么复杂，在编译期间由编译器与链接器将它集成至应用程序内，并制作成目标文件以及可以独立运作的可执行文件。</p><p>常见的iOS 环境下的静态库由 <code>.a</code> 文件，<code>.framework</code> 文件。java 环境下有<code>.so</code> 静态库</p><h3 id="2-2、动态库"><a href="#2-2、动态库" class="headerlink" title="2.2、动态库"></a>2.2、动态库</h3><blockquote><p>iOS 在<strong>运行时</strong>执行动态库，链接到相应的代码里。</p></blockquote><p> .dylib 库文件</p><h2 id="三、App-启动流程"><a href="#三、App-启动流程" class="headerlink" title="三、App 启动流程"></a>三、App 启动流程</h2><h3 id="1-dyld-start"><a href="#1-dyld-start" class="headerlink" title="1. dyld start"></a>1. dyld start</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">libdyld.dylib`start</span><br></pre></td></tr></table></figure><h3 id="2-加载镜像"><a href="#2-加载镜像" class="headerlink" title="2. 加载镜像"></a>2. 加载镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reloadAllImages:</span><br></pre></td></tr></table></figure><h3 id="3-加载链接"><a href="#3-加载链接" class="headerlink" title="3. 加载链接"></a>3. 加载链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loadInsertedDylib</span><br></pre></td></tr></table></figure><ul><li>插入（insert）： 插入网线</li><li>链接（link）： 接通网络</li></ul><h2 id="四、dyld"><a href="#四、dyld" class="headerlink" title="四、dyld"></a>四、dyld</h2><h3 id="4-1-start"><a href="#4-1-start" class="headerlink" title="4.1 start"></a>4.1 start</h3><h3 id="4-2-递归初始化"><a href="#4-2-递归初始化" class="headerlink" title="4.2 递归初始化"></a>4.2 递归初始化</h3><h3 id="4-3-objc-init"><a href="#4-3-objc-init" class="headerlink" title="4.3 objc_init"></a>4.3 objc_init</h3><h2 id="五、镜像-images"><a href="#五、镜像-images" class="headerlink" title="五、镜像 - images"></a>五、镜像 - images</h2><ul><li>dyld</li><li>Objc_init</li></ul><h2 id="六、回调函数"><a href="#六、回调函数" class="headerlink" title="六、回调函数"></a>六、回调函数</h2><ul><li>指针</li><li>注册</li><li>*snotif</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> 源码 </tag>
            
            <tag> dyld </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法的本质4_消息转发机制</title>
      <link href="/p/59010.html"/>
      <url>/p/59010.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime">GITHUB</a></p></blockquote><h3 id="1、回顾"><a href="#1、回顾" class="headerlink" title="1、回顾"></a>1、回顾</h3><p>上文消息<a href="http://nilsli.com/2020/03/06/wayOfCheckingMethod/">方法的本质3_消息查找流程</a> 一文总结了方法查找的流程，得到结论如下:</p><blockquote><ol><li>类的缓存里查找——找到——结束查找</li><li>类的方法列表里查找——找到——结束查找</li><li>递归父类缓存、方法列表查找——找到——结束查找</li><li>动态方法解析——（未分析）</li><li>以上未解决——异常崩溃——结束</li></ol></blockquote><p>下面继续学习源码，结合业务代码，深挖第四步 <strong>动态方法决议</strong>，来更深一步的学习<strong>消息转发机制</strong>。</p><h3 id="2、问题"><a href="#2、问题" class="headerlink" title="2、问题"></a>2、问题</h3><p>这篇文章，希望弄清楚下面的问题</p><ul><li>消息转发是什么</li><li>消息转发的场景</li><li>如何进行消息转发</li></ul><h3 id="3、动态方法决议"><a href="#3、动态方法决议" class="headerlink" title="3、动态方法决议"></a>3、动态方法决议</h3><h4 id="3-1-入口-class-resolveMethod"><a href="#3-1-入口-class-resolveMethod" class="headerlink" title="3.1 入口 - class_resolveMethod"></a>3.1 入口 - class_resolveMethod</h4><p>之前的分析，知道了当查找缓存未命中后，会执行<code>objc_msgSend_uncached</code> 的方法，进行方法查找。</p><p>具体执行的是方法 <code>_class_lookupMethodAndLoadCache3</code> 。</p><p>runtime 源码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _class_lookupMethodAndLoadCache.</span></span><br><span class="line"><span class="comment">* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().</span></span><br><span class="line"><span class="comment">* This lookup avoids optimistic cache scan because the dispatcher </span></span><br><span class="line"><span class="comment">* already tried that.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookUpImpOrForward</span>(cls, sel, obj, </span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码中，知道了具体执行的方法是 <code>lookUpImpOrForward</code>，这个方法执行了众多流程，缓存、递归查找等。</p><p>如果都未命中，则会找到<strong>方法决议</strong>实现，代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    runtimeLock.<span class="built_in">unlock</span>();</span><br><span class="line">    _class_resolveMethod(cls, sel, inst);</span><br><span class="line">    runtimeLock.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// Don&#x27;t cache the result; we don&#x27;t hold the lock so it may have </span></span><br><span class="line">    <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">    triedResolver = YES;</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到执行 <code>_class_resolveMethod(cls, sel, inst)</code> 前后，使用了runtimeLock 进行了锁定与解锁，具体实现时互斥锁（参见Cooci老师的<a href="https://www.jianshu.com/p/32068ffa6136">互斥锁-读写锁-条件锁</a>），来保证内存安全。</p><p>查看一下class_resolveMethod 方法</p><blockquote><p><strong>Summary</strong></p><p> _class_resolveMethod Call +resolveClassMethod or +resolveInstanceMethod. Returns nothing; any result would be potentially out-of-date already. Does not check if the method already exists.</p><p>class_resolveMethod 调用  +resolveClassMethod 或 +resolveInstanceMethod。</p><p>返回值为空；任何结果将可能已经过期。</p><p>如果方法已经存在，不会检查&#x2F;执行。</p></blockquote><p>由此可见resolveMethod 只是一个入口，会具体调用如下方法：</p><ul><li>类方法：+resolveInstanceMethod</li><li>实例方法：+resolveInstanceMethod</li></ul><p>具体的源码，见下面的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;<span class="built_in">isMetaClass</span>()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line"></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">lookUpImpOrNil</span>(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>代码</th><th>分析</th><th>备注</th></tr></thead><tbody><tr><td>! cls-&gt;isMetaClass()</td><td>是否元类</td><td>否，说明主体是实例</td></tr><tr><td>_class_resolveInstanceMethod</td><td>实例方法决议实现</td><td></td></tr><tr><td>_class_resolveClassMethod</td><td>类方法决议实现</td><td></td></tr><tr><td>_class_resolveInstanceMethod</td><td>[第2个] 查看NSObject 决议实现</td><td>发生在lookUpImpOrNil 失败后</td></tr></tbody></table><p><strong>分析:</strong> </p><blockquote><p>进入决议后，先确定是否是元类；</p><p>如果是元类，由于已知类方法存储在元类里，知道该方法主体是类，则会进入类方法决议</p><p>如果不是元类，即方法主题是实例，进入实例方法决议。</p><p>如果元类方法决议查找失败，根元类亦查找失败，由于根元类的isa 是指向自身的，所以用到了 <code>_class_resolveInstanceMethod</code> 的实例决议方法。</p></blockquote><p>具体逻辑见下图：</p><p><img src="/p/59010/001.png" alt="001"></p><h4 id="3-2-类方法决议-class-resolveClassMethod"><a href="#3-2-类方法决议-class-resolveClassMethod" class="headerlink" title="3.2 类方法决议 - _class_resolveClassMethod"></a>3.2 类方法决议 - _class_resolveClassMethod</h4><p>捋清楚入口后，继续看类方法的决议，源码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _class_resolveClassMethod</span></span><br><span class="line"><span class="comment">* Call +resolveClassMethod, looking for a method to be added to class cls.</span></span><br><span class="line"><span class="comment">* cls should be a metaclass.</span></span><br><span class="line"><span class="comment">* Does not check if the method already exists.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _class_resolveClassMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(cls-&gt;<span class="built_in">isMetaClass</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! <span class="built_in">lookUpImpOrNil</span>(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="built_in">typeof</span>(msg))objc_msgSend;</span><br><span class="line">    <span class="type">bool</span> resolved = <span class="built_in">msg</span>(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span></span><br><span class="line">    IMP imp = <span class="built_in">lookUpImpOrNil</span>(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: method %c[%s %s] &quot;</span></span><br><span class="line">                         <span class="string">&quot;dynamically resolved to %p&quot;</span>, </span><br><span class="line">                         cls-&gt;<span class="built_in">isMetaClass</span>() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         cls-&gt;<span class="built_in">nameForLogging</span>(), <span class="built_in">sel_getName</span>(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn&#x27;t add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</span></span><br><span class="line">                         <span class="string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,</span><br><span class="line">                         cls-&gt;<span class="built_in">nameForLogging</span>(), <span class="built_in">sel_getName</span>(sel), </span><br><span class="line">                         cls-&gt;<span class="built_in">isMetaClass</span>() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         cls-&gt;<span class="built_in">nameForLogging</span>(), <span class="built_in">sel_getName</span>(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析上文的源码，除了一些断言、异常的保护代码外，关键语句来到了这一句</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="built_in">typeof</span>(msg))objc_msgSend;</span><br><span class="line"><span class="type">bool</span> resolved = <span class="built_in">msg</span>(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                    SEL_resolveClassMethod, sel);</span><br></pre></td></tr></table></figure><p>这里的函数<code>msg</code> 调用了3个参数</p><ul><li>_class_getNonMetaClass(cls, inst) ：即类的本身 </li><li>SEL_resolveClassMethod ： 决议的类方法</li><li>sel ：需要查找的方法编号</li></ul><p>所以，关键的行为就是<code>SEL_resolveClassMethod</code> 方法，通过搜索，源码代码中均找不到。</p><p>回头看苹果给该方法写的注释：</p><blockquote><p>_class_resolveClassMethod</p><p>Call +resolveClassMethod, looking for a method to be added to class cls.</p></blockquote><p>意思是C 源码里写的方法，在OC 实现里，会执行+resolveClassMethod 的方法，即通过resolveClassMethod 来对该类进行决议——添加相应的类方法。</p><p>在OC里的实现即这个方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，已经大概明白了决议的意义——当方法找不到实现时，转发到类&#x2F;实例决议方法里，看看开发者是否有自行实现。其最大的意义，恐怕是收集各种崩溃了。</p><h4 id="3-3-实例方法决议-class-resolveInstanceMethod"><a href="#3-3-实例方法决议-class-resolveInstanceMethod" class="headerlink" title="3.3 实例方法决议 - class_resolveInstanceMethod"></a>3.3 实例方法决议 - class_resolveInstanceMethod</h4><p>实例方法决议的源码实现，与类方法决议类似，差别仅仅在决议执行方法，换成了<code>SEL_resolveInstanceMethod</code>，源码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="built_in">typeof</span>(msg))objc_msgSend;</span><br><span class="line"><span class="type">bool</span> resolved = <span class="built_in">msg</span>(cls, SEL_resolveInstanceMethod, sel);</span><br></pre></td></tr></table></figure><p>当决议方法得到实现后，会提示，方法XX 已经被决议成为新的实现YY—— 否则会提示决议未找到:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">    <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;RESOLVE: method %c[%s %s] &quot;</span></span><br><span class="line">                     <span class="string">&quot;dynamically resolved to %p&quot;</span>, </span><br><span class="line">                     cls-&gt;<span class="built_in">isMetaClass</span>() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                     cls-&gt;<span class="built_in">nameForLogging</span>(), <span class="built_in">sel_getName</span>(sel), imp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Method resolver didn&#x27;t add anything?</span></span><br><span class="line">        _objc_inform(<span class="string">&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span></span><br><span class="line">                     <span class="string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,</span><br><span class="line">                     cls-&gt;<span class="built_in">nameForLogging</span>(), <span class="built_in">sel_getName</span>(sel), </span><br><span class="line">                     cls-&gt;<span class="built_in">isMetaClass</span>() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                     cls-&gt;<span class="built_in">nameForLogging</span>(), <span class="built_in">sel_getName</span>(sel));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、快速转发阶段"><a href="#4、快速转发阶段" class="headerlink" title="4、快速转发阶段"></a>4、快速转发阶段</h3><h4 id="4-1-快速转发方法"><a href="#4-1-快速转发方法" class="headerlink" title="4.1 快速转发方法"></a>4.1 快速转发方法</h4><p><strong>forwardingTargetForSelector</strong> ：即将本类未实现的方法，交由指定的其他类来实现。</p><h4 id="4-2-业务代码"><a href="#4-2-业务代码" class="headerlink" title="4.2 业务代码"></a>4.2 业务代码</h4><p>实现如下：</p><ul><li><p>类<code>Person</code>, 与未实现的方法<code>teach</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)teach;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>类的转发方法——指定<code>Teacher</code> 这个类来执行</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == @<span class="built_in">selector</span>(teach)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [Teacher alloc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类<code>Teacher</code>  以及实现的方法<code>teach</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface Teacher : NSObject</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)teach;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">@implementation Teacher</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)teach&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>主业务执行，使类执行它为实现的方法<code>teach</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        Person *person = [[Person alloc] init];</span><br><span class="line">     </span><br><span class="line">        [person teach];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>执行结果，<code>teacher</code>类实现了<code>teach</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-20</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">51.477020</span>+<span class="number">0800</span> debug-objc[<span class="number">8565</span>:<span class="number">349779</span>] -[Teacher teach]</span><br></pre></td></tr></table></figure><p>由此可见，forwardingTargetForSelector 的作用，是自身无法处理，交由其他对象（可能是类）来处理。</p></li></ul><h3 id="5、慢速转发阶段"><a href="#5、慢速转发阶段" class="headerlink" title="5、慢速转发阶段"></a>5、慢速转发阶段</h3><h4 id="5-1-慢速转发方法"><a href="#5-1-慢速转发方法" class="headerlink" title="5.1 慢速转发方法"></a>5.1 慢速转发方法</h4><p><strong>methodSignatureForSelector</strong>，看看开发文档的描述：</p><blockquote><h1 id="methodSignatureForSelector"><a href="#methodSignatureForSelector" class="headerlink" title="methodSignatureForSelector:"></a>methodSignatureForSelector:</h1><p>Returns an <code>NSMethodSignature</code> object that contains a description of the method identified by a given selector.</p><p>返回一个<code>NSMethodSignature</code> 的签名对象，包含一个给定选择器的方法的描述</p></blockquote><ul><li>获取方法签名： <code>methodSignatureForSelector</code></li><li>通过获取的签名，转发信息 –<br>执行方法是 <code>forwardInvocation</code>往指定的对象传递方法和参数</li></ul><h4 id="5-2-业务代码实现"><a href="#5-2-业务代码实现" class="headerlink" title="5.2 业务代码实现:"></a>5.2 业务代码实现:</h4><p>基础代码与快速转发一致，只是删除了<strong>forwardingTargetForSelector</strong> 的实现代码。</p><p>并在<code>Person</code> 类里实现如下代码</p><ul><li><p>实现方法签名</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得方法签名</span></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSString *sel = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    <span class="comment">//生成签名</span></span><br><span class="line">    <span class="keyword">if</span> ([sel isEqualToString:@<span class="string">&quot;run&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [NSMethodSignature signatureWithObjCTypes:<span class="string">&quot;v@:&quot;</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [super methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“v” 是方法描述，更多的在这里：</p><blockquote><p>* 代表 char * </p><p>char BOOL 代表 c</p><p>:       代表 SEL </p><p>^type   代表 type *</p><p>@     代表 NSObject * 或 id</p><p>^@       代表 NSError ** </p><p>#  代表 NSObject </p><p>v       代表 void</p></blockquote></li><li><p>获取签名，进行配发信息 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;-----%@-----&quot;</span>,anInvocation);</span><br><span class="line">    <span class="comment">//取得消息</span></span><br><span class="line">    SEL selector = [anInvocation selector];</span><br><span class="line">    <span class="comment">//转发</span></span><br><span class="line">    SomePerson *someP = [SomePerson <span class="keyword">new</span>];</span><br><span class="line">    <span class="keyword">if</span> ([someP respondsToSelector:selector]) &#123;</span><br><span class="line">        <span class="comment">//调用对象，进行转发</span></span><br><span class="line">        [anInvocation invokeWithTarget:someP];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行<code>teach</code> 结果</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-20</span> <span class="number">16</span>:<span class="number">37</span>:<span class="number">41.639718</span>+<span class="number">0800</span> debug-objc[<span class="number">9325</span>:<span class="number">370827</span>] -[Teacher teach]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="6、查找失败"><a href="#6、查找失败" class="headerlink" title="6、查找失败"></a>6、查找失败</h3><p>消息没有得到处理 崩溃退出，这里从<code>forwardInvocation</code> 的实现，可以追踪到相关的代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    [self doesNotRecognizeSelector:(invocation ? [invocation selector] : <span class="number">0</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Replaced by CF (throws an NSException)</span></span><br><span class="line">- (<span class="type">void</span>)doesNotRecognizeSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;-[%s %s]: unrecognized selector sent to instance %p&quot;</span>, </span><br><span class="line">                <span class="built_in">object_getClassName</span>(self), <span class="built_in">sel_getName</span>(sel), self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7、-总结"><a href="#7、-总结" class="headerlink" title="7、 总结"></a>7、 总结</h3><p>又到了最受欢迎的总结时间。</p><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><blockquote><ul><li>消息转发是什么：向指定的对象或类，发送需要消息，请求交由对方执行</li><li>消息转发的场景：自我无法实现的场景下。</li><li>如何进行消息转发 <ul><li>快速转发：使用 <code>forwardingTargetForSelector</code> 进行定向转发</li><li>慢速转发：获取签名，使用<code>forwardInvocation</code> 转发</li></ul></li></ul></blockquote><h4 id="有图"><a href="#有图" class="headerlink" title="有图"></a>有图</h4><p>另外，总结经验再多，不如有图有真相……</p><p><img src="/p/59010/002.png" alt="消息转发流程简图"></p><p>下面是objc_msgSend 查找总流程:</p><p><img src="/p/59010/007.png" alt="objc_msgSend 流程图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 结构 </tag>
            
            <tag> 消息转发 </tag>
            
            <tag> objc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【休闲】西湖一瞥</title>
      <link href="/p/37569.html"/>
      <url>/p/37569.html</url>
      
        <content type="html"><![CDATA[<h4 id="逛次逛次的西湖"><a href="#逛次逛次的西湖" class="headerlink" title="逛次逛次的西湖"></a>逛次逛次的西湖</h4><p>今天过来平海路的Apple 直营店给电脑做大保健，顺便看了一眼西湖。</p><p>湖边景色依旧宜人，可惜游人寥寥。</p><p>期待一切顺利，然后恢复到游人如织的景色。</p><p><img src="/p/37569/02.jpg" alt="步行街"></p><p><img src="/p/37569/03.jpg" alt="Apple 直营店，天才吧的天才在户外工作"></p><p><img src="/p/37569/01.jpg" alt="【全景模式】西湖一瞥"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 休闲 </tag>
            
            <tag> 杭州 </tag>
            
            <tag> 西湖 </tag>
            
            <tag> Apple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法的本质3_消息查找流程</title>
      <link href="/p/64205.html"/>
      <url>/p/64205.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime">GITHUB</a></p></blockquote><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>在前文中，已经总结了方法查找的流程，今天从代码层面上继续阐述。</p><p>isa 的指向图如下所示：</p><p>   <img src="/p/64205/001.png" alt="消息的查找流程图"></p><h2 id="2-方法查找流程"><a href="#2-方法查找流程" class="headerlink" title="2. 方法查找流程"></a>2. 方法查找流程</h2><h3 id="2-1-从业务代码分析"><a href="#2-1-从业务代码分析" class="headerlink" title="2.1 从业务代码分析"></a>2.1 从业务代码分析</h3><p><strong>配置代码环境：</strong>，先从子类父类方法查找说起，先创建几个类，有:</p><ul><li><p>父类 <strong>Person</strong> 继承自<strong>NSObject</strong>，有方法<code>talk</code></p></li><li><p>子类 <strong>Student</strong> 继承自 <strong>Person</strong>，有方法 <code>sayEnglish</code></p></li><li><p>扩展 <strong>NSObject + sayGerman</strong>，有方法 <code>sayGerman</code></p></li></ul><p>具体代码如下所示</p><p><img src="/p/64205/003.png" alt="业务代码类结构"></p><p>主业务代码图：</p><p><img src="/p/64205/004.png" alt="业务执行方法图"></p><p>由上图可以看出，我们生成的子类<code>Student</code> 对象，既可以执行自己的对象方法<code>sayEnglish</code>，也可以执行父类方法<code>talk</code>，当需要执行的方法——子类和父类都没有之后，也可以执行根类扩展方法<code>sayGerman</code>。</p><blockquote><p>查找逻辑图可以初步理解为：子类——&gt; 父类——&gt; 父类的父类 ——&gt;根元类(NSObject)</p></blockquote><p>类方法也是类似的，就不赘述</p><h3 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h3><h4 id="2-2-1-class-lookupMethodAndLoadCache3-慢速查找开启"><a href="#2-2-1-class-lookupMethodAndLoadCache3-慢速查找开启" class="headerlink" title="2.2.1 class_lookupMethodAndLoadCache3 - 慢速查找开启"></a>2.2.1 <strong>class_lookupMethodAndLoadCache3</strong> - 慢速查找开启</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _class_lookupMethodAndLoadCache.</span></span><br><span class="line"><span class="comment">* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().</span></span><br><span class="line"><span class="comment">* This lookup avoids optimistic cache scan because the dispatcher </span></span><br><span class="line"><span class="comment">* already tried that.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;        </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookUpImpOrForward</span>(cls, sel, obj, </span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原来上文留下的<strong>class_lookupMethodAndLoadCache3</strong> 方法，最终执行的方法是<strong>lookUpImpOrForward</strong>，继续探究一下！</p><h4 id="lookUpImpOrForward-查找Imp-或转发消息"><a href="#lookUpImpOrForward-查找Imp-或转发消息" class="headerlink" title="lookUpImpOrForward - 查找Imp 或转发消息"></a><strong>lookUpImpOrForward</strong> - 查找Imp 或转发消息</h4><h5 id="乐观检查是否有缓存"><a href="#乐观检查是否有缓存" class="headerlink" title="乐观检查是否有缓存"></a>乐观检查是否有缓存</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Optimistic cache lookup</span></span><br><span class="line"><span class="keyword">if</span> (cache) &#123;</span><br><span class="line">   imp = <span class="built_in">cache_getImp</span>(cls, sel);</span><br><span class="line">   <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找类是否缓存过"><a href="#查找类是否缓存过" class="headerlink" title="查找类是否缓存过"></a>查找类是否缓存过</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtimeLock is held during isRealized and isInitialized checking</span></span><br><span class="line"><span class="comment">// to prevent races against concurrent realization.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// runtimeLock is held during method search to make</span></span><br><span class="line"><span class="comment">// method-lookup + cache-fill atomic with respect to method addition.</span></span><br><span class="line"><span class="comment">// Otherwise, a category could be added but ignored indefinitely because</span></span><br><span class="line"><span class="comment">// the cache was re-filled with the old value after the cache flush on</span></span><br><span class="line"><span class="comment">// behalf of the category.</span></span><br><span class="line"></span><br><span class="line">runtimeLock.<span class="built_in">lock</span>();</span><br><span class="line"><span class="built_in">checkIsKnownClass</span>(cls);</span><br></pre></td></tr></table></figure><p>这里通过<code>runtimeLock</code> 锁住该部分内存，进行查找，执行了<code>isKnownClass</code>的方法，具体实现在这里</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* isKnownClass</span></span><br><span class="line"><span class="comment">* Return true if the class is known to the runtime (located within the</span></span><br><span class="line"><span class="comment">* shared cache, within the data segment of a loaded image, or has been</span></span><br><span class="line"><span class="comment">* allocated with obj_allocateClassPair).</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isKnownClass</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The order of conditionals here is important for speed. We want to</span></span><br><span class="line">    <span class="comment">// put the most common cases first, but also the fastest cases</span></span><br><span class="line">    <span class="comment">// first. Checking the shared region is both fast and common.</span></span><br><span class="line">    <span class="comment">// Checking allocatedClasses is fast, but may not be common,</span></span><br><span class="line">    <span class="comment">// depending on what the program is doing. Checking if data segments</span></span><br><span class="line">    <span class="comment">// contain the address is slow, so do it last.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">sharedRegionContains</span>(cls) ||</span><br><span class="line">            <span class="built_in">NXHashMember</span>(allocatedClasses, cls) ||</span><br><span class="line">            <span class="built_in">dataSegmentsContain</span>(cls));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在类的缓存（cache-t）找"><a href="#在类的缓存（cache-t）找" class="headerlink" title="在类的缓存（cache_t）找"></a>在类的缓存（cache_t）找</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Try this class&#x27;s cache.</span></span><br><span class="line"></span><br><span class="line"> imp = <span class="built_in">cache_getImp</span>(cls, sel);</span><br><span class="line"> <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br></pre></td></tr></table></figure><h5 id="在类的方法列表里寻找"><a href="#在类的方法列表里寻找" class="headerlink" title="在类的方法列表里寻找"></a>在类的方法列表里寻找</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Try this class&#x27;s method lists.</span></span><br><span class="line">&#123;</span><br><span class="line">    Method meth = <span class="built_in">getMethodNoSuper_nolock</span>(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">        <span class="built_in">log_and_fill_cache</span>(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">        imp = meth-&gt;imp;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在父类的缓存和方法列表寻找"><a href="#在父类的缓存和方法列表寻找" class="headerlink" title="在父类的缓存和方法列表寻找"></a>在父类的缓存和方法列表寻找</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Try superclass caches and method lists.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> attempts = <span class="built_in">unreasonableClassCount</span>();</span><br><span class="line">    <span class="keyword">for</span> (Class curClass = cls-&gt;superclass;</span><br><span class="line">         curClass != nil;</span><br><span class="line">         curClass = curClass-&gt;superclass)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">        <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol><li><p>父类缓存（Cache）找</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Superclass cache.</span></span><br><span class="line"> imp = <span class="built_in">cache_getImp</span>(curClass, sel);</span><br><span class="line"> <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">     <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">         <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">         <span class="built_in">log_and_fill_cache</span>(cls, imp, sel, inst, curClass);</span><br><span class="line">         <span class="keyword">goto</span> done;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">         <span class="comment">// Stop searching, but don&#x27;t cache yet; call method </span></span><br><span class="line">         <span class="comment">// resolver for this class first.</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>父类方法列表找</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Superclass method list.</span></span><br><span class="line">Method meth = <span class="built_in">getMethodNoSuper_nolock</span>(curClass, sel);</span><br><span class="line"><span class="keyword">if</span> (meth) &#123;</span><br><span class="line">    <span class="built_in">log_and_fill_cache</span>(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">    imp = meth-&gt;imp;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="有可能内存覆盖，再给一次查找"><a href="#有可能内存覆盖，再给一次查找" class="headerlink" title="有可能内存覆盖，再给一次查找"></a>有可能内存覆盖，再给一次查找</h5><p>这里的核心方法是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    runtimeLock.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="built_in">resolveMethod</span>(cls, sel, inst);</span><br><span class="line">    runtimeLock.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// Don&#x27;t cache the result; we don&#x27;t hold the lock so it may have </span></span><br><span class="line">    <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">    triedResolver = YES;</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="父类也没有——查找失败——报错"><a href="#父类也没有——查找失败——报错" class="headerlink" title="父类也没有——查找失败——报错"></a>父类也没有——查找失败——报错</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// No implementation found, and method resolver didn&#x27;t help. </span></span><br><span class="line"><span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这个<code>_objc_msgForward_impcache</code> 的实现可不好找，在源码里只看到了这些：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> _objc_msgForward_impcache(<span class="type">void</span>);</span><br></pre></td></tr></table></figure><p>最终通过搜索查找**_objc_msgForward_impcache**，在汇编源码找到了类似的代码<img src="/p/64205/005.png" alt="消息转发流程"><br>得到这个叫做__objc_forward_handler 的代码块，搜索得知它继承自objc_defaultForwardHandler，</p><p>继续查找，得到最终的源码如下：</p><p><img src="/p/64205/006.png" alt="消息查找失败报错"></p><p>OH MY GOD! 原来这就是传说中——让程序员捶胸顿足的方法查找失败的代码</p><p><img src="/p/64205/007.png" alt="消息查找失败报错"></p><p>至此，方法查找的流程已经捋完。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>方法查找的流程，就是在类里查找缓存与方法列表里挖掘的过程。</p><p>如上文阐述：</p><blockquote><p>方法查找：缓存查找 —— <strong>类</strong>的方法列表 —— 父类的方法列表 （递归）—— 动态方法解析 —— 结束</p></blockquote><p><img src="/p/64205/002.png" alt="消息转发流程"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 类 </tag>
            
            <tag> 结构 </tag>
            
            <tag> objc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法的本质2_从objc_msgSend谈起</title>
      <link href="/p/23281.html"/>
      <url>/p/23281.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>方法的本质，就是消息传递…</em></p></blockquote><blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime">GITHUB</a></p></blockquote><h3 id="一、引子：Runtime"><a href="#一、引子：Runtime" class="headerlink" title="一、引子：Runtime"></a>一、引子：Runtime</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>我们都知道，在运行<strong>OC</strong>代码时，类或者对象在调用方法时会用到<u><strong>runtime</strong></u>，那么，到底什么是运行时呢？</p><p>寻找一些资料后可以给出概念：</p><blockquote><p>In computer science, runtime, run time or execution time is the time when the CPU is executing the machine code.<br>在计算机科学里，runtime，run time 或execution time 是指CPU 执行机器语言的期间。<br>—— 维基百科</p></blockquote><blockquote><p>Runtime 是一套由C、C++、汇编混合写成的为OC提供运行时功能的api。</p></blockquote><p>先看苹果<a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime">开发者文档</a>里对runtime 的介绍的介绍：</p><blockquote><p>The Objective-C runtime is a runtime library that provides support for the dynamic properties of the Objective-C language, and as such is linked to by all Objective-C apps. Objective-C runtime library support functions are implemented in the shared library found at <code>/usr/lib/libobjc.A.dylib</code>.</p><p>OC runtime 是一个给OC语言动态属性提供支持的运行时库，这些属性链接到所有的OC应用 。OC runtime库支持在shared library里实现的函数，这些函数库名为<code>/usr/lib/libobjc.A.dylib</code></p></blockquote><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><blockquote><p>legacy：经典版</p><p>modern：现代版，即objc2.0，我们目前用到的版本。</p></blockquote><h3 id="二、方法的本质"><a href="#二、方法的本质" class="headerlink" title="二、方法的本质"></a>二、方法的本质</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>方法的本质，就是objc_msgSend  的消息传递。先看苹果<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend">开发者文档</a>里对objc_msgSend的介绍：</p><blockquote><p>Function</p><h1 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h1><p>Sends a message with a simple return value to an instance of a class.</p><p><strong>发送一个有简单返回值的消息给类的实例</strong></p></blockquote><p>相关源码如下: </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">objc_msgSend</span>(id _Nullable self, SEL _Nonnull op, ...)</span><br></pre></td></tr></table></figure><p>其中两个关键参数<code>self</code> 和 <code>op</code> 的解释如下:</p><blockquote><p> * <strong>@param</strong> self A pointer to the instance of the class that is to receive the message.</p><p>​self  一个指向由类生产的实例的指针，用来接收消息</p><p> * <strong>@param</strong> op The selector of the method that handles the message.</p><p>​op 方法： 处理消息的方法的选择器</p></blockquote><p>可见，objc_msgSend 的核心信息，<u><strong>就是向对象主体（self）传递相应的方法&#x2F;消息（op）</strong></u>。</p><p>但是<strong>消息传递的机制</strong>到底怎样，还是用源码来解释。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>开始生成一个main.m 内代码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        LGPerson *person = [LGPerson alloc];</span><br><span class="line">        [person sayHello];</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goes here.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSApplicationMain</span>(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中LGPerson 的内部实现如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface LGPerson : NSObject</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)sayHello;</span><br><span class="line">- (<span class="type">void</span>)sayNB;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在这里，着重查看<strong>LGPerson</strong> <code>alloc</code> 方法，以及其实例 person sayHello&#96; 在汇编里的实现 : </p><p>进入到目录下，输入编译代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure><p>得到main.cpp 的文件</p><p><img src="/p/23281/001.png" alt="编译c++ 指令"></p><p><img src="/p/23281/002.png" alt="cpp 生成后的结构图"></p><p>打开main.cpp 结构如下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang assume_nonnull end</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        LGPerson *person = ((LGPerson *(*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)<span class="built_in">objc_getClass</span>(<span class="string">&quot;LGPerson&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;alloc&quot;</span>));</span><br><span class="line"></span><br><span class="line">        ((<span class="built_in">void</span> (*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)person, <span class="built_in">sel_registerName</span>(<span class="string">&quot;sayHello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSApplicationMain</span>(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文代码中，可以简化为, </p><table><thead><tr><th>Runtime 语法</th><th>OC 语法</th></tr></thead><tbody><tr><td>(LGPerson <em>(</em>)(id, SEL))(void *)</td><td>–</td></tr><tr><td>(id)objc_getClass(“LGPerson”)</td><td>[LGPerson class]</td></tr><tr><td>sel_registerName(“alloc”)</td><td>@selector(alloc)</td></tr></tbody></table><p>即代码为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LGPerson *person = ((LGPerson *(*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)<span class="built_in">objc_getClass</span>(<span class="string">&quot;LGPerson&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;alloc&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后</span></span><br><span class="line">LGPerson *person = <span class="built_in">objc_msgSend</span>([LGPerson <span class="keyword">class</span>], @<span class="built_in">selector</span>(alloc));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解释为: 向<code>LGPerson</code> 的类，发送了<code>alloc</code> 方法</p><h4 id="扩展代码实践"><a href="#扩展代码实践" class="headerlink" title="扩展代码实践"></a>扩展代码实践</h4><p>开始设定一个类<code>Student</code> </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line">interface Student : Person</span><br><span class="line">- (<span class="type">void</span>)sayCode;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="OC语法"><a href="#OC语法" class="headerlink" title="OC语法"></a>OC语法</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Student *student = [Student <span class="keyword">new</span>];</span><br><span class="line">[student sayCode];</span><br></pre></td></tr></table></figure><h5 id="NSObject-写法"><a href="#NSObject-写法" class="headerlink" title="NSObject 写法"></a>NSObject 写法</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">objc_msgSend</span>(student, <span class="built_in">NSSelectorFromString</span>(@<span class="string">&quot;sayCode&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="sel-registerName-的函数API"><a href="#sel-registerName-的函数API" class="headerlink" title="sel_registerName 的函数API"></a>sel_registerName 的函数API</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">objc_msgSend</span>(student, <span class="built_in">sel_registerName</span>(<span class="string">&quot;sayCode&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="三、底层分析"><a href="#三、底层分析" class="headerlink" title="三、底层分析"></a>三、底层分析</h3><h4 id="汇编源码"><a href="#汇编源码" class="headerlink" title="汇编源码"></a>汇编源码</h4><blockquote><p>我们现在分析，当类对象发送消息是，底层发生了什么。</p></blockquote><h5 id="1、方法入口"><a href="#1、方法入口" class="headerlink" title="1、方法入口"></a>1、方法入口</h5><p>新建工程，输入如下代码，进行断点检测；</p><p>另外在Xcode 的Debug–Debug Workflow—Always show Disassembly</p><p><img src="/p/23281/m0.png" alt="配置：打开汇编监视"></p><p><img src="/p/23281/m1.png" alt="OC方法调用，打开断点"></p><p><img src="/p/23281/m2.png" alt="按住Control 逐渐获得汇编函数"><img src="/p/23281/m3.png" alt="得到第一个方法传递函数：objc_msgSend"></p><p>很明显，这里的<strong>Student sayCode</strong> 在汇编里，执行了 <strong>objc_msgSend</strong> 方法，继续查看</p><p>打开<strong>Xcode</strong>, 搜索<strong>objc_msgSend</strong>，找到相关结果如下：</p><p><img src="/p/23281/003.png" alt="objc_msgSend 搜索结果"></p><p>由于研究的环境是移动平台，选择<strong>arm64</strong>，通过<code>ENTRY _objc_msgSend</code>结果进入</p><p>首先看到的代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ENTRY _objc_msgSend</span><br><span class="line">UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>cmpp0, #<span class="number">0</span><span class="comment">// nil check and tagged pointer check</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_TAGGED_POINTERS</span></span><br><span class="line"><span class="number">2</span>b.leLNilOrTagged<span class="comment">//  (MSB tagged pointer looks negative)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="number">3</span>b.eqLReturnZero</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="2、类Tagged-Pointer-检查"><a href="#2、类Tagged-Pointer-检查" class="headerlink" title="2、类Tagged Pointer 检查"></a>2、类Tagged Pointer 检查</h5><p>代码解析：</p><table><thead><tr><th align="center">序号</th><th>代码</th><th>解释</th></tr></thead><tbody><tr><td align="center">1</td><td>cmp p0 #0</td><td>cmp &#x3D; compare<br>检测0位寄存器 &#x3D; 空？，以及tagged point 检测</td></tr><tr><td align="center">2</td><td>b.leLNilOrTagged</td><td>&#x2F;&#x2F; 即1代码成立，跳转至LNilOrTagged的宏（下文叙述）</td></tr><tr><td align="center">3</td><td>b.eqLReturnZero</td><td>&#x2F;&#x2F; <code>b.eq</code> 即不成立，结果为空，返回并跳出</td></tr></tbody></table><p>这一小节，主要是用来判断 tagged pointer 是否存在，存在则继续进行，否则跳出。</p><p>Tagged point是苹果推出的针对64位机器的特定的指针，概念如下：</p><blockquote><p>苹果对于Tagged Pointer特点的介绍：</p><ol><li>Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate</li><li>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。</li><li>在内存读取上有着3倍的效率，创建时比以前快106倍。</li></ol></blockquote><h5 id="3、加载isa"><a href="#3、加载isa" class="headerlink" title="3、加载isa"></a>3、加载isa</h5><p>这一部分主要是通过加载的isa，获取当前底层的类的实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// person - isa - 类</span></span><br><span class="line">ldrp13, [x0]<span class="comment">// p13 = isa</span></span><br><span class="line">GetClassFromIsa_p16 p13<span class="comment">// p16 = class</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">序号</th><th>代码</th><th>解释</th></tr></thead><tbody><tr><td align="center">1</td><td>ldrp13,  [x0]</td><td>将13位存储器isa 字，加载到0位寄存器<br>LDR &#x3D; LoaD woRd</td></tr><tr><td align="center">2</td><td>GetClassFromIsa_p16 p13</td><td>通过加载的isa，宏逻辑获取到当前的类<br>GetClassFromIsa_p16 是一个汇编宏</td></tr></tbody></table><p><strong>GetClassFromIsa_p16</strong> 的汇编实现如下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.macro GetClassFromIsa_p16 <span class="comment">/* src */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line"><span class="comment">// Indexed isa</span></span><br><span class="line">movp16, $<span class="number">0</span><span class="comment">// optimistically set dst = src</span></span><br><span class="line">tbzp16, #ISA_INDEX_IS_NPI_BIT, <span class="number">1f</span><span class="comment">// done if not non-pointer isa</span></span><br><span class="line"><span class="comment">// isa in p16 is indexed</span></span><br><span class="line">adrpx10, _objc_indexed_classes@PAGE</span><br><span class="line">addx10, x10, _objc_indexed_classes@PAGEOFF</span><br><span class="line">ubfxp16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS  <span class="comment">// extract index</span></span><br><span class="line">ldrp16, [x10, p16, UXTP #PTRSHIFT]<span class="comment">// load class from array</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __LP64__</span></span><br><span class="line"><span class="comment">// 64-bit packed isa</span></span><br><span class="line"><span class="keyword">and</span>p16, $<span class="number">0</span>, #ISA_MASK</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 32-bit raw isa</span></span><br><span class="line">movp16, $<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>分析流程图如下：</p><p><img src="/p/23281/004.png" alt="GetClassFromIsa_p16 流程图"></p><h5 id="4、用isa查询方法缓存"><a href="#4、用isa查询方法缓存" class="headerlink" title="4、用isa查询方法缓存"></a>4、用isa查询方法缓存</h5><p>当在3步，isa 拿到之后，现在要做的事情，就是对当前要执行的方法进行缓存查找。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LGetIsaDone:</span><br><span class="line">CacheLookup NORMAL<span class="comment">// calls imp or objc_msgSend_uncached</span></span><br></pre></td></tr></table></figure><p><strong>CacheLookup</strong> 在这里的做法是查询类里是否含有方法到缓存。 一般有两种结果：拿到缓存IMP，或者未曾缓存。</p><p>查询可以得到有三种查询方式:</p><ul><li>NORMAL正常查找</li><li>GETIMP      获取IMP</li><li>LOOKUP     慢速查询方法</li></ul><p>根据源码，做了一些注释：</p><p><img src="/p/23281/005.png" alt="CacheLookup宏的流程"></p><p>其中多次出现<strong>CheckMiss</strong> ,也是个汇编宏，使用在缓存查找失败后。</p><p>源码如下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.macro CheckMiss</span><br><span class="line"><span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">.<span class="keyword">if</span> $<span class="number">0</span> == GETIMP</span><br><span class="line">cbzp9, LGetImpMiss</span><br><span class="line">.elseif $<span class="number">0</span> == NORMAL</span><br><span class="line">cbzp9, __objc_msgSend_uncached</span><br><span class="line">.elseif $<span class="number">0</span> == LOOKUP</span><br><span class="line">cbzp9, __objc_msgLookup_uncached</span><br><span class="line">.<span class="keyword">else</span></span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p> 根据查找的模式位NORMAL, 对应的**__objc_msgSend_uncached **。</p><p>在源码中搜索，得到相关逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line"><span class="comment">// THIS IS NOT A CALLABLE C FUNCTION</span></span><br><span class="line"><span class="comment">// Out-of-band p16 is the class to search</span></span><br><span class="line"></span><br><span class="line">MethodTableLookup</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p>执行方法查找的<strong>核心方法</strong>，就是<strong>MethodTableLookup</strong>， 继续点开查看，得到的是<img src="/p/23281/006.png" alt="方法列表查找"></p><p>这里的内容，则是到<strong>objc_class</strong> 的 <strong>class_data_bits_t</strong> 里寻找方法的具体实现了，下一篇文章我们来讲。</p><h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p>这一篇，主要是开始从汇编的角度，来实现方法查找流程，流程草写了一下，图一定补。。。</p><ul><li><input disabled type="checkbox"> 拿到isa</li><li><input disabled type="checkbox"> 查找Class</li><li><input disabled type="checkbox"> 在Cache_t 查找bucket<ul><li><input disabled type="checkbox"> bucket 相同，返回IMP</li><li><input disabled type="checkbox"> 否则 跳到BITS</li></ul></li><li><input disabled type="checkbox"> BITS 中<ul><li><input disabled type="checkbox"> 查找Rw <ul><li><input disabled type="checkbox"> 查找ro<ul><li><input disabled type="checkbox"> 查找methodList</li></ul></li></ul></li></ul></li></ul><p>总流程如下:</p><p><img src="/p/23281/007.png" alt="objc_msgSend"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 类 </tag>
            
            <tag> 结构 </tag>
            
            <tag> objc </tag>
            
            <tag> msgSend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法的本质1--cache_t方法缓存分析</title>
      <link href="/p/40097.html"/>
      <url>/p/40097.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime">GITHUB</a></p></blockquote><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><h4 id="1-1-objc-class-结构"><a href="#1-1-objc-class-结构" class="headerlink" title="1.1 objc_class 结构"></a>1.1 objc_class 结构</h4><p>前面探索了类的结构，知道了类的结构本质上是<strong>objc_class</strong>的结构体，而在 <strong>C</strong> 源码例， <strong>objc_class</strong> 结构体的结构如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA; // 指向类的isa</span></span><br><span class="line">    Class superclass; <span class="comment">// 父类</span></span><br><span class="line">    <span class="type">cache_t</span> cache;    <span class="comment">// 缓存的方法列表         // formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// 缓存的属性和变量  // class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上一篇文章，具体分析了class_data_bits_t，那么上面的缓存<strong>cache_t</strong> 还没有展开学习，下面就继续进行讲解。</p><span id="more"></span><h4 id="1-2-Cache-t-结构"><a href="#1-2-Cache-t-结构" class="headerlink" title="1.2 Cache_t 结构:"></a>1.2 Cache_t 结构:</h4><p><strong>cache_t</strong> 是<strong>objc_class</strong> 的重要组成属性，它主要用来存储方法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cache_t</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bucket_t</span> *_buckets;  <span class="comment">// 缓存的方法列表</span></span><br><span class="line">    <span class="type">mask_t</span> _mask;               <span class="comment">// 散列表的长度</span></span><br><span class="line">    <span class="type">mask_t</span> _occupied;           <span class="comment">// 缓存过的方法数量</span></span><br><span class="line">******</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>bucket 的定义</p><p>顾名思义是桶 ，装水的桶，装<strong>奥特曼</strong>的桶……</p><p>在这里是一个hash表，计算公式是hash &#x3D; sel 地址%mask，其中mask 是存放空间的大小，初始值是4。</p></blockquote><p>通过源码查看，可以知道结构体如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bucket_t</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// IMP-first is better for arm64e ptrauth and no worse for arm64.</span></span><br><span class="line">    <span class="comment">// SEL-first is better for armv7* and i386 and x86_64.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __arm64__</span></span><br><span class="line">    MethodCacheIMP _imp;<span class="comment">// 方法实现</span></span><br><span class="line">    <span class="type">cache_key_t</span> _key;<span class="comment">// 方法编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">cache_key_t</span> _key;</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看到，这里缓存了<strong>MethodCacheIMP</strong> 方法，其中 <strong>MethodCacheIMP</strong> 是<strong>IMP</strong>的子类：</p><blockquote><p><strong>MethodCacheIMP</strong> ——对于方法实现</p><p><strong>cache_key_t</strong> ——对应方法缓存编号</p></blockquote><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><h4 id="2-1方法缓存入口"><a href="#2-1方法缓存入口" class="headerlink" title="2.1方法缓存入口"></a>2.1方法缓存入口</h4><ul><li>入口<br>引起我们注意的是如下这段代码:</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_fill</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DEBUG_TASK_THREADS</span></span><br><span class="line">    <span class="function"><span class="type">mutex_locker_t</span> <span class="title">lock</span><span class="params">(cacheUpdateLock)</span></span>;</span><br><span class="line">    <span class="built_in">cache_fill_nolock</span>(cls, sel, imp, receiver);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    _collecting_in_critical();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释：</p><blockquote><p>cache_fill 方法的缓存写入操作</p><p>cache_fill_nolock 线程解锁后的缓存写入</p></blockquote><ul><li>断言保护<br>这里的方法<strong>cache_fill_nolock</strong> 就是我们的方法入口，<u>为追求速度</u>，执行的内容是无锁操作下的缓存填充，即对开辟的内存空间，进行方法写入，实现源码如下：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cache_fill_nolock</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cacheUpdateLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Never cache before +initialize is done</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;<span class="built_in">isInitialized</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the entry wasn&#x27;t added to the cache by some other thread </span></span><br><span class="line">    <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cache_getImp</span>(cls, sel)) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="type">cache_t</span> *cache = <span class="built_in">getCache</span>(cls);</span><br><span class="line">    <span class="type">cache_key_t</span> key = <span class="built_in">getKey</span>(sel);</span><br><span class="line">**** </span><br></pre></td></tr></table></figure><p>代码解释：</p><blockquote><ol><li>cacheUpdateLock.assertLocked() ：这里对内存区域锁定进行了跳出断言</li><li>if (!cls-&gt;isInitialized()) return; 对为初始化内存空间进行跳出断言</li><li>if (cache_getImp(cls, sel)) 对缓存空间已有该方法跳出断言</li></ol></blockquote><h4 id="2-2-检查容量"><a href="#2-2-检查容量" class="headerlink" title="2.2 检查容量"></a>2.2 检查容量</h4><ul><li>在检查容量之前，<strong>cache_t</strong> 做了两个操作：</li></ul><blockquote><ol><li>将类的引用地址转化成了cache 结构体:  <code>cache_t *cache = getCache(cls)</code></li><li>将方法编号<code>sel</code> 转换成了整型，方便寻址 <code>cache_key_t key = getKey(sel)</code></li></ol></blockquote><ul><li><p>容量为空检测</p><p>将方法缓存时，先确定是否为空对缓存。这里使用了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cache-&gt;<span class="built_in">isConstantEmptyCache</span>()) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        cache-&gt;<span class="built_in">reallocate</span>(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>来判断空间是否为空，<code>isConstantEmptyCache</code>这个函数更详细的操作如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">occupied</span>() == <span class="number">0</span>  &amp;&amp;  </span><br><span class="line">        <span class="built_in">buckets</span>() == <span class="built_in">emptyBucketsForCapacity</span>(<span class="built_in">capacity</span>(), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>即<code>occupied</code>占位为空，而且容器<strong>桶</strong> 也无法从其他堆中空间共享空间，就必须重新开辟新的空间，开辟空间操作见 <strong>2.3</strong>。</p></li><li><p>扩容的条件：</p><p>扩容条件的操作为将当前容量 <strong>occupied + 1</strong>, 然后检查是否达到 <strong>3&#x2F;4</strong>，超过则需要<strong>扩容</strong>；否则不需要扩容，直接进行缓存的写入，下面的代码足够明了的解释；</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use the cache as-is if it is less than 3/4 full</span></span><br><span class="line"><span class="type">mask_t</span> newOccupied = cache-&gt;<span class="built_in">occupied</span>() + <span class="number">1</span>;</span><br><span class="line"><span class="type">mask_t</span> capacity = cache-&gt;<span class="built_in">capacity</span>();</span><br><span class="line"><span class="keyword">if</span> (cache-&gt;<span class="built_in">isConstantEmptyCache</span>()) &#123;</span><br><span class="line">    <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">    cache-&gt;<span class="built_in">reallocate</span>(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Cache is too full. Expand it.</span></span><br><span class="line">    cache-&gt;<span class="built_in">expand</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><blockquote><p>mask_t newOccupied &#x3D; cache-&gt;occupied() + 1</p><p>mask_t capacity &#x3D; cache-&gt;capacity();</p><p>if (newOccupied &lt;&#x3D; capacity &#x2F; 4 * 3) </p></blockquote><p>这里的 <strong>newOccupied</strong> 是当前的占用容量+1, 与目前的总容量 <strong>capacity</strong> 的 3&#x2F;4 来做比较，这里使用占位+1 后来做比较，目的是提前准备，防止内存溢出。</p></li></ul><h4 id="2-3-内存扩容"><a href="#2-3-内存扩容" class="headerlink" title="2.3 内存扩容"></a>2.3 内存扩容</h4><h5 id="2-3-1-空间计算"><a href="#2-3-1-空间计算" class="headerlink" title="2.3.1 空间计算"></a>2.3.1 空间计算</h5><blockquote><p>扩容方法：</p><p>判断当前容量是否为空，若为空，就给初始化的内存为为4；</p><p>如果之前就有空间，则加倍。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_t::expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cacheUpdateLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> oldCapacity = <span class="built_in">capacity</span>();</span><br><span class="line">    <span class="type">uint32_t</span> newCapacity = oldCapacity ? oldCapacity*<span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uint32_t</span>)(<span class="type">mask_t</span>)newCapacity != newCapacity) &#123;</span><br><span class="line">        <span class="comment">// mask overflow - can&#x27;t grow further</span></span><br><span class="line">        <span class="comment">// fixme this wastes one bit of mask</span></span><br><span class="line">        newCapacity = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reallocate</span>(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><blockquote><p><strong>oldCapacity</strong> 定义了当前的容量</p><ol><li>如果 <strong>oldCapacity</strong> 为空，则立刻开辟大小为<em>4</em> 的空间。</li><li>否则，给当前空间加倍，即 <strong>oldCapacity*2</strong>，并在新空间内进行缓存空间开辟 <strong>reallocate</strong>。</li></ol></blockquote><h5 id="2-3-2-新建容器reallocate"><a href="#2-3-2-新建容器reallocate" class="headerlink" title="2.3.2 新建容器reallocate"></a>2.3.2 新建容器reallocate</h5><p>新开内存空间的操作步骤：</p><ol><li>确定是否可以释放旧空间</li><li>将开辟的空间和内存方法绑定，并将<strong>mask</strong> 和占位值<strong>occupied</strong> 归零。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_t::reallocate</span><span class="params">(<span class="type">mask_t</span> oldCapacity, <span class="type">mask_t</span> newCapacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> freeOld = <span class="built_in">canBeFreed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bucket_t</span> *oldBuckets = <span class="built_in">buckets</span>();</span><br><span class="line">    <span class="type">bucket_t</span> *newBuckets = <span class="built_in">allocateBuckets</span>(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache&#x27;s old contents are not propagated. </span></span><br><span class="line">    <span class="comment">// This is thought to save cache memory at the cost of extra cache fills.</span></span><br><span class="line">    <span class="comment">// fixme re-measure this</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(newCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>((<span class="type">uintptr_t</span>)(<span class="type">mask_t</span>)(newCapacity<span class="number">-1</span>) == newCapacity<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setBucketsAndMask</span>(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (freeOld) &#123;</span><br><span class="line">        <span class="built_in">cache_collect_free</span>(oldBuckets, oldCapacity);</span><br><span class="line">        <span class="built_in">cache_collect</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码讲解：</p><ul><li><p>bool freeOld &#x3D; canBeFreed() 决定了是否可以释放旧内存。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cache_t::canBeFreed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isConstantEmptyCache</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>canBeFreed</code>依赖于<code>isConstantEmptyCache</code>的取反，即需要之前方法缓存有占位，并且旧bucket 本身容量不为空。</p><p>即以下源码里返回为空：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cache_t::isConstantEmptyCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        <span class="built_in">occupied</span>() == <span class="number">0</span>  &amp;&amp;  </span><br><span class="line">        <span class="built_in">buckets</span>() == <span class="built_in">emptyBucketsForCapacity</span>(<span class="built_in">capacity</span>(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">需要 occupied == <span class="number">1</span>, 以及 <span class="built_in">buckets</span>() != <span class="built_in">emptyBucketsForCapacity</span>(<span class="built_in">capacity</span>(), <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li><li><p>setBucketsAndMask 用来初始化 新的bucket 和 occupied</p><p>newCapacity - 1 更新索引，用来查询散列表里的元素。</p></li><li><p>cache_collect_free 用来释放旧容量（oldCapacity）下的旧方法数据（oldBuckets）</p></li></ul><h4 id="2-4-缓存写入"><a href="#2-4-缓存写入" class="headerlink" title="2.4 缓存写入"></a>2.4 缓存写入</h4><h5 id="2-4-1-查找缓存"><a href="#2-4-1-查找缓存" class="headerlink" title="2.4.1 查找缓存"></a>2.4.1 查找缓存</h5><p>通过 <code>cache-&gt;find</code> 查找对应的缓存，如果没有找到，就添加新缓存，在这之前将占位<code>occupied</code>  添加1 ，实现源码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cache_fill_nolock</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ***</span><br><span class="line">     <span class="comment">// 找到对应的 bucket</span></span><br><span class="line">    <span class="type">bucket_t</span> *bucket = cache-&gt;<span class="built_in">find</span>(key, receiver);</span><br><span class="line"><span class="keyword">if</span> (bucket-&gt;<span class="built_in">key</span>() == <span class="number">0</span>) cache-&gt;<span class="built_in">incrementOccupied</span>();</span><br><span class="line">    bucket-&gt;<span class="built_in">set</span>(key, imp);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_t::incrementOccupied</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _occupied++;<span class="comment">// 占位增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-2-未扩容过"><a href="#2-4-2-未扩容过" class="headerlink" title="2.4.2 未扩容过"></a>2.4.2 未扩容过</h5><p>找到之前的bucket，按照编号和方法，写入缓存:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bucket_t</span> *bucket = cache-&gt;<span class="built_in">find</span>(key, receiver);</span><br><span class="line">bucket-&gt;<span class="built_in">set</span>(key, imp);</span><br></pre></td></tr></table></figure><h5 id="2-4-3-缓存写入实现"><a href="#2-4-3-缓存写入实现" class="headerlink" title="2.4.3 缓存写入实现"></a>2.4.3 缓存写入实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucket_t::set</span><span class="params">(<span class="type">cache_key_t</span> newKey, IMP newImp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(_key == <span class="number">0</span>  ||  _key == newKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// objc_msgSend uses key and imp with no locks.</span></span><br><span class="line">    <span class="comment">// It is safe for objc_msgSend to see new imp but NULL key</span></span><br><span class="line">    <span class="comment">// (It will get a cache miss but not dispatch to the wrong place.)</span></span><br><span class="line">    <span class="comment">// It is unsafe for objc_msgSend to see old imp and new key.</span></span><br><span class="line">    <span class="comment">// Therefore we write new imp, wait a lot, then write new key.</span></span><br><span class="line">    </span><br><span class="line">    _imp = newImp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_key != newKey) &#123;</span><br><span class="line">        <span class="built_in">mega_barrier</span>();</span><br><span class="line">        _key = newKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><blockquote><p>注释中写明了：</p><p>objc_msgSend 在无锁环境下使用key 和 imp 实现。</p><p>objc_msgSend 查看到新的imp 实现是安全的，除了空的key地址外。（可能会造成小的缓存丢失，但是并不会分发到错误的空间）</p><p>objc_msgSend 旧的imp 和新的key 是不安全的，因此我们先写新imp，等一会儿，再写新的 key</p><p>代码中的 <code>mega_barrier</code> 就是 使用了阻塞，让方法先看到imp ，保证线程的安全。</p></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><h4 id="3-1-梳理"><a href="#3-1-梳理" class="headerlink" title="3.1 梳理"></a>3.1 梳理</h4><p><strong>cache_t</strong> 起源于 OC中的方法传递，也就是<strong>objc_msgSend</strong> 的实现。在类的方法传递时，为了追求，先去cache_t 中查找是否有缓存，如果有，可以直接调用，如果没有缓存，则需要对类进行一系列的内存空间确认，进行imp - key 的写入，并进行最终调用。</p><p>这一章节应该是目前分析最难的，花了大概三到四天弄明白，希望这艰难的一步能为以后的分析打好更好的基础。</p><h4 id="3-2-流程图"><a href="#3-2-流程图" class="headerlink" title="3.2 流程图"></a>3.2 流程图</h4><p><img src="/p/40097/004.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 类 </tag>
            
            <tag> 结构 </tag>
            
            <tag> cache_t </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层研究4--类的结构分析</title>
      <link href="/p/8549.html"/>
      <url>/p/8549.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime">GITHUB</a></p></blockquote><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><h4 id="1-1-类Class-的类型"><a href="#1-1-类Class-的类型" class="headerlink" title="1.1 类Class 的类型"></a>1.1 类<strong>Class</strong> 的类型</h4><blockquote><p>Class在源码里的真正类型为<strong>objc_class</strong>的<strong>结构体</strong>。</p></blockquote><p>先查看源码——在Xcode按下<strong>Shift+Command+O</strong>，选择<strong>objc-runtime-new.h</strong>，搜索objc_class，可以得知，Class底层编译实现的前4行如下：</p><p><img src="/p/8549/01.png"></p><p>可知类结构如下：</p><ul><li><p>A. &#x2F;&#x2F;<strong>Class ISA</strong></p><p>​继承自父类 <strong>objc_class</strong> 的 <strong>isa</strong> ，指向类的指针不需显示（内存占8位），这里它返回一个<strong>nonpointer</strong>的指针，相关源码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Represents an instance of a class.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>B. <strong>Class superclass;</strong>                    </p><p>​指向本类的父类（内存占8位）</p></li><li><p>C. <strong>cache_t cache;</strong>                        </p><p>​存储指针和vtable，加速方法调用（内存占8位）</p></li><li><p>D. <strong>class_data_bits_t bits;</strong>             </p><p>​存储类的方法、属性、遵循的协议等信息的地方（内存占8位） </p></li><li><p>E. 其他方法&#x2F;函数 – <strong>不占内存</strong></p></li></ul><p>为何cache_t cache 这个变量占位位16，而不是8？</p><p>原因是因为这里的<strong>cache_t</strong>是结构体，其占内存为根据内部属性结构而定，为防止溢出，给予<strong>16位字节</strong>，而不是指针所需的8位。</p><p>Talk is cheap, show me the code, 伸伸手指，点开cache_t 的内部结构</p><p><img src="/p/8549/02.png"></p><span id="more"></span><p>我们来看看属性：</p><ul><li>bucket_t， 结构体，占8位字节</li><li>mask_t，点开后具体实现为如下：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">mask_t</span>; </span><br></pre></td></tr></table></figure><p>​为整型，占4个字节</p><ul><li>mask_t</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">mask_t</span>;</span><br></pre></td></tr></table></figure><p>​也是整形，占4个字节</p><p>共计8+4+4 &#x3D; <strong>16个字节</strong></p><h4 id="1-2-objc-class继承"><a href="#1-2-objc-class继承" class="headerlink" title="1.2 objc_class继承"></a>1.2 objc_class继承</h4><p>在底层实现里，<strong>objc_class</strong> 继承自<strong>objc_object</strong> 的<strong>结构体</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Represents an instance of a class.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-3-关于NSobject"><a href="#1-3-关于NSobject" class="headerlink" title="1.3 关于NSobject"></a>1.3 关于<strong>NSobject</strong></h4><p> 万物皆对象 - Class 继承自NSObject</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Wobjc-interface-ivars&quot;</span></span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-类的属性与成员变量"><a href="#2-类的属性与成员变量" class="headerlink" title="2. 类的属性与成员变量"></a>2. 类的属性与成员变量</h3><ol><li><h4 id="属性的存储"><a href="#属性的存储" class="headerlink" title="属性的存储"></a>属性的存储</h4><p>上面提到了类对象的结构原理，我们知道了类结构里，类型位<strong>class_data_bits_t</strong> 的<strong>bits</strong>下面我们来探寻一下，类里面的属性上怎么保存的。</p><p>我们在代码里生成一个类，分别有成员变量<strong>hobby</strong>，以及属性<strong>nickName</strong></p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface Person : NSObject&#123;</span><br><span class="line">    NSString *hobby;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="built_in">property</span> (nonatomic, copy) NSString *nickName;</span><br></pre></td></tr></table></figure><p>在主线代码引入:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        LGPerson *person = [LGPerson alloc];</span><br><span class="line">        Class pClass     = <span class="built_in">object_getClass</span>(person);</span><br><span class="line">        <span class="built_in">NSLog</span>(@<span class="string">&quot;%@ -- %p&quot;</span>, person, pClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打印得到的类<strong>pClass</strong>，通过x&#x2F;4gx 获取类结构如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) x/<span class="number">4</span>gx pClass</span><br><span class="line"><span class="number">0x1000023d0</span>: <span class="number">0x001d8001000023a9</span> <span class="number">0x0000000100b37140</span></span><br><span class="line"><span class="number">0x1000023e0</span>: <span class="number">0x00000001003da280</span> <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>观察结果得知<strong>0x1000023d0</strong> 位<strong>pClass</strong>在内存中的首地址，根据内存偏移原则，加上16+8+8共32位，即可得到<strong>bits</strong>的结构。</p><p>0x1000023d0，偏移32位，得到0x1000023f0。<strong>注意</strong>，这里要用<strong>p</strong>打印指针，而非打印值用的po</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p <span class="number">0x1000023f0</span></span><br><span class="line"><span class="number">4294976496</span></span><br></pre></td></tr></table></figure><p>oh NO！得到的是具体的值，这里需要强转一下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) <span class="built_in">p</span> (<span class="type">class_data_bits_t</span> *)<span class="number">0x1000023f0</span></span><br><span class="line">(<span class="type">class_data_bits_t</span> *) $<span class="number">3</span> = <span class="number">0x00000001000023f0</span></span><br></pre></td></tr></table></figure><p>得到$3  的值，并不是我们想要的结构，留意到<strong>objc_class</strong>里的方法 data() 方法:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA; // 8</span></span><br><span class="line">    Class superclass; <span class="comment">// 8</span></span><br><span class="line">    <span class="type">cache_t</span> cache;    <span class="comment">// 16 不是8         // formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>data() 返回是<strong>class_rw_t</strong>，点进去看看，</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_rw_t</span> &#123;</span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="type">method_array_t</span> methods;</span><br><span class="line">    <span class="type">property_array_t</span> properties;</span><br><span class="line">    <span class="type">protocol_array_t</span> protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *demangledName;</span><br></pre></td></tr></table></figure><p>留意到里面有 <strong>methods</strong>、<strong>properties</strong>、<strong>protocols</strong>等，原来这里等值便是类的相关属性方法等等结构。</p><p>现在对$3 执行data() 方法:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">3</span>-&gt;<span class="built_in">data</span>()</span><br><span class="line">(<span class="type">class_rw_t</span> *) $<span class="number">5</span> = <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>对得到的$5 进行值打印:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p *$<span class="number">5</span></span><br><span class="line">(<span class="type">class_rw_t</span>) $<span class="number">5</span> = &#123;</span><br><span class="line">  flags = <span class="number">2148139008</span></span><br><span class="line">  version = <span class="number">0</span></span><br><span class="line">  ro = <span class="number">0x0000000100002308</span></span><br><span class="line">  methods = &#123;</span><br><span class="line">    list_array_tt&lt;<span class="type">method_t</span>, <span class="type">method_list_t</span>&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        list = <span class="number">0x0000000100002240</span></span><br><span class="line">        arrayAndFlag = <span class="number">4294976064</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  properties = &#123;</span><br><span class="line">    list_array_tt&lt;<span class="type">property_t</span>, <span class="type">property_list_t</span>&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        list = <span class="number">0x00000001000022f0</span></span><br><span class="line">        arrayAndFlag = <span class="number">4294976240</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  protocols = &#123;</span><br><span class="line">    list_array_tt&lt;<span class="type">unsigned</span> <span class="type">long</span>, <span class="type">protocol_list_t</span>&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        list = <span class="number">0x0000000000000000</span></span><br><span class="line">        arrayAndFlag = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass = nil</span><br><span class="line">  nextSiblingClass = NSUUID</span><br><span class="line">  demangledName = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，$5 内结构一目了然，方法，属性，协议都显示了。</p><p>继续获取属性值:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">5.</span><span class="built_in">properties</span></span><br><span class="line">(<span class="type">property_array_t</span>) $<span class="number">7</span> = &#123;</span><br><span class="line">  list_array_tt&lt;<span class="type">property_t</span>, <span class="type">property_list_t</span>&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = <span class="number">0x00000001000022f0</span></span><br><span class="line">      arrayAndFlag = <span class="number">4294976240</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到一个二维数组的$7，观察属性列表的类型为<strong>property_array_t</strong>，继承自<strong>list_array_tt</strong>，内部拥有</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">7.l</span>ist</span><br><span class="line">(<span class="type">property_list_t</span> *) $<span class="number">8</span> = <span class="number">0x00000001000022f0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次对$8 进行* 取值，得到如下结果：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p *$<span class="number">8</span></span><br><span class="line">(<span class="type">property_list_t</span>) $<span class="number">9</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="type">property_t</span>, <span class="type">property_list_t</span>, <span class="number">0</span>&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = <span class="number">16</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    first = (name = <span class="string">&quot;nickName&quot;</span>, attributes = <span class="string">&quot;T@\&quot;NSString\&quot;,C,N,V_nickName&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出，我们的<strong>属性</strong>，就<strong>保存在properties</strong> 里中。</p></li><li><h4 id="成员变量的存储"><a href="#成员变量的存储" class="headerlink" title="成员变量的存储"></a>成员变量的存储</h4><p>上面分析了属性的存储，但是我们没有看到成员变量 <strong>hobby</strong>,我们在properties 属性里，没有看到它，到底在哪里呢?下面我们继续查找。</p><p>既然不在properties 里，那尝试一下在$5 的 <strong>ro</strong> 里进行取值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">5.</span><span class="built_in">ro</span></span><br><span class="line">(<span class="type">const</span> <span class="type">class_ro_t</span> *) $<span class="number">10</span> = <span class="number">0x0000000100002308</span></span><br></pre></td></tr></table></figure><p>得到<strong>class_ro_t</strong> 类型的结构体，继续对他取值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p *$<span class="number">10</span></span><br><span class="line">(<span class="type">const</span> <span class="type">class_ro_t</span>) $<span class="number">11</span> = &#123;</span><br><span class="line">  flags = <span class="number">388</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">24</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">  ivarLayout = <span class="number">0x0000000100001f8a</span> <span class="string">&quot;\x02&quot;</span></span><br><span class="line">  name = <span class="number">0x0000000100001f81</span> <span class="string">&quot;LGPerson&quot;</span></span><br><span class="line">  baseMethodList = <span class="number">0x0000000100002240</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x00000001000022a8</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x00000001000022f0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值这里可以看到ivars，就是我们需要的变量列表，打印一下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">11.</span><span class="built_in">ivars</span></span><br><span class="line">(<span class="type">const</span> <span class="type">ivar_list_t</span> *<span class="type">const</span>) $<span class="number">12</span> = <span class="number">0x00000001000022a8</span></span><br></pre></td></tr></table></figure><p>继续对 ivar_list_t 类型的$12 取值:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p *$<span class="number">12</span></span><br><span class="line">(<span class="type">const</span> <span class="type">ivar_list_t</span>) $<span class="number">13</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="type">ivar_t</span>, <span class="type">ivar_list_t</span>, <span class="number">0</span>&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = <span class="number">32</span></span><br><span class="line">    count = <span class="number">2</span></span><br><span class="line">    first = &#123;</span><br><span class="line">      offset = <span class="number">0x0000000100002378</span></span><br><span class="line">      name = <span class="number">0x0000000100001e64</span> <span class="string">&quot;hobby&quot;</span></span><br><span class="line">      type = <span class="number">0x0000000100001fa7</span> <span class="string">&quot;@\&quot;NSString\&quot;&quot;</span></span><br><span class="line">      alignment_raw = <span class="number">3</span></span><br><span class="line">      size = <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $.<span class="built_in">first</span></span><br><span class="line">(<span class="type">const</span> <span class="type">ivar_t</span>) $<span class="number">13</span> = &#123;</span><br><span class="line">  offset = <span class="number">0x0000000100002378</span></span><br><span class="line">  name = <span class="number">0x0000000100001e64</span> <span class="string">&quot;hobby&quot;</span></span><br><span class="line">  type = <span class="number">0x0000000100001fa7</span> <span class="string">&quot;@\&quot;NSString\&quot;&quot;</span></span><br><span class="line">  alignment_raw = <span class="number">3</span></span><br><span class="line">  size = <span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<strong>成员变量</strong>存在类的 <strong>ivars 属性</strong>里</p></li></ol><h3 id="3-类的方法"><a href="#3-类的方法" class="headerlink" title="3. 类的方法"></a>3. 类的方法</h3><h4 id="3-1-类的实例方法"><a href="#3-1-类的实例方法" class="headerlink" title="3.1 类的实例方法"></a>3.1 类的实例方法</h4><p>我们继续对类进行代码编辑，对<code>Person</code>类添加实例方法和类方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)sayHello;<span class="comment">// 实例方法</span></span><br><span class="line">+ (<span class="type">void</span>)sayHappy;<span class="comment">// 类方法</span></span><br></pre></td></tr></table></figure><p>还是对类结构$5 进行解析，这次我们打印它的 <strong>methods</strong> 属性</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">5.</span><span class="built_in">methods</span></span><br><span class="line">(<span class="type">method_array_t</span>) $<span class="number">14</span> = &#123;</span><br><span class="line">  list_array_tt&lt;<span class="type">method_t</span>, <span class="type">method_list_t</span>&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = <span class="number">0x0000000100002240</span></span><br><span class="line">      arrayAndFlag = <span class="number">4294976064</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的是<strong>method_array_t</strong> 类型的$14, 是个数组类型，继续打印:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">14.l</span>ist</span><br><span class="line">(<span class="type">method_list_t</span> *) $<span class="number">15</span> = <span class="number">0x0000000100002240</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p *$<span class="number">15</span></span><br><span class="line">(<span class="type">method_list_t</span>) $<span class="number">16</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="type">method_t</span>, <span class="type">method_list_t</span>, <span class="number">3</span>&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = <span class="number">26</span></span><br><span class="line">    count = <span class="number">4</span></span><br><span class="line">    first = &#123;</span><br><span class="line">      name = <span class="string">&quot;sayHello&quot;</span></span><br><span class="line">      types = <span class="number">0x0000000100001f8c</span> <span class="string">&quot;v16@0:8&quot;</span></span><br><span class="line">      imp = <span class="number">0x0000000100001b90</span> (LGTest`-[LGPerson sayHello] at LGPerson.m:<span class="number">13</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，<strong>实例方法</strong><code>sayHello</code> 方法，存储在类的methods属性里</p><h4 id="3-2-类的类方法存储"><a href="#3-2-类的类方法存储" class="headerlink" title="3.2 类的类方法存储"></a>3.2 类的类方法存储</h4><p>类方法在上述的过程中没有看到，那么它会在哪里呢?</p><p>为了找到它，我们重新回到最初的<strong>pClass</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) x/<span class="number">4</span>gx pClass</span><br><span class="line"><span class="number">0x1000023b0</span>: <span class="number">0x001d800100002389</span> <span class="number">0x0000000100b37140</span></span><br><span class="line"><span class="number">0x1000023c0</span>: <span class="number">0x00000001003da280</span> <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>得到<strong>isa</strong>值为<strong>0x001d800100002389</strong>，这时，唤出它的掩码 <strong>ISA_MASK</strong> 来获取它的元类</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p/x <span class="number">0x001d800100002389</span> &amp; <span class="number">0x0000000ffffffff8</span></span><br><span class="line">(<span class="type">long</span>) $<span class="number">1</span> = <span class="number">0x0000000100002388</span></span><br></pre></td></tr></table></figure><p>继续对元类**$1**的结构进行解析：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) x/<span class="number">4</span>gx <span class="number">0x0000000100002388</span></span><br><span class="line"><span class="number">0x100002388</span>: <span class="number">0x001d800100b370f1</span> <span class="number">0x0000000100b370f0</span></span><br><span class="line"><span class="number">0x100002398</span>: <span class="number">0x0000000100f946c0</span> <span class="number">0x0000000100000003</span></span><br></pre></td></tr></table></figure><p>可知<strong>0x100002388</strong>是这个元类的地址，根据上文提到的内存便宜，我们继续加上2个16进制位，得到0x1000023a8，p一下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) <span class="built_in">p</span> (<span class="type">class_data_bits_t</span> *)$<span class="number">2</span></span><br><span class="line">(<span class="type">class_data_bits_t</span> *) $<span class="number">3</span> = <span class="number">0x00000001000023a8</span></span><br></pre></td></tr></table></figure><p>继续执行上文实例方法类似的方案，执行data() — 取值 – 获取methods 的思路，具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">3</span>-&gt;<span class="built_in">data</span>()</span><br><span class="line">(<span class="type">class_rw_t</span> *) $<span class="number">4</span> = <span class="number">0x0000000100f94620</span></span><br><span class="line">(lldb) p *$<span class="number">4</span></span><br><span class="line">(<span class="type">class_rw_t</span>) $<span class="number">5</span> = &#123;</span><br><span class="line">  flags = <span class="number">2685075456</span></span><br><span class="line">  version = <span class="number">7</span></span><br><span class="line">  ro = <span class="number">0x00000001000021f8</span></span><br><span class="line">  methods = &#123;</span><br><span class="line">    list_array_tt&lt;<span class="type">method_t</span>, <span class="type">method_list_t</span>&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        list = <span class="number">0x00000001000021d8</span></span><br><span class="line">        arrayAndFlag = <span class="number">4294975960</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  properties = &#123;</span><br><span class="line">    list_array_tt&lt;<span class="type">property_t</span>, <span class="type">property_list_t</span>&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        list = <span class="number">0x0000000000000000</span></span><br><span class="line">        arrayAndFlag = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  protocols = &#123;</span><br><span class="line">    list_array_tt&lt;<span class="type">unsigned</span> <span class="type">long</span>, <span class="type">protocol_list_t</span>&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        list = <span class="number">0x0000000000000000</span></span><br><span class="line">        arrayAndFlag = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass = nil</span><br><span class="line">  nextSiblingClass = <span class="number">0x00007fff942e6990</span></span><br><span class="line">  demangledName = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">5.</span><span class="built_in">methods</span></span><br><span class="line">(<span class="type">method_array_t</span>) $<span class="number">10</span> = &#123;</span><br><span class="line">  list_array_tt&lt;<span class="type">method_t</span>, <span class="type">method_list_t</span>&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = <span class="number">0x00000001000021d8</span></span><br><span class="line">      arrayAndFlag = <span class="number">4294975960</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">10.l</span>ist</span><br><span class="line">(<span class="type">method_list_t</span> *) $<span class="number">11</span> = <span class="number">0x00000001000021d8</span></span><br><span class="line">(lldb) p *$<span class="number">11</span></span><br><span class="line">(<span class="type">method_list_t</span>) $<span class="number">12</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="type">method_t</span>, <span class="type">method_list_t</span>, <span class="number">3</span>&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = <span class="number">26</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    first = &#123;</span><br><span class="line">      name = <span class="string">&quot;sayHappy&quot;</span></span><br><span class="line">      types = <span class="number">0x0000000100001f8c</span> <span class="string">&quot;v16@0:8&quot;</span></span><br><span class="line">      imp = <span class="number">0x0000000100001bc0</span> (LGTest`+[LGPerson sayHappy] at LGPerson.m:<span class="number">17</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure><p>可见，<strong>类方法</strong><code>sayHappy</code> 方法，存储在类的<strong>元类</strong> methods属性里</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li>类的本质上一个类型为<strong>objc_class</strong>的结构体，包含有isa、父类、属性、成员变量及方法列表等</li><li>类属性存在结构体的properties里</li><li>类的成员变量存在结构体的 ivars里</li><li>类的实例方法，存在结构体 的methods 属性里</li><li>类的类方法，存在父类的class_ro_t 里的methods里</li></ul><p>如下图示：</p><p><img src="/p/8549/03.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 类 </tag>
            
            <tag> 结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020新年感想</title>
      <link href="/p/63353.html"/>
      <url>/p/63353.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>2020年是一个闰年，第一天从星期三开始。</p></blockquote><p><img src="/p/63353/shaun-the-sheep-2_poster_goldposter_com_6.jpg"></p><p>今天看了小羊肖恩大电影，故事讲得真好看，小朋友全程开心，全情投入，大朋友也觉得耳目一新，深受感动。</p><p>这是我们带他看的第一部电影，新的一年，从第一开始。</p><p>用一句涂鸦来鼓舞自己</p><blockquote><p>宁愿最后徒劳无功，</p><p>也不选择无动于衷。</p></blockquote><p>希望今年也有始有终，有所收获。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 2020 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层研究3--isa的初始化和指向分析</title>
      <link href="/p/64820.html"/>
      <url>/p/64820.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime">GITHUB</a></p></blockquote><p>开始继续学习研究OC源码，这次研究的是isa的初始化和指向分析。</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><h4 id="什么是isa"><a href="#什么是isa" class="headerlink" title="什么是isa"></a>什么是isa</h4><p>看看苹果文档的介绍：</p><blockquote><p>isa</p><p>A Pointer to the class definition of which this object is an instance.</p></blockquote><p><strong>isa</strong> ： 一个指向该对象的类的指针。</p><p>打开Xcode，找到objc.h，我们可以看看到如下代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !OBJC_TYPES_DEFINED</span></span><br><span class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="comment">/// 一个展示OC类的未知的类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_class</span> *Class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Represents an instance of a class.</span></span><br><span class="line"><span class="comment">/// 展示一个类的实例</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to an instance of a class.</span></span><br><span class="line"><span class="comment">/// 一个指向类的实例的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_object</span> *id;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看出，Class 是一个objc_class 类型的结构体。</p><p>而id类型，则是objc_object 类型的结构体.</p><span id="more"></span><h3 id="2-isa-的初始化"><a href="#2-isa-的初始化" class="headerlink" title="2. isa 的初始化"></a>2. isa 的初始化</h3><p>在此之前，先回顾一下对象初始化的流程图</p><img src="/p/64820/0001.png" style="zoom:67%;"><p>在这里，初始化实例的isa，其中 <code>cls</code> 为初始化的类对象，<code>hasCxxDtor</code> 即为是否含有C++的析构器。</p><p>我们进入 <code>initIsa(cls, true, hasCxxDtor)</code> 这个函数，看看内部实现了什么</p><h4 id="2-1-isa非nonpointer"><a href="#2-1-isa非nonpointer" class="headerlink" title="2.1 isa非nonpointer"></a>2.1 isa非<strong>nonpointer</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!nonpointer) &#123;</span><br><span class="line">    isa.cls = cls;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><p><strong>nonpointer概念:</strong>  </p><p>表示是否对isa 指针开启指针优化</p></li></ul><p>​<strong>0: 纯isa指针</strong></p><p>​<strong>1: 不止是类对象的地址，还包含类信息、对象的引用计数等。</strong></p><p>此时，如果为纯isa指针，将当前类 <code>cls</code> 赋值给 <code>isa</code> 的绑定属性 <code>cls</code></p><p>为什么有这个<strong>绑定属性</strong>，而<code>isa</code>究竟是什么看结构呢？</p><p>点击<code>isa.cls = cls;</code>中的<code>cls</code>查看它的结构，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;// isa 初始化方法</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">#if defined(ISA_BITFIELD)</span><br><span class="line">    struct &#123;</span><br><span class="line">         ISA_BITFIELD;  // defined in isa.h</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看见isa 是一个 union，联合体，里面包含了</p><ul><li><code>isa_t</code>  初始化方法</li><li><code>isa_t(uintptr_t value)</code> 工厂方法</li><li><code>Class cls</code>  <strong>绑定属性</strong></li><li>结构体<code>ISA_BITFIELD</code>位域</li></ul><ol><li><p><strong>ISA_BITFIELD概念</strong></p><p>我们点开类型为<code>struct</code>的<code>ISA_BITFIELD</code>，结构如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line"><span class="meta">      uintptr_t nonpointer        : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t has_assoc         : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t has_cxx_dtor      : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t shiftcls          : 33; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span></span><br><span class="line"><span class="meta">      uintptr_t magic             : 6;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t weakly_referenced : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t deallocating      : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t has_sidetable_rc  : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t extra_rc          : 19</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>NONPOINTER_ISA</strong>效果图（手绘中，待补全……）</p></li><li><p>还原isa_t 的结构</p><p>我们这时发现，isa的整体结构可以替换为如下的样子:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">isa_t</span> &#123;</span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="type">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">        <span class="type">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">        <span class="type">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">        <span class="type">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">        <span class="type">uintptr_t</span> magic             : <span class="number">6</span>;                                       \</span><br><span class="line">        <span class="type">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">        <span class="type">uintptr_t</span> deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">        <span class="type">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">        <span class="type">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line">        <span class="comment">//         ISA_BITFIELD;  // defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><strong>nonpointer</strong>: 表示是否对 <strong>isa</strong> 指针开启指针优化 <strong>0</strong>:纯<strong>isa</strong>指针，<strong>1</strong>:不止是类对象地址**,isa** 中包含了类信息、对象的引用计数等（占1位）</p></li><li><p><strong>has_assoc</strong>: 关联对象标志位，<strong>0</strong>没有，<strong>1</strong>存在（占1位）</p></li><li><p><strong>has_cxx_dtor</strong>: 该对象是否有 <strong>C++</strong> 或者 <strong>Objc</strong> 的析构器**,<strong>如果有析构函数</strong>,<strong>则需要做析构逻辑</strong>,** 如果没有**,**则可以更快的释放对象（占1位）</p></li><li><p>**shiftcls:**存储类指针的值。开启指针优化的情况下，在 <strong>arm64</strong> 架构中有 <strong>33</strong> 位用来存储类指针。（占33位）</p></li><li><p><strong>magic</strong>:用于调试器判断当前对象是真的对象还是没有初始化的空间 <strong>weakly_referenced</strong>:志对象是否被指向或者曾经指向一个 <strong>ARC</strong> 的弱变量，没有弱引用的对象可以更快释放。（占6位）</p></li><li><p><strong>deallocating</strong>:标志对象是否正在释放内存（占1位）</p></li><li><p><strong>has_sidetable_rc</strong>:当对象引用计数大于 <strong>10</strong> 时，则需要借用该变量存储进位（占1位）</p></li><li><p><strong>extra_rc</strong>:当表示该对象的引用计数值，实际上是引用计数值减 <strong>1</strong>， 例如，如果对象的引用计数为 <strong>10</strong>，那么 <strong>extra_rc</strong> 为 <strong>9</strong>。如果引用计数大于 <strong>10</strong>， 则需要使用到下面的 <strong>has_sidetable_rc</strong>。（占1位）</p></li></ul><h4 id="2-2-isa是nonpointer类型"><a href="#2-2-isa是nonpointer类型" class="headerlink" title="2.2 isa是nonpointer类型"></a>2.2 isa<strong>是</strong>nonpointer类型</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">        <span class="function"><span class="type">isa_t</span> <span class="title">newisa</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">        <span class="built_in">assert</span>(cls-&gt;<span class="built_in">classArrayIndex</span>() &gt; <span class="number">0</span>);</span><br><span class="line">        newisa.bits = ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.indexcls = (<span class="type">uintptr_t</span>)cls-&gt;<span class="built_in">classArrayIndex</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.shiftcls = (<span class="type">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>生成新的<code>isa</code>:</p><p><code>isa_t newisa(0);</code></p></li><li><p>c++ 析构器：</p><p>newisa.has_cxx_dtor &#x3D; hasCxxDtor;&#96; 表示当前对象是否有C++的析构函数（destructor）,如果没有，释放时会快速的释放内存。</p></li><li><p>位域赋值</p><p><code>newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3; </code>对存储指针的值进行右移动3位赋值。</p></li><li><p>返回isa</p><p><code> isa = newisa;</code></p></li></ul><h3 id="3-isa-的指向"><a href="#3-isa-的指向" class="headerlink" title="3. isa 的指向"></a>3. isa 的指向</h3><h4 id="3-1-指向图："><a href="#3-1-指向图：" class="headerlink" title="3.1 指向图："></a>3.1 指向图：</h4><p>关于isa的指向以及子类父类的关系，苹果官方给出了一张图如下所示：</p><img src="/p/64820/007.png" style="zoom:80%;"><h4 id="3-2-代码分析"><a href="#3-2-代码分析" class="headerlink" title="3.2 代码分析"></a>3.2 代码分析</h4><h5 id="3-2-1-对象的isa"><a href="#3-2-1-对象的isa" class="headerlink" title="3.2.1 对象的isa"></a>3.2.1 对象的<strong>isa</strong></h5><p>我们执行一项代码如下，并对该行打断点：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person *object = [Person alloc];</span><br></pre></td></tr></table></figure><p>我们知道：<strong>对象里的 isa ——指向——&gt; 类</strong>。</p><h5 id="3-2-2类的isa"><a href="#3-2-2类的isa" class="headerlink" title="3.2.2类的isa"></a>3.2.2类的<strong>isa</strong></h5><p>现在我们想知道类的内存空间结构，在控制台执行如下指令<code>x/4gx Person.class</code>，结果如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) x/<span class="number">4</span>gx Person.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">0x100001130</span>: <span class="number">0x001d800100001109</span> <span class="number">0x0000000100b39140</span></span><br><span class="line"><span class="number">0x100001140</span>: <span class="number">0x0000000101a46ed0</span> <span class="number">0x0000000200000007</span></span><br></pre></td></tr></table></figure><p>由于<code>isa</code>是类对象的第一个属性，我们知道<code>0x001d800100001109</code>是改对象的isa，我们看看他指向哪里呢，使用<code>p/x</code> 指令试试:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p/x <span class="number">0x001d800100001109</span></span><br><span class="line">(<span class="type">long</span>) $<span class="number">16</span> = <span class="number">0x001d800100001109</span></span><br></pre></td></tr></table></figure><p>糟糕，查看不到结果？怎么回事？类的isa 格式需要强转，可以退一步，打印类的地址试试：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">po <span class="number">0x100001130</span></span><br><span class="line">Person</span><br></pre></td></tr></table></figure><p>原来如此，在内存空间里，名为Person的类的第一个位置，指向Person类，岂不是循环指向了？</p><p>非也非也，这里指向的类，我们把它称为元类（meta-class）</p><p><strong>类的isa ——指向——&gt; 元类</strong></p><h5 id="3-2-3-元类的isa"><a href="#3-2-3-元类的isa" class="headerlink" title="3.2.3 元类的isa"></a>3.2.3 元类的<strong>isa</strong></h5><p>我们现在获得元类的具体地址，找到<code>isa</code> 的<code>MASK</code>（掩码），值为<code>0x00007ffffffffff8</code>，</p><p>输入以下指令：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p/x <span class="number">0x001d800100001109</span> &amp; <span class="number">0x00007ffffffffff8</span></span><br><span class="line">(<span class="type">long</span>) $<span class="number">17</span> = <span class="number">0x0000000100001108</span></span><br><span class="line">(lldb) po <span class="number">0x0000000100001108</span></span><br><span class="line">Person</span><br></pre></td></tr></table></figure><p>得到元类地址为：<strong>0x0000000100001108</strong>，16进制打印一下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) x/<span class="number">4</span>gx <span class="number">0x0000000100001108</span></span><br><span class="line"><span class="number">0x100001108</span>: <span class="number">0x001d800100b390f1</span> <span class="number">0x0000000100b390f0</span></span><br><span class="line"><span class="number">0x100001118</span>: <span class="number">0x0000000100f5a480</span> <span class="number">0x0000000400000007</span></span><br></pre></td></tr></table></figure><p>可以看到元类结构里，isa指针为 <strong>0x001d800100b390f1</strong>，继续获取它的指向，我们通过与掩码来计算：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) p/x <span class="number">0x001d800100b390f1</span> &amp; <span class="number">0x00007ffffffffff8</span></span><br><span class="line">(<span class="type">long</span>) $<span class="number">21</span> = <span class="number">0x0000000100b390f0</span></span><br></pre></td></tr></table></figure><p>好嘞，拿到内存指针地址为<strong>0x0000000100b390f0</strong>， 打印一下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">po <span class="number">0x0000000100b390f0</span></span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure><p>至此，我们可以看到元类的<code>isa</code>指向它的上一级元类，也就是跟元类(root meta-class)，为NSObject。</p><p>所以得出: <strong>元类的isa ——指向——&gt; 根元类</strong></p><h5 id="3-2-4-根元类的isa"><a href="#3-2-4-根元类的isa" class="headerlink" title="3.2.4 根元类的isa"></a>3.2.4 根元类的<strong>isa</strong></h5><p>我们打印下根元类结构：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x/<span class="number">4</span>gx <span class="number">0x0000000100b390f0</span></span><br><span class="line"><span class="number">0x100b390f0</span>: <span class="number">0x001d800100b390f1</span> <span class="number">0x0000000100b39140</span></span><br><span class="line"><span class="number">0x100b39100</span>: <span class="number">0x0000000101a47020</span> <span class="number">0x0000000500000007</span></span><br></pre></td></tr></table></figure><p>拿到它的isa，与掩码继续进行与运算</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p/x <span class="number">0x001d800100b390f1</span> &amp; <span class="number">0x00007ffffffffff8</span></span><br><span class="line">(<span class="type">long</span>) $<span class="number">27</span> = <span class="number">0x0000000100b390f0</span></span><br></pre></td></tr></table></figure><p>得到的结果<strong>0x0000000100b390f0</strong>，与根元类<strong>0x0000000100b390f0</strong>，完全吻合。</p><p>至此，我们得出结论：<strong>根元类的isa ——指向——&gt; 根类NSObject</strong>。</p><p>什么？你不信，这些都是猜测，证实一下？</p><p>好的，创建如下代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestNSObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// NSObject实例对象</span></span><br><span class="line">    NSObject *object1 = [NSObject alloc];</span><br><span class="line">    <span class="comment">// NSObject类</span></span><br><span class="line">    Class <span class="keyword">class</span> = <span class="built_in">object_getClass</span>(object1);</span><br><span class="line">    <span class="comment">// NSObject元类</span></span><br><span class="line">    Class metaClass = <span class="built_in">object_getClass</span>(<span class="keyword">class</span>);</span><br><span class="line">    <span class="comment">// NSObject根元类</span></span><br><span class="line">    Class rootMetaClass = <span class="built_in">object_getClass</span>(metaClass);</span><br><span class="line">    <span class="comment">// NSObject根根元类</span></span><br><span class="line">    Class rootRootMetaClass = <span class="built_in">object_getClass</span>(rootMetaClass);</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;\n%p 实例对象\n%p 类\n%p 元类\n%p 根元类\n%p 根根元类&quot;</span>,object1,<span class="keyword">class</span>,metaClass,rootMetaClass,rootRootMetaClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0x10066ddc0</span> 实例对象</span><br><span class="line"><span class="number">0x7fff9294a118</span> 类</span><br><span class="line"><span class="number">0x7fff9294a0f0</span> 元类</span><br><span class="line"><span class="number">0x7fff9294a0f0</span> 根元类</span><br><span class="line"><span class="number">0x7fff9294a0f0</span> 根根元类</span><br></pre></td></tr></table></figure><p>可见，除了NSObject 类是独有的创建，其他元类、根元类、根根元类，都是一样的，因为都是NSObject，所以结果得到了证明。</p><h4 id="3-3-总结："><a href="#3-3-总结：" class="headerlink" title="3.3 总结："></a>3.3 总结：</h4><p>我们再回到这幅图，最红是这样的：</p><img src="/p/64820/007.png" style="zoom:80%;"><ul><li><p>isa指向：</p><blockquote><ul><li>对象中的isa——&gt; 类</li><li>类中的isa ——&gt; 元类</li><li>元类中的isa —-&gt; 根元类</li><li>根元类中的isa —-&gt; 根元类</li></ul></blockquote></li><li><p>类继承关系：</p><blockquote><ul><li>子类 ———superClass——— 父类</li><li>父类 ———superClass——— 根元类</li><li>根元类 ———superClass———  NSObject</li><li>NSObject  ———superClass——— nil</li></ul></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 对齐 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层研究2--内存对齐原理</title>
      <link href="/p/43162.html"/>
      <url>/p/43162.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime">GITHUB</a></p></blockquote><p>开始继续学习研究OC源码，今天看的是OC的内存原理，以及对齐原理的分析。</p><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>内存对齐在数据结构中，是比较基础也比较重要的一环，对于iOS开发，研究底层更免不了要了解他们的原理，方便我们更透彻的学习iOS的原理。</p><p>我们先来一段维基百科的<a href="https://en.wikipedia.org/wiki/Data_structure_alignment">数据结构对齐</a>的相关知识。</p><blockquote><p>内存对齐，也可以理解为数据结构对齐（Data structure alignment），是代码编译后在内存的布局与使用方式。包括三方面内容：<strong>数据对齐</strong>、<strong>数据结构填充</strong>（padding）与<strong>包入</strong>（packing）。</p></blockquote><p>下图是内存中各类型属性所占的空间大小：</p><p><img src="/p/43162/010.png"></p><span id="more"></span><blockquote><p>列举一下各数据类型所占字节（32位）：</p><ul><li>A <strong>char</strong> (one byte) will be 1-byte aligned.</li><li>A <strong>short</strong> (two bytes) will be 2-byte aligned.</li><li>An <strong>int</strong> (four bytes) will be 4-byte aligned.</li><li>A <strong>long</strong> (four bytes) will be 4-byte aligned.</li><li>A <strong>float</strong> (four bytes) will be 4-byte aligned.</li><li>A <strong>double</strong> (eight bytes) will be 8-byte aligned on Windows and 4-byte aligned on Linux (8-byte with <em>-malign-double</em> compile time option).</li><li>A <strong>long long</strong> (eight bytes) will be 4-byte aligned.</li><li>A <strong>long double</strong> (ten bytes with C++Builder and DMC, eight bytes with Visual C++, twelve bytes with GCC) will be 8-byte aligned with C++Builder, 2-byte aligned with DMC, 8-byte aligned with Visual C++, and 4-byte aligned with GCC.</li><li>Any <strong>pointer</strong> (four bytes) will be 4-byte aligned. (e.g.: char*, int*)</li></ul></blockquote><p>需要注意的是，在64位机上，有以下不同</p><blockquote><ul><li>A <strong>long</strong> (eight bytes) will be 8-byte aligned.</li><li>A <strong>double</strong> (eight bytes) will be 8-byte aligned.</li><li>A <strong>long long</strong> (eight bytes) will be 8-byte aligned.</li><li>A <strong>long double</strong> (eight bytes with Visual C++, sixteen bytes with GCC) will be 8-byte aligned with Visual C++ and 16-byte aligned with GCC.</li><li>Any <strong>pointer</strong> (eight bytes) will be 8-byte aligned.</li></ul></blockquote><h4 id="2-原则"><a href="#2-原则" class="headerlink" title="2. 原则"></a>2. 原则</h4><ol><li><p><strong>数据成员对齐规则：</strong>结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在32位机为４字节,则要从４的整数倍地址开始存储。</p></li><li><p><strong>结构体作为成员:</strong> 如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)</p></li><li><p>**收尾工作:**结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐.</p></li></ol><h4 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h4><h5 id="3-1-属性8字节对齐："><a href="#3-1-属性8字节对齐：" class="headerlink" title="3.1 属性8字节对齐："></a>3.1 属性8字节对齐：</h5><p>当创建对象时，其属性的按类型占据不同的内存空间，但是由于大小不一，需要进行补齐；原则则是以第一位补齐为8的倍数（64位系统是8为对齐，而32位系统是4位对齐）。</p><p>以下面的代码举例子</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">    <span class="type">char</span> b;<span class="comment">// 第2行 char 在前 int 在后</span></span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">short</span> d;</span><br><span class="line">&#125; MyStr1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct2</span> &#123;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">    <span class="type">int</span> c;<span class="comment">// 第2行 int 在前 char 在后</span></span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">short</span> d;</span><br><span class="line">&#125; MyStr2;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 我们打印一下各自的所占空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;%lu -- %lu&quot;</span>,<span class="built_in">sizeof</span>(MyStr1), <span class="built_in">sizeof</span>(MyStr2));</span><br></pre></td></tr></table></figure><p>结果如下:</p><img src="/p/43162/001.png" style="zoom:50%;"><p>为何两者不一致?</p><p>我们来看第一个结构体对象的内部结构，排第一的属性double占8位，而char需要补齐7位成为8位，而剩余的int，short 则分别占4位，不需补齐，可以灵活堆在同一个内存区域。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">double</span> a;<span class="comment">// 8位</span></span><br><span class="line">    <span class="type">char</span> b;<span class="comment">// 1位  + 7 补齐  = 8</span></span><br><span class="line">    <span class="type">int</span> c;<span class="comment">// 4位</span></span><br><span class="line">    <span class="type">short</span> d;<span class="comment">// 4位</span></span><br><span class="line">&#125; MyStr1;</span><br></pre></td></tr></table></figure><p>总计是 8 + 8 + 4 + 4 &#x3D; 24；</p><p>而第二个结构体对象，排第一的属性double占8位，而剩余的int，short ，short 总计都，不需补齐，可以灵活堆在同一个内存区域。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct2</span> &#123;</span><br><span class="line">    <span class="type">double</span> a;<span class="comment">// 8 </span></span><br><span class="line">    <span class="type">int</span> c;<span class="comment">// 4</span></span><br><span class="line">    <span class="type">char</span> b;<span class="comment">// 1  补齐1位 </span></span><br><span class="line">    <span class="type">short</span> d;<span class="comment">// 2   </span></span><br><span class="line">&#125; MyStr2;</span><br></pre></td></tr></table></figure><p>这里后3位，可以放到一个8位内存区间，即4 + 1 + 2，只需补齐1位至8位，可以灵活排列在一个内存空间内，所以本结构体对象总占内存为8+4+1+2 + 1（补齐1位） &#x3D; 16。</p><p>如果没有弄懂，我们找出源码来读一读：(&#x2F;objc&#x2F;Private Headers&#x2F;Project Headers&#x2F;objc-os.h) </p><ol><li><p>创建对象 alloc<br><img src="/p/43162/1.png"></p></li><li><p>alloc方法的实现——返回rootAlloc方法<br><img src="/p/43162/2.png"></p></li><li><p>返回callAlloc的实现<br><img src="/p/43162/3.png"></p></li><li><p>当缓存区没有对象时，创建对象<br><img src="/p/43162/4.png"></p></li><li><p>去内存区域创建对象<br><img src="/p/43162/5.png"></p></li><li><p>执行类的属性方法，确定创建的空间大小<br><img src="/p/43162/6.png"></p></li><li><p>对齐内存<br><img src="/p/43162/7.png"></p></li><li><p>内存对齐的返回：类的属性大小取决于指针大小<br><img src="/p/43162/8.png"></p></li><li><p>8字节对齐：实现方法<br><img src="/p/43162/9.png"></p></li></ol><h5 id="3-2-对象16字节对齐"><a href="#3-2-对象16字节对齐" class="headerlink" title="3.2 对象16字节对齐"></a>3.2 对象16字节对齐</h5><p>在<a href="http://nilsli.com/2019/12/16/pricipleofalloc/">OC 底层研究1–alloc和init原理 </a>我们分析过，iOS环境下，为了容错处理，创建。</p><p>在 libmalloc&#x2F;src&#x2F;nano_malloc.c 第193行，我们发现如下的代码:</p><p><img src="/p/43162/002.png"></p><p>而其中<code>NANO_REGIME_QUANTA_SIZE</code> 为16，</p><figure class="highlight plaintext"><figcaption><span>为4</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">那可以开始分析源码如下：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">if (0 == size) &#123;</span><br><span class="line">size = NANO_REGIME_QUANTA_SIZE; // Historical behavior</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的意思是，如果size为0，即创建空对象，返回16位默认空间。</p><p>而 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">k = (size + NANO_REGIME_QUANTA_SIZE - <span class="number">1</span>) &gt;&gt; SHIFT_NANO_QUANTUM</span><br></pre></td></tr></table></figure><p>是向右移动4位，即16字节对齐，那究竟是怎么实现的，我们不妨来看下，假定给定申请的内存size 为40，那么</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">40</span>(size) + <span class="number">16</span> - <span class="number">1</span> =  <span class="number">55</span></span><br><span class="line"><span class="number">0011</span> <span class="number">0111</span><span class="comment">// 55 的2进制显示</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0011</span><span class="comment">// &gt;&gt; 右移动4位  == 3</span></span><br><span class="line"><span class="number">0011</span> <span class="number">0000</span><span class="comment">// 执行 slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; 左移动4位</span></span><br><span class="line">slot_bytes = <span class="number">48</span>(<span class="number">0011</span> <span class="number">0000</span>)</span><br></pre></td></tr></table></figure><p>er,  第205行中返回的slot_bytes 即是最终对齐后的内存空间位，即给入40，最终系统对齐后，返回48位(16的整数位)。</p><h4 id="4-结论"><a href="#4-结论" class="headerlink" title="4 结论"></a>4 结论</h4><p>在iOS环境下，我们创建的对象和指针遵循16位对齐的原则，而其属性位8字节对齐。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 对齐 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC 底层研究1--alloc和init原理</title>
      <link href="/p/19251.html"/>
      <url>/p/19251.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime">GITHUB</a></p></blockquote><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>开始学习研究OC源码，今天看的是对象的初始化，也就是alloc以及init的分析。</p><h3 id="2-附流程图如下"><a href="#2-附流程图如下" class="headerlink" title="2. 附流程图如下"></a>2. 附流程图如下</h3><p> <img src="/p/19251/121601.png"></p><h3 id="3-内容"><a href="#3-内容" class="headerlink" title="3. 内容"></a>3. 内容</h3><h4 id="3-1引子"><a href="#3-1引子" class="headerlink" title="3.1引子"></a>3.1引子</h4><p>我们先看一段代码，Person类的初始化，打印p1,p2,p3对象，以及指向他们的指针：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person *p1 = [Person alloc];</span><br><span class="line">Person *p2 = [p1 init];</span><br><span class="line">Person *p3 = [p1 init];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@ -- %p&quot;, p1, &amp;p1);</span><br><span class="line">NSLog(@&quot;%@ -- %p&quot;, p2, &amp;p2);</span><br><span class="line">NSLog(@&quot;%@ -- %p&quot;, p3, &amp;p3);</span><br></pre></td></tr></table></figure><p>打印结果是：</p><img src="/p/19251/121602.png" style="zoom:50%;"><p>这里为什么p1相同的情况下，经过init后的p2，p3 的地址都不一样呢，我们要用这个图来分析:</p><img src="/p/19251/121603.png" style="zoom:50%;"><p>在这里，我们**[Person alloc]<strong>创建了一个p 对象的内存空间，而</strong>[p1 init]**则是创建同样是指向p1的指针p2，p3，因为和p1 内存空间一致，所以地址均为0x6000024f4950，但是指向该3个指针的指针不一样，所以&amp;p1, &amp;p2, &amp;p3 地址不一致。 </p><h4 id="3-2源码分析："><a href="#3-2源码分析：" class="headerlink" title="3.2源码分析："></a>3.2源码分析：</h4><p>alloc 步骤如下</p><h6 id="1-alloc"><a href="#1-alloc" class="headerlink" title="1. alloc"></a><strong>1. alloc</strong></h6><p>该步骤主要为创建对象，<strong>申请内存空间</strong>。相关objc源代码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<span id="more"></span></p><h6 id="2-objc-rootAlloc"><a href="#2-objc-rootAlloc" class="headerlink" title="2. objc_rootAlloc"></a><strong>2. objc_rootAlloc</strong></h6><p>基类对于alloc 的实现，此时cls不为空，源码如下：</p><p><strong>init方法：</strong></p><p>类的init 如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+(id)init&#123;</span><br><span class="line"><span class="keyword">return</span> (id)self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象的init如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (id)init&#123;</span><br><span class="line"><span class="keyword">return</span> _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">callAlloc</span>(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处init 方法仅仅为工厂初始方法，作为父类方法，方便子类重写。</p><h6 id="3-callAlloc"><a href="#3-callAlloc" class="headerlink" title="3. callAlloc**"></a>3. callAlloc**</h6><p>callAlloc 的实现如下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="function"><span class="type">static</span> ALWAYS_INLINE id</span></span><br><span class="line"><span class="function"><span class="title">callAlloc</span><span class="params">(Class cls, <span class="type">bool</span> checkNil, <span class="type">bool</span> allocWithZone=<span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomAWZ</span>())) &#123;</span><br><span class="line">        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span></span><br><span class="line">        <span class="comment">// fixme store hasCustomAWZ in the non-meta class and </span></span><br><span class="line">        <span class="comment">// add it to canAllocFast&#x27;s summary</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fastpath</span>(cls-&gt;<span class="built_in">canAllocFast</span>())) &#123;</span><br><span class="line">            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span></span><br><span class="line">            <span class="type">bool</span> dtor = cls-&gt;<span class="built_in">hasCxxDtor</span>();</span><br><span class="line">            id obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, cls-&gt;bits.<span class="built_in">fastInstanceSize</span>());</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!obj)) <span class="keyword">return</span> <span class="built_in">callBadAllocHandler</span>(cls);</span><br><span class="line">            obj-&gt;<span class="built_in">initInstanceIsa</span>(cls, dtor);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span></span><br><span class="line">            id obj = <span class="built_in">class_createInstance</span>(cls, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!obj)) <span class="keyword">return</span> <span class="built_in">callBadAllocHandler</span>(cls);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:nil];</span><br><span class="line">    <span class="keyword">return</span> [cls alloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-class-createInstance"><a href="#4-class-createInstance" class="headerlink" title="4. class_createInstance"></a><strong>4. class_createInstance</strong></h6><p>如上代码，如无捷径，类对象即创建实例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">class_createInstance</span>(Class cls, <span class="type">size_t</span> extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5-class-createINstanceFramZone"><a href="#5-class-createINstanceFramZone" class="headerlink" title="5. _class_createINstanceFramZone"></a><strong>5. _class_createINstanceFramZone</strong></h6><ol><li><p>Cls-&gt;instanceSize</p><p>此时为对其寻址空间，统一为为每个对象开辟16位的位置，防止溢出。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> size = cls-&gt;<span class="built_in">instanceSize</span>(extraBytes);</span><br><span class="line"><span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line"><span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br></pre></td></tr></table></figure></li><li><p>calloc</p><p>如果空间已开辟，则指定空间并返回，类似去学校报道，宿管阿姨带你去宿舍并交付钥匙给你，代码如下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (zone) &#123;</span><br><span class="line">    <span class="comment">// malloc_zone_calloc 即为开辟内存</span></span><br><span class="line">    obj = (id)<span class="built_in">malloc_zone_calloc</span> ((<span class="type">malloc_zone_t</span> *)zone, <span class="number">1</span>, size);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>objc-&gt;initInstanceIsa</p><p>这一步为确定指针，即给宿舍贴上门牌号，相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">    obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);<span class="comment">// 该行开辟了名为obj空间</span></span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line">    obj-&gt;<span class="built_in">initInstanceIsa</span>(cls, hasCxxDtor);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol><p>在这一环节，<code>obj = (id)calloc(1, size)</code> 该行开辟了名为obj空间。</p><p>而<code>obj-&gt;initInstanceIsa(cls, hasCxxDtor)</code> 则真正的将内存空间obj 与类cls 进行关联上。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>总的来说，alloc的过程，即时在堆区开辟空间给对象，并在栈区开辟指针（大小为8字节）指向该对象的内存区，即给定isa，以方便寻址。</p><p>以上，如果有更深入的理解，会再来补充，供参考。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> alloc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Runtime获取第三方成员变量</title>
      <link href="/p/5621.html"/>
      <url>/p/5621.html</url>
      
        <content type="html"><![CDATA[<p>我们使用第三方库，有时候需要获取其成员变量。方法如下：</p><p><strong>导入runtime</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>声明一个Person类</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *address;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="built_in">property</span>(nonatomic,strong)NSString *name;</span><br><span class="line">@<span class="built_in">property</span>(nonatomic,assign)NSInteger age;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>使用runtime获取私有属性</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历获取Person类所有的成员变量IvarList</span></span><br><span class="line">- (<span class="type">void</span>) getAllIvarList &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> methodCount = <span class="number">0</span>;</span><br><span class="line">    Ivar * ivars = <span class="built_in">class_copyIvarList</span>([Person <span class="keyword">class</span>], &amp;methodCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCount; i ++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> * name = <span class="built_in">ivar_getName</span>(ivar);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> * type = <span class="built_in">ivar_getTypeEncoding</span>(ivar);</span><br><span class="line">        <span class="built_in">NSLog</span>(@<span class="string">&quot;Person拥有的成员变量的类型为%s，名字为 %s &quot;</span>,type, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(ivars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果如下：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-12</span> <span class="number">15</span>:<span class="number">14</span>:<span class="number">02.115744</span>+<span class="number">0800</span> PersonRuntime[<span class="number">11576</span>:<span class="number">1071364</span>] Person拥有的成员变量的类型为@<span class="string">&quot;NSString&quot;</span>，名字为 address </span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-12</span> <span class="number">15</span>:<span class="number">14</span>:<span class="number">02.115902</span>+<span class="number">0800</span> PersonRuntime[<span class="number">11576</span>:<span class="number">1071364</span>] Person拥有的成员变量的类型为@<span class="string">&quot;NSString&quot;</span>，名字为 _name </span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-12</span> <span class="number">15</span>:<span class="number">14</span>:<span class="number">02.115997</span>+<span class="number">0800</span> PersonRuntime[<span class="number">11576</span>:<span class="number">1071364</span>] Person拥有的成员变量的类型为q，名字为 _age </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> ios </tag>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 深入学习</title>
      <link href="/p/2840.html"/>
      <url>/p/2840.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p><h5 id="1-快速开发"><a href="#1-快速开发" class="headerlink" title="1.快速开发"></a>1.快速开发</h5><p>毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。</p><h5 id="2-富有表现力和灵活的UI"><a href="#2-富有表现力和灵活的UI" class="headerlink" title="2.富有表现力和灵活的UI"></a>2.富有表现力和灵活的UI</h5><p>快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。</p><h5 id="3-原生性能"><a href="#3-原生性能" class="headerlink" title="3.原生性能"></a>3.原生性能</h5><p>Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。</p> <span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/flutterchina/website@1.0/images/homepage/header-illustration.png" alt="img"></p><h3 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h3><p>Flutter的热重载可帮助您快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以在亚秒内重载，并且不会丢失状态。</p><p><img src="https://cdn.jsdelivr.net/gh/flutterchina/website@1.0/images/intellij/hot-reload.gif"></p><h3 id="现代式，响应式框架"><a href="#现代式，响应式框架" class="headerlink" title="现代式，响应式框架"></a>现代式，响应式框架</h3><p>使用Flutter的现代、响应式框架，和一系列基础widget，轻松构建您的用户界面。使用功能强大且灵活的API（针对2D、动画、手势、效果等）解决艰难的UI挑战。</p><p>示例代码：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Counter</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> increment() &#123;</span><br><span class="line">    <span class="comment">// 告诉Flutter state已经改变, Flutter会调用build()，更新显示</span></span><br><span class="line">    setState(() &#123;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 当 setState 被调用时，这个方法都会重新执行.</span></span><br><span class="line">    <span class="comment">// Flutter 对此方法做了优化，使重新执行变的很快</span></span><br><span class="line">    <span class="comment">// 所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        <span class="keyword">new</span> RaisedButton(</span><br><span class="line">          onPressed: increment,</span><br><span class="line">          child: <span class="keyword">new</span> Text(<span class="string">&#x27;Increment&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">new</span> Text(<span class="string">&#x27;Count: <span class="subst">$counter</span>&#x27;</span>),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Flutter </tag>
            
            <tag> 大前端，跨栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】产品经理vs项目经理：如何区别他们</title>
      <link href="/p/56253.html"/>
      <url>/p/56253.html</url>
      
        <content type="html"><![CDATA[<h6 id="（原链接在此）"><a href="#（原链接在此）" class="headerlink" title="（原链接在此）"></a>（<a href="https://habr.com/en/company/hygger/blog/462919/">原链接在此</a>）</h6><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>大公司和较大的团队常常存在许多战略部门与角色。因此，人们往往会对其中众多角色岗位一脸懵逼不足为奇。</p><p>不同的经理在团队中的关键职责是否那么容易区分呢？举个栗子，一个产品经理和项目经理的角色就有很多共同点。据说，这些经理中每一个人在他的生命中起码听过这样直接的问题：他们（产品经理、项目经理）有区别吗？不过，也别急着埋怨他们或者觉得难堪，就因为他们对这些职能弄不清楚。产品经理和项目经理是完全不同的角色。这篇文章的目标是定义清楚这两种在软件开发公司里的关键位置的区别，让你彻底甩掉疑惑。</p><p><img src="https://habrastorage.org/getpro/habr/post_images/eda/55f/a19/eda55fa19804f2f0d2fd819a7cf17ad8.jpg"></p><span id="more"></span><p>想象一下，你的组织需要进行人力资源优化以及一些人员裁减。如果你不得不决定团队里谁会留下，而谁该友好说再见。哪个经理你会选择留下？</p><p>显然，做出选择并不容易。如果你被问到，说出谁对团队更重要，你肯定会发现难以回答。</p><p>这个问题有正确答案吗？让我们试着理清楚。</p><h3 id="产品经理-vs-项目经理：谁的负担更重"><a href="#产品经理-vs-项目经理：谁的负担更重" class="headerlink" title="产品经理 vs 项目经理：谁的负担更重"></a>产品经理 vs 项目经理：谁的负担更重</h3><ul><li><strong>产品</strong> 是你给客户或用户提出的最终结果。产品可以是可以触摸到的实物；也可能是软件平台或者服务。</li><li><strong>项目</strong> 是一个包含着后续活动的计划。这些活动有设定好的启动和截止时间，以及一个结果。只有在最终结果达成后，项目才算完成。</li></ul><p>举个栗子，你的产品是一个约会app。开发这个应用意味着不同的项目。其中一个是编写一个内容计划以及运行一个公司博客。这个项目有自己的截止时间和结束点。</p><p>比较两种角色最无聊（但并不正确！）的方式是去观察他们的薪资收入。下图显示了详细数据：</p><p><img src="https://habrastorage.org/getpro/habr/post_images/2be/bac/2db/2bebac2db9299bdfad99da90e7b7d00f.jpg"></p><p>软件行业产品经理年收入（年份未知）</p><p><img src="https://habrastorage.org/getpro/habr/post_images/acb/312/75c/acb31275ce31fe44cc00238c5e695505.jpg"></p><p>IT行业产品项目经理年收入（年份未知）</p><h3 id="产品经理和项目经理关键职能是什么？"><a href="#产品经理和项目经理关键职能是什么？" class="headerlink" title="产品经理和项目经理关键职能是什么？"></a>产品经理和项目经理关键职能是什么？</h3><p><strong>产品经理</strong></p><p>在IT领域，产品经理负责管理软件开发。他们通常负责定义产品战略、功能有限顺序以及产品的最终交付上线。</p><p>他们负责创造想法和主动性来帮助实现战略和目标，促进内部和外部的相关部门交流；他们会访问潜在的和现有的客户，获取可能会对未来版本有帮助的反馈；他们也会和经销商一起工作，有成效地向用户展示产品细节；他们战略路线下工作，处理产品积压。</p><p>产品经理通常参加工业事件和会议，以停留在当前行业最前沿。因此，他们的核心职能列表如下：</p><ul><li>产品战略</li><li>市场调研</li><li>期望与主动性</li><li>发布</li><li>损益问题</li></ul><p><strong>项目经理</strong></p><p>在软件开发中行业，项目经理的职责与计划固定类型公司里的项目紧密相连。这些专家保证他们在正轨上运行，通过所有执行阶段，他们关心可能的制约和资源风险。</p><p>通常，他们较少关心具体的产品目标。他们分析所有的主动性和特性，来开发一个项目时间表。</p><p>作为一份工作，项目经理可能需要每天评估员工，他们的积极性来达成具体的目标。</p><p>项目经理管控项目知道他们完成，然后会评估要继续跟进的必要性。</p><p>他们的主要职责关联如下：</p><ul><li>项目交付</li><li>资源</li><li>利用软件生命周期方法</li><li>状态更新</li><li>项目预算</li><li>产能</li><li>团队合作成功</li><li>问题解决方案</li></ul><h4 id="两种岗位可能的职业路线是什么？"><a href="#两种岗位可能的职业路线是什么？" class="headerlink" title="两种岗位可能的职业路线是什么？"></a>两种岗位可能的职业路线是什么？</h4><p>这些管理们毫无疑问的寻求职业成长。从一个工作（提升）到下一个水平的行动，需要坚强的经理技能和足够的经验。</p><p>典型的来说，产品经理李正成为高级产品经理或者产品管理负责人。项目经理们的职业路线通常说升级到高级项目经理和项目负责人角色。</p><h4 id="在公司里哪一种角色更重要？"><a href="#在公司里哪一种角色更重要？" class="headerlink" title="在公司里哪一种角色更重要？"></a>在公司里哪一种角色更重要？</h4><p>如果你的公司同时需要产品经理和项目经理，那么组织结构上是完全合理的。如何定义，谁说更重要呢？</p><p>可能，下面的问题会帮助你：</p><ul><li>如果没有产品经理，团队能否运行良好？</li><li>如果项目经理离开团队，会发生什么？</li></ul><p>很有可能，你的答案会显示两个角色都是重要且不可取代。他们的紧密合作是迈向成功的关键。</p><h4 id="项目管理和产品管理工具"><a href="#项目管理和产品管理工具" class="headerlink" title="项目管理和产品管理工具"></a>项目管理和产品管理工具</h4><p>选择项目管理和产品管理一个专业工具，需要考虑明确的公司需求、团队相关成员的数量、相关行业，以及其他的因素。</p><p>当下你可以尝试小型在线管理解决方案，它能满足经理们的必要需求。</p><p>一些流行的软件方案如Trello，Wrike, Hygger或Aha提供了所有产品管理和项目管理领域的强大的工具套装。</p><p>大部分这些工具会提供用户便利便利的tas面板（为看板和敏捷开发适配），跟踪系统，待办事项列表，确定优先事项，高级别评估，有用时间线，等等等等。</p><h4 id="最后一句话"><a href="#最后一句话" class="headerlink" title="最后一句话"></a>最后一句话</h4><p>让我们简单的总结一下上面提到的事情：</p><ul><li>产品经理和项目经理角色可能被弄混，但他们是完全不同的。他们对于软件开发公司是同等重要。</li><li>产品经理驱动产品开发，主动性的工作，确定优先顺序以及制定战略决定。项目经理管控已经被开发和审批过的项目计划。</li><li>两个经理都需要专业管理软件来可视化和追踪产品和项目活动，并与团队通力合作。</li></ul><p><em>你怎么区分项目和产品经理呢？哪些软件你尝试过，为什么？</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目经理 </tag>
            
            <tag> 产品经理 </tag>
            
            <tag> IT </tag>
            
            <tag> 产品 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发中的问题集锦</title>
      <link href="/p/49163.html"/>
      <url>/p/49163.html</url>
      
        <content type="html"><![CDATA[<p>开发中难免遇到各式各样的小问题，平时收集一下，汇总如下，按Q（问题）和 A（解决方法）。</p><h4 id="Q1遇到unable-to-index-file"><a href="#Q1遇到unable-to-index-file" class="headerlink" title="Q1遇到unable to index file"></a>Q1遇到unable to index file</h4><p>详细内容：</p><p>​详细内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unable to index file </span><br><span class="line"></span><br><span class="line">fatal: updating files failed</span><br></pre></td></tr></table></figure><p>A 解决：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD qooxdoo</span><br></pre></td></tr></table></figure><h4 id="Q2-hexo部署后，CNAME会被自动删除"><a href="#Q2-hexo部署后，CNAME会被自动删除" class="headerlink" title="Q2  hexo部署后，CNAME会被自动删除"></a>Q2  hexo部署后，CNAME会被自动删除</h4><p>推送上去后，包含域名内容的CNAME 被删除，博客无法用域名解析。</p><p><strong>A 解决：</strong></p><p>出现这样的问题一般是CNAME 放在blog根目录下，正确是放在source 目录下。</p><p>然后执行 部署推送</p><p><code>hexo d -g </code></p><p>问题得到解决。</p><h4 id="Q3-This-copy-of-libswiftCore-dylib-requires-an-OS-version-prior-to-10-14-4"><a href="#Q3-This-copy-of-libswiftCore-dylib-requires-an-OS-version-prior-to-10-14-4" class="headerlink" title="Q3 This copy of libswiftCore.dylib requires an OS version prior to 10.14.4."></a>Q3 This copy of libswiftCore.dylib requires an OS version prior to 10.14.4.</h4><p>问题:</p><p>在掘金<a href="https://juejin.im/post/5a3cc9a351882560b76c5ddf">这篇文章</a>, 尝试配置SPM，通过命令创建包时，执行<code>swift run</code> 后，出现如下问题</p><p><strong><img src="/p/49163/0806-001.png" alt="0806-001"></strong></p><p><strong>A 解决：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /usr/lib/swift/*.dylib /Applications/Xcode.app/Contents/Frameworks</span><br></pre></td></tr></table></figure><h4 id="Q4-Git-遇到了-early-EOF-index-pack-failed"><a href="#Q4-Git-遇到了-early-EOF-index-pack-failed" class="headerlink" title="Q4: Git 遇到了 early EOF index-pack failed"></a>Q4: Git 遇到了 early EOF index-pack failed</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ git clone https:<span class="comment">//github.com/boostorg/boost.git</span></span><br><span class="line">Cloning into <span class="string">&#x27;boost&#x27;</span>...</span><br><span class="line">remote: Counting objects: <span class="number">183543</span>, done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">69361</span>/<span class="number">69361</span>), done.</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure><p>解决：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --add core.compression -1</span><br></pre></td></tr></table></figure><p>————————</p><p>持续添加中</p><p><img src="https://s3.amazonaws.com/com.twilio.prod.twilio-docs/images/iOSUsernotificationsSwift.width-1616.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> swift </tag>
            
            <tag> 小问题 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】从阿波罗7号卫星上俯瞰加州南部</title>
      <link href="/p/21620.html"/>
      <url>/p/21620.html</url>
      
        <content type="html"><![CDATA[<p>这是从阿波罗7号上拍摄的加州南部的照片</p><p><img src="https://www.nasa.gov/sites/default/files/thumbnails/image/as07-11-2022.jpg"></p><p>图片来自 <a href="http://nasa.org/">NASA</a></p><p>这片照片拍摄于1968年10月12日，由阿波罗7号航天器在执行它的绕地飞行第18圈时拍摄。拍摄时对地高度为124海里，加州海岸线上的穆古岬向南一直到欧申赛德，都能尽收眼底。透过云层，依稀能看见圣卡塔利娜岛屿。洛杉矶地区的近景则被从班宁市向西连绵100多英里直到马里海滩上空污染物所遮盖的模糊不清。在图片的上部（从左至右）能看见圣华金谷）在贝克斯菲尔德之外，特哈查比山脉,内华达山脉,欧文斯谷,死亡山谷以及莫哈韦沙漠。</p><p>阿波罗7号于1968年10月11日升空，被亲切称为”华尔特，华里和唐·修”, 是首次载人发射火箭计划。该计划在载人行动期间证明了指令&#x2F;服务仓任务模组技术、项目地面支援能力、阿波罗的空间交会能力，同时也实现了首次从太空进行实时电视直播。</p><p><a href="https://www.nasa.gov/image-feature/southern-california-as-seen-from-apollo-7">原文链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> NASA </tag>
            
            <tag> 太空 </tag>
            
            <tag> 卫星 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】SaaS发展历程</title>
      <link href="/p/59473.html"/>
      <url>/p/59473.html</url>
      
        <content type="html"><![CDATA[<p>撰稿人：<a href="https://www.linkedin.com/in/neerajagrawal2000/">Neeraj Agrawal</a></p><h3 id="梗概："><a href="#梗概：" class="headerlink" title="梗概："></a><strong>梗概：</strong></h3><p>　　总结了成功的SaaS公司上市前的发展轨迹：找到 product-market fit，年入$200万（ARR），然后进入T2D3阶段 - 连续两年ARR翻三倍，然后连续三年翻两倍。ARR至少$1亿，然后上市。</p><p><strong>所谓T2D3：</strong></p><p>　　连续两年 triple（三倍），然后连续三年 double（两倍）。<br>　　<br>　　<span id="more"></span></p><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a><strong>原文</strong></h3><p>【编者按】</p><p>作者 Neeraj Agrawal 是美国波斯顿著名科技行业投行 Batter Ventures 的一名普通合伙人。</p><p>　　“打造一个十亿级的SaaS企业软件公司需要怎么做？”，作为一个科技行业投资者，在从业一来，曾无数次被问到这个问题，然而很难回答。我敢打赌登山者们被问到他们到底如何征服山峦的主峰时，也会有同样的感受。问题的答案是一步步来——你不过是把一只脚从另一只脚前迈过去，当然——务实一点来讲，整个过程总是能分解成多个、清晰的步骤。</p><p>　　你不能在一天内翻越乞力马扎罗山，所以你也不可能迅速的弄出一套优秀的SaaS系统出来。相反的，你该将缩小焦点而且明确目标，接下来搞清楚下一步该怎样做，然后快速奔向目标。</p><h5 id="“我的儿子在Battery-Adventures工作”"><a href="#“我的儿子在Battery-Adventures工作”" class="headerlink" title="“我的儿子在Battery Adventures工作”"></a><strong>“我的儿子在Battery Adventures工作”</strong></h5><p>　　我之所以开始思考在风险投资行业的工作和登山的相似性，要感谢一个意想不到的人：我的母亲。她和我的父亲在1960年代中期从当时还是英属的印度拉贾斯坦邦移居到皇后区（译注:纽约）。我的父母都是聪明，努力工作，务实的人，但他们都不理解他们的儿子在工作些什么。</p><p>　　我曾无数次的向我亲爱的、娇小的妈妈（她只有约1.5米高）描述我的工作，但她从没能清晰的记得我在做些什么。在最近的一次聚会上，她骄傲的告诉她的朋友：“我的儿子在Battery Adventures工作”。她的朋友笑了，因为他们对我不像我父亲一样是个医生，或者在大牌的银行——像高盛或是摩根斯坦利工作而倍感失望。</p><p>　　她的话引起我的思考。或许他把我的工作描述的比我认为的更好一些。或许思考如何建立一家公司最好的方式是去冒险，而非历险。而或许我在风投公司的角色就像一次冒险历程里的向导：是那些曾攀登过这座山很多次的那种人，事无巨细的了解攀登过程中的岩层与沟壑，能给足够勇敢的人提供指导来面对挑战。</p><p>　　我很荣幸曾在我15年风投任职生涯中，与许多世界级的创始人共事，其中包括许多B2B，SaaS企业软件公司，诸如Marketo、Omniture、Guidewire、Bazaarvoice以及Sprinklr（如需了解所有Battery 公司投资与撤出的详细清单，请点击这里）。</p><p>　　所以我从我个人的经历中分享一些故事和建议——姑且称之为“冒险”故事，作为向导来帮助那些里程碑上的企业者去到达他们的顶峰：估值十亿美元。</p><h3 id="SaaS企业成功走向市场的7个阶段"><a href="#SaaS企业成功走向市场的7个阶段" class="headerlink" title="SaaS企业成功走向市场的7个阶段"></a>SaaS企业成功走向市场的7个阶段</h3><p>　　我相信一个SaaS企业的走向市场会成功，会有7个关键阶段。大部分的阶段围绕这一个中心店，我称之为“三倍、三倍、两倍、两倍”（简称T2D3），反映一个公司的年度财报进展。</p><p>　　这并不是通往SaaS成功的唯一的步进之路，像Cornerstone、ExactTarget和SuccessFactors这样的公司他们所展示的一样，但是这是一条通往目标稳妥的路。每一个阶段需要不同的聚焦，比方说调整你的销售进程，发展你的团队和你的组织策略，以及国际上的扩张。</p><p>　　你会注意到我提到“市场进入策略”，因为SaaS公司发展中也有很多关键阶段。它们包含了选择合伙人、选择投资人、开发灵活的产品架构以及培养成功的企业文化，等等诸如此类。在这里，我们只着眼于“攀登”的技术。所以带上你的户外工具——我们要走向偏僻跑到，直奔顶峰了。</p><h4 id="阶段1：达成一个伟大的产品-市场体系。"><a href="#阶段1：达成一个伟大的产品-市场体系。" class="headerlink" title="阶段1：达成一个伟大的产品-市场体系。"></a>阶段1：达成一个伟大的产品-市场体系。</h4><p>　　这包含了找到并且按重要性排列好消费者的通电，接着把你的产品准确指向这些痛点。很多创业者问我怎样知道他们实现了产品-市场体系。遗憾的是，没有确切的方法来测试证明。<br>　　我经常问一些特定行业的潜在消费者或者用户来描述他们的痛点。当我听到样本的稳定性时，我知道到位了。一旦产品成型，很容易来测试它是否让消费者觉得有对其帮助。–</p><p>…</p><p>译制中，<a href="https://techcrunch.com/2015/02/01/the-saas-travel-adventure">原链接在此</a></p><p><img src="https://techcrunch.com/wp-content/uploads/2015/02/rockclimb.jpg?w=1390&crop=1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 创业 </tag>
            
            <tag> SaaS </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在苹果AppStore 上下架应用</title>
      <link href="/p/51950.html"/>
      <url>/p/51950.html</url>
      
        <content type="html"><![CDATA[<h3 id="序言："><a href="#序言：" class="headerlink" title="序言："></a>序言：</h3><h6 id="作为开发者，如何快捷的在苹果商店下架上架App，请看图吧"><a href="#作为开发者，如何快捷的在苹果商店下架上架App，请看图吧" class="headerlink" title="作为开发者，如何快捷的在苹果商店下架上架App，请看图吧"></a>作为开发者，如何快捷的在苹果商店下架上架App，请看图吧</h6><h3 id="如何下架"><a href="#如何下架" class="headerlink" title="如何下架"></a>如何下架</h3><h4 id="1-进入开发者中心-itunesConnect"><a href="#1-进入开发者中心-itunesConnect" class="headerlink" title="1. 进入开发者中心 itunesConnect"></a>1. 进入开发者中心 itunesConnect</h4><p><img src="/p/51950/1.png"></p> <span id="more"></span><h4 id="2-选择相应的App"><a href="#2-选择相应的App" class="headerlink" title="2. 选择相应的App"></a>2. 选择相应的App</h4><p><img src="/p/51950/2.png"></p><h4 id="3-如图，选择价格与销售范围——-下架"><a href="#3-如图，选择价格与销售范围——-下架" class="headerlink" title="3. 如图，选择价格与销售范围—— 下架"></a>3. 如图，选择价格与销售范围—— 下架</h4><p><img src="/p/51950/3.png"></p><h4 id="4-等等10分钟左右，再次搜索，此时AppStore-已经搜索不到该App了"><a href="#4-等等10分钟左右，再次搜索，此时AppStore-已经搜索不到该App了" class="headerlink" title="4. 等等10分钟左右，再次搜索，此时AppStore 已经搜索不到该App了"></a>4. 等等10分钟左右，再次搜索，此时AppStore 已经搜索不到该App了</h4><p><img src="/p/51950/4.png"></p><p>此时的状态是：</p><p><img src="/p/51950/5.png"></p><h3 id="重新上架"><a href="#重新上架" class="headerlink" title="重新上架"></a>重新上架</h3><h4 id="1-此时，也是选择-该应用的-价格与销售范围，选择【在所有地区供应】–-存储"><a href="#1-此时，也是选择-该应用的-价格与销售范围，选择【在所有地区供应】–-存储" class="headerlink" title="1. 此时，也是选择 该应用的 价格与销售范围，选择【在所有地区供应】– 存储"></a>1. 此时，也是选择 该应用的 价格与销售范围，选择【在所有地区供应】– 存储</h4><p><img src="/p/51950/6.png"></p><h4 id="2-此时是立即上架，AppStore也是需要5-10分钟可以搜索到"><a href="#2-此时是立即上架，AppStore也是需要5-10分钟可以搜索到" class="headerlink" title="2. 此时是立即上架，AppStore也是需要5-10分钟可以搜索到"></a>2. 此时是立即上架，AppStore也是需要5-10分钟可以搜索到</h4><p><img src="/p/51950/7.png"></p><h6 id="就是这么简单，希望可以帮到你。"><a href="#就是这么简单，希望可以帮到你。" class="headerlink" title="就是这么简单，希望可以帮到你。"></a>就是这么简单，希望可以帮到你。</h6>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> appstore </tag>
            
            <tag> 上架 </tag>
            
            <tag> 下架 </tag>
            
            <tag> 苹果商店 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解SDWebImage(读sdwebimage源码分析)</title>
      <link href="/p/14198.html"/>
      <url>/p/14198.html</url>
      
        <content type="html"><![CDATA[<p>最近在看一些第三方库的源码，其中SDWebImage 尤其让人惊叹，尝试用XMind 画出原理，以后有机会， 会增加更多的细节图。</p><h4 id="大纲如下："><a href="#大纲如下：" class="headerlink" title="大纲如下："></a>大纲如下：</h4><p><img src="/p/14198/sd1.png"></p><span id="more"></span><h4 id="图片缓存的实现如下："><a href="#图片缓存的实现如下：" class="headerlink" title="图片缓存的实现如下："></a>图片缓存的实现如下：</h4><p><img src="/p/14198/sd2.png"></p><h4 id="以下为异步下载部分："><a href="#以下为异步下载部分：" class="headerlink" title="以下为异步下载部分："></a><strong>以下为异步下载部分：</strong></h4><p><img src="/p/14198/sd3.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> 开发 </tag>
            
            <tag> SDWebImage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Universal Link在微信页面中唤起原生App</title>
      <link href="/p/7421.html"/>
      <url>/p/7421.html</url>
      
        <content type="html"><![CDATA[<p>因微信封杀，已失效，微信大刀威武！</p><p>在某些电商项目，或者是社交媒体的分享页面中，我们经常会看到在页面的顶端或者底部遇到有【打开App】或者【下载App】这样的按钮。比较友好的产品经理，会做设备识别，以及检测APP是否安装，来做打开或者下载App 的需求。<br>这些功能在Safari下使用location.href&#x3D;”scheme:&#x2F;&#x2F;example” 即可实现。<br>但是在微信中，这方面做的比较恶心，微信下面几乎是全面屏蔽了唤起原生App 的功能，所有的启动都需要通过应用宝。</p><p>在iOS 9以后，苹果推出了Universal Link 这个概念，解决了使用A标签，以及iFrame 的弊端。WWDC2015 Session 509 有介绍,通过Universal Link，将App 与网页端建立连接桥，可以从Safari 或者其他前端浏览器来识别并唤醒App，甚至是微信环境下也可以冲破障碍。</p><span id="more"></span><p>参考了苹果的原生介绍，做出了微信下唤醒自己的 App 效果如下：</p><p><img src="/p/7421/0.gif"></p><h3 id="实操如下"><a href="#实操如下" class="headerlink" title="实操如下"></a>实操如下</h3><h5 id="服务器配置："><a href="#服务器配置：" class="headerlink" title="服务器配置："></a>服务器配置：</h5><p>准备独立域名。</p><p>一级域名，二级域名均可。</p><h5 id="SSL-证书"><a href="#SSL-证书" class="headerlink" title="SSL 证书"></a>SSL 证书</h5><p>这里需要为服务器配置HTTPS 用的SSL 证书。</p><h5 id="上传签名好的JSON-配置文件"><a href="#上传签名好的JSON-配置文件" class="headerlink" title="上传签名好的JSON 配置文件"></a>上传签名好的JSON 配置文件</h5><p>新建一个JSON文件，不需要后缀名，内容输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;applinks&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;apps&quot;</span>: [],</span><br><span class="line"><span class="string">&quot;details&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;appID&quot;</span>: <span class="string">&quot;5B5Q4xxxx.com.xxxx.xxxx&quot;</span>,</span><br><span class="line"><span class="string">&quot;paths&quot;</span>: [ <span class="string">&quot;/html/1/*&quot;</span>, <span class="string">&quot;/*&quot;</span>]</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 appID 相关内容可以在Developer 中心找到相关的内容。如图，前半部分为Prefix 后半部分为ID，即你的App 的bundle id，两者通过.相连。</p><p><img src="/p/7421/1.png"></p><p>注意：这里的AppID中前半部分，在App 转让主体后会改变，需重新更新。</p><p>paths 则是用来唤醒App 所需要指定的JSON文件在服务器中的路径。用”&#x2F;* “ 是根目录，而&#x2F;html 则是指html目录下的。</p><p>填好后保存为apple-app-site-association 名，上传到域名指向的服务器根目录。</p><p>App配置：</p><p>在工程文件中，找到Targets - Capabilities - Associated Domains 将开关选为On，并添加你的域名，格式为applinks:你的域名.com</p><p><img src="/p/7421/2.png"></p><p>iOS 移动端的代码配置</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">BOOL</span>)application:(<span class="type">UIApplication</span> <span class="operator">*</span>)application continueUserActivity:(<span class="type">NSUserActivity</span> <span class="operator">*</span>)userActivity restorationHandler:(void (<span class="operator">^</span>)(<span class="type">NSArray</span> <span class="operator">*</span> _Nullable))restorationHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ([userActivity.activityType isEqualToString:<span class="type">NSUserActivityTypeBrowsingWeb</span>]) &#123;</span><br><span class="line"><span class="type">NSString</span> <span class="operator">*</span>url <span class="operator">=</span> userActivity.webpageURL.description;</span><br><span class="line"><span class="comment">// 这里可以通过拆分url 来传入参数，达到跳转原生页面的功能，如跳转某商品页</span></span><br><span class="line">[<span class="type">UIApplication</span> sharedApplication] openURL:webpageURL];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>h5网页配置：</p><p>h5网页中对需要唤起App 的按钮或者控件添加点击事件，事件的函数代码如下:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">function wakeUpApp()&#123;</span><br><span class="line"><span class="keyword">if</span> (navigator.userAgent.match(<span class="regexp">/(iPhone|iPod|iPad);?/</span>i)) &#123;</span><br><span class="line"><span class="keyword">var</span> loadDateTime <span class="operator">=</span> new <span class="type">Date</span>();</span><br><span class="line">window.setTimeout(function() &#123;</span><br><span class="line"><span class="keyword">var</span> timeOutDateTime <span class="operator">=</span> new <span class="type">Date</span>();</span><br><span class="line"><span class="keyword">if</span> (timeOutDateTime <span class="operator">-</span> loadDateTime <span class="operator">&lt;</span> <span class="number">5000</span>) &#123;</span><br><span class="line">window.location.href <span class="operator">=</span> <span class="string">&quot;http://a.app.qq.com/o/simple.jsp?pkgname=你的应用宝BundleID&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">window.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="number">25</span>);</span><br><span class="line">window.location.href <span class="operator">=</span> <span class="string">&quot;https://yourdomainname.com/&quot;</span>;          </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (navigator.userAgent.match(<span class="regexp">/android/</span>i)) &#123;</span><br><span class="line"><span class="keyword">var</span> state <span class="operator">=</span> null;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">state <span class="operator">=</span> window.open(<span class="string">&quot;apps custom url schemes &quot;</span>, &#x27;_blank&#x27;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (state) &#123;</span><br><span class="line">window.close();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">window.location.href <span class="operator">=</span> <span class="string">&quot;要跳转的页面URL&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：代码中 yourdomainname.com 还可以后面添加 &#x2F;goodid&#x2F;123456 之类的属性id后缀，用来传递事件类型和id，方便移动端做更丰富的功能需求，比如通过goodid 识别要做的下一步动作是打开商品id 为123456 的商品详情页，等等。</p><p>配置完成，查看是否能唤起App，也可以通过如下图中，输入域名，长按来唤起App 做验证。</p><p><img src="/p/7421/3.png"></p><p>至此，大功告成。</p><p>值得注意的是，只能在iOS 9环境及以上实现该功能。iOS 8或者以下，只能采取老式的跳转至应用宝来实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 原生 </tag>
            
            <tag> 微信 </tag>
            
            <tag> universallink </tag>
            
            <tag> hyper </tag>
            
            <tag> 混合交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下棋</title>
      <link href="/p/31557.html"/>
      <url>/p/31557.html</url>
      
        <content type="html"><![CDATA[<p>在公园和大爷下象棋，有点紧张。<br>走了第一步后，大爷沉默了很久说：<br>“你是新手吧？”<br>“大爷你怎么知道？”<br>“我在这玩了几年，第一步走帅的真不多。”<br>“不应该让领导先走吗？”</p><p> <img src="http://puui.qpic.cn/qqvideo_ori/0/l0626p7lcr5_496_280/0"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 休闲 </tag>
            
            <tag> 人生哲理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
