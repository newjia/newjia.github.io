{"meta":{"title":"李佳的技术博客","subtitle":"「疾如風，徐如林，侵掠如火，不動如山」","description":null,"author":"李佳","url":"http://nilsli.com","root":"/"},"pages":[{"title":"[404]","date":"2024-08-07T07:10:46.384Z","updated":"2024-08-07T07:10:46.384Z","comments":true,"path":"404.html","permalink":"http://nilsli.com/404.html","excerpt":"","text":""},{"title":"这是我自己","date":"2018-09-18T09:54:59.000Z","updated":"2024-08-07T07:10:46.763Z","comments":true,"path":"about/index.html","permalink":"http://nilsli.com/about/index.html","excerpt":"","text":"关于我毕业于对外经贸大学，对移动端有了较深了解，略懂前端、RN 技术。 在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流 邮件(myhonestjj#gmail.com, 把#换成@) 我的Github About MeGraduated from UIBE(University of International Business and Economics), know pretty much about Mobile Delevepment, familiar with Front End and React Native. Please feel free to contact me if you have any question when view this website, you can communicate with me in ways below: Gmail: myhonestjj#gmail.com(repalace # with @) Github: newjia’s Github"},{"title":"contact","date":"2020-03-21T03:50:48.000Z","updated":"2024-08-07T07:10:46.764Z","comments":true,"path":"contact/index.html","permalink":"http://nilsli.com/contact/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-02-25T04:07:54.000Z","updated":"2024-08-07T07:10:46.763Z","comments":true,"path":"categories/index.html","permalink":"http://nilsli.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-03-21T03:51:27.000Z","updated":"2024-08-07T07:10:46.764Z","comments":true,"path":"friends/index.html","permalink":"http://nilsli.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-25T04:07:21.000Z","updated":"2024-08-07T07:10:46.793Z","comments":true,"path":"tags/index.html","permalink":"http://nilsli.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-08-07T07:10:46.792Z","updated":"2024-08-07T07:10:46.792Z","comments":true,"path":"images/2019/08/添加别名登录：.html","permalink":"http://nilsli.com/images/2019/08/%E6%B7%BB%E5%8A%A0%E5%88%AB%E5%90%8D%E7%99%BB%E5%BD%95%EF%BC%9A.html","excerpt":"","text":"添加别名登录：参考连接 1、首先创建本机的公钥和私钥，使用命令ssh-keygen。2、使用ssh-copy-id &lt;主机地址&gt; 来将公钥添加到目的主机。 ssh-copy-id 188.188.188.188 3、【在本地电脑】使用 vim ~&#x2F;.ssh&#x2F;config命令编辑文件，添加如下内容： 192.168.200.12HostName abc.com/188.188.188.188Port 22User rootIdentityFile ~/.ssh/id_rsa.pubIdentitiesOnly yes"}],"posts":[{"title":"【休闲】轻松惬意的假日","slug":"20221004we-have-a-wonderful-holiday","date":"2022-10-04T04:50:16.000Z","updated":"2024-08-07T07:10:46.578Z","comments":true,"path":"p/1ca18c4f.html","permalink":"http://nilsli.com/p/1ca18c4f.html","excerpt":"","text":"","categories":[],"tags":[{"name":"休闲","slug":"休闲","permalink":"http://nilsli.com/tags/%E4%BC%91%E9%97%B2/"}]},{"title":"在校园里小憩","slug":"20220715restincampus","date":"2022-07-15T02:50:31.000Z","updated":"2024-08-07T07:10:46.572Z","comments":true,"path":"p/1e30e629.html","permalink":"http://nilsli.com/p/1e30e629.html","excerpt":"","text":"","categories":[],"tags":[{"name":"休闲","slug":"休闲","permalink":"http://nilsli.com/tags/%E4%BC%91%E9%97%B2/"}]},{"title":"【数据结构与算法】-（11）霍夫曼编码（HuffmanCoding）","slug":"0427-Huffman-Coding","date":"2021-01-17T11:24:12.000Z","updated":"2024-08-14T02:52:32.995Z","comments":true,"path":"p/14e7f5a9.html","permalink":"http://nilsli.com/p/14e7f5a9.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 【数据结构与算法】-（8）栈之算法题 【数据结构与算法】-（8.1）字符串去重算法 【数据结构与算法】-（8.2）字符串搜索算法和RK&amp;BP算法 【数据结构与算法】-（8.3）KMP算法 【数据结构与算法】-（9）二叉树与顺序表实现 【数据结构与算法】-（10）线索化二叉树 文章字数: 约4.5k阅读时长: 25 分钟 一、概念1.1 霍夫曼编码的定义霍夫曼编码（Huffman Coding）是一种被广泛使用的数据压缩编码算法，由美国计算机科学家大卫·霍夫曼（David A. Huffman）在1952年发明。这种编码方式是一种变长编码方法，其核心思想是：对出现频率高的字符使用较短的编码，对出现频率低的字符使用较长的编码，以此来达到压缩数据的目的。 1.2 霍夫曼编码的特点 变长编码：不同字符的编码长度可以不同 前缀编码：任一字符的编码都不是其他字符编码的前缀 最优性：在变长编码中，霍夫曼编码是最优的 1.3 霍夫曼树霍夫曼编码的关键在于构建霍夬曼树。霍夫曼树是一种特殊的二叉树，具有以下特点： 树中每个叶节点代表一个字符及其出现频率 树中每个非叶节点的权值等于其左右子树权值之和 树的带权路径长度最小 二、霍夫曼树的存储结构2.1 节点结构霍夫曼树的节点结构通常包含以下信息： typedef struct &#123; unsigned int weight; // 权值（频率） unsigned int parent, lchild, rchild; // 父节点、左子节点、右子节点&#125; HTNode, *HuffmanTree; 2.2 霍夫曼编码表为了方便编码和解码，我们还需要一个霍夫曼编码表： typedef char** HuffmanCode; 三、霍夫曼编码的实现3.1 构建霍夫曼树构建霍夫曼树的过程是一个自底向上的过程，主要步骤如下： 将所有叶子节点（即待编码的字符）按照权值（频率）从小到大排序 取出权值最小的两个节点，生成一个新节点作为它们的父节点，新节点的权值为两个子节点权值之和 从序列中删除这两个节点，将新节点加入序列 重复步骤2和3，直到只剩一个节点，这个节点就是霍夫曼树的根节点 void CreateHuffmanTree(HuffmanTree *HT, int n, int *w) &#123; if (n &lt;= 1) return; int m = 2 * n - 1; // 霍夫曼树总节点数 *HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode)); // 0号单元未用 HuffmanTree p = *HT; // 初始化叶子节点 for (int i = 1; i &lt;= n; ++i) &#123; p[i].weight = w[i - 1]; p[i].parent = 0; p[i].lchild = 0; p[i].rchild = 0; &#125; // 初始化非叶子节点 for (int i = n + 1; i &lt;= m; ++i) &#123; p[i].weight = 0; p[i].parent = 0; p[i].lchild = 0; p[i].rchild = 0; &#125; // 构建霍夫曼树 for (int i = n + 1; i &lt;= m; ++i) &#123; int s1, s2; Select(*HT, i - 1, &amp;s1, &amp;s2); // 选择两个权值最小的节点 p[s1].parent = i; p[s2].parent = i; p[i].lchild = s1; p[i].rchild = s2; p[i].weight = p[s1].weight + p[s2].weight; &#125;&#125; 其中，Select 函数用于选择权值最小的两个节点： void Select(HuffmanTree HT, int n, int *s1, int *s2) &#123; int min1 = UINT_MAX, min2 = UINT_MAX; *s1 = *s2 = 0; for (int i = 1; i &lt;= n; i++) &#123; if (HT[i].parent == 0) &#123; if (HT[i].weight &lt; min1) &#123; min2 = min1; *s2 = *s1; min1 = HT[i].weight; *s1 = i; &#125; else if (HT[i].weight &lt; min2) &#123; min2 = HT[i].weight; *s2 = i; &#125; &#125; &#125;&#125; 3.2 生成霍夫曼编码生成霍夫曼编码的过程是从叶子节点出发，向根节点回溯，记录路径的过程。通常约定向左子树走记为0，向右子树走记为1。 void HuffmanCoding(HuffmanTree HT, int n, HuffmanCode *HC) &#123; *HC = (HuffmanCode)malloc((n + 1) * sizeof(char*)); char *cd = (char*)malloc(n * sizeof(char)); // 临时存放编码 cd[n - 1] = &#x27;\\0&#x27;; for (int i = 1; i &lt;= n; ++i) &#123; int start = n - 1; // 编码结束符位置 int c = i; int f = HT[i].parent; while (f != 0) &#123; --start; if (HT[f].lchild == c) cd[start] = &#x27;0&#x27;; else cd[start] = &#x27;1&#x27;; c = f; f = HT[f].parent; &#125; (*HC)[i] = (char*)malloc((n - start) * sizeof(char)); strcpy((*HC)[i], &amp;cd[start]); &#125; free(cd);&#125; 四、霍夫曼编码的应用4.1 数据压缩霍夫曼编码最常见的应用是数据压缩。通过对高频字符使用短编码，低频字符使用长编码，可以显著减少数据的存储空间。 void Compress(const char* input, const char* output, HuffmanCode HC) &#123; FILE *in = fopen(input, &quot;r&quot;); FILE *out = fopen(output, &quot;wb&quot;); int ch; unsigned char buf = 0; int buf_len = 0; while ((ch = fgetc(in)) != EOF) &#123; char *code = HC[ch]; for (int i = 0; code[i]; ++i) &#123; buf = (buf &lt;&lt; 1) | (code[i] - &#x27;0&#x27;); if (++buf_len == 8) &#123; fputc(buf, out); buf = 0; buf_len = 0; &#125; &#125; &#125; if (buf_len) &#123; buf &lt;&lt;= (8 - buf_len); fputc(buf, out); &#125; fclose(in); fclose(out);&#125; 4.2 数据解压解压过程是编码的逆过程，需要利用霍夫曼树从根节点开始，根据读取的位进行左右子树的选择，直到到达叶子节点。 void Decompress(const char* input, const char* output, HuffmanTree HT, int root) &#123; FILE *in = fopen(input, &quot;rb&quot;); FILE *out = fopen(output, &quot;w&quot;); int p = root; unsigned char ch; while (fread(&amp;ch, sizeof(char), 1, in) &gt; 0) &#123; for (int i = 0; i &lt; 8; ++i) &#123; if (ch &amp; (1 &lt;&lt; (7 - i))) p = HT[p].rchild; else p = HT[p].lchild; if (HT[p].lchild == 0 &amp;&amp; HT[p].rchild == 0) &#123; fputc(p, out); p = root; &#125; &#125; &#125; fclose(in); fclose(out);&#125; 五、霍夫曼编码的优缺点5.1 优点 压缩效率高：对于出现频率差异大的数据，压缩效果显著 无损压缩：解压后可以完全还原原始数据 编解码速度快：使用查表法可以快速进行编解码 5.2 缺点 需要预先知道字符频率：这可能需要对数据进行两次扫描 不适合均匀分布的数据：如果所有字符出现频率相近，压缩效果不明显 编码表可能很大：如果字符种类很多，编码表本身可能占用较大空间 六、总结霍夫曼编码是一种经典的数据压缩算法，它通过构建霍夫曼树来为字符赋予变长编码，从而达到数据压缩的目的。这种算法在数据压缩、信息论等领域有着广泛的应用。 理解和掌握霍夫曼编码不仅能帮助我们更好地理解数据压缩的原理，还能让我们对树结构、贪心算法等重要的数据结构和算法概念有更深入的认识。在实际应用中，霍夫曼编码常常与其他压缩技术结合使用，以获得更好的压缩效果。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://nilsli.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"http://nilsli.com/tags/%E6%A0%91/"},{"name":"二叉树","slug":"二叉树","permalink":"http://nilsli.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"霍夫曼树","slug":"霍夫曼树","permalink":"http://nilsli.com/tags/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91/"},{"name":"数据压缩","slug":"数据压缩","permalink":"http://nilsli.com/tags/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"}]},{"title":"【数据结构与算法】-（10）线索化二叉树","slug":"0427lineDoubleTree","date":"2021-01-17T05:00:48.000Z","updated":"2024-08-14T02:43:16.428Z","comments":true,"path":"p/440a10cd.html","permalink":"http://nilsli.com/p/440a10cd.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 【数据结构与算法】-（8）栈之算法题 【数据结构与算法】-（8.1）字符串去重算法 【数据结构与算法】-（8.2）字符串搜索算法和RK&amp;BP算法 【数据结构与算法】-（8.3）KMP算法 【数据结构与算法】-（9）二叉树与顺序表实现 文章字数: 约4k阅读时长: 20 分钟 一、概念1.1 线索化二叉树的定义线索化二叉树(Threaded Binary Tree)是一种特殊的二叉树结构。在普通二叉树中,叶子节点的左右指针往往指向NULL,造成了存储空间的浪费。线索化二叉树的主要思想是利用这些空闲指针,存储该节点在某种遍历序列中的前驱和后继节点的信息,从而加快树的遍历速度。 1.2 线索化二叉树的特点 充分利用空指针域,节省存储空间 可以直接找到任一节点的前驱和后继,而不需要重新遍历 遍历算法变得简单,不再需要使用栈 1.3 线索化二叉树的分类根据线索化的方式,可以将线索二叉树分为: 前序线索化二叉树 中序线索化二叉树 后序线索化二叉树 本文将主要讨论中序线索化二叉树。 二、线索化二叉树的存储结构2.1 节点结构线索化二叉树的节点结构需要在普通二叉树节点的基础上增加两个标志位: typedef struct ThreadNode &#123; ElemType data; // 数据域 struct ThreadNode *lchild, *rchild; // 左右孩子指针 int ltag, rtag; // 左右线索标志&#125; ThreadNode, *ThreadTree; 其中: ltag为0时指向该节点的左孩子,为1时指向该节点的前驱 rtag为0时指向该节点的右孩子,为1时指向该节点的后继 三、线索化二叉树的实现3.1 中序线索化中序线索化的过程实际上就是对二叉树进行中序遍历的过程。在遍历的同时,将空指针改为指向前驱或后继节点。 ThreadNode *pre = NULL; // 全局变量,始终指向刚刚访问过的节点void InThread(ThreadTree p) &#123; if(p) &#123; InThread(p-&gt;lchild); // 递归线索化左子树 if(!p-&gt;lchild) &#123; // 左子树为空,建立前驱线索 p-&gt;ltag = 1; p-&gt;lchild = pre; &#125; if(pre &amp;&amp; !pre-&gt;rchild) &#123; // 建立前驱节点的后继线索 pre-&gt;rtag = 1; pre-&gt;rchild = p; &#125; pre = p; // 保持pre指向p的前驱 InThread(p-&gt;rchild); // 递归线索化右子树 &#125;&#125;void CreateInThread(ThreadTree T) &#123; pre = NULL; if(T) &#123; InThread(T); // 处理最后一个节点 if(pre-&gt;rchild == NULL) &#123; pre-&gt;rtag = 1; &#125; &#125;&#125; 3.2 中序线索二叉树的遍历利用线索化的特性,我们可以实现非递归的中序遍历: void InOrderTraverse_Thr(ThreadTree T) &#123; ThreadNode *p = T; while(p) &#123; // 找到中序遍历的起始节点 while(p-&gt;ltag == 0) p = p-&gt;lchild; printf(&quot;%d &quot;, p-&gt;data); // 访问该节点 // 如果右指针是线索,直接访问后继 while(p-&gt;rtag == 1 &amp;&amp; p-&gt;rchild) &#123; p = p-&gt;rchild; printf(&quot;%d &quot;, p-&gt;data); &#125; // 否则转向右子树 p = p-&gt;rchild; &#125;&#125; 3.3 查找节点的前驱和后继在线索二叉树中,查找某个节点的前驱和后继变得非常简单: // 查找中序后继ThreadNode* InOrderNext(ThreadNode *p) &#123; if(p-&gt;rtag == 1) return p-&gt;rchild; // 右指针为线索 p = p-&gt;rchild; // 转向右子树 while(p-&gt;ltag == 0) p = p-&gt;lchild; // 找到右子树的最左节点 return p;&#125;// 查找中序前驱ThreadNode* InOrderPrev(ThreadNode *p) &#123; if(p-&gt;ltag == 1) return p-&gt;lchild; // 左指针为线索 p = p-&gt;lchild; // 转向左子树 while(p-&gt;rtag == 0) p = p-&gt;rchild; // 找到左子树的最右节点 return p;&#125; 四、线索化二叉树的应用 快速遍历: 线索化后的二叉树可以在O(n)时间内完成遍历,而不需要使用栈或者递归。 寻找前驱后继: 在某些应用中,需要频繁地查找某个节点的前驱或后继,线索化二叉树可以在O(1)时间内完成这个操作。 空间优化: 对于叶子节点很多的二叉树,线索化可以充分利用空指针域,节省存储空间。 五、总结线索化二叉树通过改造普通二叉树的结构,在节省空间的同时,提高了某些操作的效率。但是,线索化的过程会增加树的构建时间,且会使得树的结构变得复杂。因此,在实际应用中,需要根据具体需求来权衡是否使用线索化二叉树。 线索化二叉树是二叉树结构的一个重要变种,深入理解它的原理和实现,对于掌握树结构和提高算法设计能力都有很大帮助。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://nilsli.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"http://nilsli.com/tags/%E6%A0%91/"},{"name":"二叉树","slug":"二叉树","permalink":"http://nilsli.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"线索化二叉树","slug":"线索化二叉树","permalink":"http://nilsli.com/tags/%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【一起学Metal】01-Metal初体验","slug":"0821metal01","date":"2020-08-21T01:52:07.000Z","updated":"2024-08-07T07:10:46.563Z","comments":true,"path":"p/82a3d28c.html","permalink":"http://nilsli.com/p/82a3d28c.html","excerpt":"","text":"一、Metal 简介2.1 概念Metal 是一个兼顾图形与计算功能的，面向底层、低开销的硬件加速应用程序接口（API），其类似于将 OpenGL 与 OpenCL 的功能集成到了同一个API上，最初支持它的系统是 iOS 8。Metal 使得 iOS 可以实现其他平台的类似功能，例如 Khronos Group 的跨平台 Vulkan 与 Microsoft Windows 上的 Direct3D 12。 2.2 历史2014年6月2日，Metal 开始支持iOS设备（仅支持Apple A7或更新款处理器的iPhone、iPad）；2015年6月8日，Metal 开始支持运行 OS X El Capitan 的Mac设备（仅2012年中或更新款机种）。 2017年6月5日，Apple于WWDC宣布了Metal的第二个版本，支持macOS High Sierra、iOS 11和tvOS 11。由于受相同硬件支持，Metal 2并不是Metal的独立API。 Metal 2在Xcode中实现了更高效的分析和调试，加速了机器学习、降低了CPU工作负载、支持macOS上的虚拟现实以及Apple A11处理器的特性。 在2020年WWDC 上，苹果宣布了Mac 移至 Apple Silicon计划。使用Apple 芯片的Mac电脑将突出Apple GPU的特征，这些曾在macOS 和iOS 上的体现过，也将能受益于Apple GPU的 贴图延迟渲染（TBDR）架构的特征。 2.3 支持的CPU在iOS，tvOS，macOS中，Metal 支持苹果设计的A7以后的单片系统。 在macOS 中，metal也支持从HD4000 以后的 Intel 高清集成显示系统，也支持AMD GCM和 RDNA的GPU系列。 NVIDIA CPU 也受支持，但支持新设备（10系列起的新设备）的Metal 驱动程序从macOS 起已失效。 By Super Evil Megacorp, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=37251144 二、Metal 案例1：渐变背景2.1 效果一览 2.2 实现思路 2.3 代码分析三、Metal 案例2：绘制一个三角形四、比较Metal 与OpenGL五、小结","categories":[],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://nilsli.com/tags/opengl/"},{"name":"metal","slug":"metal","permalink":"http://nilsli.com/tags/metal/"},{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"}]},{"title":"计算机视觉【03-OpenGL正背面剔除】","slug":"0724renderbase","date":"2020-07-23T18:59:05.000Z","updated":"2024-08-07T07:10:46.550Z","comments":true,"path":"p/bb33e4b9.html","permalink":"http://nilsli.com/p/bb33e4b9.html","excerpt":"","text":"一、概念1.1隐藏面消除绘制3D场景式，尤其是在透视投影时，需要决定目标的哪一部分展示，哪一部分隐藏。如下图所示，如果不做隐藏面消除的配置，在3D目标旋转时，会出现透视bug，有些不该出现的出现了。 1.2深度测试二、实现深度测试2.1 创建3D目标2.2 开启正背面剔除2.2 开启深度测试在渲染方法里添加深度测试，开启深度测试的代码如下： glEnable(GL_CULL_FACE);glFrontFace(GL_CCW);glCullFace(GL_BACK); 开启后的效果：","categories":[],"tags":[{"name":"OpenGl","slug":"OpenGl","permalink":"http://nilsli.com/tags/OpenGl/"}]},{"title":"计算机视觉【02-OpenGL创建正方形】","slug":"0715square","date":"2020-07-14T17:03:01.000Z","updated":"2024-08-07T07:10:46.532Z","comments":true,"path":"p/d35ab8c1.html","permalink":"http://nilsli.com/p/d35ab8c1.html","excerpt":"","text":"一、目标结果 二、分析过程分析流程简图如下 三、全部代码如下：下面从main.cpp 的流水线讲解整个实现过程 3.1 准备工作3.1.1 设置当前工作目录gltSetWorkingDirectory(argv[0]); 其中argv 源自int main(int argc,char *argv[])&#123;&#125; 函数的参数 3.1.2 初始化GLUT的库glutInit(&amp;argc, argv); 3.1.3 初始化双缓冲区初始化双缓冲窗口，其中标志GLUT_DOUBLE、GLUT_RGBA、GLUT_DEPTH、GLUT_STENCIL分别指双缓冲窗口、RGBA颜色模式、深度测试、模板缓冲区 glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL); 3.1.4 配置GLUT 窗口glutInitWindowSize(300, 300); // 初始化窗口glutCreateWindow(&quot;Triangle&quot;); // 配置创建窗口名 3.2 GLUT 内部循环3.2.1 注册重塑函数glutReshapeFunc(changeSize); ChangeSize函数，主要作用是窗口大小改变是，接收新的宽度和高度，实现如下： void changeSize(int w,int h)&#123; /* x,y 参数代表窗口中视图的左下角坐标，而宽度、高度是像素为表示，通常x,y 都是为0 */ glViewport(0, 0, w, h); &#125; 3.2.2 注册显示函数（渲染）glutDisplayFunc(RenderScene); 有以下步骤 清理一个或一组特定的缓冲区 GL_COLOR_BUFFER_BIT :指示当前激活的用来进行颜色写入缓冲区 GL_DEPTH_BUFFER_BIT :指示深度缓存区 GL_STENCIL_BUFFER_BIT:指示模板缓冲区 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT); 设置一组浮点数来表示红色 GLfloat vRed[] = &#123;1.0,0.0,0.0,1.0f&#125;; 传递到存储着色器 shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed); 提交着色器 triangleBatch.Draw(); 交换缓冲区：这里主要是讲后台缓冲区进行渲染，结束后把图像结果交给前台 glutSwapBuffers(); 3.2.3 注册特殊函数（键位移动）glutSpecialFunc(SpecialKeys); 其实这里的键位比较简单，主要步骤如下： 设置按键每次移动的步长 GLfloat stepSize = 0.25f; 配置移动起始X, Y坐标， GLfloat blockX = vVerts[0];GLfloat blockY = vVerts[10]; 移动后X，Y坐标，这里主要判断key if (key == GLUT_KEY_UP) &#123; blockY += stepSize;&#125;if (key == GLUT_KEY_DOWN) &#123; blockY -= stepSize;&#125;if (key == GLUT_KEY_LEFT) &#123; blockX -= stepSize;&#125;if (key == GLUT_KEY_RIGHT) &#123; blockX += stepSize;&#125; 边界碰撞的配置（碰撞后返回） 碰到最左边 if (blockX &lt; -1.0f) &#123; blockX = -1.0f; &#125; 碰到最右边 //1.0 - blockSize * 2 = 总边长 - 正方形的边长 = 最左边点的位置if (blockX &gt; (1.0 - blockSize * 2)) &#123; blockX = 1.0f - blockSize * 2;&#125; 碰到最下边 //-1.0 - blockSize * 2 = Y（负轴边界） - 正方形边长 = 最下面点的位置if (blockY &lt; -1.0f + blockSize * 2 ) &#123; blockY = -1.0f + blockSize * 2;&#125; 碰到最顶边 if (blockY &gt; 1.0f) &#123; blockY = 1.0f;&#125; 重新计算所有顶点 vVerts[0] = blockX;vVerts[1] = blockY - blockSize*2;printf(&quot;(%f,%f)\\n&quot;,vVerts[0],vVerts[1]);vVerts[3] = blockX + blockSize*2;vVerts[4] = blockY - blockSize*2;printf(&quot;(%f,%f)\\n&quot;,vVerts[3],vVerts[4]);vVerts[6] = blockX + blockSize*2;vVerts[7] = blockY;printf(&quot;(%f,%f)\\n&quot;,vVerts[6],vVerts[7]);vVerts[9] = blockX;vVerts[10] = blockY;printf(&quot;(%f,%f)\\n&quot;,vVerts[9],vVerts[10]); 添加顶点到缓冲区 triangleBatch.CopyVertexData3f(vVerts); 通知重新渲染 glutPostRedisplay(); 3.3 GLUEW 库安全初始化一个GLEW库,确保OpenGL API对程序完全可用 GLenum status = glewInit();if (GLEW_OK != status) &#123; printf(&quot;GLEW Error:%s\\n&quot;,glewGetErrorString(status)); return 1; &#125; 3.4 配置渲染环境setupRC(); 3.4.1 设置清屏颜色其实也是设置当前窗口的背景色 glClearColor(0.98f, 0.80f, 0.7f, 1); 3.4.2 初始化固定着色器shaderManager.InitializeStockShaders(); 3.4.3 顶点连接类型配置和提交缓冲区triangleBatch.Begin(GL_TRIANGLE_FAN, 4);triangleBatch.CopyVertexData3f(vVerts);triangleBatch.End(); 3.5 添加到任务的 loopglutMainLoop(); 3.6 总流程main 的步骤 gltSetWorkingDirectory(argv[0]); glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL); glutInitWindowSize(300, 300); glutCreateWindow(&quot;Triangle&quot;); //注册重塑函数 glutReshapeFunc(changeSize); //注册显示函数 glutDisplayFunc(RenderScene); //注册特殊函数glutSpecialFunc(SpecialKeys); GLenum status = glewInit(); if (GLEW_OK != status) &#123; printf(&quot;GLEW Error:%s\\n&quot;,glewGetErrorString(status)); return 1; &#125; setupRC(); glutMainLoop(); 四、小结这篇文章，简单的介绍了，在特定色彩下，绘制一个正方形，并且通过按键移动它，可以见到，OpenGL 语句还是相当的见解。","categories":[],"tags":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://nilsli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://nilsli.com/tags/OpenGL/"}]},{"title":"计算机视觉【01-搭建OpenGL开发环境】","slug":"0714createopengl","date":"2020-07-14T15:35:20.000Z","updated":"2024-08-07T07:10:46.500Z","comments":true,"path":"p/7b6be80a.html","permalink":"http://nilsli.com/p/7b6be80a.html","excerpt":"","text":"一、搭建环境1.1 环境准备： 开发环境：Mac OS、Xcode 11+ OpenGL 工具包（会在本文末尾提供） include 文件夹 libGLTools.a 静态文件 1.2创建项目注意，我们使用Mac 应用来熟悉OpenGL 1.3 添加库这里需要添加的是GLUT和OpenGL,这些都是苹果内置的。步骤：在Build Phrases - Link Binary With Libraries 里，点击加号后，搜索GLUT 和OpenGL添加，如下图： 1.4 引入第三方库 将文件包内的include 文件夹里拖入拷贝至工程内 把静态库 libGTools.a 拖入Framework 文件夹下 结果的文件夹结构如下： 1.5 单独引用 GLTools.h 和glew.h：具体操作：在Build Phrases —— Complie Sources 添加GLTools.h 和glew.h文件。 结果如下： 1.6 删掉多余代码：需要删除的有：* AppDelegate.h* AppDelegate.m* ViewController.h* ViewController.m* Main.stroyboard* main.m 目录如图所示： 1.7 添加启动文件 main.cpp 创建c++ 文件： 添加 main 文件，注意关掉创建头文件的对勾 创建基础代码，如下： int main(int argc, char * argv[])&#123; return 0;&#125; 至此，本Demo 已经可以独立运行了 二、扩展：绘制三角形2.1 业务代码上面的环境搭建好了，何不来个小小的Demo 来验证一下，输入业务代码如下： #include &quot;GLTools.h&quot;#include &lt;GLUT/GLUT.h&gt;GLBatch triangleBatch;GLShaderManager shaderManager;void ChangeSize(int w, int h)&#123; glViewport(0, 0, w, h);&#125;void SetupRC()&#123; glClearColor(0.0f, 0.0f, 1.0f, 1.0f); shaderManager.InitializeStockShaders(); GLfloat vVerts[] = &#123; -0.5f, 0.0f, 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 0.5f, 0.0f, &#125;; triangleBatch.Begin(GL_TRIANGLES, 3); triangleBatch.CopyVertexData3f(vVerts); triangleBatch.End();&#125;void RenderScene(void)&#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); GLfloat vRed[] = &#123; 1.0f, 0.0f, 0.0f, 1.0f &#125;; shaderManager.UseStockShader(GLT_SHADER_IDENTITY, vRed); triangleBatch.Draw(); glutSwapBuffers();&#125;int main(int argc, char * argv[])&#123; gltSetWorkingDirectory(argv[0]); glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH | GLUT_STENCIL); glutInitWindowSize(800, 600); glutCreateWindow(&quot;Triangle&quot;); glutReshapeFunc(ChangeSize); glutDisplayFunc(RenderScene); GLenum err = glewInit(); if (GLEW_OK != err) &#123; fprintf(stderr, &quot;glew error: %s\\n&quot;, glewGetErrorString(err)); return 1; &#125; SetupRC(); glutMainLoop(); return 0;&#125; 2.2 小bug 解决运行后发现会出现如下bug， 这里提示的是饮用方式的不对，修改根据提示修改，结果如下： 其他的错误提示也算大同小异，也一样的根据系统提示做修改。 2.3 结果展示最终结果如下： 在这里画了一个简单的三角形，并用红色进行和内部渲染。 三、小结本文介绍了OpenGL环境搭建，并简单的通过业务代码创建了一个红色三角形，由于是初次接触，内部的语法不妨略过，享受一下结果，会在以后的章节进行步骤的详细讲解。 附：Demo的 Github下载","categories":[],"tags":[{"name":"进阶","slug":"进阶","permalink":"http://nilsli.com/tags/%E8%BF%9B%E9%98%B6/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://nilsli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://nilsli.com/tags/OpenGL/"},{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"}]},{"title":"离屏渲染-超详细解析","slug":"0707offrender","date":"2020-07-07T15:55:43.000Z","updated":"2024-08-07T07:10:46.476Z","comments":true,"path":"p/7f336030.html","permalink":"http://nilsli.com/p/7f336030.html","excerpt":"","text":"〇、序章作为一个面试中经常出现的话题，离屏渲染（Offscreen rendering）恐怕是极高频率提起的——最熟悉的陌生人，我们多少知道一点，也了解到由于它的出现，会带来的屏幕刷新卡顿，滑动式不跟手等体验，但是又不是知道的那么透彻。在这篇文章里，我将比较详细的讲解一下其概念、发生的场景，以及解决方案。 0.1 概念 离屏渲染，就是计算机在帧缓冲区外另外开辟一个区域，用来存储多个复杂涂层的组合绘制结果的过程。 说到离屏渲染的概念，先得了解计算机屏幕刷新原理，以及与之对应的屏内渲染。 ① 屏内渲染（Inscreen Rendering）：CPU和GPU 可以在其自有的帧缓冲区（Frame Buffer Zone）内进行图像绘制，无需额外开辟空间，待绘制完成后将绘制结果直接进行渲染 ② 离屏渲染（Offscreen Rendering）：CPU与GPU 在渲染图像之前，由于工作任务的繁重，需要在当前GPU 的双帧缓冲区之外，额外开辟一个缓冲区用来绘制图像，这个缓冲区被称为离屏缓冲区（Offscreen Buffer zone），待绘制结束之后，系统将缓冲区绘制的结果渲染到帧缓冲区，进行图像展示。 一、CPU 与 GPU1.1 名词解释 CPU(Central Processing Unit): 是计算机的主要设备之一，功能主要是解释计算机指令以及处理计算机软件中的数据。 GPU（Graphics Processing Unit）：又称为显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备上运行绘图运算工作的微处理器。 1.2 组织架构：1.2.1 CPU 组织架构CPU 主要有以下组织： Control：控制器 ALU： 算术逻辑单元 CACHE：缓存区 DRAM：动态随机存储器 示意图如下： 1.2.2 GPU组织架构GPU有如下组织构成： BIF（Bus Interface）：总线接口 PMU（Power Management Unit）: 电源管理单元 VPU（Video Processing Unit）：视频处理单元 DIF（Display Interface）：显示接口 GMC（Graphic Memory Controller）：图像内存控制器 GCA（Graphic and Compute Array）：图形和计算数组 如下： 1.3 特点 类型 身份与作用 特点 特点 CPU 运算核心&#x2F;控制 逻辑复杂，处理数据 依赖性非常高，假并发 GPU 绘图运算的微处理器 逻辑简单，绘制图形 依赖性低，多核真正并发 二、计算机渲染原理2.1 计算机扫描方式2.1.1 随机扫描显示随机扫描显示，常见于老的CRT 显示器，通过固定的线段来画出图形的线段，流程是从屏幕中的一个点移动到下一个点。在画完图后，系统会循环回到第一行，重复绘制下一个图形。 该过程如图所示： 优点如下： 电子束仅仅指向绘制图形的部分区域屏幕 产生的线条是平滑的 分辨率较高 缺点： 无法绘制较为复杂的阴影场景 2.1.2 光栅扫描显示 2.1.2.1 概念光栅扫描效果如下图所示，它是由电极发射电子束从上到下，从左到右依次扫描，形成图形。 2.1.2.2 特点 左上角开始横向扫描 依次纵向扫描 由像素阵列组成 显示整个光栅所需的时间 扫描只与屏幕像素油管，而和图像无关 扫描会产生视觉暂留 16帧-保证连贯 2.1.2.3 优点如下： 逼真的形象 数百万种将生成的颜色 阴影场景是可能的。 2.1.2.4 缺点如下： 低解析度 昂贵 2.1.3 光栅扫描结构 显示器 视频控制器 - 负责控制刷新 - 管理帧缓冲区与缓冲器 负责将帧缓冲区的内容绘制到显示器 帧缓冲区 由阵列组成 存储颜色值（黑白值） 又名：显存 连续的计算机存储空间，存储即将显示的渲染数据 计算：大小 60 * 60 的图片 &#x3D; 60 * 60 * 4 （RGBA） &#x3D; 14400bit 简单光栅扫描显示系统结构 系统总线 CPU 系统内存 显示处理器 显示处理器存储区 帧缓冲区 显示控制器 显示器 2.2 计算机渲染流程 三、iOS 环境下渲染原理3.1 渲染流程iOS 下的流程如下图所示，总结为一下几个步骤： App 配置图形代码。如生成一个 UIImageView 或 CoreAnimation动画的生成 iOS 框架代码的调用。通常有CoreGraphics、CoreAnimation和CoreImage。 系统底层引擎的调用与图形绘制计算。这部分工作交由OpenGL ES 或者原生的Metal 来完成。 调用系统显存GPU驱动器。 通过GPU 驱动器，将绘制计算好的数据存入GPU 也就是帧缓冲区。 通过视频控制器将GPU 内绘制好的数据，按照每帧的方式显示在显示器上面。 3.2 iOS 下的CoreAnimation3.2.1 结构UIKit&#x2F;AppKit为表层，来驱动 CoreAnimation 驱动 Metal&#x2F;CoreGraphic 来驱动图形硬件 Render, compose, and animate visual elements –Apple 渲染，构建，和将视觉组件构成动画 —— Apple 3.2.2 layer CALayerAn object that manages image-based content and allows you to perform animations on that content. 用来显示位图，比如有content 属性 UIView 绘制和动画 布局和子View 的管理 点击事件管理 CALayer 渲染 动画 四、CoreAnimation 渲染4.1 Application - 应用 HandleEvents - 处理事件 Commit Transaction - 提交事件，如（图片解码） 4.2 RenderServer - 渲染服务主要做以下两组工作： Decode - 解码 Draw Calls - 显示调用（需要等待下一个Runloop） 4.3 GPU 内的操作 会将 CoreAnimation 提交OpenGL 调用GPU 开启渲染流程 顶点数据 顶点着色器 偏远着色器 4.4 显示在下一个Runloop，从帧缓冲区提取数据，显示到屏幕 五、画面撕裂卡顿与掉帧5.1 画面撕裂 定义 在G-SYNC中有一个很重要的关键词，那就是“屏幕刷新率”。对于传统显示屏来说，它的屏幕刷新率是固定的，例如60Hz的刷新率，就是指每秒钟固定刷新60帧图像。如果说显卡输出图像的速度与刷新率刚好吻合，那意味着每一张图像都可以显示在用户面前，形成一个连贯、流畅影像。 但是在现实中显卡输出的图像帧率并不是固定的，它输出一帧图像的时间可能会高于1&#x2F;60秒，也能会低于1&#x2F;60秒，这样显卡的输出帧率与屏幕刷新率就不同步了。当输出帧率高于屏幕刷新率的时候，显卡输出的图像就不一定每一帧都能显示在屏幕上，如果画面恰好处于动态变换的过程中，这样的影像就不连贯了，有可能会产生“图像上半部分是前一帧，下半部分是后一帧”的问题，通俗来说就是图像撕裂。 效果图 原因 在60Hz 的扫描率下，在1&#x2F;60秒周期过后，CPU 交互给GPU 的计算工作未完成，无法给予最新的图片，故帧缓冲区未及时更新，还是上一帧的内容。 苹果解决方案 垂直同步 Vsync （Vertical sync） 帧缓冲区加锁 扫描未完成，显示图片全是上一帧的图片 保证图片的扫描是完整的 双缓冲区 两个缓冲区，一个展示时，另一个在做准备 &#x2F;&#x2F; 图片 缺点：掉帧 5.2 卡顿与掉帧5.2.1 掉帧： 原因：当接受到Vsync 垂直信号时，CPU&#x2F;GPU 的 计算还未完成（准备好），控制器会从帧缓冲区取出并显示上一帧的图像，从而本帧为正确显示，成为掉帧 三缓冲区： CPU&#x2F;GPU运算时，还有个缓冲区可以存储数据 5.2.2 屏幕卡顿 CPU&#x2F;GPU 渲染流水线耗时过长，导致掉帧 Vsync + doubleBuffering 为了解决屏幕撕裂，会付出掉帧的代价 三缓冲区时：合理使用CPU&#x2F;GPU，仅仅是减少了掉帧的次数 六、产生原因6.1 垂直同步Vsync 与双缓冲区6.1.1 垂直同步苹果对移动设备采用的是垂直同步Vsync + 双缓冲区的策略：计算机发出垂直信号，向显存——也就是帧缓冲区（Frame Buffer Zone）索取计CPU和GPU 绘制好的帧图像，从而由视频控制器显示到屏幕中，接下来发出下一次垂直信号。 这个周期由刷新频率而定，一般来说屏幕刷新频率是60Hz，这样每个刷新周期，就是16.666ms（1 &#x2F;60 * 1000）。 6.2 离屏缓冲区最终由来 一旦绘制的图层较多，以及对图层绘制较为复杂（设置圆角、透明度以及阴影等），由于帧缓冲区对绘制的图层使用完毕会之后都会丢弃，就无法满足保存临时结果。 为了使得多个图层的绘制结果能再处理过程中得以保留，系统会自动开辟一个缓冲区——离屏缓冲区，用来保存临时生成的结果。 当所有的图层运算完毕，系统将礼品缓冲区的绘制结果放入帧缓冲区，由帧缓冲区交付结果，显示到屏幕中。 6.3 渲染举例6.3.1 代码我们举例，一个视图上放一张图片视图，代码如下： - (void)addContentView&#123; UIView *contentView = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 300, 300)]; contentView.backgroundColor = [UIColor redColor]; contentView.layer.cornerRadius = 20; contentView.layer.masksToBounds = YES; [self.view addSubview:contentView]; UIImageView *iv = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;saga.jpg&quot;]]; iv.backgroundColor = [UIColor blueColor]; iv.layer.cornerRadius = 20; iv.layer.masksToBounds = YES; iv.frame = CGRectMake(30, 30, 200, 150); [contentView addSubview:iv];&#125; 运行后，打开模拟器，在Device 中打开 离屏渲染检测按钮—— Color off-screen Rendered ，即 可以得到如下的图片，四周的黄色区域显示——设置过背景和圆角的这张图片，已经参与了离屏渲染了： 原因：两个图层进行了绘制并融合，需要开辟离屏渲染区域。 七、优点、缺点与特性7.1 优点： 可以解决复杂图层渲染 复用复杂图形：如果图像多次出现，可以保存在离屏渲染缓冲区，达到复用的优点。 7.2 缺点： 性能问题——掉帧 由于离屏渲染往往是要承担较为复杂的绘制过程，通常是超过1个图层的复杂绘制，当硬件性能低下，以及绘制图层复杂双重压力下，CPU 往往无法在一个扫描周期——也就是16.67ms 内完成绘制工作并交付GPU，为了维护图片的完整性，系统会选用上一帧的图片来显示，虽然只是1帧图像的滞后，肉眼还是能察觉到图片的滞后——尤其是在视图滚动时，更为明显，这就是我们常常提到的掉帧。 7.3 特性 自动触发 空间有限制：大小为屏幕像素的2.5倍 8.4 离屏渲染的模式 拿到第一个图层，结果放入离屏渲染区 拿到第二个图层，结果放入离屏渲染区 拿到第三个图层，结果放入离屏渲染区 从离屏渲染区，获取第一个图层，添加圆角 从离屏渲染区，获取第二个图层，添加圆角 从离屏渲染区，获取第三个图层，添加圆角 3个图层，进行组合，放入帧缓冲区 进行显示到屏幕 小结： 多个图层特殊处理，每一步都需要临时的存出结果 八、产生的场景8.1 圆角对，就是圆角，可能印象中，设置了圆角就会带来离屏渲染，真的是这样吗？ 先看看苹果对圆角（cornerRadius）的定义： Setting the radius to a value greater than 0.0 causes the layer to begin drawing rounded corners on its background. By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to YES causes the content to be clipped to the rounded corners. 简单的翻一下： 当给定radius 超过0.0 会导致图层（layer）开始在其背景中绘制圆角。默认下，圆角半径不会应用到图层的内容属性的图像中；它只会应用到其背景和自身的边界线中。因此，将maskToBounds设置成YES，会导致内容切成圆角。 由此可以得到两个结论 设置 cornerRadius 不会渲染该图层的内容图像 设置 corner Radius 只会渲染 layer 的边框及背景 属性 maskToBounds 设置YES，会切成圆角 8.2 开启了光栅化 shouldRasterize 如果layer 不能被复用，则没有必要打开光栅化 如果layer 不是静态的，需要被频繁修改，比如处于动画之中，那么开启离屏渲染反而影响效率 离屏渲染缓存内容有时间限制，缓存内容100ms 内容如果没有被使用，那么它就会丢弃；无法进行复用了 离屏渲染缓存空间有限，超过2.5 倍屏幕像素大小，也会失效，且无法进行复用 8.3 常见的触发场景 使用了 mask 的layer layer.mask 需要进行裁剪的layer —— layer.maskToBound &#x2F; view.clipToBounds 设置了组透明为YES， 且透明度部位1 的layer —— layer.allowsGroupOpacity&#x2F;layer.opacity 添加了投影的layer —— layer.shadow 采用了光栅化的 layer —— layer.shouldRasterize 绘制了文字的 layer —— UILabel 、CATextLayer、 CoreText等 九、解决方案10.1 方案一：单一图片圆角设置切歌边角，以及圆角半径 imageView.clipToBounds = YES;imageView.layer.cornerRadius = 10; 9.3 方案二：将圆角图片绘制成位图（YYImage）这个方案在YYImaage 中已经做得非常好了，主要的原理是，根据传入的圆角，CPU进行上下文重绘制，得到UIImage 图片，由于最终得到的图像只有一张图片，自然不会离屏渲染了，相关代码如下： - (UIImage *)imageByRoundCornerRadius:(CGFloat)radius corners:(UIRectCorner)corners borderWidth:(CGFloat)borderWidth borderColor:(UIColor *)borderColor borderLineJoin:(CGLineJoin)borderLineJoin &#123; if (corners != UIRectCornerAllCorners) &#123; UIRectCorner tmp = 0; if (corners &amp; UIRectCornerTopLeft) tmp |= UIRectCornerBottomLeft; if (corners &amp; UIRectCornerTopRight) tmp |= UIRectCornerBottomRight; if (corners &amp; UIRectCornerBottomLeft) tmp |= UIRectCornerTopLeft; if (corners &amp; UIRectCornerBottomRight) tmp |= UIRectCornerTopRight; corners = tmp; &#125; UIGraphicsBeginImageContextWithOptions(self.size, NO, self.scale); CGContextRef context = UIGraphicsGetCurrentContext(); CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height); CGContextScaleCTM(context, 1, -1); CGContextTranslateCTM(context, 0, -rect.size.height); CGFloat minSize = MIN(self.size.width, self.size.height); if (borderWidth &lt; minSize / 2) &#123; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)]; [path closePath]; CGContextSaveGState(context); [path addClip]; CGContextDrawImage(context, rect, self.CGImage); CGContextRestoreGState(context); &#125; if (borderColor &amp;&amp; borderWidth &lt; minSize / 2 &amp;&amp; borderWidth &gt; 0) &#123; CGFloat strokeInset = (floor(borderWidth * self.scale) + 0.5) / self.scale; CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset); CGFloat strokeRadius = radius &gt; self.scale / 2 ? radius - self.scale / 2 : 0; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:corners cornerRadii:CGSizeMake(strokeRadius, borderWidth)]; [path closePath]; path.lineWidth = borderWidth; path.lineJoinStyle = borderLineJoin; [borderColor setStroke]; [path stroke]; &#125; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 10.3 方案三： 在现有图层上方遮罩图片@interface RoundImageView()@property (strong, nonatomic) UIImageView *maskView;@end@implementation RoundImageView- (instancetype)init&#123; if (self = [super init]) &#123; _maskView = [[UIImageView alloc] initWithFrame:CGRectZero]; _maskView.image = [UIImage imageNamed:@&quot;maskIV&quot;]; [self addSubview:_maskView]; &#125; return self;&#125;- (void)layoutSubviews&#123; [super layoutSubviews]; CGRect bounds = self.bounds; _maskView.frame = bounds;&#125; @end 小结从上文得知，离屏渲染是苹果为较为复杂的图像效果做出的一种妥协方案，作为一种空间换时间的方案，必然会损失一些性能，为了挽回这些损失，我们只有在深入理解背后的原理后，方能做到较为理想的结果。","categories":[],"tags":[{"name":"离屏渲染","slug":"离屏渲染","permalink":"http://nilsli.com/tags/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"},{"name":"offscreen","slug":"offscreen","permalink":"http://nilsli.com/tags/offscreen/"}]},{"title":"计算机视觉【02-OpenGL概念篇】","slug":"0706opengl","date":"2020-07-06T03:24:57.000Z","updated":"2024-08-07T07:10:46.472Z","comments":true,"path":"p/7fad6178.html","permalink":"http://nilsli.com/p/7fad6178.html","excerpt":"","text":"一、计算机视觉简介1.1 概念:计算机视觉（Computer Vision）是一门跨学科科学，用于处理计算机如何从数码相片或视频中获取高层次理解。从工程学的角度来讲，它的目的是理解并将人类视觉系统的工作任务自动化。 计算机视觉（Computer vision）是一门研究如何使机器“看”的科学，更进一步的说，就是指用摄影机和计算机代替人眼对目标进行识别、跟踪和测量等机器视觉，并进一步做图像处理，用计算机处理成为更适合人眼观察或传送给仪器检测的图像。 ——黄亚勤《基于视线跟踪技术的眼控鼠标研究与实现》 1.2 演进历史从1960年后期，作为人工智能的先锋学科，计算机视觉在大学校园里开始开设。它起初被用来模拟人类视觉系统，借此赋予机器人智能的行为。在1966年，人们相信该目的可以被达成，通过将一枚摄像头附属到计算机上并让其”展示所看到“。 真正将计算机视觉从流行的领域数字图像处理区别开来的时机，是一个将3D结构从图像中抽取出来并达到全景理解的需求。1970年代的一些研究，最终形成了现今存在的计算机视觉算法的早期框架，包括图像的边缘提取，线段标签，非多面体与多面体的模型，将对象表示为较小结构的互连，光流，和运动估计。 接下来的十年见证了基于更多严谨的数学分析和计算机视觉量化的方向。这些包括了空间刻度概念，形状的多种线索提示比如阴影、纹理、焦点，以及被称为snakes 的轮廓模型。 在1990年代，一些先前的研究话题变得比其他的更为活跃，三维重建引导了更好的相机标定的理解。随着相机标定的优化技术的发展，人们意识到，从摄影测量学领域的束调整理论中已经探索了许多想法。这推动了从多个图像中进行稀疏三维场景重建的方法。 1.2 关联领域： 人工智能 信息工程 固态物理学 神经生物学 信号处理 其他领域 1.2 OpenGL 是什么OpenGL（Open Graphic Library）是一种应用程序编程接口（Application Programming Interface, API），它是一种可以对图形硬件设备特性进行访问的软件库。 二、概念1. 上下文 Context：一组完整的 OpenGL 状态变量。注意帧缓存的内容不属于OpenGL 状态的一部分，但是帧缓存的配置（以及相关的渲染缓存）属于它的一部分。 2. 状态机理论上是OpenGL用来形容状态的工具。它描述了对象在生命周期中的各种状态、状态间发生的转变、发生转变的原因、条件及转变中执行的过程。一般具有以下特点： 有记忆功能，记忆当前的状态 可以接收输入，根据输入的内容和自己的院线状态，修改自己当前状态，并且可以有对应的输出 当进入特殊状态（如停机）的时候，变不再接受输入，停止工作。 3. 渲染 - Rendering将图形&#x2F;图像数据转换成2D空间图像的操作。 渲染器 - RendererApple Computer 的Mac OS X 操作系统的OpenGL 实现。由于一台计算机可能有多个图形功能的设备（如多个图形卡或软件实现），因此一台Mac OS X 机器上也许可以支持多个渲染器。 4. 顶点数组 VertexArray顶点数据的块（顶点坐标、纹理坐标、表面法线、RGBA颜色、颜色索引、边界标志）可以存储在一个数组中，然后通过使用单个OpenGL 命令的执行，设置多个几何图元。 5. 顶点缓冲区 VertexBuffer绘制图形前，提前分配一块显存，将顶点数据预先传入显存中，这部分的显存，被称为顶点缓冲区。 6. 管线 Pipeline就是一套流水线，负责管理渲染的过程 7. 固定管线 fixed-function pipeline一种图形流水线，它包含其操作由程序可配置的一系列参数控制的处理过程。 8. 可编程管线它允许开发者使用更为灵活地操作来替代固定功能的操作。比如现在的OpenGL 管线是可编程的流水线， 9. 着色器 Shader执行程序的工程，输入数据（例如定点、图元、或片元）到管线的一个阶段，并产生不同类型的结果数据，准备作为管线中后级阶段的输入数据使用。 固定着色器：也叫做存储着色器， 自定义着色器 顶点着色器 片元着色器 fragment shader 在光栅化完成之后执行的着色器。片元着色器的每个请求都是对一个光栅化之后的片元执行的。片元着色器也可以说是像素点着色器，负责处理一个个的像素点。如一个图像由120 * 120 像素点组成，就需要 120 * 120 &#x3D; 14400 次的GPU 运算 10. 光栅化转换投影点、线或多边形，或者位图和图像的像素到片源信息，他们每一个都对应帧缓存中的一个像素。注意：所有的图元都会被光栅化，而不仅仅是点、线或多边形。 11. 纹理可以理解为图片。用来修改光栅化产生的片元颜色的1维或2维图像 12. 混合 Blending混合可以理解为，将像素的颜色和帧缓冲区中颜色附着上的颜色混合在一起，达到新的颜色或者形状的效果。举个例子，可以将两个图层（透明度0.2 的粉色图层，透明度0.5的绿色图层）混合叠加在一起，这个过程就叫做混合 13. 变换矩阵一个多维矩阵，用来描述顶点位置，进而帮助实现图像的平移、缩放、旋转变化的效果。 14. 投影矩阵 - Projection MATRIX 正投影： 将图像完整的投影在2D平面上，关键字：【1：1】、【2D效果】。 透视投影： 将图像按照远小近大的原则投影在2D平面上，能产生3D的立体视觉效果。 15. 视口 Viewpoint屏幕上的像素点集合，决定我们作为观察者在渲染的场景中看到的内容的大小。在开发中，常见的有全幅和局部的视口。 全幅视口 局部视口 小结本章学习了随着抖音、美颜相机等流行的应用而变得火热的计算机视觉的概念，以及其底层OpenGL的相关名词，下一篇，将开始介绍其搭建过程。","categories":[],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://nilsli.com/tags/opengl/"},{"name":"音频","slug":"音频","permalink":"http://nilsli.com/tags/%E9%9F%B3%E9%A2%91/"},{"name":"视频","slug":"视频","permalink":"http://nilsli.com/tags/%E8%A7%86%E9%A2%91/"},{"name":"音视频","slug":"音视频","permalink":"http://nilsli.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"进阶","slug":"进阶","permalink":"http://nilsli.com/tags/%E8%BF%9B%E9%98%B6/"}]},{"title":"Block使用及原理探究","slug":"0524block","date":"2020-05-23T19:40:01.000Z","updated":"2024-08-07T07:10:46.468Z","comments":true,"path":"p/1bf24dc1.html","permalink":"http://nilsli.com/p/1bf24dc1.html","excerpt":"","text":"出于需要，本文分析时引用苹果开源的libclosure-74 源码，请点击对比查看苹果libclosure源码 一、Block概念1.1 名词解释也成为匿名函数，是将函数及其执行上下文封装起来的对象。有参数和返回值。 Block的结构是：__block_impl struct __block_impl &#123; void *isa; // isa 对象 int Flags; int Reserved; void *FuncPtr;//函数指针&#125; 1.2 分类根据Block 所属的libclosure 所示，一共有6种。具体操作：进入苹果libclosure源码，选择最新的libclosure-74，下载后打开工程文件，搜索NSBlock得知具体6种如下： void * _NSConcreteStackBlock[32] = &#123; 0 &#125;;void * _NSConcreteMallocBlock[32] = &#123; 0 &#125;;void * _NSConcreteAutoBlock[32] = &#123; 0 &#125;;void * _NSConcreteFinalizingBlock[32] = &#123; 0 &#125;;void * _NSConcreteGlobalBlock[32] = &#123; 0 &#125;;void * _NSConcreteWeakBlockVariable[32] = &#123; 0 &#125;; 其中：NSConcreteStackBlock、NSConcreteMallocBlock、NSConcreteGlobalBlock 是常用到的栈区、堆区、全局区的block，其余3种为系统级别，实际开发较少会用到，所以先不展开说明。 1.2.1 NSGlobalBlock（全局Block）当生成的block是独立的，不引用外部变量或者作为参赛参与其他函数，处于全局区，是为全局block void (^block)(void) = ^&#123; NSLog(@&quot;hello world!&quot;);&#125;;block();NSLog(@&quot;block %@&quot;, block); 2020-05-25 03:21:33.996335+0800 DDD[12987:411279] hello world!2020-05-25 03:21:33.996513+0800 DDD[12987:411279] block &lt;__NSGlobalBlock__: 0x10e714050&gt; 1.2.2 NSStackBlock（栈区）当block 被copy 前，会处于栈区 以下为相关示例： __block int a = 1; NSLog(@&quot;%@&quot;, ^&#123; NSLog(@&quot;aaa %d&quot;, a);&#125;); 结果如下： 2020-05-25 11:36:10.746965+0800 DDD[14013:600887] &lt;__NSStackBlock__: 0x7ffeeb06b188&gt; 1.2.3 NSMallocBlock（堆区）当block 引用外部变量，此时block 会从全局区移动到堆区 __block int a = 10;void (^block)(void) = ^&#123; NSLog(@&quot;a %d&quot;, a);&#125;;block();NSLog(@&quot;block %@&quot;, block); 2020-05-25 03:22:31.565749+0800 DDD[13022:421048] a 102020-05-25 03:22:31.565921+0800 DDD[13022:421048] block &lt;__NSMallocBlock__: 0x600000ddc1b0&gt; 1.3 Block 的常见使用 作为局部变量 returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123; // do sth..&#125;; 作为属性 @property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);c 作为函数声明中的参数 - (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName; 作为函数调用中的参数 [someObject someMethodThatTakesABlock:^returnType (parameters) &#123; // do sth&#125;]; 作为typedef typedef returnType (^TypeName)(parameterTypes);TypeName blockName = ^returnType(parameters) &#123; // DO STH&#125;; 二、循环引用及解决2.1 循环引用的产生举一个常见的循环引用的例子 - (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor purpleColor]; self.name = @&quot;hello&quot;; // ① self 持有block self.block = ^&#123; // ② block 又持有self NSLog(@&quot;__name %@&quot;, self.name); &#125;; self.block();&#125;-(void)dealloc&#123; NSLog(@&quot;进入dealloc&quot;);&#125; 当示例代码中①处 self 持有了属性 block，而 ②种 block 代码块又持有了 self，这样会导致相互引用，最终系统在执行 dealloc 方法时，向任何一个变量发送release消息时，两者都因为引用其他变量而无法释放，最终会引起内存泄漏。示意图如下： 2.2 循环引用的解决此时我们只讨论由block 引起的循环引用 2.2.1 使用weak 修饰可以考虑对当前持有block 的对象，进行weak 修饰，创建一个弱引用指向它（原理为加入到弱引用计数表，而非引用技术表），但是并不会增加引用计数。 当前案例中，引用block 的是self，所以创建一个weak 对象 weakSelf。 如下所示，即可跳出 self - block - self 的循环引用 __weak typeof(self) weakSelf = self;self.block = ^&#123; NSLog(@&quot;__name %@&quot;, weakSelf.name);&#125;;self.block(); 2.2.2 weak-strong-dance（多级block）在多级block 的场景下，弱引用会造成一些意外的情况。 对上面的例子做一些小改动，对block代码块执行的NSLog 函数，做一个延迟3秒执行操作，并让这个执行在页面消失之后，也就是dealloc 之后，看看是否还能打印 weakSelf.name。 新的代码如下： - (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor purpleColor]; self.name = @&quot;hello&quot;; __weak typeof(self) weakSelf = self; self.block = ^&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;__name %@&quot;, weakSelf.name); &#125;); &#125;; self.block();&#125;-(void)dealloc&#123; NSLog(@&quot;进入dealloc&quot;);&#125; 打印结果如下： 2020-05-25 12:43:05.876909+0800 DDD[14542:686386] 进入dealloc2020-05-25 12:43:06.475894+0800 DDD[14542:686386] __name (null) 可见，在进入dealloc 之后，添加的弱引用，已经被释放掉了，而设计的3秒后执行 weakSelf.name 也因为 weakSelf 为 nil 了，所以打印为null 解决：在代码块内，添加临时的强引用，将weakSelf 添加到强引用表里，会让dealloc 延迟执行，而当执行完之后block 会对临时的强引用进行释放，避免了循环引用的产生。 代码如下： - (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor purpleColor]; self.name = @&quot;hello&quot;; NSLog(@&quot;初始name %@&quot;, self.name); __weak typeof(self) weakSelf = self; self.block = ^&#123; __strong typeof(self) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;__name %@&quot;, strongSelf.name); &#125;); &#125;; self.block();&#125;-(void)dealloc&#123; NSLog(@&quot;进入dealloc&quot;);&#125; 打印结果及顺序： 2020-05-25 12:49:42.141133+0800 DDD[14610:698670] 初始name hello2020-05-25 12:49:47.634568+0800 DDD[14610:698670] __name hello2020-05-25 12:49:47.635013+0800 DDD[14610:698670] 进入dealloc 从结果可以看出，12:49:42 秒进入本页面，47秒后 进入打印strongSelf.name 成功，同时立刻执行dealloc方法。可见修改是成功的。 2.2.3 用临时VC 变量替代在上文中，都是通过weak 对self修饰，来避免循环引用，实际上，还可以对self 所代替的Controller 引入临时变量，来解决循环引用，话不多说，实战一下。 __block SecViewController *vc = self;self.block = ^&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;__name %@&quot;, vc.name); vc = nil; &#125;);&#125;;self.block(); 创建一个临时变量vc，使用__block 修饰，因为后面会对他做修改。 在block内部进行打印属性，完毕后置空，跳出循环引用。 打印结果如下： 2020-05-25 12:54:28.262738+0800 DDD[14645:705623] 初始name hello2020-05-25 12:54:33.263402+0800 DDD[14645:705623] __name hello2020-05-25 12:54:33.263773+0800 DDD[14645:705623] 进入dealloc 可见通过ViewController 来替代self 也算可用性的 2.2.4 将VC 作为block 变量替代如果block 是可以引入参数的，可以将控制器self 传入进去，作为临时变量，打印后block 会自动销毁，无需担心循环引用，具体如下： 创建block ，引入当前VC 的引用，的代码如下 @property (copy, nonatomic) void (^block)(SecViewController *); 执行函数为： self.block = ^(SecViewController *vc)&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;__name %@&quot;, vc.name); &#125;);&#125;;self.block(self); 此时通过self.block(self) 传入self 的引用，block 内部会自动创建一个新的临时变量指向self，该临时变量使用后会销毁。打印机如果如下； 2020-05-25 12:57:17.929178+0800 DDD[14671:710117] 初始name hello2020-05-25 12:57:22.929717+0800 DDD[14671:710117] __name hello2020-05-25 12:57:22.930072+0800 DDD[14671:710117] 进入dealloc 三、底层探索3.1 Block 的本质 Block 是一种匿名函数，它的类型是一种对象，本质是结构体。 为了证明这一点，对main.m 进行cpp 源码分析，现在main.m 生成一个block void (^block)(void) = ^&#123;&#125;;block(); 进入项目文件下，输入编译命令：xcrun -sdk iphonesimulator clang -rewrite-objc main.m 得到main.cpp 打开查看相关cpp 实现如下： OC 代码如下： void (^block)(void) = ^&#123;&#125;;block(); C++ 源码如下： void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); 将代码精简一下成为： void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA)); (block)-&gt;FuncPtr)(block); 可见主函数为__main_block_impl_0，在C++ 源码中的部分为： struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 可见，我们平常使用的代码块block代码块是一个结构体，有以下几个部分组成 block 实现 - __block_impl，这个是个指针函数，生成后会返回 block 描述信息 - __main_block_desc_0 内部构造函数 - __main_block_impl_0。主要执行了 生成薪的impl 的函数赋值（如isa，flags，funptr） 继续挖， __block_impl 类型的结构体，实现如下： struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;; 因为有熟悉的isa 的存在，可知其也算个对象类的结构体。 3.2 Block 自动捕获外部变量接下来看block 是如何捕获外界变量的，一共分为3重大的类型： 局部变量 局部静态变量 全局变量和全局静态变量 3.2.1 局部变量捕获 局部变量的捕获，是指的捕获 此时生成一个变量 int a，在代码块对其进行引用，如下： int a = 10;void (^block)(void) = ^&#123; NSLog(@&quot;%d&quot;, a);&#125;;block(); 继续进行cpp 编译，发现int main 函数下，变成了如下 int a = 10;void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); 通过精简，其内容如下： int a = 10; block = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, a)); block-&gt;FuncPtr(block); 可见__main_block_impl_0传入了新的参数a，接下来看如何实现，新的 main_block_impl_0 结构体如下： struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 可见这里比起之前的结构体，生成了一个新的属性a ，在构造函数里，发现了__main_block_impl_0中也多了一句a(_a) 的代码，可以猜测是生成了一个新的a，将传入的内部属性_a 赋值给 a 继续看main_block_func_0 的实现如下： static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int a = __cself-&gt;a; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_b68344_mi_0, a);&#125; 此时静态函数__main_block_func_0的内部对传入的block 进行了处理——接受了其内部的变量a——通过自身新生成一个a，就是这行代码 int a = __cself-&gt;a; // bound by copy 自动生成的注释很清晰的说明了原理，通过copy绑定新的值，所以说是值捕获。最终通过NSLog 打印新的变量a 3.2.2 局部静态变量捕获 局部静态变量的捕获，是指针捕获 接下来尝试一下，在block内部生成一个用static修饰的局部静态变量，看看如何捕获 static NSInteger num = 3;NSInteger (^block)(NSInteger) = ^(NSInteger n)&#123; return n * num;&#125;; num = 1;NSLog(@&quot;%ld&quot;, (long)block(2)); 进入项目文件下，输入编译命令：xcrun -sdk iphonesimulator clang -rewrite-objc main.m 得到main.cpp struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; NSInteger *num; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSInteger *_num, int flags=0) : num(_num) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static long __main_block_func_0(struct __main_block_impl_0 *__cself, NSInteger n) &#123; NSInteger *num = __cself-&gt;num; // bound by copy return n * (*num); &#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main(int argc, char * argv[]) &#123; NSString * appDelegateClassName; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; static NSInteger num = 3; NSInteger (*block)(NSInteger) = ((long (*)(NSInteger))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;num)); // 精简为 *block = __main_block_impl_0(&amp;__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;num); num = 1; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_ef866b_mi_0, (long)((NSInteger (*)(__block_impl *, NSInteger))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block, 2)); appDelegateClassName = NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;AppDelegate&quot;), sel_registerName(&quot;class&quot;))); &#125; return UIApplicationMain(argc, argv, __null, appDelegateClassName);&#125; 变化： 生成了新的整形指针NSInteger *num; 将传入的NSInteger *_num 赋值给num 代码块调用有所不同，如下： // 原函数 NSInteger (*block)(NSInteger) = ((long (*)(NSInteger))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;num));// 精简后__main_block_impl_0(&amp;__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;num) 可以清晰的看出来，此时传入的num 是一个指针，可见，是进行了指针拷贝，而不是值拷贝，所以这里num 得到了改变，打印结果会是2 2020-05-27 00:11:06.899579+0800 DDD[25215:2116517] 2 3.3.3 全局变量、全局静态变量的捕获 全局变量、全局静态变量的捕获是直接取值 这次来点刺激的，把所有用的到的都写到block 里面，再验证下cpp 会发生什么 static NSInteger num3 = 300; // 静态变量NSInteger num4 = 3000; // 全局静态变量int main(int argc, char * argv[]) &#123; NSString * appDelegateClassName; @autoreleasepool &#123; NSInteger num = 30; // 局部变量 static NSInteger num2 = 3; // 局部静态变量 __block NSInteger num5 = 30000; // __block 修饰的变量 void(^block)(void) = ^&#123; NSLog(@&quot;%ld&quot;, (long)num); NSLog(@&quot;%ld&quot;, (long)num2); NSLog(@&quot;%ld&quot;, (long)num3); NSLog(@&quot;%ld&quot;, (long)num4); NSLog(@&quot;%ld&quot;, (long)num5); &#125;; block(); appDelegateClassName = NSStringFromClass([AppDelegate class]); &#125; return UIApplicationMain(argc, argv, nil, appDelegateClassName);&#125; 进入项目文件下，输入编译命令：xcrun -sdk iphonesimulator clang -rewrite-objc main.m 得到main.cpp 不管了，就先一股脑儿的贴上来吧，接下来分析： static NSInteger num3 = 300; // 全局变量NSInteger num4 = 3000; // 静态全局变量struct __Block_byref_num5_0 &#123; // __block 修饰的变量 void *__isa;__Block_byref_num5_0 *__forwarding; int __flags; int __size; NSInteger num5;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; NSInteger num; NSInteger *num2; __Block_byref_num5_0 *num5; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSInteger _num, NSInteger *_num2, __Block_byref_num5_0 *_num5, int flags=0) : num(_num), num2(_num2), num5(_num5-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_num5_0 *num5 = __cself-&gt;num5; // bound by ref NSInteger num = __cself-&gt;num; // bound by copy NSInteger *num2 = __cself-&gt;num2; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_0, (long)num); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_1, (long)(*num2)); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_2, (long)num3); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_3, (long)num4); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_4, (long)(num5-&gt;__forwarding-&gt;num5)); &#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;num5, (void*)src-&gt;num5, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;num5, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, char * argv[]) &#123; NSString * appDelegateClassName; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; NSInteger num = 30; static NSInteger num2 = 3; __attribute__((__blocks__(byref))) __Block_byref_num5_0 num5 = &#123;(void*)0,(__Block_byref_num5_0 *)&amp;num5, 0, sizeof(__Block_byref_num5_0), 30000&#125;; void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, num, &amp;num2, (__Block_byref_num5_0 *)&amp;num5, 570425344)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); appDelegateClassName = NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;AppDelegate&quot;), sel_registerName(&quot;class&quot;))); &#125; return UIApplicationMain(argc, argv, __null, appDelegateClassName);&#125; 分析：我们看到了，num、num2、num5 在block 的构造函数__main_block_impl_0 中都有了各自的实现，有的是取值，有的是通过forwarding 传递指针。 但是num3，和num4 呢？通篇下来，没有做任何处理，在block 函数内部，通过NSLog 直接取值了…… NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_2, (long)num3);NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_8fd68e_mi_3, (long)num4); 结论：静态变量、全局静态变量，因为他们存在全局存储区，占用静态的单元，所以block 调用时是直接把值取过来用，并不需要指针引用。 3.3.4 小结捕获变量的流程，除了静态变量和全局变量以外，都是block 在内部自动生成一个新的变量，用来接收外部变量。 3.3 Block 为什么要捕获Block()block() 这种写法和普通的函数不一样，通过上文可以看到，最终实现的代码为 block-&gt;FuncPtr(block); 分析一下，这里是 block 结构体执行了其内部函数指针指向的函数，即声明一个函数式的属性，在任何想要调用的的地方调用。最终我们的确是调用了。 3.4 __block 的原理为了让外部变量在block 内部得到更改，我们通常在外部对变量使用__block 的修饰符，究竟发生了什么呢？ 那么这次，对外部加上__block 试试 __block int a = 10;void (^block)(void) = ^&#123; a++; NSLog(@&quot;%d&quot;, a);&#125;;block(); 3.4.1 CPP分析可以看到，构造函数结构体有了变化; struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_a_0 *a; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 与之前的变量不一样，生成了一个__Block_byref_a_0 *a; // by ref 的结构体指针对象，点击查看，结构如下： struct __Block_byref_a_0 &#123; void *__isa;__Block_byref_a_0 *__forwarding; int __flags; int __size; int a;&#125;; 可见和类的结构类似，有isa、数据a、内存大小_size、类似链表的__forwarding指针。结合__main_block_impl_0 的结构，可以清楚的看到，内部创建的一个结构体指针__Block_byref_a_0 *a，而 __a 的指针指向了 a。即，这里产生了一次指针拷贝。 接下来看看函数的实现： (a-&gt;__forwarding-&gt;a)++; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kh_ym1km6hs1_510g123chch8bm0000gp_T_main_acd650_mi_0, (a-&gt;__forwarding-&gt;a)); &#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125; 3.4.2 源码分析在上文中，我们看到关键函数是_Block_object_assign，打开libclosure 查看相应的函数实现，得到如下： // When Blocks or Block_byrefs hold objects then their copy routine helpers use this entry point// to do the assignment.void _Block_object_assign(void *destArg, const void *object, const int flags) &#123; const void **dest = (const void **)destArg; switch (os_assumes(flags &amp; BLOCK_ALL_COPY_DISPOSE_FLAGS)) &#123; case BLOCK_FIELD_IS_OBJECT: /*省略*/ break; case BLOCK_FIELD_IS_BLOCK: /*省略*/ *dest = _Block_copy(object); break; case BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK: case BLOCK_FIELD_IS_BYREF: /******* // copy the onstack __block container to the heap // Note this __weak is old GC-weak/MRC-unretained. // ARC-style __weak is handled by the copy helper directly. __block ... x; __weak __block ... x; [^&#123; x; &#125; copy]; ********/ *dest = _Block_byref_copy(object); 注释简单的翻译是：当block 或者block 引用持有对象时，他们的拷贝常规帮助者会使用它们的入口点来做分配工作。 里面的是现实对持有对象类型的switch，重点关注BLOCK_FIELD_IS_BYREF，注释已经说了 copy the onstack __block container to the heap 拷贝栈内__block 容器到堆 太棒了， 这就是我们需要的实现函数，即对__block 的方法做出相应，拷贝到堆区，再来看函数 _Block_byref_copy(object) 具体的实现： static struct Block_byref *_Block_byref_copy(const void *arg) &#123; struct Block_byref *src = (struct Block_byref *)arg; if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) &#123; // src points to stack struct Block_byref *copy = (struct Block_byref *)malloc(src-&gt;size); copy-&gt;isa = NULL; // byref value 4 is logical refcount of 2: one for caller, one for stack copy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | 4; // 问题 - __block 修饰变量 block具有修改能力 copy-&gt;forwarding = copy; // patch heap copy to point to itself src-&gt;forwarding = copy; // patch stack to point to heap copy copy-&gt;size = src-&gt;size;&#125; 在这里可以看到，具体的实现了： 拷贝新的对象到堆区，并置空isa struct Block_byref *copy = (struct Block_byref *)malloc(src-&gt;size);copy-&gt;isa = NULL; 将新的拷贝对象的flag 与之前栈区对象的flags的相等 // byref value 4 is logical refcount of 2: one for caller, one for stackcopy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | 4; 将新的对象指向原对象，即进行指针拷贝——这个是__block 的关键，新的指向原对象，与原地址指向同一个内存空间，故具备修改能力！ // 问题 - __block 修饰变量 block具有修改能力copy-&gt;forwarding = copy; // patch heap copy to point to itselfsrc-&gt;forwarding = copy; // patch stack to point to heap copy 新对象大小与原对象大小相等 copy-&gt;size = src-&gt;size; 总结：可见生成的a 是一个__Block_byref_a_0 类型结构体引用，而不是值拷贝的引用。**__block 在作用于内部生成了变量的指针，通过改变指针指向的地址，来即改变原变量。** 原理图如下： 四、签名4.1 block 结构分析block 的结构如下： struct Block_layout &#123; void *isa; volatile int32_t flags; // contains ref count int32_t reserved; BlockInvokeFunction invoke; struct Block_descriptor_1 *descriptor; // // imported variables&#125;;typedef void(*BlockInvokeFunction)(void *, ...); 分析如下： isa- 指向block父类的指针 用来描述block 对象的flags // Values for Block_layout-&gt;flags to describe block objectsenum &#123; BLOCK_DEALLOCATING = (0x0001), // runtime BLOCK_REFCOUNT_MASK = (0xfffe), // runtime BLOCK_NEEDS_FREE = (1 &lt;&lt; 24), // runtime BLOCK_HAS_COPY_DISPOSE = (1 &lt;&lt; 25), // compiler BLOCK_HAS_CTOR = (1 &lt;&lt; 26), // compiler: helpers have C++ code BLOCK_IS_GC = (1 &lt;&lt; 27), // runtime BLOCK_IS_GLOBAL = (1 &lt;&lt; 28), // compiler BLOCK_USE_STRET = (1 &lt;&lt; 29), // compiler: undefined if !BLOCK_HAS_SIGNATURE BLOCK_HAS_SIGNATURE = (1 &lt;&lt; 30), // compiler BLOCK_HAS_EXTENDED_LAYOUT=(1 &lt;&lt; 31) // compiler&#125;; 预留数值 函数调用invoke 描述信息 struct Block_descriptor_1 *descriptor; &#x2F;&#x2F; 此处的描述信息，是动态的，如果flags 中BLOCK_HAS_COPY_DISPOSE 值存在，则存在Block_descriptor_2，其结构如下; // 可选#define BLOCK_DESCRIPTOR_2 1struct Block_descriptor_2 &#123; // requires BLOCK_HAS_COPY_DISPOSE BlockCopyFunction copy; BlockDisposeFunction dispose;&#125;; 包含的是拷贝函数copy以及销毁函数 dispose 如果flags 中BLOCK_HAS_SIGNATURE 存在，即block 包含有签名存在，则存在Block_descriptor_3 方法签名就在3里面： 方法签名 方法布局 #define BLOCK_DESCRIPTOR_3 1struct Block_descriptor_3 &#123; // requires BLOCK_HAS_SIGNATURE const char *signature; const char *layout; // contents depend on BLOCK_HAS_EXTENDED_LAYOUT&#125;; &#x2F;&#x2F; 引入的变量等 4.2 block签名的访问上文中提到的Block_descriptor_2、Block_descriptor_3，都可以通过 Block_descriptor_1 的内存偏移进行访问到，block 的签名为@？ 4.2.1 代码部署：先设定一个最简单的代码块块用来检查： void(^block)(void) = ^&#123;&#125;;block(); 4.2.2 汇编断点配置 连接真机。配置汇编监控打开：Xcode——Debug——Debug Workflow——Always show Dissembly 对block 代码块打断点，运行程序 会跳转到汇编的main 步骤，通过Step Over键进入到 objc_retainBlock函数下 打印当前x0寄存器：register read x0得到当前运行的block 函数的位置为0x0000000104afc028 打印地址为0x0000000104afc028，得到block的类型、签名和内部实现地址： &lt;__NSGlobalBlock__: 0x104afc028&gt; signature: &quot;v8@?0&quot; invoke : 0x104afa01c (/private/var/containers/Bundle/Application/3F9F1F87-526B-499C-93CE-784F88CE7DB4/DDD.app/DDD`__main_block_invoke) 具体的细节请见下图 4.2.1 访问 Block_descriptor_2当block 的block_layout结构中flag 参数BLOCK_HAS_COPY_DISPOSE 值为1 即可通过内存偏移访问到，相关原理可以见下方代码： static struct Block_descriptor_2 * _Block_descriptor_2(struct Block_layout *aBlock)&#123; if (! (aBlock-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE)) return NULL; uint8_t *desc = (uint8_t *)aBlock-&gt;descriptor; desc += sizeof(struct Block_descriptor_1); return (struct Block_descriptor_2 *)desc;&#125; 函数实现中，第3行desc += sizeof(struct Block_descriptor_1); 即内存地址偏移Block_descriptor_1 的内存位，即可访问到Block_descriptor_2。 4.2.2 访问 Block_descriptor_3同理，在该block的flag 值 BLOCK_HAS_SIGNATURE 为正时，亦可以通过Block_descriptor_1的内存偏移而访问到Block_descriptor_3，当然，如果此时BLOCK_HAS_COPY_DISPOSE 值也为1，必须叠加Block_descriptor_2 的偏移位 static struct Block_descriptor_3 * _Block_descriptor_3(struct Block_layout *aBlock)&#123; if (! (aBlock-&gt;flags &amp; BLOCK_HAS_SIGNATURE)) return NULL; uint8_t *desc = (uint8_t *)aBlock-&gt;descriptor; desc += sizeof(struct Block_descriptor_1); if (aBlock-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123; desc += sizeof(struct Block_descriptor_2); &#125; return (struct Block_descriptor_3 *)desc;&#125; 五、block的copy 分析5.1 源码在libclosure 源码中，runtime.cpp这一页，block_copy 的函数实现如下所示： void *_Block_copy(const void *arg) &#123; struct Block_layout *aBlock; if (!arg) return NULL; // The following would be better done as a switch statement aBlock = (struct Block_layout *)arg; if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123; // latches on high latching_incr_int(&amp;aBlock-&gt;flags); return aBlock; &#125; else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123; return aBlock; &#125; else &#123; // Its a stack block. Make a copy. struct Block_layout *result = (struct Block_layout *)malloc(aBlock-&gt;descriptor-&gt;size); if (!result) return NULL; memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first#if __has_feature(ptrauth_calls) // Resign the invoke pointer as it uses address authentication. result-&gt;invoke = aBlock-&gt;invoke;#endif // reset refcount result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING); // XXX not needed result-&gt;flags |= BLOCK_NEEDS_FREE | 2; // logical refcount 1 _Block_call_copy_helper(result, aBlock); // Set isa last so memory analysis tools see a fully-initialized object. result-&gt;isa = _NSConcreteMallocBlock; return result; &#125;&#125; 5.2 分析我们知道，基于block 的性质，在block 的使用中，当block被copy 时，会从堆区到栈区进行copy，具体发生了什么，不妨读一读源码，看看苹果工程师是如何设计block的copy实现： 先判断block 的类型：先强转arg获取block_layout ，判断其flags aBlock = (struct Block_layout *)arg; 如果是堆block，即BLOCK_NEEDS_FREE：创建的对象需要程序员手动释放——由于此时block 空间已经初始化，所以不做拷贝，只增加引用计数即可，如下; if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123; // latches on high latching_incr_int(&amp;aBlock-&gt;flags); return aBlock;&#125; 如果是全局block –BLOCK_IS_GLOBAL，直接返回 else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123; return aBlock;&#125; 如果是栈区block：进行一次拷贝操作，拷贝到——&gt;堆区。 else &#123; // Its a stack block. Make a copy. struct Block_layout *result = (struct Block_layout *)malloc(aBlock-&gt;descriptor-&gt;size); if (!result) return NULL; memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first#if __has_feature(ptrauth_calls) // Resign the invoke pointer as it uses address authentication. result-&gt;invoke = aBlock-&gt;invoke;#endif // reset refcount result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING); // XXX not needed result-&gt;flags |= BLOCK_NEEDS_FREE | 2; // logical refcount 1 _Block_call_copy_helper(result, aBlock); // Set isa last so memory analysis tools see a fully-initialized object. result-&gt;isa = _NSConcreteMallocBlock; return result; &#125; 创建一个新的Block_layout struct Block_layout *result = (struct Block_layout *)malloc(aBlock-&gt;descriptor-&gt;size); 如果有函数指针调用，将新的Block_layout 指针指向原函数实现，即替换原方法实现： #if __has_feature(ptrauth_calls) // Resign the invoke pointer as it uses address authentication. result-&gt;invoke = aBlock-&gt;invoke;#endif 把原来aBlock 的数据通过内存拷贝到堆区 memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first 重置引用计数 result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING); // XXX not needed result-&gt;flags |= BLOCK_NEEDS_FREE | 2; // logical refcount 1 _Block_call_copy_helper(result, aBlock); 重置isa 指向到一个新的堆block result-&gt;isa = _NSConcreteMallocBlock; 5.3 小结5.3.1 操作copy 结果 对栈block进行copy：拷贝一份到堆区 对全局block进行copy：仍是全局block 对堆block进行copy：增加引用计数 5.3.2 总结图俗话说的好，有图有真相，将上述流程汇总成一张图，是这样的 六、release 与dispose当block 需要释放时，系统内做了哪些工作呢？先看看_Block_object_dispose 函数如下： void _Block_object_dispose(const void *object, const int flags) &#123; switch (os_assumes(flags &amp; BLOCK_ALL_COPY_DISPOSE_FLAGS)) &#123; case BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK: case BLOCK_FIELD_IS_BYREF: // get rid of the __block data structure held in a Block _Block_byref_release(object); break; case BLOCK_FIELD_IS_BLOCK: _Block_release(object); break; case BLOCK_FIELD_IS_OBJECT: _Block_release_object(object); break; case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT: case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK: case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK: case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK | BLOCK_FIELD_IS_WEAK: break; default: break; &#125;&#125; 可以看到，除了BLOCK_FIELD_IS_BYREF类型的情况，此种情况为通过__block修饰变量进入，其他情况直接调用release 或者不用操作即可。 BLOCK_FIELD_IS_BYREF 的情况下，需要调用release 方法，即_Block_byref_release(object)，继续查看如下 static void _Block_byref_release(const void *arg) &#123; struct Block_byref *byref = (struct Block_byref *)arg; // dereference the forwarding pointer since the compiler isn&#x27;t doing this anymore (ever?) byref = byref-&gt;forwarding; if (byref-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) &#123; int32_t refcount = byref-&gt;flags &amp; BLOCK_REFCOUNT_MASK; os_assert(refcount); if (latching_decr_int_should_deallocate(&amp;byref-&gt;flags)) &#123; if (byref-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123; struct Block_byref_2 *byref2 = (struct Block_byref_2 *)(byref+1); (*byref2-&gt;byref_destroy)(byref); &#125; free(byref); &#125; &#125;&#125; 释放的过程比较简单： isa 指回原对象 byref = byref-&gt;forwarding; 生成一个新的Block_byref_2 指针&#96;&#96;byref2，指向byref&#96;下个内存位 struct Block_byref_2 *byref2 = (struct Block_byref_2 *)(byref+1); 通过byref2 向原blog引用发送摧毁消息 (*byref2-&gt;byref_destroy)(byref); 释放原block（byref） free(byref); 七、总结本片篇幅较多，主要从block 的结构、block 循环引用的原理解决、block捕获外部变量，__block 究竟做了什么，以及源码层面上做了大量的分析。总的来说block是很巧妙的一项涉及，合理地用好，可以帮我们极大地提高工作效率。","categories":[],"tags":[{"name":"block","slug":"block","permalink":"http://nilsli.com/tags/block/"},{"name":"原理","slug":"原理","permalink":"http://nilsli.com/tags/%E5%8E%9F%E7%90%86/"}]},{"title":"【数据结构与算法】查找算法（二）平衡二叉树","slug":"0515avl","date":"2020-05-15T12:09:01.000Z","updated":"2024-08-07T07:10:46.467Z","comments":true,"path":"p/d4ce128d.html","permalink":"http://nilsli.com/p/d4ce128d.html","excerpt":"","text":"一、概念 平衡二叉树 （Self-Balancing Banary Search Tree 或者 Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。 AVL 树 两位俄罗斯数学家G.M.Adelson-Velskii 和E.M.Landis 在1962年共同发明一种解决平衡二叉树的算法，所以不少资料这样的平衡二叉树为 AVL树。可以看出它是一种高度平衡的二叉排序树。 平衡因子 我们将二叉树上左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor）。 最小不平衡子树 当向一棵树插入结点，距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树。 举例如下： 符合平衡二叉树 不符合的如下： 第一张图是因为并非升序。 第二张图：虽然其他姐都都比较平衡，但是结点6的左子树深度3，右子树0，差别为3，不符合每一个结点的左子树和右子树高度差至多等于1。 最小不平衡树示意图，插入新结点5后，树原本的平衡被打破，结点4 的左右子树深度为，左3 - 右 1 &#x3D; 2，大于1。称为了非平衡结点。此时从结点5开始以下的子树为最小不平衡子树。 二、实现原理三、算法实现","categories":[],"tags":[{"name":"平衡二叉树","slug":"平衡二叉树","permalink":"http://nilsli.com/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"AVL","slug":"AVL","permalink":"http://nilsli.com/tags/AVL/"}]},{"title":"【数据结构与算法】查找算法（一）","slug":"0513search","date":"2020-05-13T15:03:56.000Z","updated":"2024-08-07T07:10:46.458Z","comments":true,"path":"p/87f3f6a9.html","permalink":"http://nilsli.com/p/87f3f6a9.html","excerpt":"","text":"一、概论1.1 基本概念查找（searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定制的数据元素（或记录）。 查找表（search table）是由同一类型的数据元素（或记录）构成的组合。例如下图： 关键字（key）三数据元素中某个数据项的值，又称为键值。用它可以标示一个记录的某个数据项，我们称为关键码。 1.2 分类按照表查找方式来分有辆大众：静态查找表和动态查找表。 静态查找表（Static Search Table）： 只做查找操作的查找表，主要操作有： 查询某个“特定的”数据元素是否在查找表中 检索某个“特点的“数据元素和各种属性 动态查找表（Dynamic Search Table）：在查找的过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。动态查找表的操作是两个： 查找时插入数据元素 查找时删除数据元素 二、静态查找2.1 顺序查找顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，他的查找过程是：从表的第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较， 若某个记录的关键字和给定值相等，则查找成功，找到所查的记录； 如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。 2.3.1 顺序查找算法算法比较简单，在数组里遍历查找: int Sequential_Search(int *a, int n, int key)&#123; int i; for (i = 1; i&lt;= n; i++) &#123; if (a[i] == key) &#123; return i; &#125; &#125; return 0;&#125; 2.3.2 顺序查找优化由于上述算法，每次都需要判断i是否越界，稍显复杂，我们对算法进行改进，在0位加入一个哨兵，可以减少一次让 i 与 n 比较，具体如下： int Sequential_Search(int *a, int n, int key)&#123; int i; // 1. 在0 位设置称为key，称为哨兵 a[0] = key ; i = n; // 2. 从尾部开始倒序循环 while (a[i] != key) &#123; i--; &#125; // 3. 返回&gt;0 说明找到虚序号；=0 则 = key，表示查找失败 return i;&#125; 这里改动了3个步骤 在0 位设置称为key，称为哨兵 循环倒置。从尾部开始倒序循环，好处是形成了一个完整循环（包括哨兵） 查找结果二合一：返回&gt;0 说明找到虚序号；&#x3D;0 则 &#x3D; key，表示查找失败 2.4 折半查找折半查找（Binary Search），又称为二分查找。 前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。 折半查找的基本思想： 在有序表中，去中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功； 若给定值小于中间记录的关键字，则在中间记录作伴去继续查找； 若给定值大于中间记录的关键字中，则在中间记录的右半区继续查找。 不断重复上述过程直到查找成功，或所有查找区域无记录，查找失败位置。 举例：现在有个数组 $&lt;!–swig￼20–&gt;$，查找其中 $88$ 的序号 代码实现如下： // 折半查找int Binary_Search(int *a, int n, int key)&#123; int low, high, mid; low = 1; high = n; while (low &lt;= high) &#123; mid = (low + high) / 2; if (key &lt; a[mid]) &#123; high = mid - 1; &#125;else if(key &gt; a[mid])&#123; low = mid + 1; &#125;else&#123; return mid; &#125; &#125; return 0;&#125; 查找流程如下图: 2.3 插值查找2.3.1 折半改进由于折半查找会从中间开始查找，一旦超过一定量级，查找任务还是比较繁重。所以考虑是否还有改进空间 查找代码中求 mid的计算公式可以改进为： $$mid &#x3D; \\frac{low+high}{2} &#x3D; low + \\frac{1}{2} (high - low)$$也就是 mid等于最下标 low 加上 最高下标 high 与low 的差值的一半。 考虑将这个一半改进为以下方案：$$mid &#x3D; low + \\frac{ key - a [low]}{ a[high] - a[low]}(high - low)$$改进的好处：可以大大减少查找的次数。 比如数组 {6,12,18,25,31,37,43,50,56,62,68,75,82,88,96}，查找18 ，按照折半查找需要查找4步才可以找到 使用新公示，需要 $\\frac{ key - a [low]}{a[high] - a[low]}$ &#x3D; $ \\frac{(18 - 12)}{(96 - 12)} \\approx 0.071$，那么此时 $mid\\approx 1 + 0.071\\times (15-1) &#x3D; 1.994$，取整后，只需要查询2次即可，大大提升了效率。 这样的到了另一种有虚表查找算法，插值查找法。 2.3.2 核心概念插值查找法(Interpolation Search) 是根据要查找的关键字key 与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值公示:$$\\frac{key - a[low]}{a[high] - a[low]}$$缺点：不适合数字差距不均匀的数组。如 {0, 1, 2, 1000, 30000} 2.3.2 算法实现由上可知，只需要改进一行代码 // 插值查找int Binary_Search(int *a, int n, int key)&#123; int low, high, mid; low = 1; high = n; while (low &lt;= high) &#123; // 插值公示 mid = low + (high - low) * (key - a[low]) / (a[high] - a[low])); if (key &lt; a[mid]) &#123; high = mid - 1; &#125;else if(key &gt; a[mid])&#123; low = mid + 1; &#125;else&#123; return mid; &#125; &#125; return 0;&#125; 2.5 斐波那契查找斐波那契查找（Fibonacci Search），利用了黄金分割来实现。 查找的流程，先举例实现吧，假设给定一个数组 $a[10] &#x3D; $ {0, 1, 16, 24, 35, 47, 59, 62,73, 88, 99}, 此时$n &#x3D; 10$，需要查找的键为 $key &#x3D; 99$ 先定义一个斐波那契数列 F[n] 下标 0 1 2 3 4 5 6 7 8 9 F 0 1 1 2 3 5 8 13 21 34 它原理之前有学习过，实现原理是递归原理，代码实现如下： F[0] = 0;F[1] = 1;for (int i = 2; i &lt; 100; i++) &#123; F[i] = F[i -1] + F[i - 2];&#125; 定义变量和下表 int low, high, mid, i, k;low = 1, high = n; 其中 low 、high分别为数组最低下标，默认 high为最大 计算 n 位于斐波那契数列的位置 while (n &gt; F[k]) -1 k++; 由于上文给出的数组长度$n &#x3D; 10$，得出 $F[6] &lt; n &lt; F[7]$， 所以此时 $k &#x3D; 7$，在队列中如图示 将不满的数值补全，用a[n]，为什么补齐？ for (i = n; i &lt; F[k] - 1; i++) &#123; a[i] = a[n];&#125; 开始查找： 设定初始条件 $low &lt;&#x3D; high$，假设查找 n &#x3D; 10，需要查找key &#x3D; 59 计算当前分割下标，$mid &#x3D; low + F[k - 1] -1$， 此时$mid &#x3D; 1 + F[7-1] -1 &#x3D;8$ 判断，若 $key &lt; a[mid]$ ，即如果查找记录小于当前分割记录 最高下标调整到分隔下标的 $mid -1$ 处 high = mid -1; 斐波那契数列下标减$1$位 k--; 这一步中 key 为59， a[mid] 及a[8] 为73，所以$key&lt;a[mid]$，需要进行调整， 如下图所示 此时各项参数结果为：$k &#x3D; 6, low &#x3D; 1, mid &#x3D; 8, high &#x3D; 7$ 继续循环查找。 计算当前分隔的下标：$mid &#x3D; F[6-1] - 1 &#x3D; 5$ 。 继续判断 key 与 a[mid]，此时 $a[5] &#x3D; 47 &lt; key$， 执行两个步骤： 最低下标调整到分割下标 $mid + 1$ 处 low = mid + 1; 斐波那契数列下标减2位 k = k - 2; 实现示意图如下： 此时各项参数结果为：$k &#x3D; 4, low &#x3D; 6, mid &#x3D; 5, high &#x3D; 7$ 再次循环。 计算当前分隔的下标：$mid &#x3D; 6 + F[4-1] -1 &#x3D; 7$。 继续判断 key 与 a[mid] 的大小，此时 $a[7] &#x3D; 62 &gt; key$，因此执行第三步的策略。 重复一下如下： 最高下标调整到分隔下标的 $mid -1$ 处 high = mid -1; 斐波那契数列下标减$1$位 k-- 实现示意图如下： 此时各项参数结果为：$k &#x3D; 3, low &#x3D; 6, mid &#x3D; 5, high &#x3D; 6$ 再次循环。 计算当前分隔的下标：$mid &#x3D; 6 + F[3-1] &#x3D;1 &#x3D; 6$ 判断 key 与 a[mid] ，此时 a[6] &#x3D; 59 &#x3D; key 。说明查找到，进行返回数组下标，返回值为 $6$ if(mid &lt; n) return mid;else return n; 回答为什么补齐$a[n]$ 在循环查找的过程中，如果查找的$key&#x3D;99$， 那么第一次查找时， $mid &#x3D; 8$； $low &#x3D; mid + 1 &#x3D; 9$ $k &#x3D; k - 2 &#x3D; 7 - 2 &#x3D; 5$ 第二次循环时，此时改变分隔mid 下标的值，$mid &#x3D;low + F[k - 1] - 1 &#x3D; 9 + 3 - 1 &#x3D; 11$， 而此时a[mid] 为a[11] ，数组a 中的11位时没有值，会导致下一步与 key 的比较失败，为了避免情况发生，对上文中将不满的数值补全，用 a[i] = a[n]。 2.2.2 算法核心根据上文的查找流程，总结一下算法核心 当 $key &#x3D; a[mid]$ 时，查找成功 当 $key &lt; a[mid]$ 时，新范围是第 low 个到第 mid -1 个，此时范围个数为 F[k - 1] - 1 个 当 $key &gt; a[mid]$ 时，新范围是第 m+1 个到第 high 个，此时范围个数为 F[k-2] -1 个 示意图如下： 2.2.2 算法实现先看看代码 int F[100];int Fibonnaci_Search(int *a, int n, int key)&#123; int low, high, mid, i, k; low = 1; high = n; k = 0; while (n &gt; F[k] - 1) &#123; k++; &#125; for (i = n; i &lt; F[k] - 1; i++) &#123; a[i] = a[n]; &#125; while (low &lt;= high) &#123; mid = low + F[k -1] -1; if (key &lt; a[mid]) &#123; high = mid -1; k--; &#125; else if (key &gt; a[mid]) &#123; low = mid++; k = k -2; &#125; else &#123; if (mid &lt;= n) return mid; else return n; &#125; &#125; return 0;&#125; 2.6 查找效率三种查找方式的公式如下，三种方式各有优劣，适合不同场景: 折半查找: $mid &#x3D; (low + high) &#x2F; 2$ 插值查找，适合: $mid &#x3D; low + \\frac{key - a[low]}{a[high] - a[low]} * (high - low)$ 斐波那契查找: $mid &#x3D; low + F[k - 1] - 1$ 优劣点即使用场景： 折半查找：适合数据规模较小，执行效率高 插值查找：适合数据规模较大，比折半查找更高效，但规模较小，以数值递增波动较大时与折半查找区别不大； 斐波那契：相比插值查找，适合数据递增波动较大的场景。 三、动态查找3.1 二叉排序树3.1.1 定义二叉排序树（Binary Sort Tree），又称为二叉查找树。它是一种空树，或者具有下列性质的二叉树： 若它的左子树不空，则右子树上所有结点的值均小于它的根结点的值 若它的右子树不空，则左子树上所有结点的值均大于它的根结点的值 它的左、右子树分别为二叉排序树 3.1.2 查找 二叉树的结构如下： typedef struct BitNode&#123; int data; // 数据域 struct BitNode *lChild, *rChild; // 指针分别指向左、右子树&#125;BitNode, *BiTree; 代码实现如下: Status SearchBST(BiTree T, int key, BiTree f, BiTree *p)&#123; if (!T) &#123; *p = f; return FALSE; &#125;else if( key == T-&gt;data)&#123; *p = T; return SUCCESS; &#125;else if(key &lt; T-&gt;data)&#123; return SearchBST(T-&gt;lChild, key, T, p); &#125;else&#123; return SearchBST(T-&gt;rChild, key, T, p); &#125;&#125; 分析查找流程: 判断树的有效性 指针 f 指向 T 结点的双亲，如果第一次，使用值为 NULL 判断结点数值与 目标值元素结点的数据是否相等 结点的值与目标值相等——指针 p 指向元素结点，返回成功 如果目标值key小于元素结点数据，在左子树上，进行查找函数递归 如果目标 key大于元素结点数据，在右子树上，进行查找函数递归 示意图如下： 3.1.3 插入插入的流程有以下几个步骤 先查找目标元素，如果存在，无需插入，返回 如果不存在，判断 目标值 key 与 指针p 如果大于，则 插入 s 为左孩子 如果小于，则插入 s 为右孩子 代码实现如下 Status InsertBST(BiTree *T, int key)&#123; BiTree p, s; if (!SearchBST(*T, key, NULL, &amp;p)) &#123; s = (BiTree)malloc(sizeof(BiTree)); s-&gt;data = key; s-&gt;lChild = s-&gt;rChild = NULL; if (!p) &#123; *T = s; &#125;else if (key &lt; p-&gt;data)&#123; p-&gt;lChild = s; &#125;else&#123; p-&gt;rChild = s; &#125; return SUCCESS; &#125;else&#123; return FALSE; &#125;&#125; 3.2.4 删除删除结点有三种情况分析: 叶子结点 仅有左&#x2F;右子树的结点 左右子树都有结点的 对应的策略如下： 当删除叶子结点： 无需操作，free 即可 当删除仅有左&#x2F;右子树的结点时： 将它的原子树移动到它的位置，替代他即可 当删除结点左右子树都有结点时： 找到待删结点的前缀 重接q 的右子树 重接q 的左子树 代码实现如下： Status DeleteBST(BiTree *p)&#123; BiTree q,s; // 右子树为空 if ((*p)-&gt;rChild == NULL) &#123; q = *p; *p = (*p)-&gt;lChild; free(q); // 左子树为空 &#125;else if ((*p)-&gt;lChild == NULL)&#123; q = *p; *p = (*p)-&gt;rChild; free(q); // 左右子树均不为空 &#125;else&#123; q = *p; s = (*p)-&gt;lChild; while (s-&gt;rChild) &#123; q = s; s = s-&gt;rChild; &#125; (*p)-&gt;data = s-&gt;data; if (q!= *p) &#123; q-&gt;rChild = s-&gt;lChild; &#125;else&#123; q-&gt;lChild = s-&gt;lChild; &#125; free(s); &#125; return SUCCESS;&#125; 示意图如下： 找到目标结点 $8$，标记为 p 将p 赋值给临时变量 q，再将其左子树赋值给临时变量 s 循环找到左子树的右结点，知道右侧尽头，得到结点$7$，将临时变量s指向该结点 将删除结点的数值赋值为 临时变量 s-&gt; data，即 p-&gt;data = s-&gt;data。 最后一步，将目标结点7 进行释放，至此，删除完成。 上述情况时最右侧结点为叶子结点，还有一种情况最右侧结点右子结点，该如何处理呢。 这里的步骤和上文一样，赋值临时变量p，s 找到目标结点6，将临时变量s 指向6 将删除结点的数值赋值为 临时变量 s-&gt; data，即 p-&gt;data = s-&gt;data。此时相当于结点6 被删除，它的子结点需要妥善处理。 此时如果 p 和 q 指向不相同，则将 6 的子树交给 它的父结点。 即 q-&gt;rChild = s-&gt;lChild。这样节点6 留下的左结点被链接进入树了。 最后一步，free 掉删除的目标结点 3.2.5 总结二叉排序树是以连接的方式存储，保持了链式存储结构在执行插入和删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。","categories":[],"tags":[{"name":"二分法","slug":"二分法","permalink":"http://nilsli.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"斐波那契","slug":"斐波那契","permalink":"http://nilsli.com/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"},{"name":"插值","slug":"插值","permalink":"http://nilsli.com/tags/%E6%8F%92%E5%80%BC/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://nilsli.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"【数据结构与算法10】拓扑排序","slug":"0513topsorting","date":"2020-05-13T09:49:41.000Z","updated":"2024-08-07T07:10:46.466Z","comments":true,"path":"p/96e21745.html","permalink":"http://nilsli.com/p/96e21745.html","excerpt":"","text":"一、概念定义 拓扑排序，其实就是对一个有向图构造拓扑序列的过程。 AOV 网在一个表示工程的有向图中，用定点表示活动，用弧表示活动之间的有限关系，这样的有向图为顶点表示活动的网，我们称为AOV 网(Activity On Vertex Network)。 拓扑序列设 G&#x3D; (V, E) 设一个具有n 个顶点的有向图， V 中的顶点序列 v1, v2, …… vn，满足若从订单 vi 到 vj 有一条路径，则在顶点序列中定点 vi 必在顶点 vj 之前。则我们称这样的顶点序列为一个拓扑序列。 二、排序算法三、流程解析","categories":[],"tags":[{"name":"图","slug":"图","permalink":"http://nilsli.com/tags/%E5%9B%BE/"},{"name":"拓扑","slug":"拓扑","permalink":"http://nilsli.com/tags/%E6%8B%93%E6%89%91/"}]},{"title":"【多线程】锁分析","slug":"0513lock","date":"2020-05-13T04:56:41.000Z","updated":"2024-08-07T07:10:46.445Z","comments":true,"path":"p/48b87814.html","permalink":"http://nilsli.com/p/48b87814.html","excerpt":"","text":"一、概念1.1 同步为了避免多个线程同时读写同一个数据而产生不可预料的后果，我们要将各个线程对同一个数据的访问同步（Synchronization）。 所谓同步，即指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。如此，对数据的访问被原子化了。 同步最常见的方法是使用锁（Lock）。 1.2 锁锁是一种非强制机制，每一个线程在访问数据或资源之前首先试图获取（Acquire）锁，并在访问结束之后释放（Release）锁。在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。 二、类型在计算机开发中，锁通常有3大类：自旋锁、互斥锁、条件锁。 2.1 自旋锁（SpinLock）特点线程反复检查变量是否可用。由于线程在这一过程中保持执行，因此属于忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。 例子 OSSpinLock 因为线程安全，现已被废弃 2.2 互斥锁（Mutex）特点防止两条线程同时对同一公共资源进行读写的机制。通过将代码切片成一个个临界区而实现。 例子 pthread_mutex @synchronized NSLock os_unfair_lock 2.3 条件锁（Condition Variable）特点作为一种同步手段，作用类似一个栅栏。当进程的某些资源要求不满足就进入休眠，也就是锁住。当资源被分配到了，条件锁打开，进程继续进行。 例子 NSCondition NSConditionLock 2.4 递归锁(recursive)特点同一个线程可以加锁N 次而不会引起死锁 例子 NSRecursiveLock pthread_mutex(recursive) 2.5 信号量（Semaphore）特点允许多给写线程并发访问的资源，简称信号量，一个初始值为N的信号量允许N个线程并发放温。 线程访问资源时做以下操作: 信号值减1 如果信号值小于0，则进入等待状态，否则继续执行 线程访问完资源后，释放信号量时操作如下： 信号量得值加1 如果信号量的值小于1，唤醒一个等待中的线程 例子 dispatch_semaphore 三、常见锁分析3.1 递归锁 - @synchronized分析3.1.1 引子先编写 如下代码，并打开汇编诊断（Xcode中，Debug——Debug Flow——Always Show Dissembly） @synchronizedd (self) &#123; NSLog(@&quot;hey jude&quot;);&#125; 得到如下调用栈： 留意到有objc_sync_enter 以及objc_sync_exit，进入退出一一匹配，猜测可能就是锁的加锁与解锁。先不管了，找到objc 开源库 3.1.2 objc_sync_enter在objc4 中可以找到objc_sync_enter 函数，它的作用是：开始锁住obj，如有必要，开辟递归互斥锁关联到obj，一旦锁被获取到，返回OBJC_SYNC_SUCCESS的标识 &#x2F;&#x2F; Begin synchronizing on ‘obj’. &#x2F;&#x2F; Allocates recursive mutex associated with ‘obj’ if needed. &#x2F;&#x2F; Returns OBJC_SYNC_SUCCESS once lock is acquired. 函数实现如下： int objc_sync_enter(id obj)&#123; int result = OBJC_SYNC_SUCCESS; if (obj) &#123; SyncData* data = id2data(obj, ACQUIRE); ASSERT(data); data-&gt;mutex.lock(); &#125; else &#123; // @synchronizedd(nil) does nothing if (DebugNilSync) &#123; _objc_inform(&quot;NIL SYNC DEBUG: @synchronizedd(nil); set a breakpoint on objc_sync_nil to debug&quot;); &#125; objc_sync_nil(); &#125; return result;&#125; 分析一下方法实现： 如果加锁目标对象不存在，不作操作 // @synchronizedd(nil) does nothing if (DebugNilSync) &#123; _objc_inform(&quot;NIL SYNC DEBUG: @synchronizedd(nil); set a breakpoint on objc_sync_nil to debug&quot;); &#125; objc_sync_nil(); 注释已经写得很清楚了，does nothing。继续看objc_sync_nil 如何实现 BREAKPOINT_FUNCTION( void objc_sync_nil(void)); 的确，啥也没干。这样也解释了某些场合下，锁一个空对象，是不会做操作的。 如果传入对象存在 if (obj) &#123; SyncData* data = id2data(obj, ACQUIRE); ASSERT(data); data-&gt;mutex.lock(); 防止死锁：这里的SyncData 拥有next 指向的递归锁结构，好处就是最终总会有 object 为 nil，会跳出循环，不会死锁。 这里的好处就是最终总会有 object 为 nil，会跳出循环，防止死锁。 typedef struct alignas(CacheLineSize) SyncData &#123; struct SyncData* nextData; DisguisedPtr&lt;objc_object&gt; object; int32_t threadCount; // number of THREADS using this block recursive_mutex_t mutex;&#125; SyncData; 里面有数据域：DisguisedPtr、threadCount、recursive_mutex_t，以及指针域：SyncData* nextData 继续看 id2data 的实现如下： 查询当前单一线程的快速缓存文件匹配。 如果有，对锁住的次数，根据传入参数类型(获取、释放、查看)，分别进行操作。 如果是获取资源：锁次数++ 如果是释放资源：锁次数–。当然如果次数变为0，此时锁也不复存在，需要从快速缓存移除。 如果是查看资源：不操作。 相关代码精简如下： SyncData *data = (SyncData *)tls_get_direct(SYNC_DATA_DIRECT_KEY);if (data)&#123; uintptr_t lockCount; switch(why)&#123; case ACQUIRE: &#123; lockCount++; case RELEASE: lockCount--; if (lockCount == 0) &#123; // remove from fast cache tls_set_direct(SYNC_DATA_DIRECT_KEY, NULL); case CHECK: // do nothing break; &#125;&#125; 查询所有线程内部缓存文件与锁持有对象的匹配 首先会查找一个线程缓存SyncCache，查找的过程是这样的（有精简）： static SyncCache *fetch_cache(bool create)&#123; _objc_pthread_data *data; data = _objc_fetch_pthread_data(create); /* 省略部分*/ // Make sure there&#x27;s at least one open slot in the list. if (data-&gt;syncCache-&gt;allocated == data-&gt;syncCache-&gt;used) &#123; data-&gt;syncCache-&gt;allocated *= 2; data-&gt;syncCache = (SyncCache *) realloc(data-&gt;syncCache, sizeof(SyncCache) + data-&gt;syncCache-&gt;allocated * sizeof(SyncCacheItem)); &#125; return data-&gt;syncCache;&#125; 先创建一个_objc_pthread_data 类型的线程数据 查看线程私有数据，如果有，就会更新data 接下来对同步缓存容量查看，如果使用已满（allocated &#x3D;&#x3D; used），会进行 *2 扩建扩容 接下来将同步缓存返回 有意思的是这个syncCache 是专门针对@synchronized 准备的，如下图 接下来根据缓存文件SyncCache 的存在，进行循环遍历，取出cache内的元素—— SyncCacheItem 结构体，根据传入参数类型(获取、释放、查看)，进行内部属性，分别进行操作。 如果是获取资源：锁次数++ case ACQUIRE: item-&gt;lockCount++;= 如果是释放资源：锁次数–。当然如果次数变为0，需要从线程缓存数据移除。 case RELEASE: item-&gt;lockCount--; if (item-&gt;lockCount == 0) &#123; // remove from per-thread cache cache-&gt;list[i] = cache-&gt;list[--cache-&gt;used]; 如果是查看资源：不操作。 case CHECK: // do nothing 去已使用列表查找匹配对象（快速、慢速缓存均未找到） 在介绍步骤之前，先普及一下已使用列表（in-use list） 的结构。在这个id2data函数执行初始时，执行了两个代码 static SyncData* id2data(id object, enum usage why)&#123; spinlock_t *lockp = &amp;LOCK_FOR_OBJ(object); SyncData **listp = &amp;LIST_FOR_OBJ(object); 即生成了一个名为lockp 的自旋锁，以及SyncData 指针对象。而LOCK_FOR_OBJ与LIST_FOR_OBJ是两个宏操作，如下： // Use multiple parallel lists to decrease contention among unrelated objects.#define LOCK_FOR_OBJ(obj) sDataLists[obj].lock#define LIST_FOR_OBJ(obj) sDataLists[obj].datastatic StripedMap&lt;SyncList&gt; sDataLists; 看得出都说在查找一个sDataLists 的列表元素的lock、data属性，这个表结构比较简单： struct SyncList &#123; SyncData *data; spinlock_t lock; constexpr SyncList() : data(nil), lock(fork_unsafe_lock) &#123; &#125;&#125;; 接下来重点关注一下StripedMap 这个类，可以成为条纹映射map，是一种结构void* -&gt; T的map，有一个indexForPointer 的函数，用来指向内部存储的对象——即缓存的syncData 对象 static unsigned int indexForPointer(const void *p) &#123; uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p); return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;&#125; 好的，接下来看 先加锁 如果找到，添加到快速缓存以及线程内缓存里 #if SUPPORT_DIRECT_THREAD_KEYS if (!fastCacheOccupied) &#123; // Save in fast thread cache tls_set_direct(SYNC_DATA_DIRECT_KEY, result); tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)1); &#125; else #endif &#123; // Save in thread cache if (!cache) cache = fetch_cache(YES); cache-&gt;list[cache-&gt;used].data = result; cache-&gt;list[cache-&gt;used].lockCount = 1; cache-&gt;used++; &#125; 如果未找到，创建新的data，并加入到datalist 内部 posix_memalign((void **)&amp;result, alignof(SyncData), sizeof(SyncData));result-&gt;object = (objc_object *)object;result-&gt;threadCount = 1;new (&amp;result-&gt;mutex) recursive_mutex_t(fork_unsafe_lock);result-&gt;nextData = *listp;*listp = result; 解锁 小结：这个查找锁的过程，很类似方法查找的过程，先通过缓存查找，接着在方法列表里查找，如果查找不到，会创建一个并加入到列表以及二级缓存中，进行返回。 对已获取的data 加锁 执行如下操作： result = data-&gt;mutex.tryLock(); 这里会返回这个tryLock 的实现是一个递归互斥锁的执行结果，具体实现如下： bool tryLock()&#123; if (os_unfair_recursive_lock_trylock(&amp;mLock)) &#123; lockdebug_recursive_mutex_lock(this); return true; &#125; return false;&#125; 3.1.3 objc_send_exit分析完了enter，再看看如何对@synchronized 如何离开。 函数主要操作是： 终止同步锁obj， 返回OBJC_SYNC_SUCCESS（成功） 或者OBJC_SYNC_NOT_OWNING_THREAD_ERROR（失败） &#x2F;&#x2F; End synchronizing on ‘obj’. &#x2F;&#x2F; Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR 查看同步数据是否存在 主函数实现精简如下 SyncData* data = id2data(obj, RELEASE); if (!data) &#123; result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; &#125; else &#123; bool okay = data-&gt;mutex.tryUnlock(); if (!okay) &#123; result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; &#125; &#125; 如果锁列表里找不到obj，即加锁对象不存在，退出并报出对象同步未拥有的线程错误 如果有找到，尝试解锁tryUnlock。这里的解锁也是递归锁的解锁，具体实现如下： bool tryUnlock()&#123; if (os_unfair_recursive_lock_tryunlock4objc(&amp;mLock)) &#123; lockdebug_recursive_mutex_unlock(this); return true; &#125; return false;&#125; 如果解锁失败，也报出对象同步未拥有的线程错误 3.1.4 总结 针对pthread 进行了封装，体现在tls 的查找机制。 @synchronized 分为高速缓存、线程内数据缓存（tls）以及已使用对象的列表进行加锁缓存 加锁为一个syncList 的列表，列表内有多个syncData 的对象 外界对加锁对象的获取&#x2F;释放，会相应的对同步数据节点的属性+1&#x2F;-1 优点：采用缓存机制，不会产生死锁 3.1.5 引申先看一下会打印什么，注意，这里对self.arr 进行了@synchronized 锁操作？ for (int i = 0; i &lt; 100000; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; @synchronizedd (self.arr) &#123; self.arr = [NSMutableArray array]; &#125; &#125;);&#125; 结果，会崩溃 为什么，注意到这个可变数组 self.arr 一直属于 nil，那上文源码中得知： // @synchronizedd(nil) does nothing if (DebugNilSync) &#123; _objc_inform(&quot;NIL SYNC DEBUG: @synchronizedd(nil); set a breakpoint on objc_sync_nil to debug&quot;); &#125; 即去锁一个空对象，是不会有锁操作，反而会报错崩溃。 解决 解决方案也简单： 对self 进行同步锁，这个似乎太臃肿了 也可以使用引入NSLock 进行锁定，如下操作： for (int i = 0; i &lt; 100000; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLock *lock = [[NSLock alloc] init]; self.arr = [NSMutableArray array]; [lock lock]; &#125;);&#125; 下面来分析一下NSLock 3.2 互斥锁 - NSLock 的分析大家都知道OC 中Foundation 并没有开源，所以无从查看NSLock 的实现，但是Swift 对Foundation 却开源了， 我们不妨曲线救国，在Swift 中一探究竟。相关Swift Foundation的源码可以在苹果的Github仓库 下载 3.2.1 创建 类的生成 open class NSLock: NSObject, NSLocking &#123; // 内部私有的互斥锁，容量创建为1 internal var mutex = _MutexPointer.allocate(capacity: 1) 公用的init方法如下： public override init() &#123; pthread_mutex_init(mutex, nil)#if os(macOS) || os(iOS) pthread_cond_init(timeoutCond, nil) pthread_mutex_init(timeoutMutex, nil)#endif#endif &#125; 可见，这个类的初始化，对内部的pthread_mutex_init 进行了操作，初始化局部变量互斥锁mutex 3.2.2 加锁加锁的过程很简单，就是对内部这个互斥锁加锁 open func lock() &#123; pthread_mutex_lock(mutex)&#125; 这里使用的是常见的pthread_mutex_lock 函数用来操作互斥锁。这里的问题是，如果mutex 当前被锁住，执行函数，会让当前线程阻塞，直到mutex状态改变为可以执行位置。 在这种情况下，大胆的猜测一下，当多次调用NSLock 的lock 方法时（递归），会反复调用mutex，造成锁等待，谁也开不了谁，最终线程阻塞，影响性能。 可见 NSLock 虽好，可以有造成线程阻塞的风险，尤其是进行递归循环的时候。 3.2.3 解锁 open func unlock() &#123; pthread_mutex_unlock(mutex)#if os(macOS) || os(iOS) // Wakeup any threads waiting in lock(before:) pthread_mutex_lock(timeoutMutex) pthread_cond_broadcast(timeoutCond) pthread_mutex_unlock(timeoutMutex)#endif#endif &#125; 解锁时，会对当前的mutex 进行解锁，以及超时解锁（使用） 3.3 递归锁与互斥锁区别3.3.4 阻塞分析及解决提问：下面会打印什么： - (void)showLock&#123; NSLock *lock = [[NSLock alloc] init]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; static void (^test)(int); test = ^(int value)&#123; [lock lock]; NSLog(@&quot;加锁🔐&quot;); if (value &gt; 0) &#123; NSLog(@&quot;value1 %d&quot;, value); test(value - 1); NSLog(@&quot;value2 %d&quot;, value); &#125; NSLog(@&quot;开锁🔐&quot;); [lock unlock]; &#125;; test(5); &#125;);&#125; 结果会不会是 5-1 &#x3D;4 ? 看一下打印如下： 2020-05-22 17:39:13.720485+0800 DDD[7989:543814] 加锁🔐2020-05-22 17:39:13.720724+0800 DDD[7989:543814] value1 5 记过很残酷，block 只进行到第一个 NSLog 就不走了，第二个NSLog 都不再走了。 原因：递归调用普通的互斥锁，会造成线程阻塞（因为不会查询缓存）。block 反复调用自身block，都走不到 解决：使用递归锁 NSCursiveLock 替换 NSLock 即代码为： - (void)showLock&#123; NSRecursiveLock *lock = [[NSRecursiveLock alloc] init]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; static void (^test)(int); test = ^(int value)&#123; [lock lock]; NSLog(@&quot;加锁🔐&quot;); if (value &gt; 0) &#123; NSLog(@&quot;value1 %d&quot;, value); test(value - 1); &#125; [lock unlock]; &#125;; test(5); &#125;);&#125; 打印结果如下： 2020-05-22 17:51:20.645879+0800 DDD[8048:551083] 加锁🔐2020-05-22 17:51:20.646149+0800 DDD[8048:551083] value1 52020-05-22 17:51:20.646378+0800 DDD[8048:551083] 加锁🔐2020-05-22 17:51:20.646562+0800 DDD[8048:551083] value1 42020-05-22 17:51:20.646739+0800 DDD[8048:551083] 加锁🔐2020-05-22 17:51:20.646890+0800 DDD[8048:551083] value1 32020-05-22 17:51:20.647074+0800 DDD[8048:551083] 加锁🔐2020-05-22 17:51:20.647220+0800 DDD[8048:551083] value1 22020-05-22 17:51:20.648720+0800 DDD[8048:551083] 加锁🔐2020-05-22 17:51:20.648967+0800 DDD[8048:551083] value1 12020-05-22 17:51:20.649133+0800 DDD[8048:551083] 加锁🔐 此时不再阻塞，递归锁顺利完成了任务 内部实现：继续在Swift Foundation 查看NSRecursiveLock 的实现，结果如下： withUnsafeMutablePointer(to: &amp;attrib) &#123; attrs in pthread_mutexattr_init(attrs) pthread_mutexattr_settype(attrs, Int32(PTHREAD_MUTEX_RECURSIVE)) pthread_mutex_init(mutex, attrs) &#125; 可见同 NSLock 类似，它的实现是调用pthread_mutexattr_settype 函数，并且类型为PTHREAD_MUTEX_RECURSIVE 3.3.2 递归锁的死锁还是上面的例子，加一个for 循环，结果会如何呢？ - (void)showLock&#123; NSRecursiveLock *lock = [[NSRecursiveLock alloc] init]; for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; static void (^test)(int); test = ^(int value)&#123; [lock lock]; NSLog(@&quot;加锁🔐&quot;); if (value &gt; 0) &#123; NSLog(@&quot;value1 %d&quot;, value); test(value - 1); &#125; [lock unlock]; &#125;; test(5); &#125;); &#125;&#125; 结果很残酷，是这样的，又崩溃了（为什么要说又呢😿） 提示很明显，最后一行String release 释放一个野指针。。。 原因: for 循环在block 内部，对同一个对象进行了多次锁操作，最后大家都锁了一次，直到这个资源身上挂着N把锁，最后大家都无法一次性解锁——找不到解锁的出口 。 即 操作1-&gt; 加锁1-&gt; 加锁2-&gt; 操作1结束 -(有2的锁)- 无法结束解锁——形成死锁 **解决:**可以采用使用缓存的@synchronized ，因为它对对象进行所操作，会先从缓存查找是否有锁syncData 存在，如果有，直接返回而不加锁，保证锁的唯一性。 操作如下： - (void)showLock&#123; for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; static void (^test)(int); test = ^(int value)&#123; @synchronizedd (self) &#123; NSLog(@&quot;加锁🔐&quot;); if (value &gt; 0) &#123; NSLog(@&quot;value1 %d&quot;, value); test(value - 1); &#125; &#125; &#125;; test(5); &#125;); &#125;&#125; 结果：也很和谐如下： 2020-05-22 18:17:02.225527+0800 DDD[8255:571494] 加锁🔐2020-05-22 18:17:02.225658+0800 DDD[8255:571494] value1 52020-05-22 18:17:02.225762+0800 DDD[8255:571494] 加锁🔐2020-05-22 18:17:02.225841+0800 DDD[8255:571494] value1 42020-05-22 18:17:02.225931+0800 DDD[8255:571494] 加锁🔐2020-05-22 18:17:02.226324+0800 DDD[8255:571494] value1 32020-05-22 18:17:02.226424+0800 DDD[8255:571494] 加锁🔐2020-05-22 18:17:02.226521+0800 DDD[8255:571494] value1 22020-05-22 18:17:02.226977+0800 DDD[8255:571494] 加锁🔐2020-05-22 18:17:02.227604+0800 DDD[8255:571494] value1 12020-05-22 18:17:02.228490+0800 DDD[8255:571494] 加锁🔐 3.3.3 递归锁内部区别 @synchronized 采用缓存机制，不会造成死锁 NSRecursiveLock 异步循环调用时，会造成多次加锁，造成死锁 3.3.4 应用场景 普通场景下，涉及到安全，可以用NSLock 循环调用时用 NSRecursiveLock 循环调用时，如果要注意死锁，建议使用 @synchronized 3.4 条件锁分析A、NSCondiction实际上作为一个锁和一个线程检查器：锁主要为了当检测条件时保护数据源，执行条件引发的任务；县城检查其主要是根据条件决定是否运行线程，即线程是否被阻塞。 执行起来，主要有4个步骤 [condition lock] : 一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据原只被访问、修改一次，其他线程的命令需要在 lock外等待，直到 unlock 才可以访问 [condition unlock]： 与lock 同时使用 [condition wait] ; 让当前线程处于等待状态 [condition signal]: CPU发信号高速县城不用再等待，可以继续执行了 B、NSConditionLock是一种锁，一旦一个线程获得锁，其他线程一定等待。 主要有如下几个步骤： [lock lock] : 标识lock 期待获得锁，如果没有其他线程获得锁（此时不需要判断内部condition）那他能执行以下代码，如果已经有其他线程获得锁（可能是条件锁，或者无条件锁），则等待，知道其他线程解锁。 [lock lockWhenCondition: A]： 表示如果没有其它线程获得该锁，但是所内部的condition不等于条件A，他依然不能获得锁，仍然等待。如果内部的condition 等于条件A，并且没有其他线程获得该锁，则进入代码区，同时设置他获得该锁，其他任何线程都将等待它的代码完成，直至它解锁。 [lock unlockWhenCondition: A]：表示释放锁，同时把内部的condition 设置为A条件。 return [xxx lockWhenCondition: A before: B]表示如果锁定（没获得锁），并超过该时间则不再阻塞线程。但是需要注意的是：返回值是NO，它没有改变锁的状态，这个函数的目的在于可以实现两种状态下的处理。 总结一下：所谓的condition（状态值）是证书，内部通过整数来比较条件。","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://nilsli.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"锁","slug":"锁","permalink":"http://nilsli.com/tags/%E9%94%81/"}]},{"title":"【数据结构与算法】-（9）二叉树与顺序表实现","slug":"0426tree","date":"2020-04-26T04:09:11.000Z","updated":"2024-08-07T07:10:46.406Z","comments":true,"path":"p/919af6b6.html","permalink":"http://nilsli.com/p/919af6b6.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 【数据结构与算法】-（8）栈之算法题 【数据结构与算法】-（8.1）字符串去重算法 【数据结构与算法】-（8.2）字符串搜索算法和RK&amp;BP算法 【数据结构与算法】-（8.3）KMP算法 【数据结构与算法】-（9）二叉树与顺序表实现 一、概念1.1 树的定义 树是 n （n ≥ 0）个结点的有限集。n&#x3D;0时称为空树。 在任意一棵非空树中：（1）有且仅有一个特定的成为根（Root）的结点；（2）当 n &gt; 1 时，其余结点可分为m（m &gt; 0）个互不相交的有限集 T1、 T2、…… Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree），如下图所示： 子树如下图所示： 1.2 树的其他特性 度（Degree）：结点拥有的子树数成为结点的度。 度为0的结点成为叶子结点（Leaf）或终端结点 度不为0的结点成为非终端结点或分枝结点。 层次（Level）：指从根开始定义起，结点所在的楼层。（按照根结点为1开始依次算起） 深度（Depth）：树中结点的最大层次成为树的深度或高度。 子结点、双亲结点：结点的子树的根成为该结点的孩子（Child），相应地，该结点成为孩子的双亲结点（Parent） 1.3 二叉树的定义 二叉树（Binary Tree） 是 n （n ≥ 0）个结点的有限集合，该集合或为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 因为二叉树最多只能由左结点和右结点，一个普遍的二叉树如图 1.4 二叉树的基本特点1.4.1 特点 每个结点最多有两棵子树，所以二叉树中不存在度大于2度结点。 左子树和右子树顺序不可颠倒。 即使树中某结点只有一棵子树，也要区分他是左子树还是右子树。 1.4.2 基本形态 空二叉树 只有一个根结点 根结点只有左子树 根结点只有右子树 根结点既有左子树也有右子树 1.5 特殊的二叉树1.5.1 斜树顾名思义，所有的结点都只有左子树或右子树。所有结点只有左子树的叫左斜树，只有右子树的成为右斜树，两者统称为斜树。 1.5.2 满二叉树在一棵树中，如果所有的分支结点都存在左子树和右子树，并且所有的叶子都在同一层上，这样的二叉树称为满二叉树。 1.5.3 完全二叉树对一颗具有n个结点的二叉树按层序编号，如果编号为i（1≤ i ≤ n）的结点与同样深度的满二叉树中编号为i 的结点在二叉树中的位置完全相同，这棵二叉树称为完全二叉树。 如下图所示，完全二叉树并不要求所有子结点全部填满，只需要子树树按顺序排列。 换句通俗的话说，哥哥一家没生满二胎，弟弟一家不允许要孩子……🐶，否则就不是完全二叉树。 如下图中，11节点丢失的情况下，不可以称为完全二叉树 二、二叉树的存储结构2.1 顺序存储结构通常用数组来存储二叉树，先看看存储完全二叉树的情况 可以看到，二叉树中的元素按照顺序依次放入开辟好的数组内存空间里。 但是，凡事都有但是，在某些极端情况下，某一棵树，缺胳膊少腿儿，导致空间大大浪费，比如下图： 这棵树只有4个有效的结点，但是却不得不开辟从A～M一共13个结点的内存空间，这种情况的树，使用数组结构来存储，对内存空间是一种浪费。 2.2 二叉链表鉴于上文中数组结构无法更高效的表述二叉树，引入了链表的结构进行表述。 由于二叉树结构最多有两个孩子，所以引入的链表结点，结构分别为数据域、左孩子指针、右孩子指针 结点结构如下 左孩子 数据 右孩子 lChild data rChild 用代码来表述可以是这样的 struct BiTreeNode&#123; int data; BiTreeNode *lChild; BITreeNode *rChild;&#125;BiTreeNode, *BiTree 把上文中较特殊的二叉树，用这样的结点表述的二叉树结构如下： 三、二叉树的遍历 二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。 二叉树的遍历方法，主要有四种： 3.1 前序遍历遍历的规则是若二叉树为空，空操作返回；否则先访问根结点，然后前序遍历左子树，再前序遍历右子树 如图示： 3.2 中序遍历遍历的规则是若二叉树为空，空操作返回；否则从根结点开始（但此时并不遍历根结点），先前序遍历左子树，先遍历访问根结点，再前序遍历右子树。 如图示： 3.3 后序遍历遍历的规则是若二叉树为空，空操作返回；否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。 如图示 3.4 层序遍历遍历的规则是若二叉树为空，空操作返回；否则从树的第一层——也就是根结点开始访问，从上往下，在同一层时从左至右对结点逐个访问。 访问顺序如图示： 三、顺序存储下的实现3.1 顺序存储的实现3.1.1 二叉树基本操作 初始化环境 创建结点结构 typedef struct &#123; int level; //结点层 int order; //本层的序号(按照满二叉树给定序号规则)&#125;Position; 以及其他辅助条件 #define MAXSIZE 100 /* 存储空间初始分配量 */#define MAX_TREE_SIZE 100 /* 二叉树的最大结点数 */typedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 */typedef int CElemType; /* 树结点的数据类型，目前暂定为整型 */typedef CElemType SqBiTree[MAX_TREE_SIZE]; /* 0号单元存储根结点 */CElemType Nil = 0; /*设整型以0为空 或者以 INT_MAX(65535)*/ 初始化一个二叉树T Status InitBiTree(SqBiTree T)&#123; for (int i = 0; i &lt; MAX_TREE_SIZE; i++) &#123; //将二叉树初始化值置空 T[i] = Nil; &#125; return OK;&#125; 创建二叉树（放入数据） Status CreateBiTree(SqBiTree T)&#123; int i = 0; //printf(&quot;按层序输入结点的值(整型),0表示空结点, 输入999结束.结点数&lt;=%d\\n&quot;,MAX_TREE_SIZE); /* 1 --&gt;1 2 3 --&gt;2 4 5 6 7 --&gt;3 8 9 10 --&gt;4 1 2 3 4 5 6 7 8 9 10 Nil Nil Nil */ while (i &lt; 10) &#123; T[i] = i+1; printf(&quot;%d &quot;,T[i]); //结点不为空,且无双亲结点 if (i != 0 &amp;&amp; T[(i+1)/2-1] == Nil &amp;&amp; T[i] != Nil) &#123; printf(&quot;出现无双亲的非根结点%d\\n&quot;,T[i]); exit(ERROR); &#125; i++; &#125; //将空赋值给T的后面的结点 while (i &lt; MAX_TREE_SIZE) &#123; T[i] = Nil; i++; &#125; return OK;&#125; 清空二叉树 清空一棵二叉树，与构造一棵二傻树一样，只需将每个结点值置空即可。 可以直接定义一个新函数，将两个函数对等。 #define ClearBiTree InitBiTree 判断二叉树是否为空 只需判断根结点是否为空 Status BiTreeEmpty(SqBiTree T)&#123; //根结点为空,则二叉树为空 return T[0] == Nil;&#125; 获取二叉树的深度 计算深度，需要看从当前结点，到根结点经历的路径条数 int BiTreeDepth(SqBiTree T)&#123; int j = -1; int i; //找到最后一个结点 //MAX_TREE_SIZE -&gt; 100 -&gt; 10 目的找到最后一个结点10的位置 for (i = MAX_TREE_SIZE-1 ; i&gt;=0; i--) &#123; if (T[i] != Nil) break; &#125; do &#123; j++; &#125; while ( powl(2, j) &lt;= i); //计算2的次幂 return j;&#125; 3.1.2 结点操作 获取二叉树根结点的值 只需计算数组T 首结点的值即可 Status Root(SqBiTree T,CElemType *e)&#123; if (BiTreeEmpty(T)) &#123; return ERROR; &#125; *e = T[0]; return OK;&#125; 返回结点位置为e 的值 CElemType Value(SqBiTree T,Position e)&#123; /* Position.level -&gt; 结点层.表示第几层; Position.order -&gt; 本层的序号(按照满二叉树给定序号规则) */ //pow(2,e.level-1) 找到层序 printf(&quot;%d\\n&quot;,(int)pow(2,e.level-1)); //e.order printf(&quot;%d\\n&quot;,e.order); //4+2-2; return T[(int)pow(2, e.level-1)+e.order-2]; &#125; 修改结点位置e 的值 Status Assign(SqBiTree T,Position e,CElemType value)&#123; //找到当前e在数组中的具体位置索引 int i = (int)powl(2, e.level-1)+e.order -2; //叶子结点的双亲为空 if (value != Nil &amp;&amp; T[(i+1)/2-1] == Nil) &#123; return ERROR; &#125; //给双亲赋空值但是有叶子结点 if (value == Nil &amp;&amp; (T[i*2+1] != Nil || T[i*2+2] != Nil)) &#123; return ERROR; &#125; T[i] = value; return OK;&#125; 获取结点位置e 的双亲 CElemType Parent(SqBiTree T, CElemType e)&#123; //空树 if (T[0] == Nil) &#123; return Nil; &#125; for (int i = 1 ; i &lt; MAX_TREE_SIZE; i++) &#123; //找到e if (T[i] == e) &#123; return T[(i+1)/2 - 1]; &#125; &#125; //没有找到 return Nil;&#125; 获取某结点的左孩子 步骤为当前结点的 CElemType LeftChild(SqBiTree T,CElemType e)&#123; //空树 if (T[0] == Nil) &#123; return Nil; &#125; for (int i = 0 ; i &lt; MAX_TREE_SIZE-1; i++) &#123; //找到e if (T[i] == e) &#123; return T[i*2+1]; &#125; &#125; //没有找到 return Nil; &#125; 获取某结点的右孩子 CElemType RightChild(SqBiTree T,CElemType e)&#123; //空树 if (T[0] == Nil) &#123; return Nil; &#125; for (int i = 0 ; i &lt; MAX_TREE_SIZE-1; i++) &#123; //找到e if (T[i] == e) &#123; return T[i*2+2]; &#125; &#125; //没有找到 return Nil; &#125; 获取某结点的左兄弟 CElemType LeftSibling(SqBiTree T,CElemType e)&#123; /* 空树 */ if(T[0]==Nil) return Nil; for(int i=1;i&lt;=MAX_TREE_SIZE-1;i++) /* 找到e且其序号为偶数(是右孩子) */ if(T[i]==e&amp;&amp;i%2==0) return T[i-1]; return Nil; /* 没找到e */&#125; 获取某结点的右兄弟 CElemType RightSibling(SqBiTree T,CElemType e)&#123; /* 空树 */ if(T[0]==Nil) return Nil; for(int i=1;i&lt;=MAX_TREE_SIZE-1;i++) /* 找到e且其序号为奇数(是左孩子) */ if(T[i]==e&amp;&amp;i%2==1) return T[i+1]; return Nil; /* 没找到e */&#125; 3.1.3 遍历二叉树 前序遍历 void PreTraverse(SqBiTree T,int e)&#123; //打印结点数据 visit(T[e]); //先序遍历左子树 if (T[2 * e + 1] != Nil) &#123; PreTraverse(T, 2*e+1); &#125; //最后先序遍历右子树 if (T[2 * e + 2] != Nil) &#123; PreTraverse(T, 2*e+2); &#125;&#125;Status PreOrderTraverse(SqBiTree T)&#123; //树不为空 if (!BiTreeEmpty(T)) &#123; PreTraverse(T, 0); &#125; printf(&quot;\\n&quot;); return OK;&#125; 中序遍历 void InTraverse(SqBiTree T, int e)&#123; /* 左子树不空 */ if (T[2*e+1] != Nil) InTraverse(T, 2*e+1); visit(T[e]); /* 右子树不空 */ if (T[2*e+2] != Nil) InTraverse(T, 2*e+2);&#125;Status InOrderTraverse(SqBiTree T)&#123; /* 树不空 */ if (!BiTreeEmpty(T)) &#123; InTraverse(T, 0); &#125; printf(&quot;\\n&quot;); return OK;&#125; 后序遍历 void PostTraverse(SqBiTree T,int e)&#123; /* 左子树不空 */ if(T[2*e+1]!=Nil) PostTraverse(T,2*e+1); /* 右子树不空 */ if(T[2*e+2]!=Nil) PostTraverse(T,2*e+2); visit(T[e]);&#125;Status PostOrderTraverse(SqBiTree T)&#123; if(!BiTreeEmpty(T)) /* 树不空 */ PostTraverse(T,0); printf(&quot;\\n&quot;); return OK;&#125; 层序遍历 void LevelOrderTraverse(SqBiTree T)&#123; int i = MAX_TREE_SIZE-1; //找到最后一个非空结点的序号 while (T[i] == Nil) i--; //从根结点起,按层序遍历二叉树 for (int j = 0; j &lt;= i; j++) //只遍历非空结点 if (T[j] != Nil) visit(T[j]); printf(&quot;\\n&quot;);&#125; 3.2 链式存储的实现3.2.1 二叉树的基本操作 数据类型及结点结构如下： typedef char CElemType;CElemType Nil=&#x27; &#x27;; /* 字符型以空格符为空 */typedef struct BiTNode /* 结点结构 */&#123; CElemType data; /* 结点数据 */ struct BiTNode *lchild,*rchild; /* 左右孩子指针 */&#125;BiTNode,*BiTree; 初始化二叉树 只需对当前二叉树赋值为空即可。 Status InitBiTree(BiTree *T)&#123; *T=NULL; return OK;&#125; 创建二叉树 void CreateBiTree(BiTree *T)&#123; CElemType ch; //获取字符 ch = str[indexs++]; //判断当前字符是否为&#x27;#&#x27; if (ch == &#x27;#&#x27;) &#123; *T = NULL; &#125;else &#123; //创建新的结点 *T = (BiTree)malloc(sizeof(BiTNode)); //是否创建成功 if (!*T) &#123; exit(OVERFLOW); &#125; /* 生成根结点 */ (*T)-&gt;data = ch; /* 构造左子树 */ CreateBiTree(&amp;(*T)-&gt;lchild); /* 构造右子树 */ CreateBiTree(&amp;(*T)-&gt;rchild); &#125; &#125; 清空二叉树 这里的逻辑与数组存储树一样的，逻辑等于初始化二叉树，用新函数来等同于它。 #define ClearBiTree DestroyBiTree 销毁二叉树 void DestroyBiTree(BiTree *T)&#123; if(*T) &#123; /* 有左孩子 */ if((*T)-&gt;lchild) DestroyBiTree(&amp;(*T)-&gt;lchild); /* 销毁左孩子子树 */ /* 有右孩子 */ if((*T)-&gt;rchild) DestroyBiTree(&amp;(*T)-&gt;rchild); /* 销毁右孩子子树 */ free(*T); /* 释放根结点 */ *T=NULL; /* 空指针赋0 */ &#125;&#125; 判断二叉树是否为空 Status BiTreeEmpty(BiTree T)&#123; if(T) return FALSE; else return TRUE;&#125; 获取二叉树的深度 int BiTreeDepth(BiTree T)&#123; int i,j; if(!T) return 0; //计算左孩子的深度 if(T-&gt;lchild) i=BiTreeDepth(T-&gt;lchild); else i=0; //计算右孩子的深度 if(T-&gt;rchild) j=BiTreeDepth(T-&gt;rchild); else j=0; //比较i和j return i&gt;j?i+1:j+1;&#125; 3.2.2 结点操作 获取二叉树根结点的值 CElemType Root(BiTree T)&#123; if (BiTreeEmpty(T)) return Nil; return T-&gt;data;&#125; 获取指针p 指向的结点的值 CElemType Value(BiTree p)&#123; return p-&gt;data;&#125; 给p 指向的结点赋值 void Assign(BiTree p,CElemType value)&#123; p-&gt;data=value;&#125; 3.2.3 遍历操作 前序遍历 void PreOrderTraverse(BiTree T)&#123; if(T==NULL) return; printf(&quot;%c&quot;,T-&gt;data);/* 显示结点数据，可以更改为其它对结点操作 */ PreOrderTraverse(T-&gt;lchild); /* 再先序遍历左子树 */ PreOrderTraverse(T-&gt;rchild); /* 最后先序遍历右子树 */&#125; 中序遍历 void InOrderTraverse(BiTree T)&#123; if(T==NULL) return ; InOrderTraverse(T-&gt;lchild); /* 中序遍历左子树 */ printf(&quot;%c&quot;,T-&gt;data);/* 显示结点数据，可以更改为其它对结点操作 */ InOrderTraverse(T-&gt;rchild); /* 最后中序遍历右子树 */&#125; 后序遍历 void PostOrderTraverse(BiTree T)&#123; if(T==NULL) return; PostOrderTraverse(T-&gt;lchild); /* 先后序遍历左子树 */ PostOrderTraverse(T-&gt;rchild); /* 再后序遍历右子树 */ printf(&quot;%c&quot;,T-&gt;data);/* 显示结点数据，可以更改为其它对结点操作 */&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://nilsli.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"http://nilsli.com/tags/%E6%A0%91/"},{"name":"二叉树","slug":"二叉树","permalink":"http://nilsli.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【数据结构与算法】-（8.3）KMP算法","slug":"0423kmp","date":"2020-04-23T10:09:33.000Z","updated":"2024-08-07T07:10:46.399Z","comments":true,"path":"p/22d3726c.html","permalink":"http://nilsli.com/p/22d3726c.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 【数据结构与算法】-（8）栈之算法题 【数据结构与算法】-（8.1）字符串去重算法 【数据结构与算法】-（8.2）字符串搜索算法和RK&amp;BP算法 〇、引言在上篇文章中，我们着重介绍了朴素算法（BF算法）以及RK算法，是否还有更优的选择呢， 一、概念 克努斯-莫里斯-普拉特算法 在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个主文本字符串S内查找一个词W的出现位置。此算法通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。 这个算法是由高德纳和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终由三人于1977年联合发表。 二、原理2.1 回顾BF 算法再次回顾一下字符串查找的题目，给定一个字符串S = &#39;abcdbdacd&#39; ，模式串T = &#39;abcdz&#39;&#39; ，在这个场景下，S 和 T 的前4个字符都相等，从第5个字符开始不等。查找流程，如果所示 2.2 弊端：无用回溯从上面可以看到，按照之前的 BF 算法， 也就是朴素算法， 当模式串T 与主串S不一致时候，会将主串的起始序号i 回溯至2，模式串j回溯至1，重新开始匹配。 这样看起来非常有条理，代码写起来也容易看懂，但是是不是有些冗余呢？ 这么说吧，给出的条件模式串T 中的 abcdz，第一位a与其他位的字符均不相，那么对比结果后，主串中的S 的首字符a 同样与不相等呢? 那么此时拿T中的首字符a 与S 中前2-5位字符，可以得知，必然都不相等。 那么，是不是可以，将主串S中，确定与模式串T匹配过的那一部分字符跳过——也就是主串的 i 不再进行回溯，而只移动模式串T呢？答案是可以的，不过要分两种情况。 2.3 场景A：模式串T 无重复看看图所示。 在S 和 T模式串 T 中前4位均匹配，第5位匹配失败。 由于的abcd 均不相等，而第5位失败后，我们可以轻易得知，模式串首位a 与主串的前4位均不相等，故可以直接将主串的 i 移动到第5位与模式串相比。 此时 i 不变，j 回归到1 2.4 场景B：模式串T有重复那么，如果模式串中，如果有其他字符与a 重复，是不是也可以全部跳过呢？ 当然不是。 我们设定一个场景，主串S &#x3D; abcabd，模式串为T &#x3D; abcabz 我们通过BF 朴素算法再次排列一下，如图所示 可见，由于模式串中首位a 与第二、三位的b、c 均不相等，所以第2、3步均为多余步骤，可以跳过。 而来到第4步时，由于模式串T 自身有重复的字符，即第1位&#x3D;第4位，第2位&#x3D;第5位。 在第1步中，模式串T 的第4位、第5位的a、b 均与 主串的第4、5位匹配过，是一一对应相等的。 那么等于说，第4步中，模式串的首字符a、b，被移动与S 的第4、5位去匹配，也可以省略。 汇总一下：模式串中有与首字符相同的字符，可以跳过一些重复判断步骤。 如下图所示，这样的步骤就可以跳过： 从上图中可以看到，主串的 i是不会像BF算法一样，反复的回溯的， 这也是KMP算法的重要的一点，这样可以省掉一部分的时间复杂度。 2.5 思考归纳另外，j值的变化也值得寻味。 场景A中，由于模式串没有重复元素，j 从5回到了1 （重复数0） 而在场景B中，由于模式串中的 T &#x3D; abcabz，ab 是重复的，此时 j 跳到了3（重复数2）。 这里根据反复的思考，得出 j 值变化多少，与重复数量——也就是前缀，后缀相似度有关。 这里KMP算法，引入了一个next 数组，专门用来保管 j值的变化，数组结果如下 究竟是怎么来的，继续探索 2.5 逆推next 数组探索之前，要牢记一句话：next数组用来保存 j 的变化后的位置。 2.5.1 模式串为：abcdef j 123456 模式串T abcdef 当 j &#x3D; 1 时，next[j] &#x3D; 1 ，属第一种情况 当 j &#x3D; 2 时，此时 j 从1位（a）到 j - 1 （b）位中，只有一个字符 ‘a’， 属于其他情况，此时 next[2] &#x3D; 1 当 j &#x3D; 3 时，此时 j 从1位（a）到 j - 1 （ab）位中，有2个字符 ‘ab’，但是a、b并不相等，第二种情况并不满足，所以此时 next[3] &#x3D; 1 当 j &#x3D; 4 时，此时 j 从1位（a）到 j - 1 （ab）位中，有3个字符 ‘abc’，但是a、b、c并不相等，第二种情况并不满足，所以此时 next[4] &#x3D; 1 当 j &#x3D; 5 时，此时 j 从1位（a）到 j - 1 （abcde）位中，有4个字符 ‘abcd’，但是a、b、c、d并不相等，第二种情况并不满足，所以此时 next[5] &#x3D; 1 于是总结一下得出next 数组为 01111。 j 12345 模式串T abcde next[j] 01111 2.5.2 模式串为：abcabf j 123456 模式串 abcabf 当 j &#x3D; 1 时，next[j] &#x3D; 1 ，属第一种情况 当 j &#x3D; 2 时，此时 j 从1位（a）到 j - 1 （b）位中，只有一个字符 ‘a’， 属于其他情况，此时 next[2] &#x3D; 1 当 j &#x3D; 3 时，此时 j 从1位（a）到 j - 1 （ab）位中，有2个字符 ‘ab’，但是a、b并不相等，第二种情况并不满足，所以此时 next[3] &#x3D; 1 当 j &#x3D; 4 时，此时 j 从1位（a）到 j - 1 （ab）位中，有3个字符 ‘abc’，但是a、b、c并不相等，第二种情况并不满足，所以此时 next[4] &#x3D; 1 当 j &#x3D; 5 时，此时 j 从1位（a）到 j - 1 （abcde）位中，有4个字符 ‘abcd’，第1位、第4位的a相等，所以此时k &#x3D; 5，即next[5] &#x3D; 2 当 j &#x3D; 6 时，此时 j 从1位（a）到 j - 1 （abcde）位中，有4个字符 ‘abcd’，第1位、第4位的a相等，所以此时k &#x3D; 5，即next[5] &#x3D; 2 于是总结一下得出next 数组为 011123。 j 123456 模式串 abcabf next[j] 011123 2.5.3 模式串为：abcbbabc j 12345678 模式串 abcbbabc 当 j &#x3D; 1 时，next[j] &#x3D; 1 ，属第一种情况 当 j &#x3D; 2 时，此时 j 从1位（a）到 j - 1 （b）位中，只有一个字符 ‘a’， 属于其他情况，此时 next[2] &#x3D; 1 当 j &#x3D; 3 时，此时 j 从1位（a）到 j - 1 （ab）位中，有2个字符 ‘ab’，但是a、b并不相等，第二种情况并不满足，所以此时 next[3] &#x3D; 1 当 j &#x3D; 4 时，此时 j 从1位（a）到 j - 1 （ab）位中，有3个字符 ‘abc’，但是a、b、c并不相等，第二种情况并不满足，所以此时 next[4] &#x3D; 1 当 j &#x3D; 5 时，此时 j 从1位（a）到 j - 1 （abcb）位中，有4个字符 ‘abcb’，虽然第2、第4相等，但是并不满足前缀相等，所以此时k &#x3D; 5，即next[5] &#x3D; 1 当 j &#x3D; 6 时，此时 j 从1位（a）到 j - 1 （abcba）位中，abcba，首位相等，取第一位 + 1，所以此时k &#x3D; 2，即next[6]] &#x3D; 2 当 j &#x3D; 7 时，此时 j 从1位（a）到 j - 1 （abcbab）位中，abcbab，首位相等，取第2位 + 1，所以此时k &#x3D; 3，即next[7] &#x3D; 3 当 j &#x3D; 8 时，此时 j 从1位（a）到 j - 1 （abcbab）位中，abcbab，首位相等，取第3位 + 1，所以此时k &#x3D; 4，即next[8] &#x3D; 4 综上所述，这时的next数组为 01111234 j 12345678 模式串 abcbbabc next[j] 01111234 2.5.4 模式串为：aaaaab j 123456 模式串 aaaaab 分析如下： 当 j &#x3D; 1 时，next[j] &#x3D; 1 ，属第一种情况 当 j &#x3D; 2 时，当 j &#x3D; 2 时，此时 j 从1位（a）到 j - 1 （b）位中，只有一个字符 ‘a’， 属于其他情况，此时 next[2] &#x3D; 1 当 j &#x3D; 3 时，此时 j 从1位（a）到 j - 1 （aa）位中，有aa 相等，取前面出现的序号+1，得k &#x3D; 1+1&#x3D;2，即 next[3] &#x3D; 2 当 j &#x3D; 4 时，此时 j 从1位（a）到 j - 1 （aaa）位中，前缀为 aa，后缀也为 aa， 取前面出现的序号+1，得k &#x3D; 2+1&#x3D;2，即 next[3] &#x3D; 3 当 j &#x3D; 5 时，此时 j 从1位（a）到 j - 1 （aaaa）位中，有aaa ，后缀 aaa，后缀也是 aaa 取前面出现的序号+1，得k &#x3D; 3+1&#x3D;4，即 next[3] &#x3D; 4 当 j &#x3D; 6 时，此时 j 从1位（a）到 j - 1 （aaaaa）位中，有aaaaa ，后缀 aaaa，后缀也是 aaa 取前面出现的序号+1，得k &#x3D; 4+1&#x3D;4，即 next[3] &#x3D; 5 综上所述，此时的 next 数组为 0123456 j 123456 模式串 aaaaab next[j] 012345 三、代码实现3.1 获取next 数组总结了半天next 数组，现在先来用代码创建一下 先定义一个特定的String 数组，用来装字符数组 typedef char String[MAXSIZE+1]; /* 0号单元存放串的长度 */void get_nextArray(String T, int *next)&#123; int i, j; i = 1; j = 0; next[1] = 0; // 这是第一种情况，初始为0 while ( i &lt; T[0]) // 循环上限为模式串的长度 &#123; // 比较模式串 T 的前缀后缀俩字符, //若相等，分别递增 if( j == 0 || T[i] == T[j]) &#123; ++i; ++j; next[i] = j; &#125; else &#123; // 如果不相等， j 回溯回当前 j = next[j] ; &#125; &#125;&#125; 3.2 获取匹配的字符串拿到了当前的next 数组，现在就把它用起来吧 int getIndexKMP(String S, String T, int pos)&#123; // s = 主串 // T = 模式串 // pos = 最终符合需求的位置 int i = pos; int j = 1; // next 数组的初始化 int next[255]; // 根据模式串，定义出next get_nextArray(T, next); // 开始判断 while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) &#123; // 主串与字串如果相等，继续 if (j == 0 || S[i] == T[j]) &#123; ++i; ++j; &#125;else&#123; // 两者不相等， j 回溯，具体位置为数组中的值 j = next[j]; &#125; &#125; // 如果 j 的长度大于模式串长度，即已经取得成功 if (j &gt; T[0]) return i - T[0]; else return 0;&#125; 3.3 运行检验IDE 里操作一下，奥利给！ int main(int argc, const char * argv[]) &#123; // insert code here... printf(&quot;第一次查询&quot;); String S, T; StrAssign(S, &quot;cccaababcabc&quot;); StrAssign(T, &quot;abc&quot;); int result = getIndexKMP(S, T, 1); if (result &gt; 0) &#123; printf(&quot;在里面的序号为: %d\\n\\n&quot;, result); &#125;else&#123; printf(&quot;查找失败，主串并无匹配的模式串!\\n\\n&quot;); &#125; return 0;&#125; 结果如下： 给出的 S = cccaababcabc ， T = abc ，结果是从第7位开始重复，命中！ 四、优化改进4.1 分析不足上面已经基本实现了KMP算法的时间部分，但是——有些场景还是会有些不理想。 假设给出S = aaaaabcdefgh， 给出的 T = aaaaad 如上图所示，当前4位匹配已知，对比到第5位时，会对 j 进行回溯。 此时 T 的next 数组位 01234，所以j 回溯到 next[5] &#x3D; 4，即第4位，如第2张图所示。 而此时a 不等于 b，再次回溯，以此类推，一直到第5步，发现回溯完后，T 中的a 一直不等于b，不得不放弃回溯，直接将S 中的 i 增加，跳到下一个字符。 而我们明明看到了，a 中的前5位都是一致的，本来第1步时，模式串中a 不等于主串 中的b， 完全可以放弃2，3，4，5这几部的比较。 4.2 新的nextVal 数组根据上面的总结，说明之前的next数组有可以改进的地方，改进如下: void get_nextVal(String T, int *nextVal)&#123; int i, j; i = 1; j = 0; nextVal[1] = 0; // 这是第一种情况，初始为0 while ( i &lt; T[0]) // 循环上限为模式串的长度 &#123; // 比较模式串 T 的前缀后缀俩字符, //若相等，分别递增 if( j == 0 || T[i] == T[j]) &#123; ++i; ++j; if (T[i] == T[j]) &#123; nextVal[i] = nextVal[j]; &#125;else&#123; nextVal[i] = j; &#125; &#125; else &#123; // 如果不相等， j 回溯回当前 j = nextVal[j] ; &#125; &#125;&#125; 可以看到，在判断前后缀相同的时候，添加了这一段判断 if (T[i] == T[j]) nextVal[i] = nextVal[j]; 这里的的意思是： 判断——如果当前 T 中的i 位字符与 T 的i位字符相等，且两串的各自下一个字符还是一一相等，把T中前缀的值——即上一次匹配 的的next 值，放入新的nextVal 数组中。 4.3逆推nextVal数组声明比较的规则，即拿 左边 &#x3D; T[j] 右边 &#x3D; T [next[j]] 两者相比较！ 4.3.1 模式串为：ababaaaba j 123456789 模式串 ababaaaba next[j] 011234223 nextVal[j] 010104210 j &#x3D; 1, nextVal[1] &#x3D; 0; j &#x3D; 2, 照旧。左边为T [2] &#x3D; b，右边 T[next[2]] &#x3D; T[1] &#x3D; a 这种前后字符不相等，还是沿用之前next[i] 的逻辑，即 &#x3D; 1； j &#x3D; 3，此时为新情况，左边为T [3] &#x3D; a，右边 T[next[3]] &#x3D; T[1] &#x3D; a 这种前后字符相等，使用新逻辑：nextVal[3] &#x3D; nextVal[1] &#x3D; 0； j &#x3D; 4 ，此时为新情况，左边为T [4] &#x3D; b，右边 T[next[4]] &#x3D; T[2] &#x3D; b 这种前后字符相等，使用新逻辑：nextVal[4] &#x3D; nextVal[2] &#x3D; 1； j &#x3D; 5，此时为新情况，左边为T [5] &#x3D; a，右边 T[next[5]] &#x3D; T[3] &#x3D; a 这种前后字符相等，使用新逻辑：nextVal[5] &#x3D; nextVal[3] &#x3D; 0； j &#x3D; 6，照旧。左边为T [6] &#x3D; a，右边 T[next[6]] &#x3D; T[4] &#x3D; b 这种前后字符不相等，还是沿用之前next[i] 的逻辑，即 &#x3D; 4； j &#x3D; 7，照旧。左边为T [7] &#x3D; a，右边 T[next[7]] &#x3D; T[2] &#x3D; b 这种前后字符不相等，还是沿用之前next[i] 的逻辑，即 &#x3D; 2； j &#x3D; 8，此时为新情况，左边为T [8] &#x3D; b，右边 T[next[8]] &#x3D; T[2] &#x3D; b 这种前后字符相等，使用新逻辑：nextVal[8] &#x3D; nextVal[2] &#x3D; 1； j &#x3D; 9，此时为新情况，左边为T [9] &#x3D; a，右边 T[next[9]] &#x3D; T[3] &#x3D; a 这种前后字符相等，使用新逻辑：nextVal[9] &#x3D; nextVal[3] &#x3D; 0； 4.3.2 模式串为：aaaacd j 123456 模式串 aaaaad next[j] 012345 nextValue[j] 000005 现在回到引起需要改进的字符串里面来，aaaaad，依次分析 j &#x3D; 1, nextVal[1] &#x3D; 0; j &#x3D; 2, 此时为新情况，左边为T [2] &#x3D; a，右边 T[next[2]] &#x3D; T[1] &#x3D; a 这种前后字符相等，使用新逻辑：nextVal[2] &#x3D; nextVal[1] &#x3D; 0； j &#x3D; 3，此时为新情况，左边为T [3] &#x3D; a，右边 T[next[3]] &#x3D; T[2] &#x3D; a 这种前后字符相等，使用新逻辑：nextVal[3] &#x3D; nextVal[2] &#x3D; 0； 同上累加 同上累加 同上累加 j &#x3D; 6，此时照旧。左边T[6] &#x3D; d， 右边 T [next[6]] &#x3D; T [5] &#x3D; a， 两者并不相等，沿用之前的next，即 nextVal[6] &#x3D; 5 4.4 改进小结总之，这里改进了的一句代码 if (T[i] == T[j]) &#123; nextVal[i] = nextVal[j];&#125; 最终的含义： 是如果存在某个字符a，如果它当前next位指向的字符相等—— 它的偏移值nextVal 数组当前的值，就使用会沿用指向的那个值的nextVal值。其他情况的逻辑照旧。 画了个图解释一下： 相关实现代码，放在GITHUB 上，欢迎食用 XD!","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://nilsli.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"KMP","slug":"KMP","permalink":"http://nilsli.com/tags/KMP/"},{"name":"字符串查找","slug":"字符串查找","permalink":"http://nilsli.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE/"}]},{"title":"【数据结构与算法】-（8.2）字符串搜索算法和RK&BP算法","slug":"0422rkbp","date":"2020-04-22T09:45:47.000Z","updated":"2024-08-07T07:10:46.393Z","comments":true,"path":"p/8a586c1e.html","permalink":"http://nilsli.com/p/8a586c1e.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 【数据结构与算法】-（8）栈之算法题 【数据结构与算法】-（8.1）字符串去重算法 引言 字符串搜索算法（String searching algorithms） 又称字符串比对算法（string matching algorithms）是一种搜索算法，是字符串算法中的一类，用以试图在一长字符串或文章中，找出其是否包含某一个或多个字符串，以及其位置。 题目：字符串匹配给你一个仅包含小写字母的字符串主串S &#x3D; abcacabdc， 模式串 T&#x3D; abd, 请查找出模式串在主串第一次出现的位置；提示：主串和模式串均为小写字母且都是合法输入 一、BF算法1.1 概念 Brute-Force算法，简称为 BF算法，是一种简单朴素的模式匹配算法，常用于在一个主串 S 内查找一个子串 T 的出现位置。 1.2 思路 排列两个串，对其内部字符进行逐一比较 首先对S[1] 和 T[1] 比较，如果相等则跳到S[2] 和T[2]，两者下标各加1 如果S[i] 和 T[j] 不相等： 主串的待选次序i 回退到之前j 的下一位，即是i = i - j + 2 j 退回到第1位 匹配成功条件：字串每一个字符都匹配完，即j &gt; T[0] 。此时，主串位置 i 即为所得 1.3 代码实现： 字符生成字符串 T /* 生成一个其值等于chars的串T */Status StrAssign(String T,char *chars)&#123; int i; if(strlen(chars)&gt;MAXSIZE) return ERROR; else &#123; T[0]=strlen(chars); for(i=1;i&lt;=T[0];i++) T[i]=*(chars+i-1); return OK; &#125;&#125; 清除字符串 S Status ClearString(String S)&#123; S[0]=0;/* 令串长为零 */ return OK;&#125; 输出字符串里的字符 void StrPrint(String T)&#123; int i; for(i=1;i&lt;=T[0];i++) printf(&quot;%c&quot;,T[i]); printf(&quot;\\n&quot;);&#125; 输出Next 数组的值 void NextPrint(int next[],int length)&#123; int i; for(i=1;i&lt;=length;i++) printf(&quot;%d&quot;,next[i]); printf(&quot;\\n&quot;);&#125; 返回字符串 s 的元素个数 int StrLength(String S)&#123; return S[0];&#125; 执行算法内容 int Index_BF(String S, String T,int pos)&#123; //i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 int i = pos; //j用于子串T中当前位置下标值 int j = 1; //若i小于S的长度并且j小于T的长度时，循环继续 while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) &#123; //比较的2个字母相等,则继续比较 if (S[i] == T[j]) &#123; i++; j++; &#125;else&#123; //不相等,则指针后退重新匹配 //i 退回到上次匹配的首位的下一位; //加1,因为是子串的首位是1开始计算; //再加1的元素,从上次匹配的首位的下一位; i = i-j+2; //j 退回到子串T的首位 j = 1; &#125;&#125; //如果j&gt;T[0],则找到了匹配模式 if (j &gt; T[0]) &#123; //i母串遍历的位置 - 模式字符串长度 = index 位置 return i - T[0]; &#125;else&#123; return -1; &#125; &#125; 验证算法内容： int main(int argc, const char * argv[]) &#123; int i,*p; String s1,s2; StrAssign(s1, &quot;abcdex&quot;); printf(&quot;s1子串为&quot;); StrPrint(s1); StrAssign(s2, &quot;xe&quot;); printf(&quot;s2子串为&quot;); StrPrint(s2); i = Index_BF(s1, s2, 1); printf(&quot;i = %d\\n&quot;,i); return 0;&#125; 结果验证： 1.4 时间复杂度但是此直观算法较为暴力，复杂度达到了O(mn)，其中 S 的长度为n，T 的长度为m， 所以我们要考虑更快速的算法。 二、RK算法2.0 概念 RK 算法（Rabin–Karp algorithm ）是一个字符串查找算法，由Richard M. Karp and Michael O. Rabin 在1987年提出，使用哈希算法，来比对字符串。 在这里，与粗暴简单的BF 算法不一样，我们引入了哈希值来进行比对，这样计算机只需要匹配整形，相比匹配字符串，更快一些。 散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。 散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。 2.1 思路： 主串分解成多个字串，用子串与模式串进行核对 把需要匹配的字符串，转换成hash 值 以 a 为基点，将字符与a 的ASCII 码的差值，转换成整形： 如abc，结果为 Result&#x3D; ( a - ‘a’ ) * 262 + (b - ‘a’ ) * 26 + (c - ‘a’ ) 用主串对字串和模式串的的hash 值来互相判断，更为高效 2.2 代码实现 二次确认hash 值相等。以防止有的字符串相同，但是hash 不相等。 int isMatch(char *S, int i, char *P, int m)&#123; int is, ip; for(is=i, ip=0; is != m &amp;&amp; ip != m; is++, ip++) if(S[is] != P[ip]) return 0; return 1;&#125; 算出 d 进制下的最高位: int getMaxValue(int m)&#123; int h = 1; for(int i = 0;i &lt; m - 1;i++)&#123; h = (h*d); &#125; return h;&#125; 进行RK 进入查询 int RK(char *S, char *P)&#123; //1. n:主串长度, m:子串长度 int m = (int) strlen(P); int n = (int) strlen(S); printf(&quot;主串长度为:%d,子串长度为:%d\\n&quot;,n,m); //A.模式串的哈希值; St.主串分解子串的哈希值; unsigned int A = 0; unsigned int St = 0; //2.求得子串与主串中0~m字符串的哈希值[计算子串与主串0-m的哈希值] //循环[0,m)获取模式串A的HashValue以及主串第一个[0,m)的HashValue //此时主串:&quot;abcaadddabceeffccdd&quot; 它的[0,2)是ab //此时模式串:&quot;cc&quot; //cc = 2 * 26^1 + 2 *26 ^0 = 52+2 = 54; //ab = 0 * 26^1 + 1 *26^0 = 0+1 = 1; for(int i = 0; i != m; i++)&#123; //第一次 A = 0*26+2; //第二次 A = 2*26+2; A = (d*A + (P[i] - &#x27;a&#x27;)); //第一次 st = 0*26+0 //第二次 st = 0*26+1 St = (d*St + (S[i] - &#x27;a&#x27;)); &#125; //3. 获取d^m-1值(因为经常要用d^m-1进制值) int hValue = getMaxValue(m); //4.遍历[0,n-m], 判断模式串HashValue A是否和其他子串的HashValue 一致. //不一致则继续求得下一个HashValue //如果一致则进行二次确认判断,2个字符串是否真正相等.反正哈希值冲突导致错误 //注意细节: //① 在进入循环时,就已经得到子串的哈希值以及主串的[0,m)的哈希值,可以直接进行第一轮比较; //② 哈希值相等后,再次用字符串进行比较.防止哈希值冲突; //③ 如果不相等,利用在循环之前已经计算好的st[0] 来计算后面的st[1]; //④ 在对比过程,并不是一次性把所有的主串子串都求解好Hash值. 而是是借助s[i]来求解s[i+1] . 简单说就是一边比较哈希值,一边计算哈希值; for(int i = 0; i &lt;= n-m; i++)&#123; if(A == St) if(isMatch(S,i,P,m)) //加1原因,从1开始数 return i+1; St = ((St - hValue*(S[i]-&#x27;a&#x27;))*d + (S[i+m]-&#x27;a&#x27;)); &#125; return -1;&#125; 2.3 代码验证 执行查找代码 int main()&#123; char *buf=&quot;abcababcabx&quot;; char *ptrn=&quot;abcabx&quot;; printf(&quot;主串为%s\\n&quot;,buf); printf(&quot;子串为%s\\n&quot;,ptrn); int index = RK(buf, ptrn); printf(&quot;find index : %d\\n&quot;,index); return 1;&#125; 结果如下： 2.4 复杂度 时间复杂度：O(n+m)，最坏O((n-m) * m) 空间复杂度：O(1)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://nilsli.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"RK","slug":"RK","permalink":"http://nilsli.com/tags/RK/"},{"name":"BF","slug":"BF","permalink":"http://nilsli.com/tags/BF/"},{"name":"字符查找","slug":"字符查找","permalink":"http://nilsli.com/tags/%E5%AD%97%E7%AC%A6%E6%9F%A5%E6%89%BE/"}]},{"title":"【数据结构与算法】-（8.1）字符串去重算法","slug":"0422stringmatch","date":"2020-04-22T05:59:10.000Z","updated":"2024-08-07T07:10:46.397Z","comments":true,"path":"p/cc625709.html","permalink":"http://nilsli.com/p/cc625709.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 【数据结构与算法】-（8）栈之算法题 去除重复字母LeetCode 级别：困难 Q： 题目给你一个仅包含小写字母的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小。要求：不能打乱其他字符的相对位置。原题目leetcode链接 示例1: 输入：&quot;bcabc&quot; 输出：&quot;abc&quot; 示例2: 输入：&quot;cbacdcbc&quot; 输出：&quot;acdb&quot; ~~cbad~~, ~~bacd~~, ~~adcb~~ Analyze:分析关键字：字典序、不打乱 字典序最小：即排列顺序按照26个字母一次排序，比如给的antman 肯定要排在ultraman 前面 不打乱排序：即去除重复字母后，未被重复的那部分字母，不改变原来位置。比如bcabc 结果是 abc 那么去除的是第1、第2位的b和c， 后面3位abc 依然不变。 A：思路： 给定字符串 s ，排除字符串异常情况； 使用一个record 数组，来记录字符串中字母出现的次数； 创建一个栈stack ，用来存储去除重复字母的结果，并利用它的特性帮助我们找到正确的次序。 遍历给定的字符串s； 从0～top 依次遍历 stack，判断当前的字符s[i] 是否存在于stack 中，用一个int类型的值isExist来表示是否存在。 如果isExsit 存在，即&#x3D;&#x3D;1，将record [s[i]] 位置上出现次数减1，即record[s[i]]--，并继续遍历下一个字符；意思是，当前的stack 已经包含这个字符，以后都不需要继续处理这个字符了。 如果isExist 不存在，则需要while循环一下，找到这个字符正确的位置，然后存储起来。循环规则大概是这样：跳过栈中比当前字符大、而且后面还会出现的元素，将字符入栈。 while 循环的条件如下： 用top &gt; -1 来保证栈不为空 用 stack[top] &gt; s[i] 表示栈定元素比当前元素大 用 record[stack[top]] &gt; 1 表示后面还会出现 等遍历完所有的字符后，对当前的字符栈stack 添加一个结束符\\0，并返回当前字符串首地址； 代码实现char *removeDuplicateLetters(char *s)&#123; /* ① 特殊情况处理,s为空,或者字符串长度为0; ② 特殊情况,s的长度为1,则没有必要后续的处理,则直接返回s; */ if (s == NULL || strlen(s) == 0) &#123; return &quot;&quot;; &#125; if (strlen(s) == 1) &#123; return s; &#125; //record数组,用来记录字符串s中每个字符未来会出现的次数; char record[26] = &#123;0&#125;; int len = (int)strlen(s); //申请一个字符串stack;(用栈的特性来进行stack字符串的数据进出) char* stack = (char*)malloc(len * 2 * sizeof(char)); //memset(void *s, int ch, size_t n) 将stack len*2*sizeof(char)长度范围的空间填充0; memset(stack, 0, len * 2 * sizeof(char)); //stack 栈顶赋初值为-1; int top = -1; //1.统计每个字符的频次 //例如bcabc recod[26] = &#123;1,2,2&#125;; int i; for (i = 0; i &lt; len; i++) &#123; record[s[i] - &#x27;a&#x27;]++; &#125; //2.遍历s,入栈 for (i = 0; i &lt; len; i++) &#123; //isExist 标记, 判断当前字符是否存在栈中; int isExist = 0; //①从0~top,遍历stack 判断当前字符s[i]是否存在于栈stack中 //如果当前字符是否存在于栈的flag, 0表示不存在, 1表示存在 //top指向栈顶(也是执行stack字符串最后一个字符的位置,表示字符串长度上限) for (int j = 0; j &lt;= top; j++) &#123; if (s[i] == stack[j]) &#123; isExist = 1; break; &#125; &#125; //② 如果存在,record[s[i]]位置上的出现次数减一，并继续遍历下一个字符 //③ 如果不存在,则需要循环一个正确位置存储起来; //④ 如果不存在，跳过栈中所有比当前字符大、且后面还会出现的元素，然后将当前字符入栈 // top &gt; -1表示栈非空 //stack[top] &gt; s[i]表示栈顶元素比当前元素大 //record[stack[top]] &gt; 1表示后面还会出现 //例如b,c因为不符合以下条件会直接入栈.stack[] = &quot;bc&quot;,但是当当前字符是&quot;a&quot;时,由于bcabc,a不应该是在stack的顺序是&quot;bca&quot;,所以要把位置不符合的字符出栈; //top = 1,stack[top] &gt; s[i], c&gt;a; 并且stack[top] 在之后还会重复的出现,所以我们可以安心的把stack中的栈顶C出栈,所以stack[]=&quot;b&quot;,top减一后等于0; 同时也需要将record[c]出现次数减一; //top=0,stack[top]&gt;s[i],b&gt;a,并且stack[top] 在之后还会出现,所以stack把栈顶b出栈,所以此时栈stack[]=&quot;&quot;,top减一后等于-1, 此时栈中位置不正确的字符都已经移除; if (isExist == 1) &#123; record[s[i] - &#x27;a&#x27;]--; &#125; else &#123; while (top &gt; -1 &amp;&amp; stack[top] &gt; s[i] &amp;&amp; record[stack[top] - &#x27;a&#x27;] &gt; 1) &#123; // 跳过该元素，频次要减一 record[stack[top] - &#x27;a&#x27;]--; // 出栈 top--; &#125; //⑤ 结束while 循环; //循环结束的3种可能性:(1)移动到栈底(top == -1) ; (2)栈顶元素小于当前元素(stack[top] &lt;= s[i]) (3)栈顶元素后面不出现(record[stack[top]] == 1) // 此时，当前元素要插入到top的下一个位置 // top往上移动1位 top++; // 入栈 stack[top] = s[i]; &#125; &#125; //结束栈顶添加字符结束符 stack[++top] = &#x27;\\0&#x27;; return stack;&#125; 试着执行一下代码： char *s ;s = removeDuplicateLetters(&quot;zdzdaabc&quot;); 结果如下： 从 zdzdaabc &#x3D; &gt; dzabc ，符合要求 ✅ 提交结果 leetcode 双百，可以可以","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://nilsli.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"去重","slug":"去重","permalink":"http://nilsli.com/tags/%E5%8E%BB%E9%87%8D/"}]},{"title":"【数据结构与算法】-（8）栈之算法题","slug":"0420exercise4stack","date":"2020-04-20T10:11:53.000Z","updated":"2024-08-07T07:10:46.392Z","comments":true,"path":"p/b0e10b1c.html","permalink":"http://nilsli.com/p/b0e10b1c.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 0. 算法题解法要进大厂，必须要迈过的一步，就是算法题，那么算法题的思路究竟是如何呢？ 笔者总结了一下近十年工作中的精髓，思路如下： 我们遇到什么困难也不要怕，微笑着面对它……奥利给！ 抱歉走错片场了……想说的真正意思上这样的： 0.1 方法 充分阅读题目，了解题目背后的关键意思； 分析题目，涉及到哪些数据结构，对问题进行分类——到底属于链表问题、栈思想问题、字符串问题、二叉树问题、图相关问题、排序问题；与你之前所接触过的算法题有没有类似，找到问题的解题思路 实现算法。在算法的实现的过程，并不是一蹴而就，肯定是需要不断的调试、修改的。 验证算法正确性。 找到题源，看其他的开发者对齐的解决思路。 找到题解建议之后，对于其他优秀思路，分析它的优势，并且学习它的思路，并且写成其他解法的代码 算法题的解题能力来自于2点： 对于数据结构与算法核心问题是否夯实； 是否有足够多且足够耐心的积累； 0.2 思想应用指的是利用栈的特性(先进后出)去解决问题,那么什么问题适合用栈思想解决了? 数据是线性的。 问题中常常涉及到数据的来回比较，匹配问题；例如：每日温度、括号匹配、字符串解码、去掉重复字母等问题。 问题中涉及到数据的转置，例如进制问题、链表倒序打印问题等。 注意并不是说栈思想只是一个解决的的参考思想，并不是万能的。它适用于以上这样的情况下去解决问题；利用栈思想解决问题时，首先需要透彻的解析问题之后，找到问题解决的规律，才能使用它解决。思想只有指导作用，遇到不同的题目，需要个例分析。在基本思想上去找到解决问题之道; 0.3 推荐书单 1. 进制转换Q: 题目如何将十进制转化为8进制的整形 A: 解答1. 初始化栈SqStack S;SElemType e;//1.初始化一个空栈SInitStack(&amp;S); Status InitStack(SqStack *S)&#123; S-&gt;top = -1; return OK;&#125; 2. 压栈循环取余，N 为除以8 的取余 //2.while (N) &#123; PushData(&amp;S, N%8); N = N/8;&#125; 3. 出栈当栈不为空，一直输出，pop出栈 while (!StackEmpty(S)) &#123; Pop(&amp;S, &amp;e); printf(&quot;%d\\n&quot;,e);&#125; 4. 打印结果：int main(int argc, const char * argv[]) &#123; // insert code here... printf(&quot;Hello, World!\\n&quot;); conversion(5201314); return 0;&#125; 运行结果如下： 2. 括号匹配检验Q: 题目括号匹配检验（题源：LeetCode） 给定一个只包括 (，)，&#123;，&#125;，[，] 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: &quot;()&quot;输出: true 示例 2: 输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3: 输入: &quot;(]&quot;输出: false 示例 4: 输入: &quot;([)]&quot;输出: false 示例 5: 输入: &quot;&#123;[]&#125;&quot;输出: true A: 解答3. 每日温度4. 杨辉三角5. 爬楼梯6. 字符串编码问题","categories":[],"tags":[]},{"title":"【iOS进阶】-启动优化","slug":"0419optimization","date":"2020-04-18T16:27:05.000Z","updated":"2024-08-07T07:10:46.392Z","comments":true,"path":"p/7bfd68ea.html","permalink":"http://nilsli.com/p/7bfd68ea.html","excerpt":"","text":"零、引言用户在移动应用的世界里，第一印象至关重要。对于iOS应用而言，这意味着启动时间必须迅速且流畅。启动优化不仅是提升用户体验的关键，也是展示技术实力的窗口。本文将深入探讨iOS应用的启动过程，分析启动时间的重要性，并提供一系列实用的优化策略和技巧。 一、iOS应用启动过程概述1.1 iOS应用启动的基本流程。 用户触发启动： 当用户点击应用图标时，iOS系统开始启动过程。 加载可执行文件： 系统首先加载应用的可执行文件。这个阶段包括验证应用签名的安全性，以及将应用的可执行文件加载到内存中。 运行时环境设置： 接下来，系统为应用设置运行时环境。这包括分配必要的内存资源和设置应用所需的环境变量。 调用main()函数： 启动过程的下一个步骤是调用应用的main()函数。在标准iOS应用中，main()函数通常很简单，它的主要任务是调用UIApplicationMain()函数。 **执行UIApplicationMain()**： UIApplicationMain()函数是启动过程中的关键部分。它创建了应用的UIApplication对象和应用的主UIWindow，并设置了应用的委托（AppDelegate）。 加载和设置AppDelegate： UIApplicationMain()会根据Info.plist文件中的设置，实例化AppDelegate类，并将其设置为UIApplication对象的代理。AppDelegate负责处理应用生命周期和UI事件。 调用application:didFinishLaunchingWithOptions: 一旦AppDelegate被创建和设置，application:didFinishLaunchingWithOptions:方法会被调用。这个方法是开发者自定义代码的主要入口点，用于设置应用的初始状态、创建UI界面、连接到数据库或执行其他必要的启动任务。 渲染初始界面： application:didFinishLaunchingWithOptions:执行完毕后，应用的初始界面（通常在Storyboard或通过代码设置）被加载和渲染，此时用户开始看到应用的UI。 应用准备就绪： 完成上述步骤后，应用变为活动状态，用户可以开始与其交互。 1.2 main()函数和UIApplicationMain的作用 main()函数 启动点：main()函数是iOS应用的入口点，是程序执行的第一站。它是每个C或Objective-C程序的标准入口点。 简洁性：在标准的iOS应用中，main()函数通常非常简洁。它的主要任务是调用UIApplicationMain()函数。 桥接角色：它作为程序运行和iOS应用框架之间的桥接，确保了iOS特有的应用生命周期和事件处理能夔正确启动。 UIApplicationMain()函数 核心作用：UIApplicationMain()函数是iOS应用启动流程的核心。它负责创建应用的UIApplication对象和应用的主UIWindow。 设置AppDelegate：此函数还设置应用的AppDelegate，并将其作为UIApplication对象的代理。这一步是关键，因为AppDelegate负责响应应用生命周期事件，如应用启动、进入后台等。 运行循环：UIApplicationMain()还启动了主运行循环（main run loop），这对于处理用户界面事件和各种输入至关重要。 事件处理：它处理用户的触摸事件、系统事件等，并将它们分发到应用中相应的处理程序。 总的来说，main()函数是应用启动的起点，而UIApplicationMain()是应用启动过程中最关键的函数，负责创建和设置应用的基础结构，并启动事件处理循环。这两个函数共同确保了iOS应用能够按照期望的方式启动和运行。 1.3 didFinishLaunchingWithOptions方法的作用 应用初始化：这个方法是在应用启动后首先被调用的点，用于执行应用级别的初始化操作。在这里，开发者可以设置应用的初始状态，配置全局变量等。 界面设置： 在application:didFinishLaunchingWithOptions:中，开发者通常会建立和配置应用的初始用户界面。这包括创建窗口（UIWindow），设置根视图控制器，以及可能的其他界面相关配置。 集成服务：这个方法也是集成各种服务和第三方库的理想位置。例如，可以在这里初始化数据库、配置分析工具、集成社交媒体SDK等。 处理启动选项： 该方法的参数launchOptions提供了应用启动的上下文信息，比如用户是通过点击通知、URL或者是从其他应用中启动的。这使得开发者可以根据不同的启动情况，执行相应的操作。 性能优化： 由于这个方法是在应用启动时调用的，因此在这里进行的所有操作都会直接影响应用的启动时间。因此，开发者需要谨慎处理这里的代码，避免执行耗时操作，以确保应用启动快速。 返回值： 该方法最终返回一个布尔值，指示应用是否成功启动并准备好运行。通常在所有初始化操作成功完成后，返回true。 二、测量启动时间2.1 Xcode 设置 设置启动参数： 在弹出的窗口中，选择“Run”（运行）选项卡。 导航到“Arguments”（参数）部分。 在“Environment Variables”（环境变量）区域中添加一个新的变量。名称设置为DYLD_PRINT_STATISTICS，值设置为1。这会在应用启动时打印出详细的加载统计信息。 运行应用：观察Xcode控制台输出。它会显示应用启动的时间统计，包括总启动时间和主要阶段的时间（例如，动态库加载时间）。 2.2 使用Instruments 打开Instruments： 在Xcode中，选择“Xcode”菜单中的“Open Developer Tool”（打开开发者工具），然后选择“Instruments”。 选择适当的模板： 在Instruments中，选择“Time Profiler”（时间分析器）工具。 配置记录设置： 选择你的应用和目标设备。 设置适当的记录选项，例如记录的时间长度。 开始记录： 点击“Record”（记录）按钮开始捕捉数据。 启动你的应用。 让应用运行一段时间，然后停止记录。 分析数据： 查看捕获的数据，特别注意应用启动期间的CPU使用情况和函数调用时间。 使用Instruments的详细视图和过滤功能来定位可能导致延迟的代码。 1.3 冷启动与热启动 冷启动（Cold Launch） 场景：应用从完全关闭状态启动，不在内存中。 过程：包括加载应用到内存、初始化运行环境和设置。 性能影响：通常耗时更长，因为需要完整的加载和初始化过程。 优化焦点：减少初始化代码量，优化资源加载和应用大小。 热启动（Warm Launch） 场景：应用已在内存中或之前运行过，但不在前台。 过程：主要涉及恢复到前台，部分资源可能仍在内存中。 性能影响：通常比冷启动快，因为省去了一些初始化步骤。 优化焦点：确保快速恢复和有效的状态管理。 总结来说，冷启动涉及完整的应用启动过程，而热启动则是从一种“休眠”状态恢复，两者在优化策略上有所不同。 三、优化启动时间的技巧和策略 减少初始化代码：优化AppDelegate中的代码，延迟加载不必要的服务。举个例子： 假设我们有一个名为MyService的服务，需要在应用启动时初始化，但不是立即必需的。我们可以在AppDelegate中进行延迟加载。import UIKitclass AppDelegate: UIResponder, UIApplicationDelegate &#123; var window: UIWindow? var myService: MyService? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // 设置UI和其他初始化代码... // 延迟加载MyService DispatchQueue.global(qos: .background).async &#123; self.myService = MyService() self.myService?.setup() &#125; return true &#125; // 其他AppDelegate方法...&#125;class MyService &#123; func setup() &#123; // 长时间运行的设置或初始化代码... &#125;&#125; 静态资源和资源预加载：管理静态资源的有效方法，以及预加载技巧。 举例：假设我们有一组图像资源需要在应用中使用，但不需要在应用启动时立即加载。我们可以实现一个预加载机制，让这些资源在后台逐渐加载，以便在需要时立即使用。UIKitclass ResourcePreloader &#123; private var images: [String: UIImage] = [:] // 异步预加载图像 func preloadImages(named imageNames: [String]) &#123; DispatchQueue.global(qos: .background).async &#123; for imageName in imageNames &#123; if let image = UIImage(named: imageName) &#123; self.images[imageName] = image &#125; &#125; &#125; &#125; // 获取预加载的图像 func getPreloadedImage(named imageName: String) -&gt; UIImage? &#123; return images[imageName] &#125;&#125;class AppDelegate: UIResponder, UIApplicationDelegate &#123; var window: UIWindow? let preloader = ResourcePreloader() func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // 预加载图像资源 preloader.preloadImages(named: [&quot;image1&quot;, &quot;image2&quot;, &quot;image3&quot;]) return true &#125; // 其他AppDelegate方法...&#125; 代码解释： 资源预加载：ResourcePreloader类负责预加载和存储图像资源。preloadImages方法在后台线程中加载图像，这样就不会阻塞主线程。 后台线程加载：使用DispatchQueue.global(qos: .background).async确保资源加载在后台进行，以减少对主线程和应用启动性能的影响。 资源访问：getPreloadedImage方法提供了对预加载图像的访问。这使得在应用的其他部分中可以快速获取这些图像。 启动时预加载：在AppDelegate的application(_:didFinishLaunchingWithOptions:)方法中调用预加载，以确保在应用启动时开始加载资源。 并行和异步执行：利用并行编程和异步执行来加快启动速度。 假设我们的应用需要在启动时执行两个耗时任务：一个是数据加载（loadData），另一个是复杂计算（performComplexCalculation）。我们将这些任务放在不同的后台线程上执行，以提高效率。UIKitclass AppDelegate: UIResponder, UIApplicationDelegate &#123; var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // 设置UI和其他初始化代码... // 异步加载数据 DispatchQueue.global(qos: .userInitiated).async &#123; self.loadData() &#125; // 异步执行复杂计算 DispatchQueue.global(qos: .userInitiated).async &#123; self.performComplexCalculation() &#125; return true &#125; // 模拟耗时的数据加载 private func loadData() &#123; // 数据加载逻辑... print(&quot;Data loaded.&quot;) &#125; // 模拟复杂计算 private func performComplexCalculation() &#123; // 复杂计算逻辑... print(&quot;Complex calculation performed.&quot;) &#125; // 其他AppDelegate方法...&#125; 代码解释： 异步任务：在application(_:didFinishLaunchingWithOptions:)方法中，我们使用DispatchQueue.global(qos: .userInitiated).async来异步执行loadData和performComplexCalculation方法。这使得这些任务在后台线程上并行运行。 质量服务等级：通过设置qos: .userInitiated，我们告诉系统这些任务虽然是后台任务，但对用户体验有显著影响，因此应该较快处理。 主线程保护：通过将耗时任务放在后台执行，我们避免了阻塞主线程，这对于保持应用的响应性至关重要，特别是在启动阶段。 优化Storyboard和XIB文件：减少和优化界面资源的加载时间。 拆分复杂的Storyboard： 如果你的Storyboard非常庞大和复杂，它可能会显著增加加载时间。拆分成多个较小的Storyboard可以加快加载速度。 在Xcode中，可以通过创建新的Storyboard文件并将现有Storyboard中的一部分视图控制器移动到新的Storyboard来完成这一过程。 使用Storyboard Reference来在Storyboard之间进行导航。 优化视图层次结构 减少视图层次的深度可以减少渲染时间。 尽量使用较少的容器视图。 避免不必要的嵌套。例如，如果可以直接在父视图上实现所需的布局，则不需要额外的容器视图。 使用轻量级的视图和控件 某些视图和控件比其他的更加消耗资源。 当可能时，使用更简单的控件。例如，使用UILabel而不是UITextView来显示不可编辑的文本。 避免过度使用高成本的UI元素，如阴影、透明度和复杂的形状。 延迟加载非关键内容 对于不立即显示的视图和数据，可以考虑延迟加载。 使用代码而不是Storyboard来创建这些视图，并在需要时才加载它们。 对于TableView和CollectionView，使用惰性加载数据。 精简资源文件 减小Storyboard或XIB文件的大小也能提高加载速度。 移除不使用的视图控制器、视图和资源。 使用向量图形（如PDF）而不是位图图像，可以减少应用的大小，并且在不同屏幕尺寸上看起来更清晰。 逐步特性加载：实现逐步加载应用特性的方法。 假设我们的应用有多个功能模块，比如“用户资料”、“消息”和“设置”。我们将实现一个机制，在应用启动时不立即加载这些模块，而是根据用户的交互逐步加载它们,示例代码如下：UIKitclass AppModuleManager &#123; static let shared = AppModuleManager() private(set) var userProfileModule: UserProfileModule? private(set) var messagesModule: MessagesModule? private(set) var settingsModule: SettingsModule? private init() &#123;&#125; func loadUserProfileModule() &#123; if userProfileModule == nil &#123; userProfileModule = UserProfileModule() userProfileModule?.loadModule() &#125; &#125; func loadMessagesModule() &#123; if messagesModule == nil &#123; messagesModule = MessagesModule() messagesModule?.loadModule() &#125; &#125; func loadSettingsModule() &#123; if settingsModule == nil &#123; settingsModule = SettingsModule() settingsModule?.loadModule() &#125; &#125;&#125;// 示例模块类class UserProfileModule &#123; func loadModule() &#123; // 加载用户资料模块的相关资源和设置 &#125;&#125;class MessagesModule &#123; func loadModule() &#123; // 加载消息模块的相关资源和设置 &#125;&#125;class SettingsModule &#123; func loadModule() &#123; // 加载设置模块的相关资源和设置 &#125;&#125;// 在AppDelegate或其他合适的地方调用let moduleManager = AppModuleManager.sharedmoduleManager.loadUserProfileModule() // 根据需要调用 代码解释： 模块化管理：创建AppModuleManager类来管理不同的功能模块。这个类用于加载和保存对应的模块实例。 延迟实例化：每个模块的加载方法首先检查相应模块是否已经实例化。如果尚未实例化，则创建并加载该模块。 按需加载：应用的其他部分可以根据需要调用这些加载方法，例如在用户点击某个功能的导航标签时。 资源和设置的加载：每个模块类有一个loadModule方法，用于执行该模块所需的资源加载和配置设置。 通过这种逐步加载模块的方式，应用可以在启动时保持轻量级，同时按需加载所需的功能，从而提高整体性能和用户体验。 四、最佳实践和常见陷阱4.1 最佳实践 iOS应用启动优化的最佳实践包括一系列技术和策略，旨在提高应用的启动速度和用户体验。以下是一些关键的最佳实践： 精简AppDelegate的逻辑：在AppDelegate中仅执行必要的启动逻辑，避免过度拥挤和复杂的初始化代码。 延迟加载非关键服务：将不影响首次用户体验的服务和任务延迟加载，例如在后台线程中初始化数据库或第三方服务。 优化Storyboard和XIB文件：简化视图层次结构，移除不必要的视图和控件，减少Storyboard的复杂性。 使用代码而非Storyboard创建视图：当可能时，通过代码创建视图而不是Storyboard，以减少加载时间。 异步加载和并行处理：使用Grand Central Dispatch (GCD) 或其他并行编程技术来异步执行耗时操作。 资源预加载和缓存：提前加载和缓存关键资源，如图像和数据，以减少实际使用时的加载时间。 避免在启动时阻塞主线程：确保主线程专注于UI渲染和用户交互，避免在其中执行耗时操作。 逐步加载特性和模块：根据用户的交互逐步加载应用的特性，而不是一次性加载所有功能。 监控和分析启动性能：定期使用Xcode的性能分析工具（如Instruments）来监控启动时间，并识别优化机会。 精简应用大小：减少应用的总大小，包括可执行文件、资源和依赖库，以加快下载和加载速度。 利用新的API和技术：随着iOS系统的更新，利用最新的API和技术来优化启动时间，例如使用SwiftUI来创建更高效的界面。 避免不必要的网络请求：在启动过程中避免或推迟网络请求，尤其是在用户体验上不是立即必需的请求。 4.2 常见问题和陷阱。 过度优化：在追求启动速度时过度优化，可能会导致代码复杂度上升，降低可维护性。 忽视线程安全：在并行和异步执行代码时，忽略线程安全可能导致数据竞争和不稳定的应用行为。 滥用后台线程：过多地在后台线程执行任务可能会导致系统资源紧张，反而影响性能。 忽视用户体验：在优化过程中过分关注启动速度而牺牲用户体验，如延迟加载重要功能，可能会导致用户不满。 忽视内存使用：在启动时预加载大量资源可能会导致内存使用激增，从而影响应用性能。 依赖外部资源：在启动时依赖外部资源，如网络请求，可能会因为网络条件差导致启动延迟。 未适当处理冷启动和热启动：没有区分对待冷启动和热启动，可能会错过针对性的优化机会。 忽略测试和监控：没有定期进行性能测试和监控可能会导致优化效果不明显或引入新的性能问题。 结论上面是总结得来的所有可行的方法，总的来说，优化iOS应用的启动时间对于提升用户体验至关重要。通过有效的策略和技巧，如逐步加载、并行处理和资源优化，可以显著加快启动速度，从而提升用户满意度。","categories":[],"tags":[{"name":"启动优化","slug":"启动优化","permalink":"http://nilsli.com/tags/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"},{"name":"调优","slug":"调优","permalink":"http://nilsli.com/tags/%E8%B0%83%E4%BC%98/"}]},{"title":"【数据结构与算法】-（7）队列","slug":"0413queue","date":"2020-04-13T17:13:40.000Z","updated":"2024-08-07T07:10:46.388Z","comments":true,"path":"p/c0a767bd.html","permalink":"http://nilsli.com/p/c0a767bd.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 一、概念 队列 (queue) 是只允许在一端进行插入操作、而在另一端进行删除操作的线性表 队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾(rear)，允许删除的一端称为队头(front)。 二、操作入队和出队：正如上文提到的，队列讲究的是先进先出的原则。队列的内部规则，好比大学上课时的占座位，先占到座位的总是前三排，来得晚的只能做到后面去了，等到下课了，先出去的也往往是前三排，也就是先来的那些同学。 给队列的进队入队画了个示意图如下： 三、循环队列3.1 原理线性表有顺序存储和链式存储，队列作为线性表的一种，同样有循环队列的结构。 像上图中，当C3离开，相继加入了C4和C5，队尾指针就要指出到队列外了，这时就会报出数组越界的错误，但是可以看到队列下方0、1、2位都是空的，这种情况叫做“假溢出”。 为了解决这种前面空，后面满的情况，我们经常采用解决方案，就是头尾相连的循环。 队列的头尾相连的循环结构称为循环队列 引入循环队列的概念，是为了解决假溢出的现象，那么，究竟什么时候队列真正满了呢？ 我们根据下图分析： 当初始时，队列空：此时 Q.front = Q.rear 当a、b、c 依次入队，front 不变，rear 指向到元素c后面 当a离开，front 下沉，指向b 当d、e、f、g入队后，此时rear指向最后一个元素b，此时与front重合 此时rear、 front再次重合，回到老路上了？ 解决办法是：预留一个元素位，防止重合。 也就是说当队列满时，还会有一个空闲的空间。如最后一张图所示，这样rear和front 不会重合。 所以判断队伍满的条件是： 队列满：Q.front = (Q.rear + 1) % MaxSize 3.2 顺序存储结构实现3.2.1 创建队列：创建队列比较简单，只需要使得rear、front 都为0 即可 初始化顺序结构的队列结构如下: #define MAXSIZE 20typedef struct&#123; QElemType data[MAXSIZE]; int front; int rear;&#125;SqQueue; 初始化一个空队列 typedef int Status;#define OK 1;Status InitQueue(SqQueue *q)&#123; q-&gt;front = q-&gt;rear = 0; return OK;&#125; 3.2.2 清空一个队列：和创建队列基本相同 Status ClearQueue(SqQueue *q)&#123; q-&gt;front = q-&gt;rear = 0; return OK;&#125; 3.2.3 判断是否是空队列：只需查看rear 和front 是否相等 Status CheckIfEmpty(SqQueue *q)&#123; return q-&gt;front == q-&gt;rear ;&#125; 3.5 返回队列的长度：需要将尾部减去头部，因为有循环，所以最后要加上MAXSIZE 最后MAXSIZE取模 Status getLength(SqQueue q)&#123; return (q.rear - q.front + MAXSIZE) % MAXSIZE;&#125; 3.6 获得队头的元素#define ERROR 0;Status getHeadItem(SqQueue q, QElemType e)&#123; if(q.front == q.rear ) return ERROR; e = q.data[q.front]; return OK;&#125; 3.7 元素入队Status EnQueue(SqQueue *q, QElemType e)&#123; // 判断队伍是否满了 if ((q-&gt;rear + 1) % MAXSIZE == q-&gt;front) &#123; return ERROR; &#125; q-&gt;data[q-&gt;rear] = e; q-&gt;rear = ( q-&gt;rear + 1 ) %MAXSIZE; return OK;&#125; 3.8 元素出队列Status DeQueue(SqQueue *q, QElemType *e)&#123; // 先判断队伍是否为空 if (q-&gt;rear == q-&gt;front) &#123; return ERROR; &#125; *e = q-&gt;data[q-&gt;front]; q-&gt;front = (q-&gt;front + 1 ) % MAXSIZE; return OK;&#125; 3.9 遍历队列中的元素Status ShowQueue(SqQueue q)&#123; if (q.rear == q.front) &#123; return ERROR; &#125; int i = q.front; while ((i + q.front) != q.rear) &#123; printf(&quot;%d&quot;, q.data[i]); i = (i + 1) % MAXSIZE; &#125; return OK;&#125; 将以上方法执行的业务代码如下： int main(int argc, const char * argv[]) &#123; // insert code here... // 初始化队列 Status j; SqQueue Q; QElemType d; InitQueue(&amp;Q); printf(&quot;已经初始化队列&quot;); // 判断是否为空 printf(&quot;队列是否为空呢 %u(1:yes 0:no)&quot;, CheckIfEmpty(Q)); // 元素入队列 printf(&quot;开始往队列添加元素\\n&quot;); for (int i = 0; i &lt; 5; i++) &#123; EnQueue(&amp;Q, i); &#125; // 遍历队列 ShowQueue(Q); printf(&quot;队列是否为空呢 %u(1:yes 0:no)\\n&quot;, CheckIfEmpty(Q)); // 获队列的长度 printf(&quot;队列的长度是 %d\\n\\n&quot;, getLength(Q)); // 出队列 printf(&quot;出队\\n&quot;); DeQueue(&amp;Q, &amp;d); ShowQueue(Q); // 获取队列的头 j = getHeadItem(Q, d); if (j) &#123; printf(&quot;头元素是%d\\n&quot; , j); &#125; // 清空队列 ClearQueue(&amp;Q); printf(&quot;清空完成，现在队列打印长度为%d\\n\\n&quot;, getLength(Q)); return 0;&#125; 打印结果如下： 3.3 链式存储结构的实现链式结构的队列结构图： 操作实现如下： 3.3.1 链队列结构： 队列结点结构如下 typedef int QElemType;typedef struct Node &#123; QElemType data; struct Node * next;&#125;Node, *QueuePtr; 队列结构如下: 只需创建2个指针 typedef struct &#123; QueuePtr front, rear;&#125;QueueLinkList; 3.3.2 创建队列创建链式结构的队列，只需要创建空间、将front 的next 指向空即可 Status createLink(QueueLinkList *q)&#123; q-&gt;front = q-&gt;rear = (QueuePtr)malloc(sizeof(QueuePtr)); if (q-&gt;front == NULL) &#123; return ERROR; &#125; q-&gt;front-&gt;next = NULL; return OK;&#125; 3.3.3 销毁队列销毁队列的步骤只需要依次free队列中的元素，这里用q-&gt;rear 来临时保管front 指向的元素。 具体操作如下 // 销毁Status destroyLink(QueueLinkList *q)&#123; while (q-&gt;rear) &#123; q-&gt;rear = q-&gt;front-&gt;next; free(q-&gt;front); q-&gt;front = q-&gt;rear; &#125; return OK;&#125; 3.3.4 清空一个队列主要分三步： 将 rear 指向 front， 即使得首尾相等，名义上成为了空队列 保留front 的next 元素，断开front 的next 依次释放队列中元素 来看下代码的实现： Status clearLink(QueueLinkList *Q)&#123; // 创建2个临时指针变量 QueuePtr p, q; // 将尾结点放到头结点 Q-&gt;rear = Q-&gt;front ; // 用q 临时接收 首元结点 q = Q-&gt;front-&gt;next; // 将头结点与后面断开 Q-&gt;front-&gt;next = NULL; // 循环遍历，把接收到Q-&gt;front 后面的元素统统释放 while (q) &#123; p = q; q = q-&gt;next; free(p); &#125; return OK;&#125; 3.3.5 判断是否为空队列只需查看rear 和front 是否相等 Status CheckIfEmpty(SqQueue *q)&#123; return q-&gt;front == q-&gt;rear ;&#125; 3.3.6 返回队列的长度定义一个递增变量，记下循环从 front 到 rear 的次数，即为长度 Status getLength(QueueLinkList Q)&#123; // 定义递增变量 i int i = 0 ; // 定义一个指针指向 front QueuePtr p = Q.front; // 循环 while (Q.rear != p) &#123; i++; p = p-&gt;next; &#125; return i;&#125; 3.3.7 获取队头的元素Status getHead(QueueLinkList Q, QElemType e)&#123; if (Q.front == Q.rear) &#123; return ERROR; &#125; e = Q.front-&gt;next-&gt;data; return OK ;&#125; 3.3.8 元素入队列入队列的操作和顺序的类似，步骤有以下： 创建新结点，并确保结果不为空 将新结点赋值，指向为NULL 将原链队列的rear 端指向新结点 将新结点作为原链队列的 rear Status enQueue(QueueLinkList *Q, QElemType e)&#123; QueuePtr s = (QueuePtr)malloc(sizeof(QueuePtr)); if (!s) &#123; return ERROR; &#125; s-&gt;data = e; s-&gt;next = NULL; Q-&gt;rear-&gt;next = s; Q-&gt;rear = s; return OK;&#125; 3.3.9 元素出队列出队列，需要先确认现有队列不为空，以及将现有的front 进行出队列操作 代码实现如下： Status deueue(QueueLinkList *Q, QElemType *e)&#123; if (Q-&gt;rear == Q-&gt;front) &#123; return ERROR; &#125; QueuePtr p ; p = Q-&gt;front-&gt;next; *e = p-&gt;data; Q-&gt;front-&gt;next = p-&gt;next; if (Q-&gt;rear == p) &#123; Q-&gt;rear = Q-&gt;front; &#125; free(p); return OK ;&#125; 3.3.10 遍历元素// 遍历Status showLink(QueueLinkList Q)&#123; if (Q.rear == Q.front) &#123; return ERROR; &#125; QueuePtr p = Q.front-&gt;next; while (p ) &#123; printf(&quot;%d\\n&quot;, p-&gt;data); p = p-&gt;next; &#125; return OK;&#125; 3.3.11 总结业务业务代码如下: int main(int argc, const char * argv[]) &#123; QueueLinkList Q; printf(&quot;开始创建\\n&quot;); createLink(&amp;Q); printf(&quot;创建成果，当前长度 %d\\n&quot;, getLength(Q)); printf(&quot;依次添加元素\\n&quot;); int i = 1; while (i &lt; 10) &#123; enQueue(&amp;Q, i); i++; &#125; printf(&quot;添加成功，新队列元素为\\n&quot;); showLink(Q); QElemType head = 0; Status j = getHead(Q, head); if (j) &#123; printf(&quot;该队头为%d\\n\\n&quot;,j ); &#125; printf(&quot;开始出队\\n&quot;); Status result = deueue(&amp;Q, &amp;head); if (result) &#123; printf(&quot;出队成功，新队列元素为\\n&quot;); showLink(Q); &#125; // 清空队列 Status clearResult = clearLink(&amp;Q); if (clearResult) &#123; printf(&quot;清空成功，新队列元素为\\n&quot;); showLink(Q); &#125;else&#123; printf(&quot;清空失败\\n&quot;); &#125; // 销毁队列 Status destroyResult = destroyLink(&amp;Q); if (destroyResult) &#123; printf(&quot;销毁成功，新队列元素为\\n&quot;); showLink(Q); &#125;else&#123; printf(&quot;销毁失败\\n&quot;); &#125; return 0;&#125; 最终结果如下:","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://nilsli.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://nilsli.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"队列","slug":"队列","permalink":"http://nilsli.com/tags/%E9%98%9F%E5%88%97/"}]},{"title":"【数据结构与算法】-（6）栈","slug":"0411stackNqueue","date":"2020-04-11T13:37:54.000Z","updated":"2024-08-07T07:10:46.386Z","comments":true,"path":"p/7914b7d0.html","permalink":"http://nilsli.com/p/7914b7d0.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 1. 概念1.1 定义 栈 (stack) 是限定仅在表尾进行插入和删除操作的线性表 栈的插入操作（push），叫作进栈、入栈。类似子弹入弹夹。 栈的删除操作（pop），叫作出栈，也有的叫做弹栈。 允许插入和删除的一段叫作栈顶 (top)，另一段底叫作栈底(bottom&#x2F;rear) 1.2 示意图 1.2 栈的顺序存储结构及实现1.2.1 顺序栈结构顺序栈由一个数据数组和栈顶指针组成： typedef struct&#123; SElemType data[MAXSIZE]; int top; /* 用于栈顶指针 */&#125;SqStack; 和链式结构类似，指针top 永远指向下一个栈内元素。 1.2.2 创建空栈初始化栈，只需要将栈顶top 处于-1 即可，类似数组，有心数据进来就从0开始排列 Status InitStack(SqStack *S)&#123; S-&gt;top = -1; return OK;&#125; 1.2.3 清空一个栈清空栈也栈顶top 处于-1 即可。 Status ClearStack(SqStack *S)&#123; // 只需要修改top标签 -1. S-&gt;top = -1; return OK;&#125; 1.2.4 判断栈是否为空由于栈内只要有有元素，栈顶top都会移动位置，所以只需要判断是否在-1 即可 Status StackEmpty(SqStack S)&#123; return S.top == -1;&#125; 1.2.5 返回栈的长度由于栈顶从0开始排列起来，长度必须上top的序号+1 int StackLength(SqStack S)&#123; return S.top + 1;&#125; 1.2.6 获取栈顶元素类似数组一样，栈定元素为最后一个元素，即S.data[S.top] Status GetTop(SqStack S,SElemType *e)&#123; if (S.top == -1) return ERROR; else *e = S.data[S.top]; return OK;&#125; 1.2.7 插入元素e 为新栈顶元素（压栈）压栈即把top 序号 位置提升1位，top位的元素为新元素。 Status PushData(SqStack *S, SElemType e)&#123; //栈已满 if (S-&gt;top == MAXSIZE -1) &#123; return ERROR; &#125; //栈顶指针+1; S-&gt;top ++; //将新插入的元素赋值给栈顶空间 S-&gt;data[S-&gt;top] = e; return OK;&#125; 1.2.8 删除栈定元素，并用e带回（出栈）出栈与入栈恰恰相反，将top 位的元素弹出，同时将top 序号减1 Status Pop(SqStack *S,SElemType *e)&#123; //空栈,则返回error; if (S-&gt;top == -1) &#123; return ERROR; &#125; //将要删除的栈顶元素赋值给e *e = S-&gt;data[S-&gt;top]; //栈顶指针--; S-&gt;top--; return OK;&#125; 1.2.9 从栈底到栈顶每个元素打印（遍历）Status StackTraverse(SqStack S)&#123; int i = 0; printf(&quot;此栈中所有元素&quot;); while (i&lt;=S.top) &#123; printf(&quot;%d &quot;,S.data[i++]); &#125; printf(&quot;\\n&quot;); return OK;&#125; 1.3 栈的链式存储结构及实现1.3.1 示意图栈道链式存储结构，简称链栈。 链栈的示意图和顺序结构很类似，如图所示了入栈和出栈的流程： 1.3.2 链栈结构链栈道结构和单链表很相似： 节点的结构如下： typedef struct StackNode&#123; SElemType data; struct StackNode *next;&#125;StackNode,*LinkStackPtr; 链栈结构如下： typedef struct&#123; LinkStackPtr top; int count;&#125;LinkStack; 1.3.3 创建空栈Status InitStack(LinkStack *S)&#123; S-&gt;top=NULL; S-&gt;count=0; return OK;&#125; 1.3.4 清空一个栈Status ClearStack(LinkStack *S)&#123; LinkStackPtr p,q; p = S-&gt;top; while (p) &#123; q = p; p = p-&gt;next; free(q); &#125; S-&gt;count = 0; return OK; &#125; 1.3.5 判断栈是否为空Status StackEmpty(LinkStack S)&#123; return S.count == 0;&#125; 1.3.6 返回栈的长度int StackLength(LinkStack S)&#123; return S.count;&#125; 1.3.7 获取栈顶元素Status GetTop(LinkStack S,SElemType *e)&#123; if(S.top == NULL) return ERROR; else *e = S.top-&gt;data; return OK;&#125; 1.3.8 插入元素e 为新栈顶元素（压栈）Status Push(LinkStack *S, SElemType e)&#123; //创建新结点temp LinkStackPtr temp = (LinkStackPtr)malloc(sizeof(StackNode)); //赋值 temp-&gt;data = e; //把当前的栈顶元素赋值给新结点的直接后继, 参考图例第①步骤; temp-&gt;next = S-&gt;top; //将新结点temp 赋值给栈顶指针,参考图例第②步骤; S-&gt;top = temp; S-&gt;count++; return OK;&#125; 1.3.9 删除栈定元素，并用e带回（出栈）Status Pop(LinkStack *S,SElemType *e)&#123; LinkStackPtr p; if (StackEmpty(*S)) &#123; return ERROR; &#125; //将栈顶元素赋值给*e *e = S-&gt;top-&gt;data; //将栈顶结点赋值给p,参考图例① p = S-&gt;top; //使得栈顶指针下移一位, 指向后一结点. 参考图例② S-&gt;top= S-&gt;top-&gt;next; //释放p free(p); //个数-- S-&gt;count--; return OK;&#125; 1.3.10 从栈底到栈顶每个元素打印（遍历）Status StackTraverse(LinkStack S)&#123; LinkStackPtr p; p = S.top; while (p) &#123; printf(&quot;%d &quot;,p-&gt;data); p = p-&gt;next; &#125; printf(&quot;\\n&quot;); return OK;&#125; 1.4 栈与递归1.4.1 递归的定义 直接调用自己或通过一系列的调用语句间接地调用自己的函数，叫做递归函数。 1.4.2 递归的特点 每个递归定义必须有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。 1.4.3 递归与迭代的区别 迭代： 使用的是循环结构。 递归：使用的是选择结构。是程序结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。 1.4.4 递归的使用场景 定义是递归的 数据结构是递归的 问题的解法是递归的 1.4.5 递归应用——斐波那契数列问题：如果兔子2个月之后就会有繁殖能力，那么一对兔子每个月能生出一对兔子；假设所有的兔子都不死，那么n个月后能生出多杀只兔子呢？ 解法： int Fbi(int i)&#123; if(i&lt;2) return i == 0?0:1; return Fbi(i-1)+Fbi(i-2);&#125; 1.4.6 递归过程与递归工作栈我们日常使用函数时，常有函数内套用其他函数，而其他函数又会套用其他的函数，比如如下的代码： void main()&#123; int m, n; first(m, n);&#125; int first(int s, int t)&#123; int i; //... second(i);&#125;int second(int d)&#123; int x,y; // blablabla&#125; 这样的结构，其实也是递归的应用，这种应用叫做递归工作站，其结构示意图如下:","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://nilsli.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://nilsli.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"http://nilsli.com/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://nilsli.com/tags/%E9%98%9F%E5%88%97/"}]},{"title":"【数据结构与算法】-（5）链表面试题解析","slug":"0409questionsOfAlgo","date":"2020-04-09T03:28:58.000Z","updated":"2024-08-07T07:10:46.385Z","comments":true,"path":"p/50518edc.html","permalink":"http://nilsli.com/p/50518edc.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 序言之前复习了一下数据结构以及线性表的基础，继续来做一些习题，巩固一下。 Q1 链表合并1. 题目：将两个递增的有序链表合并为一个有序链表；要求结果链表仍然是用两个链表的存储空间，不另外占用其他的存储空间；表中不允许有重复的数据 如La{1 ,2, 3}, Lb{3, 6, 9}, 合并成为 Lc{1, 2, 3, 6, 9} 2. 分析：本题要求如下： 两个都是递增有序链表 不允许重复数据 结果要求保持递增关系，可以考虑后插法 不占用额外空间，也不允许新建维持逻辑 3. 算法思路： 准备临时变量：头指针Lc——由于要求不占用额外空间，Lc指向（借用）La 的头结点 依次循环La、Lb ， 比较pa、pb两者的 data 值大小，取较小者存到Lc里 比较较小者剩余链表，与较大者的data，循环往复 4. 代码实现：ListNode* mergeTwoLists(ListNode* La, ListNode* Lb) &#123; if(La == NULL) return Lb; else if(Lb == NULL) return La; ListNode *Lc = NULL; if(La-&gt; data &lt; Lb-&gt; data)&#123; Lc = La; Lc-&gt;next = mergeTwoLists(La-&gt;next, Lb); &#125;else&#123; Lc = Lb; Lc-&gt;next = mergeTwoLists(La, Lb-&gt;next); &#125; return Lc;&#125; 5. 流程图解 Q2 链表：求重1. 题目：已知两个链表A和B分别表示两个集合.其元素递增排列. 设计一个算法,用于求出A与B的交集,并存储在A链表中; 例如: La &#x3D; {2,4,6,8}; Lb &#x3D; {4,6,8,10}; Lc &#x3D; {4,6,8} 2. 分析： 需要比较相同元素，予以保留 比较后不同的元素，予以删除 3. 算法思路这道题目与上道题恰恰相反，在依次循环后，留下相同的元素。 准备临时变量： 原始链表La、Lb、 链表 La 和 Lb 各自的首元结点指针pa、 pb、 头指针Lc——由于要求不占用额外空间，Lc指向（借用）La 的头结点 依次循环La、Lb ， 比较pa、pb两者的 data 值大小 若相等，把pa存到Lc里，释放pb指定结点 若不相等，释放掉较小的元素 若循环至某一方为空，删除&#x2F;释放非空表所有元素 4. 代码实现void Intersection(LinkList *La, LinkList *Lb, LinkList *Lc)&#123; //目标: 求2个递增的有序链表La,Lb的交集, 使用头指针Lc指向带回; LinkList pa,pb,pc,temp; //pa 是链表La的工作指针,pb 是链表Lb的工作指针, 初始化为首元结点;La的头结点作为Lc的头结点; pa = (*La)-&gt;next; pb = (*Lb)-&gt;next; *Lc = pc = *La; while (pa &amp;&amp; pb) &#123; if (pa-&gt;data == pb-&gt;data) &#123; //相等,交集并入结果链表中; //(1).取La中的元素,将pa链接到pc的后面,pa指针后移; pc-&gt;next = pa; pc = pa; pa = pa-&gt;next; //(2)删除Lb中对应相等的元素 temp = pb; pb = pb-&gt;next; free(temp); &#125;else if(pa-&gt;data &lt; pb-&gt;data)&#123; //删除较小值La的元素; temp = pa; pa = pa-&gt;next; free(temp); &#125;else&#123; //删除较小值Lb中的元素 temp = pb; pb = pb-&gt;next; free(temp); &#125; &#125; //Lb为空,删除非空表La中的所有元素 while (pa) &#123; temp = pa; pa = pa-&gt;next; free(temp); &#125; //La为空,删除非空表Lb中的所有元素 while (pb) &#123; temp = pb; pb = pb-&gt;next; free(temp); &#125; pc-&gt;next = NULL; free(*Lb);&#125; 5. 流程图解Q3 链表原地旋转【面试常有】1. 题目：设计一个算法,将链表中所有节点的链接方向”原地旋转”，即要求仅仅利用原表的存储空间。换句话说,要求算法空间复杂度为O(1); 例如:L &#x3D; {0,2,4,6,8,10}, 逆转后: L &#x3D; {10,8,6,4,2,0}; 2. 分析： 不可以开辟空间 只能移动指针 首选头插法 3. 算法思路： 保持当前头结点的下个结点 将当前头结点的指向指到上一个结点 把当前头结点保存为上一个结点 将头结点的下一个结点，设定为头结点 4. 代码实现：struct LinkList* reverseList(struct LinkList* head)&#123; if(head == NULL || head-&gt;next == NULL) return head; struct LinkList *preNode = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return preNode; &#125; 5. 流程图解 Q4 链表删除指定元素1. 题目：设计一个算法，删除递增有序链表中值大于等于mink且小于等于maxk（mink, maxk是给定的两个参数,其值可以和表中的元素相同,也可以不同）的所有元素; 2. 分析： 链表递增 给定上边界、下边界 上下边界找到后，桥接起来 边界中其他元素删除 3. 算法思路： mink：循环链表1次，找到第一个大于mink的结点，记住其前驱结点pre maxk：循环链表2次，找到大于等于maxk 的结点，用p标记 桥接：把 pre -&gt; next 指向结点p 循环释放，释放pre、p 中间的结点 4. 代码实现：void DeleteMinMax(LinkList *L, int mink, int maxk)&#123; //目标: 删除递增有序链表L中值大于等于mink 和小于等于maxk的所有元素 LinkList p,q,pre; pre = *L; LinkList temp; //p指向首元结点 p = (*L)-&gt;next; //1.查找第一值大于mink的结点 while (p &amp;&amp; p-&gt;data &lt; mink) &#123; //指向前驱结点 pre = p; p = p-&gt;next; &#125; //2.查找第一个值大于等于maxk的结点 while (p &amp;&amp; p-&gt;data&lt;=maxk) &#123; p = p-&gt;next; &#125; //3.修改待删除的结点指针 q = pre-&gt;next; pre-&gt;next = p; while (q != p) &#123; temp = q-&gt;next; free(q); q = temp; &#125;&#125; 5. 流程图解Q5 数组平移1. 题目：设将n(n&gt;1)个整数存放到一维数组R中, 试设计一个在时间和空间两方面都尽可能高效的算法;将R中保存的序列循环左移p个位置 (0&lt;p&lt;n) 个位置， 即将R中的数据由 (x0,x1,……,xn-1) 变换为*(xp,xp+1,…,xn-1,x0,x1,…,xp-1)*. 例如: pre[10] &#x3D; {0,1,2,3,4,5,6,7,8,9}, n &#x3D; 10,p &#x3D; 3; pre[10] &#x3D; {3,4,5,6,7,8,9,0,1,2} 2. 分析： 数组而非链表 往左移动，原左边的元素依次推到右边 本质上两个区块元素交换，可考虑先原地旋转 再将两个区块元素各自原地旋转 3. 算法思路： 将原数组原地旋转，成为*[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]* 从后面第p位，将原数组断成为*[9, 8, 7, 6, 5, 4, 3]*, [2, 1, 0] 再将新的两个数组原地旋转*[3, 4, 5, 6, 7, 8, 9]*, [0, 1, 2] 合并成为目标数组 [3, 4, 5, 6, 7, 8, 9, 0, 1, 2] 4. 代码实现：void Reverse(int *pre,int left ,int right)&#123; //将数组R中的数据原地逆置 //i等于左边界left,j等于右边界right; int i = left,j = right; int temp; //交换pre[i] 和 pre[j] 的值 while (i &lt; j) &#123; //交换 temp = pre[i]; pre[i] = pre[j]; pre[j] = temp; //i右移,j左移 i++; j--; &#125;&#125;void LeftShift(int *pre,int n,int p)&#123; //将长度为n的数组pre 中的数据循环左移p个位置 if (p&gt;0 &amp;&amp; p&lt;n) &#123; //1. 将数组中所有元素全部逆置 Reverse(pre, 0, n-1); //2. 将前n-p个数据逆置 Reverse(pre, 0, n-p-1); //3. 将后p个数据逆置 Reverse(pre, n-p, n-1); &#125;&#125; 5. 流程图解Q6 链表查主元素1. 题目：已知一个整数序列A &#x3D; (a0,a1,a2,…an-1)，其中(0&lt;&#x3D; ai &lt;&#x3D;n),(0&lt;&#x3D; i&lt;&#x3D;n)。 若存在ap1&#x3D; ap2 &#x3D; …&#x3D; apm &#x3D; x，且m&gt;n&#x2F;2(0&lt;&#x3D;pk&lt;n,1&lt;&#x3D;k&lt;&#x3D;m)，则称x 为 A的主元素。 例如,A &#x3D; (0,5,5,3,5,7,5,5)，则5是主元素；若B &#x3D; (0,5,5,3,5,1,5,7)，则A 中没有主元素，假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法,找出数组元素中的主元素，若存在主元素则输出该元素，否则输出-1. 2. 分析： 递增数组 数组中可能有多次出现的元素 出现次数超过一半 &gt; n/2 ，即为目标元素 3. 算法思路： 假定一个候选主元素 key 依次遍历循环数组，将key 与数组元素对比，记录其与其他元素相同的次数，记作count，count 初始值为1 如果遇到相同元素，count++ ，否则 count++ 循环中，如遇到count 为0，即重复次数达不到一半，将遇到的下一个元素设定为key, count 置1， 重新循环 再次循环数组，计算数组中元素与key 重合次数，如大于 n/2， 即为主元素，否则无主元素。 4. 代码实现：int MainElement(int *A, int n)&#123; //目标: 求整数序列A中的主元素; //count 用来计数 int count = 1; //key 用来保存候选主元素, 初始A[0] int key = A[0]; //(1) 扫描数组,选取候选主元素 for (int i = 1; i &lt; n; i++) &#123; //(2) 如果A[i]元素值 == key ,则候选主元素计数加1; if (A[i] == key) &#123; count++; &#125;else&#123; //(3) 当前元素A[i] 非候选主元素,计数减1; if(count &gt;0)&#123; count--; &#125;else&#123; //(4) 如果count 等于0,则更换候选主元素,重新计数 key = A[i]; count = 1; &#125; &#125; &#125; //如果count &gt;0 if (count &gt;0)&#123; //(5)统计候选主元素的实际出现次数 for (int i = count = 0; i &lt; n; i++) if (A[i] == key) count++; &#125; //(6)判断count&gt;n/2, 确认key是不是主元素 if (count &gt; n/2) return key; else return -1; //不存在主元素&#125; Q7 链表的元素删除1. 题目用单链表保存m个整数, 结点的结构为*(data,link),且|data|&lt;&#x3D;n*(n为正整数)。 现在要去设计一个时间复杂度尽可能高效的算法。对于链表中的data 绝对值相等的结点, 仅保留第一次出现的结点,而删除其余绝对值相等的结点。例如,链表A &#x3D; {21,-15,15,-7,15}, 删除后的链表 A &#x3D; {21,-15,-7}; 2. 分析： 时间复杂度高效 可用空间换时间——即开辟更多空间 循环原链表，若元素已经出现过，保存第一个，删除其他绝对值相等的元素 3. 算法思路： 可额外开辟大小为 n + 1 的辅助数组，初始值为 0 从首元结点开始遍历链表，检查元素值，用t[|data|] 计算链表元素出现的次数： 若元素[｜data｜] 为0，即首次出现，保留结点，使得 t[|data|] &#x3D; 1 若 [|data|] 不为 0， 则将该结点从链表中删除。 xvoid DeleteEqualNode(LinkList *L,int n)&#123; //目标: 删除单链表中绝对值相等的结点; //1. 开辟辅助数组p. int *p = alloca(sizeof(int)*n); LinkList r = *L; //2.数组元素初始值置空 for (int i = 0; i &lt; n; i++) &#123; *(p+i) = 0; &#125; //3.指针temp 指向首元结点 LinkList temp = (*L)-&gt;next; //4.遍历链表,直到temp = NULL; while (temp!= NULL) &#123; //5.如果该绝对值已经在结点上出现过,则删除该结点 if (p[abs(temp-&gt;data)] == 1) &#123; //临时指针指向temp-&gt;next r-&gt;next = temp-&gt;next; //删除temp指向的结点 free(temp); //temp 指向删除结点下一个结点 temp = r-&gt;next; &#125;else &#123; //6. 未出现过的结点,则将数组中对应位置置为1; p[abs(temp-&gt;data)] = 1; r = temp; //继续向后遍历结点 temp = temp-&gt;next; &#125; &#125; &#125; 5. 复杂度 时间复杂度: O(m), 对长度为m的链表进行一趟遍历,则算法时间复杂度为O(m); 空间复杂度: O(n)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://nilsli.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性表","slug":"线性表","permalink":"http://nilsli.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"链表","slug":"链表","permalink":"http://nilsli.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【底层探索】- 多线程(一)","slug":"0509thread","date":"2020-04-06T10:18:51.000Z","updated":"2024-08-07T07:10:46.429Z","comments":true,"path":"p/e318a7b3.html","permalink":"http://nilsli.com/p/e318a7b3.html","excerpt":"","text":"一、线程定义1.1 基本概念 线程（Thread），有时被称为轻量级进程（Lightweight Progress, LWP），是程序执行流的最小单位。 一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级等资源（如打开文件和信号）。一个经典的线程与进程关系如图所示。 归纳一下总结一下。 线程是进程的基本执行单元，一个进程的所有任务都在线程中执行 进程想要执行任务，必须得有线程，至少1条 程序启动时，会默认开启一条线程，这条线程称为主线程或UI 线程 1.2 线程的访问权限线程实际上也拥有自己的私有存储空间，包括一下方面 栈 线程局部存储（TLS，Thread Local Storage）。线程局部存储是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。 寄存器。寄存器是执行流的基本数据，因此为线程私有。 从C 程序角度看，数据在线程之间是否私有如下所示： 二、进程的定义进程时指在系统中正在进行的一个应用程序。每个进程之间时独立的内存空间和地址 面试题：每个iOS App 有几个进程，为何这样设计？ iPhone 从早起1G 开始就显得比安卓系统更流畅，是因为它采用了单一进程 的策略。 这样避免了进程的来回切换，CPU 消耗大大降低；另外在数据安全性上，才用单一沙盒机制，隔离文件，保证App 的独立性，提高安全系数。 三、线程与进程关系他们的关系主要从以下几个方面考虑 地址空间： 线程： 同一地址的线程共享本进程的地址空间 进程：进程之间是独立的地址空间 资源拥有 线程：同一进程哪都线程共享本进程的资源，如内存空间、I&#x2F;O、CPU 等 进程：进程之间的资源上独立的 健壮性——多进程比多线程健壮 线程：进程内任意线程崩溃，会导致整个进程瘫痪。 进程：进程崩扩后，在保护模式下不会对其他进程发生影响。 资源消耗 线程：进程切换时，消耗的资源大，效率高 进程：线程无法切换，只能互相通信，消耗的资源较小 执行过程 线程：不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制 进程：每个独立的进程都有一个程序运行的入口、顺序执行序列和程序入口。 基本属性。 线程：是处理器调度的基本单位。 进程：并不是。 四、多线程4.1 多线程的原理 CPU 在单位时间片里快速在各个线程之间切换 不论是在多处理器的计算机上还是在单处理器的计算机上，线程总是”并发”执行的。当线程数量小于等于处理器数量时（并且操作系统支持多处理器），线程的并发是真正的并发，不同的线程运行在不同的处理器上，彼此之间互不相干。但对于线程数量大于处理器数量的情况，线程的并发会收到一些阻碍，因为此时至少有一个处理器会运行多个线程。 在单处理器对应多线程的情况下，并发是一种模拟出来的状态。操作系统会让这些多线程程序轮流执行，每次进执行一小段时间（通常是几十到几百毫秒），这样每个线程就”看起来“在同事执行。 处于运行中线程拥有一段可以执行的时间，这段时间称为时间片（Time Slice）。当时间片用尽，该进程将进入就绪状态。 4.2 多线程的好处 多线程能改进应用的响应机制 多线程能改进多核系统下的应用的实时表现 4.3 线程的生命周期多线程的生命周期，一般有以下几个 新建 运行 Running。此时线程正在执行 就绪 Ready。此时线程可以立即运行，但是CPU 已经被占用 堵塞 BLocked。此时CPU 正在执行sleep 方法&#x2F;锁等占用动作，此时其他线程无法执行。 死亡。任务完成，或者强制退出线程 4.4 线程池的原理4.4.1 执行流程 判断线程池大小是否小于核心线程池等大小 如果否，继续判断工作队列是否已满 如果否，提交任务到工作队列 创建线程去执行任务 如归是，线程队列已满，判断线程池是否都已在工作 如果是，交给饱和策略 如果否，创建线程去执行任务 如果小与，此时可以直接创建线程去执行任务 4.4.2 策略这里需要找一下 Oracle 关于线程池执行器的一些解释 类型 策略名 static class ThreadPoolExecutor.AbortPolicy抛出RejectedExecutionException 的异常，并阻止系统运行 static class ThreadPoolExecutor.CallerRunsPolicy拒绝任务，并在执行方法的调用线程里运行该拒绝任务，除非执行者被关闭，此时任务也会被弃用。 static class ThreadPoolExecutor.DiscardOldestPolicy放弃执行最早的未完成请求，并尝试执行任务 static class ThreadPoolExecutor.DiscardPolicy任务被拒绝添加时，线程池丢弃被拒绝的任务 4.5 线程和runloop 的关系概念上，主要有以下几个 runloop 与线程是一一对应的，一个runloop 对应一个核心进程（因为runloop 是可以嵌套的，但是核心的只有一个），他们的关系保存在一个全局的字典里。 runloop 是来管理线程的，当线程的runloop 被开启后，线程会在执行完任务后进入休眠状态，有了任务就会被唤醒去执行任务。 runloop 在第一次获取时被创建，在线程时被销毁 对于主线程来说，runloop 在程序一启动就默认创建好了 对于子线程来说，runloop 是懒加载的，只有当我们使用的时候才会创建。所以在子线程用定时器要注意：确保子线程的runloop 被创建，不然定时器不会回调。 4.6 iOS 中的多线程iOS 中一般有以下多线程 GCD 就是我们最常使用的Grand Central Dispatch。底层由C 语言写成，由苹果公司开发的一种用于多核处理器的应用优化技术，初始使用在Mac OS X 10.6 以及移动端的iOS 4 上。GCD 的名字起源于位于美国纽约曼哈顿中城的大中央总站。 示例： - (IBAction)analyzeDocument:(NSButton *)sender &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSDictionary *stats = [myDoc analyze]; dispatch_async(dispatch_get_main_queue(), ^&#123; [myModel setDict:stats]; [myStatsView setNeedsDisplay:YES]; &#125;); &#125;);&#125; NSThread 是苹果公司基于GCD 包装的一种面向对象的管理线程的方式，可以由程序员自行创建线程及退出。 pThread 即POSIX线程。POSIX 线程提供了一个基于C 语言的接口来创建线程。如果你不是在写Cocoa 应用，这恐怕是最理想的创建线程的选择。POSIX 接口相当简单也足够灵活的配置你的线程。 NSOperation 五、线程间的通讯这个也是面试题经常会问到的，无论是中级还是高级的面试题。 苹果官方 线程相关的文档是这样介绍的，线程间的通讯如下： 一共有7种方式: 直接传递消息：可以从一个线程往任意一个线程发送消息。这种能力意味着一个线程能从根本上在任意一个其他的线程执行某方法。因为他们被执行在目标线程的环境下，在该线程下消息被自动连续的发送。 比较常见的就是performSelector 全局变量：共享内存及共享对象，尽管共享变量快捷而渐变，但相比直接传递消息他们也更加不稳定。使用共享变量得用所活着其他同步机制格外小心的保护，以确保代码的准确性。一旦使用不当容易引起竞态条件、数据改变或者崩溃。 Conditions：当一个线程执行了特定的部分代码，同步工具可以用来控制。你可以想象conditions 当作门卫，只有当状态条件满足的情况下，线程才允许执行。 Runloop 资源：自定义runloop 资源用来在线程里接受应用特定的信息。因为他们是事件驱动，runloop 资源会在无任务时将你的线程休眠，改进线程的效率。 端口与套接字：基于端口的通讯是一种在两个线程通讯更精密的方式，也是一种可靠的技术。更重要的是，端口和套接字能用来与外部实体进行通讯，例如其他进程和服务。为了效率期间，端口通过使用runloop 资源来实现，因此等待端口无事可做时，线程也会被休眠。 消息队列：经典的多处理器服务为来管理进出的数据，制定了一个先进先出队列（FIFO）概念。尽管消息队列简单而方便，他们也不像其他通讯技术那样高效。 对象分发：对象分发是一种Cocoa 技术，提供了基于端口高级实现。尽管在线程内使用这门技术也能用，但鉴于使用它会带来的性能开支，高度不建议使用。分发对象更适合于进程间的通信，尤其是当进程消耗已经很高的情况下（虱子多了不咬，债多了不愁）。 六、线程的关闭建议在创建线程的时候，就设计好响应取消和退出线程的消息。对于长任务来说，这可能意味着周期性的停止工作而查看是否有消息到达。如果确实有消息进来——要求线程退出，线程可能接下来可以实现一些必须的清理工作，然后优雅的退出；否则继续工作。 响应取消消息的方法是使用Runloop，看看下面的代码： - (void)threadMainRoutine&#123; BOOL moreWorkToDo = YES; BOOL exitNow = NO; NSRunLoop* runLoop = [NSRunLoop currentRunLoop]; // Add the exitNow BOOL to the thread dictionary. NSMutableDictionary* threadDict = [[NSThread currentThread] threadDictionary]; [threadDict setValue:[NSNumber numberWithBool:exitNow] forKey:@&quot;ThreadShouldExitNow&quot;]; // Install an input source. [self myInstallCustomInputSource]; while (moreWorkToDo &amp;&amp; !exitNow) &#123; // Do one chunk of a larger body of work here. // Change the value of the moreWorkToDo Boolean when done. // Run the run loop but timeout immediately if the input source isn&#x27;t waiting to fire. [runLoop runUntilDate:[NSDate date]]; // Check to see if an input source handler changed the exitNow value. exitNow = [[threadDict valueForKey:@&quot;ThreadShouldExitNow&quot;] boolValue]; &#125;&#125;","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://nilsli.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"http://nilsli.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"http://nilsli.com/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"【底层探索】- 多线程(二)GCD应用","slug":"0512gcd","date":"2020-04-05T01:09:43.000Z","updated":"2024-08-07T07:10:46.434Z","comments":true,"path":"p/bd5c42bb.html","permalink":"http://nilsli.com/p/bd5c42bb.html","excerpt":"","text":"一、面试题解析1.1 第一题A、提问：以下代码，会打印什么？ dispatch_queue_t queue = dispatch_queue_create(&quot;lj&quot;, DISPATCH_QUEUE_SERIAL);NSLog(@&quot;1&quot;);dispatch_async(queue, ^&#123;//block1 NSLog(@&quot;2&quot;); dispatch_sync(queue, ^&#123;//block2 NSLog(@&quot;3&quot;); &#125;); NSLog(@&quot;4&quot;);&#125;);NSLog(@&quot;5&quot;); B、思路： 创建的事串行队列，所以队列依次进行 先执行 NSLog(@&quot;1&quot;);，打印1 接下来的异步函数dispatch_async(queue, ^&#123;//block1&#125;); 需要耗时，所以先跳过 执行 NSLog(@&quot;5&quot;);，打印5 回头来执行第3步异步函数内部的代码。 先执行NSLog(@&quot;2&quot;);， 打印2 接下来执行同步函数 dispatch_sync(queue, ^&#123;xxx&#125;);， 此时阻塞线程。 后面的NSLog(@&quot;4&quot;); 需等待上一步同步函数执行完才能执行，无法执行打印。 异步函数内部NSLog(@&quot;3&quot;); 新创建，但是属于好事操作，需等待外部流程——即NSLog(@&quot;4&quot;); 这一代码执行完。 上面两部互为等待，形成死锁。无法执行，会导致崩溃。 原理图可以这样看待： C、回答：打印1,5,2。以及崩溃 D、验证： 1.2 第二题（美团）A、提问：以下代码，会打印什么 __block int a = 0;while (a &lt; 10) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; a++; &#125;);&#125;NSLog(@&quot;a = %d \\n&quot;, a); B、思路： 首先执行的是异步函数，决定了每个任务都是独立、无线程阻塞、放飞自我的 执行在全局并发队列里，即各自分别执行，会频繁读取a++，线程并不安全 上面第1、第2步决定了，当a自增到10时，跳出while 循环，但是打印的时候，很可能某1个或者多个任务还在异步执行，此时有两种情况 打印前a++ ：此时很能有1个或多个任务在抢占资源，进行a++， 那么多次打印后打印 大于10 打印后a++ ：即此时打印函数这个任务，成功抢占资源，先打印成功 则打印了10 流程请参考图 C、回答：打印结果 &gt;&#x3D; 10 D、验证 二、GCD 简介2.1 概念 GCD 全称是Grand Central Dispatch，是苹果公司为多核的并行运算提出的解决方案，一种纯C 语言写成的框架，提供了非常多强大的函数 2.2 GCD 的优点主要有以下几点 GCD 会自动利用更多的CPU 内核（双核、四核等） GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。程序员只需要告诉GCD 执行的任务，不需要编写任何线程管理代码。 2.3 GCD 的函数GCD 的函数使用过程为：将任务添加到队列，并且制定执行任务的函数 任务使用 block 封装 任务的block 没有参数也没有返回值 函数的类型有异步函数和同步函数 2.3.1 异步函数 dispatch_async 不用等当前语句执行完毕，就可以执行下一条语句 会开启线程执行 block 的任务 异步是多线程的代名词 2.3.2 同步函数 dispatch_sync 必须等待当前语句执行完毕，才会执行下一条语句（俗称阻塞线程） 不会开启线程 在当前执行block 的任务 2.4. 队列队列通常有并行队列和串行队列，顾名思义，并行队列队列宽度足够，互不干扰，各自为政；串行队列宽度只有1，每次只能执行同一个任务。 串行队列（Seiral Dispatch Queue）: 每次只有一个任务被执行，任务一个接一个地执行。（只开启1个线程，一个任务执行完毕后，在执行下一个任务） 并发队列（Concurrent Dispatch Queue）： 可以多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）。 注意：并发队列的并发功能只有在异步函数（async）下有效。 如下图所示 队列的概念主要两个重要的队列： 2.4.1 主队列 主队列专门用来在主线程上调度任务的队列，并不会开启线程 才用先进先出（FIFO）原则，主线程空闲时才会呆㷣度队列中的任务在主线程中执行 如果当前主线程正在有任务执行，那么无论主队列中当前被添加了什么任务，都不会被调度。 主队列的获取代码为： dispatch_queue_t queue = dispatch_get_main_queue(); 平时开发中的 UI 操作，都必须在主线程的主队列中进行。 2.4.2 全局队列为了方便程序员自行使用其他队列，苹果提供了全局队列：dispatch_get_global_queue(0, 0)， 而且全局队列是一个并发队列。 在使用多线程开发时，如果对队列没有特殊需求，在执行异步任务时，可以直接使用全局队列。 2.5 函数与队列函数（同步、异步）和队列（串行、并发）的组合一共有4种，主要有以下特点： 同步函数串行队列： 不会开启线程，在当前线程执行任务 任务串行执行，one by one 会产生线程阻塞 同步函数并发队列 不会开启线程，在当前线程执行任务 任务一个接一个，无阻塞 异步函数串行队列 开启一条新线程 任务一个接一个 异步函数并发队列 开启多个线程，在当前新线程执行任务 任务异步执行，没有顺序，由CPU 调度 2.6 死锁主线程因为同步函数强制执行当前任务的特性，会让后面的任务等待。 而主队列等待主线程的任务执行完毕，才能执行自己的任务，最后导致主队列和主线程相互等待，造成死锁 举例如下： - (void)test&#123; dispatch_queue_t q = dispatch_get_main_queue(); NSLog(@&quot;!!!!&quot;); dispatch_sync(q, ^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;);&#125; 上文中代码，主队列必须执行dispatch_sync了之后 才能继续执行后面的代码 但是主线程有任务在执行——正在执行test 解决方案：将任务同步添加到主队列当中： - (void)test&#123; dispatch_queue_t q = dispatch_get_main_queue(); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; dispatch_sync(q, ^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;); &#125;);&#125; 三、GCD 栅栏函数3.1 概念栅栏函数的作用，是控制任务执行的顺序，它是一种同步函数。 3.2 使用一般有同步和异步两种 异步： dispatch_barrier_async 代码以前的任务执行完，才会执行以后的任务 同步：dispatch_barrier_sync 作用相同，但是执行这个会阻塞线程，影响后面的任务执行。 可见，同步的栅栏函数，也是另一种加锁的方式 3.3 举例 同步栅栏函数 异步栅栏函数 3.4 注意点 栅栏函数主要作用是同步效果 提高代码的安全性能，线程安全 基本原理是阻塞队列 使用自定义的队列，不可使用全局的，否则进程都会阻塞 使用同一并发队列，即目标与栅栏函数在同一个队列里。 比如AFN ，他会自行实现了一个内部的队列，保证代码的内聚。 四、GCD 调度组4.1 概念调度组的作用是：控制任务的执行顺序 4.2 调度 创建组：dispatch_group_create 进组任务： dispatch_group_async。规则为先进组、后出组 进组：dispatch_group_enter 出组：dispatch_group_leave 进组任务执行完毕通知：dispatch_group_notify 进组任务执行等待时机：dispatch_group_wait 4.3 使用在日常业务开发中，可以将多个异步进行的事件放入group 中( 进组)，待各自完成（出组）后，实现最终结果——是不是很熟悉，有时候多个token 进行拼接获取，最终得到可以使用的，这个流程就可以通过调度组实现。 - (void)test3&#123; dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(0, 0); __block int a = 0; __block int b = 0; dispatch_group_async(group, queue, ^&#123; a += 2; dispatch_group_enter(group); &#125;); dispatch_group_leave(group); dispatch_group_async(group, queue, ^&#123; b += 2; dispatch_group_enter(group); &#125;); dispatch_group_leave(group); dispatch_group_notify(group, queue, ^&#123; NSLog(@&quot;当前a + b = %d&quot;, a + b); &#125;); &#125; 最终打印结果为： 2020-05-12 14:58:02.479083+0800 ttttt[12127:739541] 当前a + b = 4 五、信号量如何准确的打印第一题的数值，达到10的结果呢？ 可以使用信号量，可以有效的避免异步函数造成任务不可控。主要流程有如下几点 创建信号量 信号等待，即锁住线程。信号量– 执行业务，解锁开关，即业务不执行完，线程无法往后走。信号量++ 如下： // 1. 创建信号量dispatch_semaphore_t sem = dispatch_semaphore_create(1); __block int a = 0; while (a &lt; 10) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; a++; NSLog(@&quot;a = %d \\n&quot;, a); // 解锁线程 dispatch_semaphore_signal(sem); &#125;); // 等待信号、锁住线程 dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); &#125; 成功打印结果如下： 五、GCD 的Dispatch_source5.1 概念 An object that coordinates the processing of specific low-level system events, such as file-system events, timers, and UNIX signals. Gispatch source 是一种协调特定的低级别系统事件，如文件系统事件、Timer以及UNIX 信号。 5.2 特点 CPU 符合非常小，不占用资源 联合体，结构简洁，使用更高效 5.3 使用 创建源 : 创建一个dispatch source 来监测低级别的系统事件。具体实现为 dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, unsigned long mask, dispatch_queue_t queue); type - dispatch source 的类型。举个例子，创建 定时器source，指定为 DISPATCH_SOURCE_TYPE_TIMER handle - 监控回调的句柄 mask - 决定哪些事件是需要的flags 的掩码。 queue - 事件回调block 需要提交的目标队列 管理事件回调 代码水岸为： void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler); 获取源 属性 合并数据到一个分发的源，并提交它的事件回调block 到自己的目标队列中。 代码实现为： void dispatch_source_merge_data(dispatch_source_t source, unsigned long value); 取消源 使用方式为 void dispatch_source_cancel(dispatch_source_t source); 5.4 应用5.4.1 代码实现 创建队列 self.queue = dispatch_queue_create(&quot;lj&quot;, 0); 创建源 self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue()); 配置事件回调 dispatch_source_set_event_handler(self.source, ^&#123; NSUInteger value = dispatch_source_get_data(self.source); NSLog(@&quot;获取到 %lu&quot;, (unsigned long)value);&#125;); 激活源 dispatch_resume(self.source); 提交时间回调到目标队列中 - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; self.value += 1; dispatch_source_merge_data(self.source, self.value);&#125; 5.4.2 运行查看由于是点击事件触发，所以依次增加，结果为: 2020-05-12 15:37:25.606845+0800 ttttt[12489:768578] 获取到 12020-05-12 15:37:26.336439+0800 ttttt[12489:768578] 获取到 22020-05-12 15:37:26.936856+0800 ttttt[12489:768578] 获取到 32020-05-12 15:37:27.689042+0800 ttttt[12489:768578] 获取到 42020-05-12 15:37:29.186446+0800 ttttt[12489:768578] 获取到 5** 六、总结在这一章节，主要复习了GCD 的各种应用，认识了队列与函数，以及各种加锁的方式（栅栏函数等），这里有个小小的练习：自定义的source 写的Timer，供参考。 Github Demo地址","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://nilsli.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"http://nilsli.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"GCD","slug":"GCD","permalink":"http://nilsli.com/tags/GCD/"}]},{"title":"【底层探索】- KVO（下）自定义KVO","slug":"0508kvo","date":"2020-04-04T08:37:15.000Z","updated":"2024-08-07T07:10:46.428Z","comments":true,"path":"p/fe949d29.html","permalink":"http://nilsli.com/p/fe949d29.html","excerpt":"","text":"序上文中，初步探索了KVO的使用以及背后的实现原理，这次来自己实现一个KVO，一方面在过程中加深理解，另一方面可以感受一下使用场景。 根据上文总结，KVO的实现一共有3部分： 添加KVO监听方法 KVO 通知实现方法 KVO 移除方法 下面一步一步来进行实现 一、添加KVO监听1.0 创建自定义方法仿照KVO 方法之前，先看一下原生的方法，从中做一下借鉴： - (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context; 可见一共有4个重要参数 观察者 - observer - NSObject 类型 检测关键键 - keyPath - NSString 类型 选项 - options - NSKeyValueObservingOptions 类型 上下文 - 用来定位键值 - (void*) 指针类型 明白之后，写一个对NSObject 的分类，在分类里进行方法扩展，创建一个自定义的监听方法如下： @interface NSObject (LJKVO)- (void)lj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(LJKeyValueObservingOptions)options context:(nullable void *)context; 可见在options 做了自定义，可以简单的自定义一下： typedef NS_OPTIONS(NSUInteger, LJKeyValueObservingOptions) &#123; LJKeyValueObservingOptionNew = 0x01, LJKeyValueObservingOptionOld = 0x02,&#125;; 1.1 验证传入setter 有效性第一件事就是判断当前对象的类里，是否有与这个keyPath匹配setter 方法，得过了这一关，才允许添加观察，否则会抛出异常。 判断步骤如下： 拿到当前对象的类 获取keyPath 对应的setter方法编号。 这里有个细节的地方是，setter 方法是首字母大写，比如属性是name，它的setter 方法变成setName，所以需要对字符串做一下调整——添加set、首字母大写——这些在代码里可以看见。 去当前对象的父类——也就是类对象查找keyPath 对应的方法实现， 判断setter方法实现是否存在： 如果实现，则通过； 找不到，即抛出异常 - (void)judgeSetterMethodFromKeyPath:(NSString *)keyPath&#123; /*Step 1*/ Class superClass = object_getClass(self); /*Step 2*/ SEL setterSeletor = NSSelectorFromString(setterForGetter(keyPath)); /*Step 3*/ Method setterMethod = class_getInstanceMethod(superClass, setterSeletor); /*Step 4*/ if (!setterMethod) &#123; @throw [NSException exceptionWithName:NSInvalidArgumentException reason:[NSString stringWithFormat:@&quot;没有当前%@的setter&quot;,keyPath] userInfo:nil]; &#125;&#125;/* 对setter 方法进行字符串微调 1、添加set字符 2、首字母大写 如name 属性，其setter方法为 setName*/static NSString *setterForGetter(NSString *getter)&#123; if (getter.length &lt;= 0) &#123; return nil;&#125; NSString *firstString = [[getter substringToIndex:1] uppercaseString]; NSString *leaveString = [getter substringFromIndex:1]; return [NSString stringWithFormat:@&quot;set%@%@:&quot;,firstString,leaveString];&#125; 1.2 动态生成自定义子类大家知道原生的类添加KVO之后，会动态生成NSKVONotifying 的类，这个类继承自原来的类，有class 以及对属性的setter 方法、dealloc 方法等等。但是对我们自己写的——新诞生的动态子类，目前是光溜溜的来，但是自定义的步骤里面，它几乎是啥也没有，类似孙悟空从石头缝里蹦出来的一样。那么在这里，我们的流程是这样的： 动态生成类 注册类 给类添加class 方法，即指向原类的方法 给类添加setter 方法，基于keyPath 1.2.1 拼接子类名还记得系统生成的动态子类，是以NSKVONotifying_ 作为前缀，我们也做一个类似的类如下 获取当前对象的类： 将自定义的拼接到前面 根据字符串生成子类 实现代码如下： NSString *oldClassName = NSStringFromClass([self class]);NSString *newClassName = [NSString stringWithFormat:@&quot;%@%@&quot;,@&quot;LJKVONotifying_&quot;,oldClassName];Class newClass = NSClassFromString(newClassName); 得到的类，原来的类为Dog， 新类将会是LJKVONotifying_Dog 1.2.2 判断是否存在动态子类也要先判断这个类是否已经存在，以防止重复添加。如果已经存在就退出 // 防止重复创建生成新类if (newClass) return newClass; 1.2.3 申请动态子类内存空间这个比较简单，使用的是objc_allocateClassPair newClass = objc_allocateClassPair([self class], newClassName.UTF8String, 0); 1.3.4 注册该动态子类也就是讲这个新的 NSKVONotifying_xx 的类注册到（非元）类的散列表中 objc_registerClassPair(newClass); 1.3.5 添加class 方法。即给新的动态子类，添加class 方法首先是给这个类添加自定义的lj_class 方法，即使得该动态子类继承自原类。 这里涉及到给当前的动态子类的父类——即原来的类，建立联系 Class lj_class(id self, SEL _cmd)&#123; return class_getSuperclass(object_getClass(self));&#125; 那么，接下来，将这个类方法，添加到子类的方法列表里: SEL classSEL = NSSelectorFromString(@&quot;class&quot;);Method classMethod = class_getInstanceMethod([self class], classSEL);const char *classTypes = method_getTypeEncoding(classMethod);class_addMethod(newClass, classSEL, (IMP)lj_class, classTypes); 1.3.6 添加自定义的setter 方法。由于KVO 主要观察的是 setter 方法，所以需要写一个自定义的 setter 方法。 setter 方法的核心是，当这个动态子类接收到消息后，转发给原来的类——也就是其父类，告知它，现在属性有变化了，具体的实现，是把改动的值change 通过消息发送（objc_msgSend） 发送过去。 好的，下面来完成这个lj_setter 方法 从 setter 方法，获得完整的方法名keyPath static void lj_setter(id self, id newValue)&#123; NSString *keyPath = getterForSetter(NSStringFromSelector(_cmd)); /****/&#125;static NSString *getterForSetter(NSString *setter)&#123; if (setter.length &lt;= 0 || ![setter hasPrefix:@&quot;set&quot;] || ![setter hasSuffix:@&quot;:&quot;]) &#123; return nil;&#125; NSRange range = NSMakeRange(3, setter.length-4); NSString *getter = [setter substringWithRange:range]; NSString *firstString = [[getter substringToIndex:1] lowercaseString]; return [getter stringByReplacingCharactersInRange:NSMakeRange(0, 1) withString:firstString];&#125; 向父类发送新的值，此时需要自定义一个结构体，然后使用objc_msgSendSuper 发送 id oldValue = [self valueForKey:keyPath];void (*lj_msgSendSuper)(void *,SEL , id) = (void *)objc_msgSendSuper;// void /* struct objc_super *super, SEL op, ... */struct objc_super superStruct = &#123; .receiver = self, .super_class = class_getSuperclass(object_getClass(self)),&#125;;//objc_msgSendSuper(&amp;superStruct,_cmd,newValue)lj_msgSendSuper(&amp;superStruct,_cmd,newValue); 获取观察者。这里的观察者，为了避免全局冗余参数参数，提前使用关联对象与本类进行绑定，这一点在后面会介绍。 NSMutableArray *observerArr = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kLJKVOAssiociateKey)); 接下来，处理新的旧的值，将newValue的改变 该遍赋值给change，并发送给类，完成消息的发送 for (LJKVOInfo *info in observerArr) &#123; if ([info.keyPath isEqualToString:keyPath]) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSMutableDictionary&lt;NSKeyValueChangeKey,id&gt; *change = [NSMutableDictionary dictionaryWithCapacity:1]; // 对新旧值进行处理 if (info.options &amp; LJKeyValueObservingOptionNew) &#123; [change setObject:newValue forKey:NSKeyValueChangeNewKey]; &#125; if (info.options &amp; LJKeyValueObservingOptionOld) &#123; [change setObject:@&quot;&quot; forKey:NSKeyValueChangeOldKey]; if (oldValue) &#123; [change setObject:oldValue forKey:NSKeyValueChangeOldKey]; &#125; &#125; // 2: 消息发送给观察者 SEL observerSEL = @selector(lj_observeValueForKeyPath:ofObject:change:context:); objc_msgSend(info.observer,observerSEL,keyPath,self,change,NULL); &#125;); &#125; &#125; 可以看到观察者使用了LJKVOInfo, 这里我对观察者，做了模型的处理，更方便接耦。 里面包含了众多参数如下： @interface LJKVOInfo : NSObject@property (nonatomic, weak) NSObject *observer;@property (nonatomic, copy) NSString *keyPath;@property (nonatomic, assign) LJKeyValueObservingOptions options; 注意⚠️，这里有个坑点，是关于observer！ 由于原对象持有observer，observer 在添加关联对象时又持有self，self 又持有原对象，会导致循环引用——所以这里observer 必须使用weak 弱引用，防止循环引用 好了，现在的setter 方法的步骤已经完成，把它添加到动态子类里 SEL setterSEL = NSSelectorFromString(setterForGetter(keyPath));Method setterMethod = class_getInstanceMethod([self class], setterSEL);const char *setterTypes = method_getTypeEncoding(setterMethod);class_addMethod(newClass, setterSEL, (IMP)lj_setter, setterTypes); 1.3 isa 转向还记得原生的对象添加了KVO后，会将isa swizzling ，将isa 偷偷指向新的动态子类，委托后者对键值的变化进行消息发送，我们现在就是要做这个。 object_setClass(self, newClass); 一行代码搞定…… 1.4 保存观察者信息好了，动态子类也生成类，isa 也转向了，是不是大功告成了？不，还少了一步，把当前的监控者保存一下，不然以后无法找到他进行消息传递 LJKVOInfo *info = [[LJKVOInfo alloc] initWitObserver:observer forKeyPath:keyPath options:options];NSMutableArray *observerArr = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kLJKVOAssiociateKey));if (!observerArr) &#123; observerArr = [NSMutableArray arrayWithCapacity:1]; [observerArr addObject:info]; objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(kLJKVOAssiociateKey), observerArr, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125; 二、实现KVO监听方法这部分是最简单的，由开发者根据业务实现内容； 还是打印一下我写的 - (void)lj_observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context&#123; NSLog(@&quot;change %@&quot;, change);&#125; 三、移除KVO 监听移除KVO 与添加KVO 的进程是相反的，主要工作有：从观察者群里移除指定keyPath 的观察者、isa 转向（指回原类） 3.1 获取观察者群体还是用关联对象获取 NSMutableArray *observerArr = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kljKVOAssiociateKey));if (observerArr.count&lt;=0) &#123; return;&#125; 3.1 移除观察者这里移除观察者，是根据remove 方法传入的keyPath 进行匹配，如果匹配一致，则进行移除 for (LJKVOInfo *info in observerArr) &#123; if ([info.keyPath isEqualToString:keyPath]) &#123; [observerArr removeObject:info]; objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(kLJKVOAssiociateKey), observerArr, OBJC_ASSOCIATION_RETAIN_NONATOMIC); break; &#125;&#125; 3.2 isa 转向通过object_setClass 将isa 指回去 if (observerArr.count&lt;=0) &#123; // 指回给父类 Class superClass = [self class]; object_setClass(self, superClass);&#125; 四、改进——函数式编程上述的步骤基本完成了自定义的KVO，但是使用起来太过冗余，每次使用，都得调用 addObserver、observeValueForKeyPath以及removeObserver 三个函数，使用起来非常的冗余，是否有改进的空间呢？ 这里，使用block 的思想，使得更加函数的调用的聚合 4.1 定义block函数类型我们把添加的四大要素，都加入到block类型里，以供业务代码调用，具体如下： typedef void(^LJKVOBlock)(id observer,NSString *keyPath,id oldValue,id newValue); 4.2 改进添加观察者方法 先把观察者模型的初始化方法，改进称为block， 方便回调 - (instancetype)initWitObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath handleBlock:(LJKVOBlock)block&#123; if (self=[super init]) &#123; _observer = observer; _keyPath = keyPath; _handleBlock = block; &#125; return self;&#125; 函数声明如下： - (void)lj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(LJKVOBlock)block; 函数实现改进如下： - (void)lj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(LJKVOBlock)block&#123; // 1: 验证是否存在setter方法 : 不让实例进来 [self judgeSetterMethodFromKeyPath:keyPath]; // 2: 动态生成子类 Class newClass = [self createChildClassWithKeyPath:keyPath]; // 3: isa的指向 : ljKVONotifying_ljPerson object_setClass(self, newClass); // 4: 保存信息 ljInfo *info = [[ljInfo alloc] initWitObserver:observer forKeyPath:keyPath handleBlock:block]; NSMutableArray *mArray = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kljKVOAssiociateKey)); if (!mArray) &#123; mArray = [NSMutableArray arrayWithCapacity:1]; objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(kljKVOAssiociateKey), mArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; [mArray addObject:info];&#125; 4.3 具体使用使用起来，就很简洁了，一个block搞定 self.d = [[Dog alloc] init];[self.d lj_addObserver:self forKeyPath:@&quot;petName&quot; block:^(id _Nonnull observer, NSString * _Nonnull keyPath, id _Nonnull oldValue, id _Nonnull newValue) &#123; NSLog(@&quot;%@-%@&quot;,oldValue,newValue);&#125;]; 五、自动销毁机制上面第四部实现了block 引用，的确大大提升了业务代码的使用效率，但是还是需要自动执行移除观察，以及isa 的转向回去。 是否有更多优化的空间，将移动观察做的更加高效呢？ 当然可以！还记得动态子类生成后，也动态添加了dealloc 方法，那么，还是做dealloc 方法上做文章吧。 思路：自定义一个dalloc ，在里面实现对对象的KVO移除，在load 时将其与系统dealloc 进行方法交换 5.1 写自定义dealloc自己写一个dealloc，主要实现isa 的转向，在系统dealloc 进行之前，将当前对象的isa 指向原来的类。 代码如下： - (void)myDealloc&#123; Class superClass = [self class]; object_setClass(self, superClass); [self myDealloc];&#125; 5.2 将新旧方法进行交换这里依然使用runtime 的method swizzling 进行。 + (BOOL)kc_hookOrigInstanceMenthod:(SEL)oriSEL newInstanceMenthod:(SEL)swizzledSEL &#123; Class cls = self; Method oriMethod = class_getInstanceMethod(cls, oriSEL); Method swiMethod = class_getInstanceMethod(cls, swizzledSEL); if (!swiMethod) &#123; return NO; &#125; if (!oriMethod) &#123; class_addMethod(cls, oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod)); method_setImplementation(swiMethod, imp_implementationWithBlock(^(id self, SEL _cmd)&#123; &#125;)); &#125; BOOL didAddMethod = class_addMethod(cls, oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod)); if (didAddMethod) &#123; class_replaceMethod(cls, swizzledSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod)); &#125;else&#123; method_exchangeImplementations(oriMethod, swiMethod); &#125; return YES;&#125; 5.3 在load 中执行hook 方法及交换由于dealloc 为系统方法，在ARC 不允许通过 @selector(dealloc) 写入 那么还是使用runtime 特性，使用NSSelectorFromString(@&quot;dealloc&quot;) 来拿到，并进行交换。 这些交换，写到load 里面，编译时即可完成 + (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self kc_hookOrigInstanceMenthod:NSSelectorFromString(@&quot;dealloc&quot;) newInstanceMenthod:@selector(myDealloc)]; &#125;);&#125; 六、总结总的来说，自定义的KVO 和自定义的KVC 很类似，一步一步，生成子类，完善方法，isa 转向；而移除时，倒叙进行，isa 指回去之后，移除观察就可以了，而动态子类会保留，以便下次使用。 关于自定义KVO 的Demo 已经上传至我的Github ，欢迎下载参考","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"KVO","slug":"KVO","permalink":"http://nilsli.com/tags/KVO/"}]},{"title":"【数据结构与算法】-（4）双向链表和双向循环链表","slug":"doubleList","date":"2020-04-03T12:04:49.000Z","updated":"2024-08-07T07:10:46.614Z","comments":true,"path":"p/56790.html","permalink":"http://nilsli.com/p/56790.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 一、概念双向链表： 是在单链表的每个节点中，再设置一个指向其前驱结点的指针域。 所以在双向链表中的结点有两个指针域，一个指向直接后继，另一个指向直接前驱。 双向循环链表： 与双向链表相比，双向循环链表的尾结点的next指向头结点，头结点的prior 指向尾结点，形成一个循环。如下图所示： 创建代码如下： #define ElemType int;typedef struct DulNode&#123; ElemType data; struct DulNode *prior /*直接前驱指针*/ struct DulNode *next /*直接后继指针*/&#125; DulNode, *DuLinkList; 二、双向链表的操作2.1 创建链表创建双向链表的步骤如下： 创建空链表L，以及结点*L 指定一个尾结点为p 创建临时结点temp，并进行数值给定 将当前尾结点p与temp进行双线链接链接 temp 是 p 的后继 p 是 temp 的前驱 将temp 赋值给p，p依然为链表的尾结点。 // ① 创建*L 指向头结点*L = (LinkList)malloc(sizeof(Node));if (*L == NULL) return ERROR;(*L)-&gt;prior = NULL;(*L)-&gt;next = NULL;(*L)-&gt;data = -1;//② 新建一个尾结点 pLinkList p = *L;for(int i=0; i &lt; 10;i++)&#123; // ③ 创建1个临时的结点 LinkList temp = (LinkList)malloc(sizeof(Node)); temp-&gt;prior = NULL; temp-&gt;next = NULL; temp-&gt;data = i; // ④ 为新增的结点建立双向链表关系 // 1 temp 是p的后继 p-&gt;next = temp; // 2 temp 的前驱是p temp-&gt;prior = p; // ⑤ p 要记录最后的结点的位置,方便下一次插入 p = p-&gt;next; &#125; 2.2 增加结点向双向链表种添加结点的步骤和单向链表添加结点类似，只是多了一步链接前驱的工作。 步骤如下： 新建目标结点temp 创建指针 p ，指向链表的头结点 通过循环便利，将 p 向后移，找到插入位置 i 的结点 【判断】如果插入位置超出链表本身长度，跳出 【判断】如果 p 为链表尾部，只需做 p 与temp首尾相连 找到i 结点后，分两步对p 与temp 进行首尾相连 将原p 的next 的 prior 指向 目标结点temp 将目标结点的next 指向 p 的 next 将 p 的next 指向目标结点 temp 将 目标结点 temp 的 prior 指向 p 注意：这里的第四步中，第1，2两步必须先于3，4两步执行，否则先将p 与 temp，关联上，会导致原p 的next 丢失，成为野指针。 画个图表示一下流程： Status ListInsert(LinkList *L, int i, ElemType data)&#123; //1. 插入的位置不合法 为0或者为负数 if(i &lt; 1) return ERROR; //2. 新建结点 LinkList temp = (LinkList)malloc(sizeof(Node)); temp-&gt;data = data; temp-&gt;prior = NULL; temp-&gt;next = NULL; //3.将p指向头结点! LinkList p = *L; //4. 找到插入位置i直接的结点 for(int j = 1; j &lt; i &amp;&amp; p;j++) p = p-&gt;next; //5. 如果插入的位置超过链表本身的长度 if(p == NULL)&#123; return ERROR; &#125; //6. 判断插入位置是否为链表尾部; if (p-&gt;next == NULL) &#123; p-&gt;next = temp; temp-&gt;prior = p; &#125; else &#123; //1️⃣ 将p-&gt;next 结点的前驱prior = temp p-&gt;next-&gt;prior = temp; //2️⃣ 将temp-&gt;next 指向原来的p-&gt;next temp-&gt;next = p-&gt;next; //3️⃣ p-&gt;next 更新成新创建的temp p-&gt;next = temp; //4️⃣ 新创建的temp前驱 = p temp-&gt;prior = p; &#125; return OK;&#125; 2.3 删除结点删除链表中的结点分两种：删除指定位置结点和删除指定元素的结点。其思路都是一致的，遍历链表中的元素，找到指定元素，并进行删除。主要流程与删除单向链表的逻辑类似，只是多了一个移除前驱结点的操作。 删除结点的通俗理解：就好比员工离职前，必要的一步就是工作交接，告诉大家接下来工作时谁来接手，锅该由谁来背，公司才能正常运行；否则你一拍屁股删库跑路了，公司可就热闹了，大家都抓瞎了，这样就乱套了。 2.3.1 删除指定位置结点流程如下： 给定一个工具结点p，指向链表的头结点 依次循环查找，将 p 指向删除位的前一个 创建临时结点 temp 指向要删除的结点，并把该结点 data 赋值给返回的 *e 待删除结点上一结点的 next 指向 temp 的后一个结点 待删除结点是否链尾结点？ 并非链尾：将待删除结点 temp 的下一结点的 prior 指向工具结点p 是链尾：不作处理 释放待删除结点 temp 总结一下，核心操作就两步： 将目标上一个结点的 next 指给下一个 将目标的下一个结点的 prior 指给上个结点 有图有真相： 贴一下实操的代码如下: Status DeleteVeryNode(LinkList *L, int i, ElemType *e)&#123; int k = 1; LinkList p = (*L); //1.判断双向链表是否为空,如果为空则返回ERROR; if (*L == NULL) &#123; return ERROR; &#125; //2. 将指针p移动到删除元素位置前一个 while (k &lt; i &amp;&amp; p != NULL) &#123; p = p-&gt;next; k++; &#125; //3.如果k&gt;i 或者 p == NULL 则返回ERROR if (k&gt;i || p == NULL) &#123; return ERROR; &#125; //4.创建临时指针temp 指向要删除的结点,并将要删除的结点的data 赋值给*e,带回到main函数 LinkList temp = p-&gt;next; *e = temp-&gt;data; //5. p-&gt;next 等于要删除的结点的下一个结点 p-&gt;next = temp-&gt;next; //6. 如果删除结点的下一个结点不为空,则将将要删除的下一个结点的前驱指针赋值p; if (temp-&gt;next != NULL) &#123; temp-&gt;next-&gt;prior = p; &#125; //7.删除temp结点 free(temp); return OK;&#125; 2.3.2 删除指定元素的结点删除指定元素的结点，会更简单，只需要遍历循环，找到相应的结点后，依次对前驱点和后继点进行重新配置。 步骤如下： 创建链表L， 将p 指向首结点。 遍历链表L，判断给定元素 data 与 p-&gt; data是否相等，相等即找到目标结点 修改目标结点的前驱结点的后继指针，指向目标结点下一个结点（交代后事….） 若删除结点非尾结点：修改目标结点后继结点的前驱指针 prior，指向目标的上一个结点。 释放被删除的结点 p 贴一下实操的代码如下: Status DeleteDefinedNode(LinkList *L, int data)&#123; // 1. 创建链表，以及头结点 p LinkList p = *L; //1.遍历双向循环链表 while (p) &#123; //2.判断当前结点的数据域和data是否相等,若相等则删除该结点 if (p-&gt;data == data) &#123; //修改被删除结点的前驱结点的后继指针 p-&gt;prior-&gt;next = p-&gt;next; //修改被删除结点的后继结点的前驱指针 if(p-&gt;next != NULL)&#123; p-&gt;next-&gt;prior = p-&gt;prior; &#125; //释放被删除结点p free(p); //退出循环 break; &#125; //没有找到该结点,则继续移动指针p p = p-&gt;next; &#125; return OK;&#125; 2.4 查询结点 创建链表L， 将p 指向首结点。 遍历链表L，判断给定元素 data 与 p-&gt; data是否相等， 相等即找到目标结点，跳出。 否则继续循环，将 p 移动到下一个结点 int selectElem(LinkList L,ElemType elem)&#123; LinkList p = L-&gt;next; int i = 1; while (p) &#123; if (p-&gt;data == elem) &#123; return i; &#125; i++; p = p-&gt;next; &#125; return -1;&#125; 2. 5 更新结点更新结点，只需要遍历循环链表，找到序号内的结点，将其数据域 data 替换为新的数据 Status replaceLinkList(LinkList *L,int index,ElemType newElem)&#123; LinkList p = (*L)-&gt;next; for (int i = 1; i &lt; index; i++) &#123; p = p-&gt;next; &#125; p-&gt;data = newElem; return OK;&#125; 三、双向循环链表的操作3.1 创建链表双向循环链表的创建步骤，与双向链表类似。差别在于：多了将尾结点的 next 指向 头结点，而头结点的 prior 指向 尾结点。 具体步骤： 创建空链表L，以及结点*L，使得其前驱和后继都指向自己 指定一个尾结点为p 创建临时结点temp，并进行数值给定 将当前尾结点p与temp进行双线链接链接 temp 是 p 的后继 p 是 temp 的前驱 temp 的后继是 p p 的前驱是新建的 temp 将temp 赋值给p，p依然为链表的尾结点，方便下次插入新结点。 实现源码如下： Status creatCircularLinkList(LinkList *L)&#123; // 1 创建空链表 *L = (LinkList)malloc(sizeof(Node)); if (*L == NULL) &#123; return ERROR; &#125; (*L)-&gt;next = (*L); (*L)-&gt;prior = (*L); // 指定一个尾结点为 p LinkList p = *L; for(int i=0; i &lt; 10;i++)&#123; //1.创建1个临时的结点 LinkList temp = (LinkList)malloc(sizeof(Node)); temp-&gt;data = i; //2.为新增的结点建立双向链表关系 //① temp 是p的后继 p-&gt;next = temp; //② temp 的前驱是p temp-&gt;prior = p; //③ temp的后继是*L temp-&gt;next = (*L); //④ p 的前驱是新建的temp p-&gt;prior = temp; //⑤ p 要记录最后的结点的位置,方便下一次插入 p = p-&gt;next; &#125; return OK;&#125; 3.2 增加结点与双向链表相似，区别在于双向循环链表由于有首位域，在找到指定位置后，需要先将插入结点的prior 和 next 与 前后建立关系，之后再考虑前结点的 next链接，最后考虑的是 目标结点的next 具体步骤如下： 新建目标结点temp 创建指针 p ，指向链表的头结点 通过循环便利，将 p 向后移，找到插入位置 i 的结点 【判断】如果插入位置超出链表本身长度，跳出 【判断】如果 p 为next指向 头结点跳出 找到i 结点后，分两步对p 与temp 进行首尾相连 将temp 的 prior 指向 p 将 temp 的 next 指向 p 的 next 将 p 的next 指向目标结点 temp 判断 temp 是否是尾结点 如果是：将头结点的 prior 指向 temp 如果否：将目标结点 temp 的 prior 指向 p Status LinkCircularListInsert(LinkList *L, int index, ElemType e)&#123; //1. 创建指针p,指向双向链表头 LinkList p = (*L); int i = 1; //2.双向循环链表为空,则返回error if(*L == NULL) return ERROR; //3.找到插入前一个位置上的结点p while (i &lt; index &amp;&amp; p-&gt;next != *L) &#123; p = p-&gt;next; i++; &#125; //4.如果i&gt;index 则返回error if (i &gt; index) return ERROR; //5.创建新结点temp LinkList temp = (LinkList)malloc(sizeof(Node)); //6.temp 结点为空,则返回error if (temp == NULL) return ERROR; //7.将生成的新结点temp数据域赋值e. temp-&gt;data = e; //8.将结点temp 的前驱结点为p; temp-&gt;prior = p; //9.temp的后继结点指向p-&gt;next; temp-&gt;next = p-&gt;next; //10.p的后继结点为新结点temp; p-&gt;next = temp; //如果temp 结点不是最后一个结点 if (*L != temp-&gt;next) &#123; //11.temp节点的下一个结点的前驱为temp 结点 temp-&gt;next-&gt;prior = temp; &#125;else&#123; (*L)-&gt;prior = temp; &#125; return OK;&#125; 3.3 删除结点双向循环链表的结点删除，比双向链表的简单，因为链表首尾相连的特性，不需要考虑是否为尾结点或者头结点。 流程如下： 给定一个工具结点p，指向链表的头结点 依次循环查找，将 p 指向删除位的前一个 创建临时结点 temp 指向要删除的结点，并把该结点 data 赋值给返回的 *e 待删除结点上一结点的 next 指向 temp 的后一个结点 释放待删除结点 temp 总结一下，核心操作就两步： 将目标上一个结点的 next 指给下一个 将目标的下一个结点的 prior 指给上个结点 Status LinkListDelete(LinkList *L,int index,ElemType *e)&#123; int i = 1; LinkList temp = (*L)-&gt;next; if (*L == NULL) &#123; return ERROR; &#125; //①.如果删除到只剩下首元结点了,则直接将*L置空; if(temp-&gt;next == *L)&#123; free(*L); (*L) = NULL; return OK; &#125; //1.找到要删除的结点 while (i &lt; index) &#123; temp = temp-&gt;next; i++; &#125; //2.给e赋值要删除结点的数据域 *e = temp-&gt;data; //3.修改被删除结点的前驱结点的后继指针 temp-&gt;prior-&gt;next = temp-&gt;next; //4.修改被删除结点的后继结点的前驱指针 temp-&gt;next-&gt;prior = temp-&gt;prior; //5. 删除结点temp free(temp); return OK;&#125; 3.4 查询结点与双向链表相同，更新结点，只需要遍历循环链表，找到序号内的结点，将其数据域 data 替换为新的数据 代码参见 2.5 四、总结4.1 线性表结构 4.2 顺序表与链表比较顺序结构的线性表与链式结构的线性表比较起来， 从空间性能上比较： 存储空间分配 存储密度的大小 存储密度 &#x3D; $\\frac{数据元素本身占用存储量}{结点结构占用的存储量}$ 时间性能比较： 存储元素的效率 插入和删除操作的效率 4.3 其他双向链表比起单向链表来说，增加了prior 这一指针域，可以在查找和删除时，极其迅速的操作，无须做更多的判断，极大地提高了运算效率。同时在操作时，需要注意指针修改顺序，以免形成野指针。","categories":[],"tags":[{"name":"链表","slug":"链表","permalink":"http://nilsli.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"循环","slug":"循环","permalink":"http://nilsli.com/tags/%E5%BE%AA%E7%8E%AF/"}]},{"title":"【底层探索】- KVO（上）","slug":"0507kvo1","date":"2020-04-02T18:10:28.000Z","updated":"2024-08-07T07:10:46.422Z","comments":true,"path":"p/78de752a.html","permalink":"http://nilsli.com/p/78de752a.html","excerpt":"","text":"一、KVO 初探1.1 概念 Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects. 键值观察（KVO）是一种机制，允许对象在其他对象的特定属性改变后得到通知。 KVO 概念，参看 苹果开放文档 1.2 使用 注册监听 func addObserver(_ observer: NSObject, forKeyPath keyPath: String, options: NSKeyValueObservingOptions = [], context: UnsafeMutableRawPointer?) 实现键值变换的通知 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(void *)context; 移除监听，当不再需要监听事件时 func removeObserver(_ observer: NSObject, forKeyPath keyPath: String) 1.1 context 的作用1.1.1 介绍添加KVO 的关键方法为 - (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context; objserver - 观察者 keyPath - 关键路径，即观察的重点，如属性 options - 键值观察的策略选项。 context - 观察上下文。 1.1.2 原因：苹果文档 在context 这一小节 写到： A safer and more extensible approach is to use the context to ensure notifications you receive are destined for your observer and not a superclass. 更安全和扩展性更好的获取方式，就是使用context来确保你收到的通知被指向你的观察者，而不是父类。 可见上下文指针（context） 是用来区分多个对象同时使用使用相同的keyPath，这样无需区分不同对象，减少判断嵌套，提高性能。 可以快速定位观察键，是的区分观察对象更加便利、安全、直接。 类似标签区别 1.1.3 使用context 使用静态地址指针，用法如下： 创建 context 指针 static void *PersonAccountBalanceContext = &amp;PersonAccountBalanceContext;static void *PersonAccountInterestRateContext = &amp;PersonAccountInterestRateContext; 将不同的context 注册在相同对象的观察者中 - (void)registerAsObserverForAccount:(Account*)account &#123; [account addObserver:self forKeyPath:@&quot;balance&quot; options:(NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld) context:PersonAccountBalanceContext]; [account addObserver:self forKeyPath:@&quot;interestRate&quot; options:(NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld) context:PersonAccountInterestRateContext];&#125; 1.2 移除观察者的重要性 会触发隐藏的崩溃 移除观察者，通常会使用这个方法 - (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 如果不移除，当被观察者被dealloc 后，观察者还在苦苦的观察它，长此以往，找不到对象 会形成野指针，造成崩溃。 类似女同事们默默喜欢关注吴尊好多年，结果突然你告诉我他早就脱单结婚了，女儿都八岁了，能不崩溃吗。 1.3 手动&#x2F;自动观察开关有些业务场景，经常需要变换对键的观察，由于需求的变换，可能之前一直在观察的值，这个版本就不需要在观察了，那么再去删除大量的观察代码肯定不是一件明智的事情（谁知道产品经理下一步会不会回退需求呢？）。 可以通过开关自动观察指定键的对象按钮来实现 + (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key; 当需要手动来操作时，返回NO 此时对需要改动的键值，手动添加willChangeValueForKey 和didChangeValueForKey 两个方法，这样是的被观察对象的观察策略生效。 代码如下： 业务代码对对象进行观察以及改变 - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self.person willChangeValueForKey:@&quot;name&quot;]; self.person.name = @&quot;haha&quot;; [self.person didChangeValueForKey:@&quot;name&quot;];&#125; 类的实现下，关闭自动 // 自动开关+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123; return NO;&#125; 当需要自动观察指定的键时，返回YES // 自动开关+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123; return YES;&#125; 1.4 路径集合在某些场景下，观察对象手多个外接属性&#x2F;变量影响，也可以使用KVO。 一个典型的场景，是在音乐&#x2F;电视剧下载时，由于某些专辑有多首歌曲，某些时候下载过程中，会有新的关联专辑加入进来，此时下载进度条可能满了之后会会退（奇怪的需求）。 给对象添加一个下载进度的KVO 监测 [self.person addObserver:self forKeyPath:@&quot;downloadProgress&quot; options:(NSKeyValueObservingOptionNew) context:NULL]; 业务层，对简洁相关联的属性，进行增减。比如这里，使用到的是下载进度相关的”已写入数据”和”总数据”，当点击时，他们会依次添加 self.person.writtenData += 10;self.person.totalData += 20; 最后，在集合关联键值方法里，给他们绑定上关系。 此时有3个关键键了，分别上：downloadProgress、totalData、writtenData 他们之间的关系是： 下载进度 &#x3D; 当前下载量 &#x2F; 总量 （downloadProgress &#x3D; writtenData &#x2F; totalData） + (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123; NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key]; if ([key isEqualToString:@&quot;downloadProgress&quot;]) &#123; NSArray *affectingKeys = @[@&quot;totalData&quot;, @&quot;writtenData&quot;]; keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys]; &#125; return keyPaths;&#125; 1.5 集合数组观察 比如对某个数组添加观察。 [self.person addObserver:self forKeyPath:@&quot;dateArray&quot; options:(NSKeyValueObservingOptionNew) context:NULL]; 对数组进行改动。此时需要将其先改成可变数组，才能改动 [[self.person mutableArrayValueForKey: @&quot;dateArray&quot;] addObject: @&quot;hello&quot;]; 原因：因为数组没有遵循KVC，并没有使用setter 方法 1.6 观察类型枚举 NSKeyValueChangeSetting NSKeyValueChangeInsertion NSKeyValueChangeRemoval NSKeyValueChangeReplacement 二、KVO 原理2.1 概念 Automatic key-value observing is implemented using a technique called isa-swizzling. 自动KVO 使用isa 改变的技术来实现 2.2 动态生成子类为了分析所谓的动态生成子类，先写一段代码，生成一个Dog 的类，对其name 属性添加观察，并打印实例d 观察前和观察后的类名。代码如下: Dog *d = [[Dog alloc] init];NSLog(@&quot;添加前-: %s\\n&quot;, object_getClassName(d));[d addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:NULL];NSLog(@&quot;添加后-: %s&quot;, object_getClassName(d)); 运行，打印结果如下: 如何判断是子类呢，可以写个方法来打印当前Dog 类的子类列表 // 注册类的总数int count = objc_getClassList(NULL, 0);// 创建一个数组， 其中包含给定对象NSMutableArray *mArray = [NSMutableArray arrayWithObject:[d class]];// 获取所有已注册的类Class* classes = (Class*)malloc(sizeof(Class)*count);objc_getClassList(classes, count);for (int i = 0; i&lt;count; i++) &#123; if ([d class] == class_getSuperclass(classes[i])) &#123; [mArray addObject:classes[i]]; &#125;&#125;free(classes);NSLog(@&quot;classes = %@&quot;, mArray); 打印结果如下: 2020-05-07 16:54:32.770527+0800 MyKVO[8567:500364] 添加前-: Dog2020-05-07 16:54:32.771302+0800 MyKVO[8567:500364] 添加后-: NSKVONotifying_Dog2020-05-07 16:54:32.788208+0800 MyKVO[8567:500364] classes = ( Dog, &quot;NSKVONotifying_Dog&quot;) 果然生成了一个NSKVONotifying_Dog 基于Dog 类的子类 当对某个对象实用KVO，会动态生成子类 NSKeyValueNotifying__XXX，这个类的isa 指向对象的类 2.3 键值观察的是setter方法我们知道KVO 是对属性做的键值观察，那么为什么不是成员变量呢？为了解决这个问题，不妨生成一个成员变量，对他做一下检测试试。 先给类Dog 新增一个成员变量age，记得添加@public, 这样才能在外部访问 @interface Dog : NSObject&#123; @public NSString *age;&#125;@property (copy, nonatomic) NSString *petName; 接下来给狗狗对象d 添加属性petName、成员变量age 的KVO方法 [self.d addObserver:self forKeyPath:@&quot;petName&quot; options:(NSKeyValueObservingOptionNew) context:NULL];[self.d addObserver:self forKeyPath:@&quot;age&quot; options:(NSKeyValueObservingOptionNew) context:NULL]; 添加一个改变属性的点击事件。当点击屏幕，给d 的属性和成员变量赋值 - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; self.d.petName = @&quot;Jacob&quot;; NSLog(@&quot;self.petName-%@&quot;, self.d.petName); self.d-&gt;age = @&quot;18&quot;; NSLog(@&quot;self.age-%@&quot;, self.d-&gt;age);&#125; 运行，点击屏幕，监控键值变化如下： 可见打印结果中，self.petName 的值变化，得到了打印验证；而 self.d-&gt;age 作为公开出来的成员变量，并不会在其值发生改变打印。为什么呢? 我们都知道属性创建之后，系统会自动配置setter 方法和getter 方法； 而成员变量，则是需要手动添加setter&#x2F;getter 方法，区别就在setter 方法未实现。 所以我们得知，KVO 监控的是变量的setter 方法 2.4 动态子类会重写方法在上文得知，会动态生成NSKeyValueNotifying__XXX 的子类后，不免想要看看这个新的类，究竟实现了那些内容。 先看看类里面有哪些方法，写一个遍历类的方法： #pragma mark - 遍历方法-ivar-property- (void)printClassAllMethod:(Class)cls&#123; NSLog(@&quot;*********************&quot;); unsigned int count = 0; Method *methodList = class_copyMethodList(cls, &amp;count); for (int i = 0; i&lt;count; i++) &#123; Method method = methodList[i]; SEL sel = method_getName(method); IMP imp = class_getMethodImplementation(cls, sel); NSLog(@&quot;%@-%p&quot;,NSStringFromSelector(sel),imp); &#125; free(methodList);&#125; 输入这个新的类： [self printClassAllMethod: NSClassFromString(@&quot;NSKVONotifying_Dog&quot;)]; 打印结果如下： 可见实现的类有如下: set 方法 ——setPetName class 方法 dealloc 方法 _isKVOA 键的标识 2.5 KVO移除时操作当对一个对象的监控结束后，会移除KVO 监控，这时候会发生什么呢？ 2.5.1 isa 指回原类试验一下，在dealloc 方法，添加移除方法，并在前后打印类的名字 NSLog(@&quot;移除前，类名为: %s&quot;, object_getClassName(self.d));[self.d removeObserver:self forKeyPath:@&quot;petName&quot;];[self.d removeObserver:self forKeyPath:@&quot;age&quot;];NSLog(@&quot;移除后，类名为: %s\\n&quot;, object_getClassName(self.d)); 在这里可以清晰的看到，当移除KVO 观测属性值后，这个动态子类，又变回了Dog类，即isa 指向又从动态子类，指向了原来的类 2.5.2 动态子类会缓存那么移除KVO 后，动态子类是否销毁？ 打印一下当前d 的类的子类即可，先定义一个打印方法 - (void)printClasses:(Class)cls&#123; // 注册类的总数 int count = objc_getClassList(NULL, 0); // 创建一个数组， 其中包含给定对象 NSMutableArray *mArray = [NSMutableArray arrayWithObject:cls]; // 获取所有已注册的类 Class* classes = (Class*)malloc(sizeof(Class)*count); objc_getClassList(classes, count); for (int i = 0; i&lt;count; i++) &#123; if (cls == class_getSuperclass(classes[i])) &#123; [mArray addObject:classes[i]]; &#125; &#125; free(classes); NSLog(@&quot;classes = %@&quot;, mArray);&#125; 执行对self.d 的打印 - (void)dealloc&#123; NSLog(@&quot;*************移除前&quot;); [self printClasses:[self.d class]]; [self.d removeObserver:self forKeyPath:@&quot;petName&quot;]; [self.d removeObserver:self forKeyPath:@&quot;age&quot;]; NSLog(@&quot;*************移除后&quot;); [self printClasses:[self.d class]];&#125; 得到结果如下： 很显然，这里的NSKVONotifying_Dog， 依旧存在，我们可以大胆推断，这里应该是缓存下来，方便下次再进行调用。 原理图如下：","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"KVO","slug":"KVO","permalink":"http://nilsli.com/tags/KVO/"}]},{"title":"【数据结构与算法】-（3）循环链表(单向)","slug":"circularList","date":"2020-04-02T08:06:27.000Z","updated":"2024-08-07T07:10:46.598Z","comments":true,"path":"p/54688.html","permalink":"http://nilsli.com/p/54688.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 一、定义 将单链表中终点结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相连的单链表称为单循环链表，简称循环链表（circular linked list）。 我们先讨论的是单向循环链表，示意图如下所示: 二、操作2.1 创建单向循环链表创建逻辑主要有下面的步骤: 先判断是否第一次创建？ 是（空链表）：创建一个结点，使新结点next 指向自身 否：使尾节点的next&#x3D;新节点。新节点的next指向头节点 下面用代码解释一下： 先定义一个结点(结构体)，定一个别名： //定义结点typedef struct Node&#123; ElemType data; struct Node *next;&#125;Node;typedef struct Node * LinkList; 创建一些变量，以供环境使用： Status CreateList(LinkList *L)&#123; int item; LinkList temp = NULL; LinkList target = NULL; 接下来判断这个链表*L 是否为空： if(*L==NULL) 如果输入的链表是空的——则创建一个结点，使它的next指向自己： Status CreateList(LinkList *L)&#123; printf(&quot;输入节点的值，输入0结束\\n&quot;); while(1) &#123; scanf(&quot;%d&quot;,&amp;item); if(item==0) break; //如果输入的链表是空。则创建一个新的节点，使其next指针指向自己 (*head)-&gt;next=*head; if(*L==NULL) &#123; *L = (LinkList)malloc(sizeof(Node)); if(!L)exit(0); (*L)-&gt;data=item; (*L)-&gt;next=*L; &#125; 如果链表不为空——则去寻找链表的尾结点。 这里寻找尾结点可以有两种实现方式： 遍历尾结点，根据尾结点指针会指向首元结点来定位到尾结点。 1、使得尾结点的next 指向新结点。 2、新结点的next 指向头结点。 else&#123; for (target = *L; target-&gt;next != *L; target = target-&gt;next); // 为新结点开辟内存空间 temp=(LinkList)malloc(sizeof(Node)); // 如开辟失败，返回错误 if(!temp) return ERROR; // 新结点写入数据 temp-&gt;data=item; temp-&gt;next=*L; //新节点指向头节点 target-&gt;next=temp;//尾节点指向新节点&#125; 创建一个工具结点r，用它来灵活处理以后一个结点（后插法） 1. 新建一个 `r` LinkList r = NULL; 2. 在该链表创建时，将唯一的结点赋值给`r` //第一次创建if(*L == NULL)&#123; *L = (LinkList)malloc(sizeof(Node)); if(!*L) return ERROR; (*L)-&gt;data = item; (*L)-&gt;next = *L; r = *L; 3. 创建新的结点，进行赋值，`next`指向原链表首结点 temp = (LinkList)malloc(sizeof(Node));if(!temp) return ERROR;temp-&gt;data = item;temp-&gt;next = *L; 4. 把原最后一个结点的尾结点指向新结点，以及新结点赋值给工具结点`r` r-&gt;next = temp; 这样，闭环完成，整个过程示意图可以用下面的图实现： 2.2 单向循环链表插入数据分两种情况，插入点是否为首元结点 2.2.1 插入点位首元结点 创建新结点并进行赋值 找到链表最后的结点——尾结点 让新结点的next 指向头结点 让尾结点的 next 指向新的头结点 让头结点指向temp ——临时的新结点 具体代码实现如下： temp = (LinkList)malloc(sizeof(Node));if (temp == NULL) &#123; return ERROR;&#125;temp-&gt;data = num;for (target = *L; target-&gt;next != *L; target = target-&gt;next);temp-&gt;next = *L;target-&gt;next = temp;*L = temp; 如图所示： 2.2.2 插入点非首元结点 创建新结点 temp，并判断成功与否 找到插入的位置，如果超过链表长度，则自动插入队尾 通过工具target 找到要插入位置的前一个结点，让 target-&gt;next = temp 插入结点的前一个结点next 指向新结点，新结点next指向target原来的next 位 具体代码实现如下： temp = (LinkList)malloc(sizeof(Node));if (temp == NULL) &#123; return ERROR;&#125;temp-&gt;data = num;for ( i = 1,target = *L; target-&gt;next != *L &amp;&amp; i != place - 1; target = target-&gt;next,i++) ;temp-&gt;next = target-&gt;next;target-&gt;next = temp; 2.3 单向循环链表的删除单向循环链表的删除，与顺序表的删除很类似，步骤都是先确定需要删除的位置，通过判断是否首元结点，做不同的操作。具体操作步骤如下： 2.3.1 删除点为首元结点 如果本链表只剩首元结点，则直接将*L 置为空； 实施代码如下： if((*L)-&gt;next == (*L))&#123; (*L) = NULL; return OK;&#125; 如果本链表还剩其他结点 找到尾结点 target 尾结点 next 指向原来首元结点的下一个结点，即 target-&gt;next = (*L)-&gt;next 用 temp 临时接收首元结点 新结点为首元结点 释放之前的接收的首元结点 temp 实施代码如下： // 步骤 1⃣️for (target = *L; target-&gt;next != *L; target = target-&gt;next);// 步骤 2⃣️temp = *L;// 步骤 3⃣️*L = (*L)-&gt;next;// 步骤 4⃣️target-&gt;next = *L;// 步骤 5⃣️free(temp); 2.3.2 删除点为非首元结点 找到需要删除结点的上一个结点，用target表示 用temp临时接受需要删除的结点 target 的next 指之前指向的下一个结点 释放temp结点 实施代码如下： // 步骤 1⃣️for(i=1,target = *L;target-&gt;next != *L &amp;&amp; i != place -1;target = target-&gt;next,i++);// 步骤 2⃣️temp = target-&gt;next;// 步骤 3⃣️target-&gt;next = temp-&gt;next;// 步骤 4⃣️free(temp); 示意图如下： 2.4 单向链表的查询这里仅仅讨论下简单的链表查询，步骤如下： 循环查找链表中给定值的结点 若查询的结点指向首元结点，并且此时尾结点值也不为所需，跳出 实施代码如下： int i = 1; LinkList p; p = L; // 1⃣️ 寻找链表中的结点 data == value while (p-&gt;data != value &amp;&amp; p-&gt;next != L) &#123; i++; p = p-&gt;next; &#125; // 2⃣️ 当尾结点指向头结点就会直接跳出循环,所以要额外增加一次判断尾结点的data == value; if (p-&gt;next == L &amp;&amp; p-&gt;data != value) &#123; return -1; &#125; 三、小结单向循环链表与顺序表有些许相似，但是不同点在于，它并非是按照序号排列，而是通过指针的指向进行连接，而且有首尾相连的特点。","categories":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/categories/ios/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://nilsli.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"循环","slug":"循环","permalink":"http://nilsli.com/tags/%E5%BE%AA%E7%8E%AF/"}]},{"title":"【底层探索】- KVC原理分析","slug":"0505kvc","date":"2020-04-02T05:50:05.000Z","updated":"2024-08-07T07:10:46.419Z","comments":true,"path":"p/f704cb0c.html","permalink":"http://nilsli.com/p/f704cb0c.html","excerpt":"","text":"序思考拓展题为什么先进入objc_setProperty_atomic_copy 方法，而不是setName:? 回答：通用原则。即面向不同的数据类型，采用统一的属性设值的方法，会更加的高效，符合高内聚的原则。 一、概念及常见使用1.0 概念 KVC(Key-Value coding) 是一个由NSKeyValueCoding 协议触发的机制，允许对象通过该机制获取他们的属性。当一个对象符合KVC 原则，它的属性就可以用字符串通过一个简洁、相同的信息接口快捷访问到。 这种简洁访问机制，借助实例变量量和关联存取方法补充了对象直接访问的机制。 相关链接：关于KVC(Apple Opensource) 1.1 简单使用假设有类BankAccount，有众多属性如下： @interface BankAccount : NSObject @property (nonatomic) NSNumber* currentBalance; // An attribute@property (nonatomic) Person* owner; // A to-one relation@property (nonatomic) NSArray&lt; Transaction* &gt;* transactions; // A to-many relation @end 给起通过KVC属性赋值，如下 [myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;]; 1.2 集合类型对数组进行修改： person.array = [@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;]; 方法一、创建新的数组（普通方法） NSArray *array = [person valueForKey:@&quot;array&quot;];// 用 array 的值创建一个新的数组array = @[@&quot;100&quot;,@&quot;2&quot;,@&quot;3&quot;];[person setValue:array forKey:@&quot;array&quot;]; 方法二、通过可变数组赋值（KVC） NSMutableArray *ma = [person mutableArrayValueForKey:@&quot;array&quot;];ma[0] = @&quot;100&quot;; 可见可变数组实行KVC 方法，更为简洁 1.3 集合操作符集合操作符如下： 比如某个模型结构如下： @interface Transaction : NSObject @property (nonatomic) NSString* payee; // To whom@property (nonatomic) NSNumber* amount; // How much@property (nonatomic) NSDate* date; // When @end 想要获取多个Transaction 的payee 属性的结合，可以用集合运算符 NSArray *distinctPayees = [self.transactions valueForKeyPath:@&quot;@distinctUnionOfObjects.payee&quot;]; 可见，集合运算符主要在于获取对象的值 1.4 访问非对象属性 问题：如何访问结构体？ 这个问题经常出现在C、C++混编的环境下出现，解决的防范也比较简单，由于结构体并不遵循Key-Value Coding，可以先将其转为遵循KVC的NSValue 类型，然后通过KVC 对其进行存取。 给一个结构体ThreeFloats，作为Person 的属性出现 typedef struct &#123; float x, y, z;&#125; ThreeFloats;@interface Person : NSObject&#123;&#125;@property (nonatomic) ThreeFloats threeFloats;@end 转换为NSValue ThreeFloats floats = &#123;1., 2., 3.&#125;;NSValue *value = [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)]; 存其值 [person setValue:value forKey:@&quot;threeFloats&quot;];NSValue *reslut = [person valueForKey:@&quot;threeFloats&quot;]; 取其值 ThreeFloats th;[reslut getValue:&amp;th] ;NSLog(@&quot;%f - %f - %f&quot;,th.x,th.y,th.z); 打印结果如下： 1.5 通过keyPath 实现多级访问这种情况出现在多级对象属性的情况下，如下面： @interface Person : NSObject&#123; @property (nonatomic, strong) LGStudent *student;&#125;@interface Student : NSObject @property (nonatomic, copy) NSString *name;&#125; Student *student = [[Student alloc] init];student.subject = @&quot;iOS&quot;;person.student = student; 存值 通过keyPath 设置值的方式如下: [person setValue:@&quot;大师班&quot; forKeyPath:@&quot;student.subject&quot;]; 这里用到了student.subject 实现多级别访问 取值 也通过student.subject 实现多级别访问 NSLog(@&quot;%@&quot;,[person valueForKeyPath:@&quot;student.subject&quot;]); 二、KVC 原理剖析2.1 分析Setter 调用过程对对象对实例变量赋值的流程如下： 查找setter 方法，如果存在，赋值成功 查看 accessInstanceVariablesDirectly （直接访问成员遍历）是否开启 若开启，查找 _, _is, , or is 若未开启，直接给变量赋值 若以上都没执行，会报错，结果位 setValue:forUndefinedKey 2.2 分析Getter 取值过程 先查找Getter 方法，如果存在，取值成功。 采用的是标准的getter 方法 get&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;, or _&lt;key&gt; 如果非集合类型：查看 accessInstanceVariablesDirectly （直接访问成员遍历）是否开启 如果开启——通过 _, _is, , or is 查找实现取值 如果关闭——其他查找 如果没有，直接赋值 报错 valueForUndefinedKey 三、自定义KVC 方法上面理解了KVC 的设值与取值过程，尝试自定义一个KVC。其实分析完上面的设值与取值，仿造的过程也是依样画葫芦。具体步骤如下： 3.1 Setter 方法 创建一个类的分类。在分类里创建取值和赋值的方法，有如下方法 - (void)lg_setValue:(nullable id)value forKey:(NSString *)key; 判断key 的有效性 if(!key) || key.length == 0&#123; return&#125; 找到相应的的 set、 _set、setIs 方法，主要看本类是否相应对应名字的方法，实现如下： NSString *Key = key.capitalizedString;// 拼接方法NSString *setKey = [NSString stringWithFormat:@&quot;set%@:&quot;,Key];NSString *_setKey = [NSString stringWithFormat:@&quot;_set%@:&quot;,Key];NSString *setIsKey = [NSString stringWithFormat:@&quot;setIs%@:&quot;,Key];if ([self lg_performSelectorWithMethodName:setKey value:value]) &#123; NSLog(@&quot;*********%@**********&quot;,setKey); return;&#125;else if ([self lg_performSelectorWithMethodName:_setKey value:value]) &#123; NSLog(@&quot;*********%@**********&quot;,_setKey); return;&#125;else if ([self lg_performSelectorWithMethodName:setIsKey value:value]) &#123; NSLog(@&quot;*********%@**********&quot;,setIsKey); return;&#125; 看是否响应该方法 - (BOOL)lg_performSelectorWithMethodName:(NSString *)methodName value:(id)value&#123; if ([self respondsToSelector:NSSelectorFromString(methodName)]) &#123; #pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [self performSelector:NSSelectorFromString(methodName) withObject:value];#pragma clang diagnostic pop return YES; &#125; return NO;&#125; 判断是否能直接赋值实例变量 这是一个重要的开关.开启，则可以通过手动设值，跳到5 如果关闭，则由于本类不相应对应的setter 方法，无法有效赋值，会进行异常抛出如下： if (![self.class accessInstanceVariablesDirectly] ) &#123; @throw [NSException exceptionWithName:@&quot;LGUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil]; &#125; 找到相应的实例变量进行复制 定义一个收集实例变量的的可变数组 NSMutableArray *mArray = [self getIvarListName];// _&lt;key&gt; _is&lt;Key&gt; &lt;key&gt; is&lt;Key&gt;NSString *_key = [NSString stringWithFormat:@&quot;_%@&quot;,key];NSString *_isKey = [NSString stringWithFormat:@&quot;_is%@&quot;,Key];NSString *isKey = [NSString stringWithFormat:@&quot;is%@&quot;,Key]; 获取相应的 ivar if ([mArray containsObject:_key]) &#123; // 4.2 获取相应的 ivar Ivar ivar = class_getInstanceVariable([self class], _key.UTF8String);&#125; 对相应的ivar 设置值 // 4.3 对相应的 ivar 设置值object_setIvar(self , ivar, value);return; 找不到相应的实例——报错处理 @throw [NSException exceptionWithName:@&quot;UnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: this class is not key value coding-compliant for the key name.****&quot;,self,NSStringFromSelector(_cmd)] userInfo:nil]; 3.2 Getter 方法getter 方法与 Setter 方法相仿，继续进行一下 设置自定义的getter 方法。代码如下： - (id)lj_valueForKey: (NSString *)key; 判断key，保证不为空 if (key == nil || key.length == 0) return nil; 找到对应的get、、countOf 、objectInAtIndex 等直接取值的方法。后两种一般是集合类型（数组等）用到的方法。 先对键Key 进行大写转换 // key 要大写NSString *Key = key.capitalizedString; 用get、countOf、objectIn 等方法，对key拼接 // 拼接方法NSString *getKey = [NSString stringWithFormat:@&quot;get%@&quot;,Key];NSString *countOfKey = [NSString stringWithFormat:@&quot;countOf%@&quot;,Key];NSString *objectInKeyAtIndex = [NSString stringWithFormat:@&quot;objectIn%@AtIndex:&quot;,Key]; 判断本类是否相应对应的get、countOf、objectInAtIndex 方法，如果有，就执行该方法，直接获取到对应的值。 #pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; if ([self respondsToSelector:NSSelectorFromString(getKey)]) &#123; return [self performSelector:NSSelectorFromString(getKey)]; &#125;else if ([self respondsToSelector:NSSelectorFromString(key)])&#123; return [self performSelector:NSSelectorFromString(key)]; &#125;else if ([self respondsToSelector:NSSelectorFromString(countOfKey)])&#123; if ([self respondsToSelector:NSSelectorFromString(objectInKeyAtIndex)]) &#123; int num = (int)[self performSelector:NSSelectorFromString(countOfKey)]; NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1]; for (int i = 0; i&lt;num-1; i++) &#123; num = (int)[self performSelector:NSSelectorFromString(countOfKey)]; &#125; for (int j = 0; j&lt;num; j++) &#123; id objc = [self performSelector:NSSelectorFromString(objectInKeyAtIndex) withObject:@(num)]; [mArray addObject:objc]; &#125; return mArray; &#125; &#125;#pragma clang diagnostic pop 此时判断能否直接赋值实例变量。用到的是该类的accessInstanceVariablesDirectly 属性是否开启。 如果已打开，则表示可以通过取其 _、_is、、is 来取值，跳到5 若未打开，抛出异常，表示找不到该键对应值 相关代码如下： if (![self.class accessInstanceVariablesDirectly] ) &#123; @throw [NSException exceptionWithName:@&quot;LGUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil]; &#125; 找到实例变量，进行取值 定义一个收集实例变量的可变数组： NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1];unsigned int count = 0;Ivar *ivars = class_copyIvarList([self class], &amp;count);for (int i = 0; i&lt;count; i++) &#123; Ivar ivar = ivars[i]; const char *ivarNameChar = ivar_getName(ivar); NSString *ivarName = [NSString stringWithUTF8String:ivarNameChar]; NSLog(@&quot;ivarName == %@&quot;,ivarName); [mArray addObject:ivarName];&#125;free(ivars); 依次判断该数组是否包含键关键字，其顺序为 _key——&gt; _isKey——&gt; key——&gt; isKey，通过找到的关键字，进行取值 NSString *_key = [NSString stringWithFormat:@&quot;_%@&quot;,key];NSString *_isKey = [NSString stringWithFormat:@&quot;_is%@&quot;,Key];NSString *isKey = [NSString stringWithFormat:@&quot;is%@&quot;,Key];if ([mArray containsObject:_key]) &#123; Ivar ivar = class_getInstanceVariable([self class], _key.UTF8String); return object_getIvar(self, ivar);;&#125;else if ([mArray containsObject:_isKey]) &#123; Ivar ivar = class_getInstanceVariable([self class], _isKey.UTF8String); return object_getIvar(self, ivar);;&#125;else if ([mArray containsObject:key]) &#123; Ivar ivar = class_getInstanceVariable([self class], key.UTF8String); return object_getIvar(self, ivar);;&#125;else if ([mArray containsObject:isKey]) &#123; Ivar ivar = class_getInstanceVariable([self class], isKey.UTF8String); return object_getIvar(self, ivar);;&#125; 四、KVC 实用小技巧4.1 自动转换类型 KVC 具备自动转换数据类型的功能 当我们对Int 类型的属性，添加字符串的类型，正常是这样的 @interface LGPerson : NSObject @property (nonatomic, assign) int age;@end[person setValue:@18 forKey:@&quot;age&quot;]; 那么下面这种方式能成功吗? [person setValue:@&quot;20&quot; forKey:@&quot;age&quot;]; 可见是可以执行的，在通过KVC 设置之后，自动转换成了int类型，整个数据成为了NSCFNumber。可见其灵活程度！ 4.2 空值报警总有些时候，设置值可能会异常为空，那怎么办呢？可以通过重写空值报警来避免异常 设值为空重写 - (void)setNilValueForKey:(NSString *)key&#123; NSLog(@&quot;报告! 设置 %@ 是空值&quot;,key);&#125; 取值为空重写 - (id)valueForUndefinedKey:(NSString *)key&#123; NSLog(@&quot;报告!!!: %@ 没有这个key - 给你一个其他的吧,别奔溃了!&quot;,key); return @&quot;Master 牛逼&quot;;&#125; 4.3 键值验证当类对应的键的值还是找不到，即将要报错了，我们还是可以自行挽救一下——先验证对应的键值是否成功，如果不成功，自行报错并写补救方法。 NSError *error; NSString *name = @&quot;Good&quot;; if (![person validateValue:&amp;name forKey:@&quot;names&quot; error:&amp;error]) &#123; NSLog(@&quot;%@&quot;,error); &#125;else&#123; NSLog(@&quot;%@&quot;,[person valueForKey:@&quot;name&quot;]); &#125; 实现方法里，可以这样写 //MARK: - 键值验证 - 容错 - 派发 - 消息转发- (BOOL)validateValue:(inout id _Nullable __autoreleasing *)ioValue forKey:(NSString *)inKey error:(out NSError *__autoreleasing _Nullable *)outError&#123; if([inKey isEqualToString:@&quot;name&quot;])&#123; [self setValue:[NSString stringWithFormat:@&quot;里面修改一下: %@&quot;,*ioValue] forKey:inKey]; return YES; &#125; *outError = [[NSError alloc]initWithDomain:[NSString stringWithFormat:@&quot;%@ 不是 %@ 的属性&quot;,inKey,self] code:10088 userInfo:nil]; return NO;&#125; 五、总结总的来说，KVC 是比较简单的一个章节，其原理是对类内部逐级查验，从set 方法、直接赋值开关、isKey 等键的取值实现赋值和取值的过程。而实现自定义KVC，则是依照逻辑一步一步写成。","categories":[],"tags":[{"name":"KVC","slug":"KVC","permalink":"http://nilsli.com/tags/KVC/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"}]},{"title":"【数据结构与算法】-（2）线性表基础","slug":"linearlist","date":"2020-04-01T09:19:38.000Z","updated":"2024-08-07T07:10:46.669Z","comments":true,"path":"p/43366.html","permalink":"http://nilsli.com/p/43366.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 零、前言上文学到了数据结构和算法的一些基础知识，接下来从最基础的概念，线性表说起。 一、线性表的定义和特点1.1 定义 定义：零个或多个数据元素的有限序列 线性表，顾名思义，就是有着和线一样特性的表。比如我们乘坐的火车，通常是由许多节车厢组成，车厢首尾相连，最终形成一辆火车。这样的结构，就可以成为线性表。 1.2 线性表的抽象数据类型线性表的抽象类型定义如下： ADT 线性表（List）Data：线性表的数据对象集合为&#123;a1,a2,......an&#125;,每个元素的类型均为DataType. 其中,除了第一个元素a1外,每一个元素有且只有一个直接前驱元素,除了最后一个元素an外,每个元素有且只有一个直接后继元素. 数据元素之间的关系是一对一的关系.Operation InitList(*L) : 初始化操作，建立一个空的线性表L&lt;sub&gt;0&lt;/sub&gt; ListEmpty(L) : 若线性表已存在，返回`true`; 否则返回`false` ClearList(*L): 将线性表清空 GetElem(L, i, &amp;e): 将线性表L 中的第 i 个位置元素值返回给 e LocateElm（L，e）：在线性表L 中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回 0 表示失败 ListInsert(*L, i, e): 在线性表L 中第 i 个位置插入新元素e ListDelete(*L, i, *e): 删除线性表L 中第 i 个位置元素，并用 e 返回其值 ListLength(L): 返回线性表L 的元素个数endADT 1.3 线性表的顺序存储结构1.3.1 顺序存储定义先来看看线性表两种物理结构的第一种：顺序存储结构 定义：线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。 示意图如下： 1.3.2 顺序存储方式线性表的顺序存储结构，就是在内存中找了个空间，通过展位的方式，把一定内存空间给占了，然后把相同数据类型的数据元素一次存放在这块空地中。既然线性表的每个数据元素类型都相同，所以可以用C 语言的一维数组来实现顺序存储结构。 看看线性表的顺序存储的结构 #define MAXSIZE 20typedef int ElemType;typedef struct&#123; ElemType data[MaxSize]; int length;&#125;Sqlist; 通过观察可以发现，描述顺序存储结构需要三个属性： 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。 线性表的最大存储容量：数组长度MaxSize 线性表的当前长度: length 1.3.3 数据长度与线性表长度区别 数组长度时存放线性表的存储空间的长度，存储分配后这个量一般是不变的。 线性表的长度时线性表中数据元素的个数，随着线性表的插入和删除操作的进行，这个量是变化的。 在任意时刻，线性表的长度应该小于等于数组的长度。 1.4 顺序表的基本操作1.4.1 顺序表的初始化Status InitList(Sqlist *L)&#123; //为顺序表分配一个大小为MAXSIZE 的数组空间 L-&gt;data = malloc(sizeof(ElemType) * MAXSIZE); //存储分配失败退出 if(!L-&gt;data) exit(ERROR); //空表长度为0 L-&gt;length = 0; return OK;&#125; 1.4.2 顺序表的插入/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L); 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */Status ListInsert(Sqlist *L,int i,ElemType e)&#123; //i值不合法判断 if((i&lt;1) || (i&gt;L-&gt;length+1)) return ERROR; //存储空间已满 if(L-&gt;length == MAXSIZE) return ERROR; //插入数据不在表尾,则先移动出空余位置 if(i &lt;= L-&gt;length)&#123; for(int j = L-&gt;length-1; j&gt;=i-1;j--)&#123; //插入位置以及之后的位置后移动1位 L-&gt;data[j+1] = L-&gt;data[j]; &#125; &#125; //将新元素e 放入第i个位置上 L-&gt;data[i-1] = e; //长度+1; ++L-&gt;length; return OK; &#125; 1.4.3 顺序表的取值Status GetElem(Sqlist L,int i, ElemType *e)&#123; //判断i值是否合理, 若不合理,返回ERROR if(i&lt;1 || i &gt; L.length) return ERROR; //data[i-1]单元存储第i个数据元素. *e = L.data[i-1]; return OK;&#125; 1.4.3 顺序表的删除/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) 操作结果: 删除L的第i个数据元素,L的长度减1 */Status ListDelete(Sqlist *L,int i)&#123; //线性表为空 if(L-&gt;length == 0) return ERROR; //i值不合法判断 if((i&lt;1) || (i&gt;L-&gt;length+1)) return ERROR; for(int j = i; j &lt; L-&gt;length;j++)&#123; //被删除元素之后的元素向前移动 L-&gt;data[j-1] = L-&gt;data[j]; &#125; //表长度-1; L-&gt;length --; return OK; &#125; 1.4.5 清空顺序表/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */Status ClearList(Sqlist *L)&#123; L-&gt;length=0; return OK;&#125; 1.4.6 判断顺序表清空/* 初始条件：顺序线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */Status ListEmpty(Sqlist L)&#123; if(L.length==0) return TRUE; else return FALSE;&#125; 1.4.7 获取顺序表长度/* ListEmpty元素个数 */int ListLength(Sqlist L)&#123; return L.length;&#125; 1.4.8 顺序输出List/* 初始条件：顺序线性表L已存在 *//* 操作结果：依次对L的每个数据元素输出 */Status TraverseList(Sqlist L)&#123; int i; for(i=0;i&lt;L.length;i++) printf(&quot;%d\\n&quot;,L.data[i]); printf(&quot;\\n&quot;); return OK;&#125; 1.4.9 顺序表查找元素并返回位置/* 初始条件：顺序线性表L已存在 *//* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 *//* 若这样的数据元素不存在，则返回值为0 */int LocateElem(Sqlist L,ElemType e)&#123; int i; if (L.length==0) return 0; for(i=0;i&lt;L.length;i++) &#123; if (L.data[i]==e) break; &#125; if(i&gt;=L.length) return 0; return i+1;&#125; 1.5 顺序存储结构表的优缺点 优点 无须为表示表中元素之间的逻辑关系而增加额外的存储空间 可以快速地存取表中任意位置的元素 缺点 插入和删除操作需要移动大量元素 当线性表长度变化较大时，难以确定存储空间的容量 造成存储空间的“碎片” 1.5 线性表的链式存储结构1.5.1 定义上文提到，顺序存储结构哦的线性表，最大的特点就是插入和删除时，需要移动大量元素，这显然需要耗费时间。 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的人一位置。 以前在顺序结构中，每个数据元素只要存数据元素信息就可以了。现在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。 我们把存储数据元素信息的域成为数据域。 把存储直接后继位置的域称为指针域。 指针域中存储的信息称做指针或链，这两部分信息组成数据元素的存储映像，称为结点（Node） n个结点链接成一个链表，成为线性表的链式存储结构，因为此链表的每个节点中只包含一个指针域，所以叫单链表。 链表中第一个结点的存储位置叫做头指针。 单链表的第一个结点前附设一个结点，称为头结点。 而单链表的逻辑结构如下: 1.5.2 头指针与头结点的异同 头指针 头结点 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针 头结点是为了操作的统一和方便设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度） 头指针具有标示作用，所以常用头指针冠以链表的名字 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了 无论链表是否为空，头指针均不为空。头指针式链表的必要元素 头结点不一定是链表必须要素 1.5.3 为什么要添加头结点 便于首元结点处理 便于空表和非空表的统一处理 1.6 单链表1.6.1 单链表取值//2.3 单链表取值/* 初始条件: 顺序线性表L已存在,1≤i≤ListLength(L); 操作结果：用e返回L中第i个数据元素的值 */Status GetElem(LinkList L,int i,ElemType *e)&#123; //j: 计数. int j; //声明结点p; LinkList p; //将结点p 指向链表L的第一个结点; p = L-&gt;next; //j计算=1; j = 1; //p不为空,且计算j不等于i,则循环继续 while (p &amp;&amp; j&lt;i) &#123; //p指向下一个结点 p = p-&gt;next; ++j; &#125; //如果p为空或者j&gt;i,则返回error if(!p || j &gt; i) return ERROR; //e = p所指的结点的data *e = p-&gt;data; return OK; &#125; 1.6.2 单链表的插入单链表的插入操作，分为两种： 1.6.2.1 前插法将新结点插入在链表头结点前面，成为前插法 /* 随机产生n个元素值,建立带表头结点的单链线性表L(前插法)*/void CreateListHead(LinkList *L, int n)&#123; LinkList p; //建立1个带头结点的单链表 *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL; //循环前插入随机数据 for(int i = 0; i &lt; n;i++) &#123; //生成新结点 p = (LinkList)malloc(sizeof(Node)); //i赋值给新结点的data p-&gt;data = i; //p-&gt;next = 头结点的L-&gt;next p-&gt;next = (*L)-&gt;next; //将结点P插入到头结点之后; (*L)-&gt;next = p; &#125;&#125; //3.1 前插法整理创建链表LiStatus = ClearList(&amp;L);CreateListHead(&amp;L, 20);printf(&quot;整理创建L的元素(前插法):\\n&quot;);ListTraverse(L); 1.6.2.2 后插法将新结点插入在链表的尾结点后面，称为后插法 /* 随机产生n个元素值,建立带表头结点的单链线性表L(后插法)*/void CreateListTail(LinkList *L, int n)&#123; LinkList p,r; //建立1个带头结点的单链表 *L = (LinkList)malloc(sizeof(Node)); //r指向尾部的结点 r = *L; for (int i=0; i&lt;n; i++) &#123; //生成新结点 p = (Node *)malloc(sizeof(Node)); p-&gt;data = i; //将表尾终端结点的指针指向新结点 r-&gt;next = p; //将当前的新结点定义为表尾终端结点 r = p; &#125; //将尾指针的next = null r-&gt;next = NULL; &#125; //3.2 后插法整理创建链表LiStatus = ClearList(&amp;L);CreateListTail(&amp;L, 20);printf(&quot;整理创建L的元素(后插法):\\n&quot;);ListTraverse(L); 1.6.3 单链表的删除要删除单链表中指定元素，通插入元素一样，应该先找到该位置的钱去结点。 用C代码实现如下： //2.4 单链表删除元素/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */Status ListDelete(LinkList *L,int i,ElemType *e)&#123; int j; LinkList p,q; p = (*L)-&gt;next; j = 1; //查找第i-1个结点,p指向该结点 while (p-&gt;next &amp;&amp; j&lt;(i-1)) &#123; p = p-&gt;next; ++j; &#125; //当i&gt;n 或者 i&lt;1 时,删除位置不合理 if (!(p-&gt;next) || (j&gt;i-1)) return ERROR; //q指向要删除的结点 q = p-&gt;next; //将q的后继赋值给p的后继 p-&gt;next = q-&gt;next; //将q结点中的数据给e *e = q-&gt;data; //让系统回收此结点,释放内存; free(q); return OK;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://nilsli.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性表","slug":"线性表","permalink":"http://nilsli.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"数据结构","slug":"数据结构","permalink":"http://nilsli.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"理论","slug":"理论","permalink":"http://nilsli.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"基础","slug":"基础","permalink":"http://nilsli.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"【类的加载】-（3）loading_images","slug":"load-images","date":"2020-04-01T04:58:01.000Z","updated":"2024-08-07T07:10:46.672Z","comments":true,"path":"p/6283d578.html","permalink":"http://nilsli.com/p/6283d578.html","excerpt":"","text":"本页所使用的objc runtime 756.2，来自 Apple 开源文档 类的加载探寻系列:1、【类的加载】-（1）类的启动 2、【类的加载】-（2）懒加载类与分类 3、【类的加载】-（3）loading_images 一、加载镜像load_images前两篇文章学习了objc_init 中的主要方法map_images ，接下来学习加载镜像，先把源码摆出来： 通过注视可以看到，主要执行了2件事务： 找到 load 方法 调用load 方法。 voidload_images(const char *path __unused, const struct mach_header *mh)&#123; // Return without taking locks if there are no +load methods here. if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods &#123; mutex_locker_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); &#125; // Call +load methods (without runtimeLock - re-entrant) call_load_methods();&#125; 其中找到load 方法，是通过先找到其背后的类或者分类。 1.1 准备类下面这行代码表示类 void prepare_load_methods(const headerType *mhdr)&#123; size_t count, i; runtimeLock.assertLocked(); classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; schedule_class_load(remapClass(classlist[i])); &#125; category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = categorylist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) continue; // category for ignored weak-linked class if (cls-&gt;isSwiftStable()) &#123; _objc_fatal(&quot;Swift class extensions and categories on Swift &quot; &quot;classes are not allowed to have +load methods&quot;); &#125; realizeClassWithoutSwift(cls); assert(cls-&gt;ISA()-&gt;isRealized()); add_category_to_loadable_list(cat); &#125;&#125; 找到类的列表： classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); 准备load 方法，把类添加到可load 列表，将类标记为可执行 static void schedule_class_load(Class cls)&#123; if (!cls) return; assert(cls-&gt;isRealized()); // _read_images should realize if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // Ensure superclass-first ordering schedule_class_load(cls-&gt;superclass); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED); &#125; 把类添加到可加载列表的实现 void add_class_to_loadable_list(Class cls)&#123; IMP method; loadMethodLock.assertLocked(); method = cls-&gt;getLoadMethod(); if (!method) return; // Don&#x27;t bother if cls has no +load method if (PrintLoading) &#123; _objc_inform(&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;, cls-&gt;nameForLogging()); &#125; if (loadable_classes_used == loadable_classes_allocated) &#123; loadable_classes_allocated = loadable_classes_allocated*2 + 16; loadable_classes = (struct loadable_class *) realloc(loadable_classes, loadable_classes_allocated * sizeof(struct loadable_class)); &#125; loadable_classes[loadable_classes_used].cls = cls; loadable_classes[loadable_classes_used].method = method; loadable_classes_used++;&#125; 把分类添加到可加载列表 void add_category_to_loadable_list(Category cat)&#123; IMP method; loadMethodLock.assertLocked(); method = _category_getLoadMethod(cat); // Don&#x27;t bother if cat has no +load method if (!method) return; if (PrintLoading) &#123; _objc_inform(&quot;LOAD: category &#x27;%s(%s)&#x27; scheduled for +load&quot;, _category_getClassName(cat), _category_getName(cat)); &#125; if (loadable_categories_used == loadable_categories_allocated) &#123; loadable_categories_allocated = loadable_categories_allocated*2 + 16; loadable_categories = (struct loadable_category *) realloc(loadable_categories, loadable_categories_allocated * sizeof(struct loadable_category)); &#125; loadable_categories[loadable_categories_used].cat = cat; loadable_categories[loadable_categories_used].method = method; loadable_categories_used++;&#125; 其中 Class cls = remapClass(cat-&gt;cls); 这行代码，重映射了分类的类，即帮分类把懒加载的类进行了实现，否则分类无法找到可以依附的主类。 1.2 调用 load 方法源码如下： do &#123; // 1. Repeatedly call class +loads until there aren&#x27;t any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); 1.2.1 调用类的load 方法 列举可加载的类 循环找到类的对应load 方法的method 函数 向类发送该method 函数，完成调用 static void call_class_loads(void)&#123; int i; //(1) // Detach current loadable list. struct loadable_class *classes = loadable_classes; int used = loadable_classes_used; loadable_classes = nil; loadable_classes_allocated = 0; loadable_classes_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Class cls = classes[i].cls; //(2) load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; if (PrintLoading) &#123; _objc_inform(&quot;LOAD: +[%s load]\\n&quot;, cls-&gt;nameForLogging()); &#125; //(3) (*load_method)(cls, SEL_load); &#125; // Destroy the detached list. if (classes) free(classes);&#125; 1.2.2 调用分类的load 方法 列举可加载的分类 // Detach current loadable list.struct loadable_category *cats = loadable_categories;int used = loadable_categories_used;int allocated = loadable_categories_allocated;loadable_categories = nil;loadable_categories_allocated = 0;loadable_categories_used = 0; 循环找到分类的对应load 方法的method 函数 // Call all +loads for the detached list.for (i = 0; i &lt; used; i++) &#123; Category cat = cats[i].cat; load_method_t load_method = (load_method_t)cats[i].method; &#125; 向分类发送该method 函数，完成调用 (*load_method)(cls, SEL_load); 释放可执行分类列表，保证程序启动只调用一次该加载。 这里通过一个叫做loadable_categories_used 和used 的标识，来决定是否加载，并进行摧毁。 把使用过的 int used = loadable_categories_used;/****/ shift = 0; for (i = 0; i &lt; used; i++) &#123; if (cats[i].cat) &#123; cats[i-shift] = cats[i]; &#125; else &#123; shift++; &#125; &#125; used -= shift; // Destroy the new list. if (loadable_categories) free(loadable_categories); 二、类的扩展-extension扩展的特性如下 作为匿名的分类 可以添加属性和方法 生成时间：编译时作为类的一部分（ro）一起被编译 如果有与主类同名扩展方法，会先执行扩展方法，因为attachList 内存前插，所以造成覆盖原方法的假象。 三、runtime 关联对象3.1 介绍3.1.1 概念 associatedObject又称关联对象。顾名思义，就是把一个对象关联到另外一个对象身上。 3.1.2 应用场景 为分类添加属性时，用到添加setter和getter方法，在实现里需要将类与属性关联 给某个类添加一个临时的属性 3.2 关联对象的使用 添加关联。 主要用到void objc_setAssociatedObject 函数， 源码的实现是： void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123; _object_set_associative_reference(object, (void *)key, value, policy);&#125; 参数一：id object : 给哪个对象添加属性，这里要给自己添加属性，用self。 参数二：void * &#x3D;&#x3D; id key : 属性名，根据key获取关联对象的属性的值，在objc_getAssociatedObject中通过次key获得属性的值并返回。 参数三：id value : 关联的值，也就是set方法传入的值给属性去保存。 参数四：objc_AssociationPolicy policy : 策略，属性以什么形式保存。 业务上，比如给当前的类把cate_name 作为属性绑定，业务代码如下 -(void)setCate_name:(NSString *)cate_name&#123; objc_setAssociatedObject(self, @&quot;name&quot;,cate_name, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; 获取关联属性 主要函数为：objc_getAssociatedObject方法 查看源码的实现是： id objc_getAssociatedObject(id object, const void *key) &#123; return _object_get_associative_reference(object, (void *)key);&#125; 这里两个参数： 参数一：id object : 获取哪个对象里面的关联的属性。 参数二：void * &#x3D;&#x3D; id key : 什么属性，与objc_setAssociatedObject中的key相对应，即通过key值取出value。 业务实现：去除当前类中 name属性，作为cate_name 返回 -(NSString *)cate_name&#123; return objc_getAssociatedObject(self, @&quot;name&quot;);&#125; 3.1 关联对象关联原理 程序运行时创建一个大大Hash 表 通过manager 进入迭代器对每个类表查找 如果找到，对新添加的属性进行绑定 如果找不到，创建一个，进行绑定存储 通过manager 管理 // 关联对象的管理类 AssociationsManager manager; 获取关联的 HashMap -&gt; 存储当前关联对象 AssociationsHashMap &amp;associations(manager.associations()); 获取 AssociationsHashMap 的迭代器 - (对象的) 进行遍历 AssociationsHashMap::iterator i = associations.find(disguised_object); 根据key去获取关联属性的迭代器 // 根据key去获取关联属性的迭代器 ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; // 替换设置新值 j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; // 到最后了 - 直接设置新值 (*refs)[key] = ObjcAssociation(policy, new_value); &#125; 没有对象的关联信息情况。创建map，通过key-value 存入 if (new_value) &#123; /** 存在该对象，查找遍历，略过*/ &#125;else&#123; ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects();&#125; 3.2 关联对象查找原理主要有以下几个步骤： 生成关联对象的管理类 AssociationsManager manager;AssociationsHashMap &amp;associations(manager.associations()); 生成伪装地址。处理参数 object 地址 disguised_ptr_t disguised_object = DISGUISE(object); 生成Hash表中所有对象的额迭代器 AssociationsHashMap::iterator i = associations.find(disguised_object); 对象内部继续生称迭代器，准备迭代属性 if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; // 内部对象的迭代器 ObjectAssociationMap::iterator j = refs-&gt;find(key); &#125; 查找——找到 - 把值和策略读取出来 // 内部对象的迭代器 ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; // 找到 - 把值和策略读取出来 ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); // OBJC_ASSOCIATION_GETTER_RETAIN - 就会持有一下 if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123; objc_retain(value); &#125; &#125; 如果找到，就进行持有 if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123; objc_retain(value); &#125; 完整的查找过程的源码如下: id _object_get_associative_reference(id object, void *key) &#123; id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; &#123; // 关联对象的管理类 AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); // 生成伪装地址。处理参数 object 地址 disguised_ptr_t disguised_object = DISGUISE(object); // 所有对象的额迭代器 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; // 内部对象的迭代器 ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; // 找到 - 把值和策略读取出来 ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); // OBJC_ASSOCIATION_GETTER_RETAIN - 就会持有一下 if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123; objc_retain(value); &#125; &#125; &#125; &#125; if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123; objc_autorelease(value); &#125; return value;&#125; 3.3 实战3.3.1 目标给UIAlertController 添加一个block 回调 3.3.2 添加前添加钱，每个UIAlertAction 处理自己的逻辑，如果逻辑较多，业务分离开，不方便阅读。 static void *SIGNALERTCONTROLLER = &quot;SIGNALERTCONTROLLER&quot;;- (void)askUserAQuestion &#123; UIAlertController *ac = [UIAlertController alertControllerWithTitle:@&quot;hai&quot; message:@&quot;hey&quot; preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *aa = [UIAlertAction actionWithTitle:@&quot;aaa&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; [self doFirst]; &#125;] ; UIAlertAction *bb = [UIAlertAction actionWithTitle:@&quot;bb&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; [self doSecond]; &#125;] ; UIAlertAction *cc = [UIAlertAction actionWithTitle:@&quot;cc&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; NSLog(@&quot;cancel&quot;); &#125;] ; [ac addAction:aa]; [ac addAction:bb]; [ac addAction:cc]; [self presentViewController:ac animated:YES completion:^&#123;&#125;]; &#125; 3.3.3 添加后统一在block 中处理业务，逻辑更集中 static void *SIGNALERTCONTROLLER = &quot;SIGNALERTCONTROLLER&quot;;- (void)askUserAQuestion &#123; UIAlertController *ac = [UIAlertController alertControllerWithTitle:@&quot;hai&quot; message:@&quot;hey&quot; preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *aa = [UIAlertAction actionWithTitle:@&quot;aaa&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; void (^block) (NSInteger) = objc_getAssociatedObject(ac, SIGNALERTCONTROLLER ); block(0); &#125;] ; UIAlertAction *bb = [UIAlertAction actionWithTitle:@&quot;bb&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; void (^block) (NSInteger) = objc_getAssociatedObject(ac, SIGNALERTCONTROLLER ); block(1); &#125;] ; UIAlertAction *cc = [UIAlertAction actionWithTitle:@&quot;cc&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; void (^block) (NSInteger) = objc_getAssociatedObject(ac, SIGNALERTCONTROLLER ); block(2); &#125;] ; [ac addAction:aa]; [ac addAction:bb]; [ac addAction:cc]; void (^block)(NSInteger) = ^(NSInteger index)&#123; NSLog(@&quot;index---&gt; %ld&quot;, (long)index); if (index == 0) &#123; [self doFirst]; &#125;else if (index == 1)&#123; [self doSecond]; &#125;else&#123; NSLog(@&quot;cancel&quot;); &#125; &#125;; objc_setAssociatedObject(ac, SIGNALERTCONTROLLER, block, OBJC_ASSOCIATION_COPY); [self presentViewController:ac animated:YES completion:^&#123;&#125;]; &#125;- (void)doFirst&#123;&#125;- (void)doSecond&#123;&#125; 四、initialize 的调用调用步骤如下 lookUpImpOrForward if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; cls = initializeAndLeaveLocked(cls, inst, runtimeLock); // runtimeLock may have been dropped but is now locked again // If sel == initialize, class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won&#x27;t happen. 2778172&#125; initializeAndLeaveLocked // Locking: caller must hold runtimeLock; this may drop and re-acquire itstatic Class initializeAndLeaveLocked(Class cls, id obj, mutex_t&amp; lock)&#123; return initializeAndMaybeRelock(cls, obj, lock, true);&#125; initializeAndMaybeRelock // runtimeLock is now unlocked, for +initialize dispatchassert(nonmeta-&gt;isRealized());initializeNonMetaClass(nonmeta); initializeNonMetaClass &#123; callInitialize(cls); if (PrintInitializing) &#123; _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;, pthread_self(), cls-&gt;nameForLogging()); &#125;&#125; callInitialize(cls); void callInitialize(Class cls)&#123; ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize); asm(&quot;&quot;);&#125; 五、面试题 load 与initialize 的区别5.1 调用方式： load 根据函数地址调用 initialize 通过objc_msgSend 调用 5.2 调用时刻 load 属于runtime 加载类、分类的时候，只会调用一次 initialize 方法上类第一次收到消息时，每个类调用一次，而父类的initialize 可能会调用多次 5.3 调用顺序： load： 先编译那个类就先调用它的load，父类的load 方法优先。 分类中也是先主类执行，后分类执行 initialize：和普通方法一样，因为执行的是objc_msgSend 。 先执行子类的initialize，如果没有，执行父类的。 分类部分，如果分类有，执行分类，不执行主类的","categories":[],"tags":[{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/%E7%B1%BB/"},{"name":"加载","slug":"加载","permalink":"http://nilsli.com/tags/%E5%8A%A0%E8%BD%BD/"},{"name":"load","slug":"load","permalink":"http://nilsli.com/tags/load/"}]},{"title":"【数据结构与算法】-（1）基础篇","slug":"dataStructureNAlgorithmBasicTheory","date":"2020-03-31T09:01:00.000Z","updated":"2024-08-07T07:10:46.604Z","comments":true,"path":"p/43384.html","permalink":"http://nilsli.com/p/43384.html","excerpt":"","text":"【数据结构与算法】-（1）基础篇 【数据结构与算法】-（2）线性表基础 【数据结构与算法】-（3）循环链表（单向） 【数据结构与算法】-（4）双向链表和双向循环链表 【数据结构与算法】-（5）链表面试题解析 【数据结构与算法】-（6）栈 【数据结构与算法】-（7）队列 一、数据结构1 数据结构的起源早期人们都把计算机理解为数值计算工具，就是感觉计算机当然是用来计算的，所以计算机解决问题，应该是先从具体问题中抽象出一个适当的数据模型，设计出一个解此数据类型的算法，然后再编写程序，得到一个实际的软件。 可现实中，我们更多的不是解决数值计算的问题，而是需要一些更科学有效的手段（比如表、树和图等数据结构）等帮助，才能更好地解决问题。 所以 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。 2 术语概念说到数据结构是什么，我们得先来谈谈什么叫做数据。 数据结构中，有5个基本概念：数据、数据元素、数据项、数据对象和数据结构。 他们之间的关系如下图所示： 具体到代码上，参考如下代码： //声明一个结构体类型struct Teacher&#123; //一种数据结构 char *name; //数据项--名字 char *title; //数据项--职称 int age; //数据项--年龄&#125;;int main(int argc, const char * argv[]) &#123; struct Teacher t1; //数据元素; struct Teacher tArray[10]; //数据对象; return 0;&#125; 1.2.1数据 是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实数等数值类型，还包括字符及声音、图像、视频等非数值类型类型。 ——《大话数据结构》 比如我们平时使用搜索殷勤，有网页、mp3、图片、视频等分类。MP3 就是声音数据 数据的特点: 可以输入到计算机 可以被计算机程序处理 1.2.2 数据元素 组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 比如，在人类中，人就是数据元素。 而在动物类中，牛、马、羊、鸡等动物就是动物类的数据元素了。 1.2.3 数据项 一个数据元素由若干数据项组成。 比如人这样的数据元素，可以有眼耳鼻舌口这些数据项，也有姓名、年龄、性别、出生地址、电话等数据项。 数据项上数据不可分割的最小单位。 1.2.4 数据对象 性质相同的数据元素的集合，是数据的子集。 性质相同的意思，是指数据元素具有相同数量和类型的数据项，比如，人都有姓名、生日、性别等相同的数据项。 1.2.5 数据结构 是相互之间存在一种或多种特定关系的数据元素的集合。 在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。而在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据之间存在的一种或多种特定关系，也就是数据的组织形式。 3 逻辑结构与物理结构按照观点的不同，我们把数据结构分为逻辑结构和物理结构。 3.1 逻辑结构 是指数据对象中数据元素之间的相互关系 逻辑关系按照类别分为线性结构与非线性结构： 1.3.1 线性结构 线性结构中的数据元素是一对一的关系 线性表 栈和队列 字符串 1.3.2 非线性结构 非线性结构中的数据元素是一对多或多对多的关系。 集合结构集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。 树形结构树形结构中的数据元素之间存在一种一对多的层次关系。 图形结构图形结构中的数据元素是多对多的关系 3.2 物理结构 是指数据的逻辑结构在计算机中的存储形式。 数据元素的存储形式有两种：顺序存储和链式存储。 3.2.1 顺序存储结构 把数据元素存放在抵制连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 如下图所示： 3.2.2 链式存储结构 把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置，如图所示： 4 抽象数据类型4.1 数据类型 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量的表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。 在C语言中，按照趣致的不同，数据类型可以分为两类： 原子类型：不可以再分解的基本类型。包括整型、浮点型、字符类型等 结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。 4.2 抽象数据类型抽象是指抽出事物具有的普遍型的本质。我们对已有的数据类型进行抽象，就有了抽象数据类型。 抽象数据类型（Abstract Data Type：ADT）： 是指一个数学模型及定义在该模型上的一组操作。 抽象的意义在于数据类型的数字抽象特性。 抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。 二、算法2.1 定义 是解决特定问题对求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 什么是算法？算法是描述解决问题的方法。 自唐代以来，历代更有许多专门论述“算法”的专著： 唐代：《一位算法》 一卷，《算法》 一卷； 宋代：《算法绪论》 一卷、《算法秘诀》 一卷；最著名的是杨辉的《杨辉算法》； 元代：《丁巨算法》； 明代：程大位 《算法统宗》 清代：《开平算法》、《算法一得》、《算法全书》。 而英文名称“algorithm”来自于9世纪波斯数学家花拉子米（比阿勒·霍瓦里松，波斯语：خوارزمی ‎，拉丁转写：al-Khwarizmi），因为比阿勒·霍瓦里松在数学上提出了算法这个概念。“算法”原为“algorism”，即“al-Khwarizmi”的音转，意思是“花拉子米”的运算法则，在18世纪演变为“algorithm”。 欧几里得算法被人们认为是史上第一个算法。 2.2 特性算法具有五个基本特征：输入、输出、有穷性、确定性和可行性。 有穷性指算法在执行有限的步骤之后，自动结束而不会出现无限循环，而且每一个步骤在可接受的时间内完成。 确定性算法的每一步骤都具有确定的含义，不会出现二义性。 可行性算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成 输入输出算法具有零个或多个输入 2.3 算法设计的要求2.3.1 正确性 算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反应问题的需求、能够得到问题的正确答案。 大概分为以下四个层次： 算法程序没有语法错误。 算法程序对于合法的输入数据能够产生满足要求的输出结果。 算法程序对于非法的输入数据能够得出满足规格说明的结果。 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。 以上这四层含义里，层次1 要求最低，而层次4 时最困难的，实际开发中，我们几乎不可能逐一验证所有的输入都能得到正确的结果。 2.3.2 可读性 算法设计的另一目的是为了便于阅读、理解和交流。 可读性时算法（也包括实现它的代码）好坏很重要的标志。 2.3.3 健壮性 当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。 2.3.4 时间效率高和存储量低 设计算法应该尽量满足时间效率高和存储量低的特点。 在生活中，人们都希望花最少的钱，用最短的时间，办最大的事，算法也是一样的思想，最好用最少的存储空间，办成同样的事——就是好的算法。 2.4 效率的度量方法通过对算法的数据测试，利用计算机的计时功能，来计算不同算法的效率是高还是低。 2.4.1 事后统计方法 这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编织的程序的运行时间进行比较，从而确定算法效率的高低。 2.4.2 事前统计方法 在计算机程序编制前，依据统计方法对算法进行估算。 我们发现，一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素： 算法采用的策略、方法 编译产生的代码质量 问题的输入规模 机器执行指令的速度 抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。 我们看看两种求和的算法： 第一种算法 int i, sum = 0 n = 100; /* 执行 1次*/for(i = 1; i &lt;= n; i++) /* 执行 n + 1 次*/&#123; sum += i; /* 执行 n 次*/&#125;print(&quot;%d&quot;, sum); /* 执行 1 次*/ 第二种算法 int sum = 0, n = 100; /* 执行 1次*/sum = (1 + n) * n/2; /* 执行 1次*/printf(&quot;%d&quot;, sum); /* 执行 1次*/ 显然，第一种算法，执行了 1 + (n+1) + n + 1 次 &#x3D; 2n + 3 次 而第二种算法是1+1+1 &#x3D; 3 次。算法好坏显而易见。 最终，在分析程序的运行时间时，最重要的是吧程序看成是独立于程序设计语言的算法或一系列步骤。 2.5 算法时间复杂度2.5.1 定义 在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n) 随n 的变化情况并确定T(n) 的数量级。 算法的时间复杂度，也就是算法的时间量度，记作：T(n) &#x3D; O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n) 是问题规模 n 的某个函数。 大写O() 来体现算法复杂度的激发，我们称之为大O记法。 上面求和算法的时间复杂度，分别为O(n) 和 O(1) 2.5.2 推导大O 阶方法 用常数1 取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是1，则去除与这个项相乘的常数 2.5.3 常数阶下面这个算法，就是刚刚的第二个算法（高斯算法）。 int sum = 0, n = 100; /* 执行 1次*/sum = (1 + n) * n/2; /* 执行 1次*/printf(&quot;%d&quot;, sum); /* 执行 1次*/ 这个算法的运行次函数是 f(n) &#x3D; 3。根据我们推导大O阶的方法，第一步就是把常数3 改为1，再加上它没有最高阶项，所以这个算法的时间复杂度为O(1) 如果这里的第二行 sum &#x3D; (1 + n) * n &#x2F; 2 有10句，会是怎么样？ int sum = 0, n = 100; /* 执行 1次*/sum = (1 + n) * n/2; /* 执行 1次*/sum = (1 + n) * n/2; /* 执行 1次*/sum = (1 + n) * n/2; /* 执行 1次*/sum = (1 + n) * n/2; /* 执行 1次*/sum = (1 + n) * n/2; /* 执行 1次*/sum = (1 + n) * n/2; /* 执行 1次*/sum = (1 + n) * n/2; /* 执行 1次*/sum = (1 + n) * n/2; /* 执行 1次*/sum = (1 + n) * n/2; /* 执行 1次*/sum = (1 + n) * n/2; /* 执行 1次*/printf(&quot;%d&quot;, sum); /* 执行 1次*/ 事实上，无论n 为多少，上面的代码就说3次和12次执行的差异。这种与问题的大小无关（n） 的多少，执行时间恒定的算法，我们称之为具有 O(1) 的时间复杂度 2.5.4 线性阶我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。 下面这段代码，它的循环的时间复杂度为O(n)，因为循环体中的代码须要执行 n 次 int i;for(i = 0; i &lt; n; i++)&#123; / * 时间复杂度为O（1）的程序步骤序列 */&#125; 2.5.5 对数阶int count = 1;while (count &lt; n)&#123; count = count * 2; /* 时间复杂度为 O(1) 的程序步骤序列*/&#125; 上面这行代码，由于每次 count 乘以 2 以后，就距离 n 更近了一份。 也就是说，有多少个2 相乘后大于 n，则会推出循环。 由 2x&#x3D; n 得到 x &#x3D; log2n 。所以这个循环的时间复杂度为O(logn)。 2.5.6 平方阶下面的例子说一个循环嵌套，它的内循环时间复杂度为O(n) in i,j;for(i = 0; i &lt; n; i++)&#123; for (j = 0; j &lt; n; j++) &#123; / * 时间复杂度为 O(1) 的程序步骤序列*/ &#125;&#125; 而对于外层的循环，不过是内部这个时间复杂度 O(n) 的语句，再循环 n 次。所以这段代码的时间复杂度为 O(n2)。 2.6 常见的时间复杂度常见的时间复杂度如表所示 执行次数函数 阶 非正式术语 12 O(1) 常数阶 2n + 3 O(n) 线性阶 3n2 + 2n + 1 O(n2) 平方阶 5 log2n + 20 O(logn) 对数阶 2n + 3n log2n + 19 O(nlogn) nlogn 阶 6n3 + 2 n2 + 3n + 4 O(n3) 立方阶 2 n O(2n) 指数阶 常用的时间复杂度所消耗的时间从小到大依次是: O(1) &lt; O(log*n*) &lt; O(*n*) &lt; O(*n*log*n*) &lt; O(*n*2) &lt; O(*n*3) &lt; O(2n) &lt; O(n!) &lt; O(nn) 2.7 最坏情况与平均情况我们查找一个由 n 个随机数字数组中的某个数组，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的复杂度为O(n)，这是最坏的一种情况了。 最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏时间的运行时间。 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，我们运行一段程序代码时，实习完看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。 对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。 另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。一般在没有特殊说明的情况下，都是指最坏时间复杂度。 2.8 算法空间复杂度算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) &#x3D; O(&fnof;(n))，其中，n 为问题的规模，&fnof;(n) 为语句关于 n 所占存储空间的函数。 通常，我们都适用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://nilsli.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://nilsli.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"理论","slug":"理论","permalink":"http://nilsli.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"基础","slug":"基础","permalink":"http://nilsli.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"【类的加载】-（2）懒加载类与分类","slug":"lazyNcat","date":"2020-03-31T04:58:01.000Z","updated":"2024-08-07T07:10:46.655Z","comments":true,"path":"p/38312.html","permalink":"http://nilsli.com/p/38312.html","excerpt":"","text":"本页所使用的objc runtime 756.2，来自 Apple 开源文档 类的加载探寻系列:1、【类的加载】-（1）类的启动 2、【类的加载】-（2）懒加载类与分类 3、【类的加载】-（3）loading_images 一、懒加载类1.1 概念 懒加载(lazy loading)又称为延迟加载，它是指系统不会在初始化是就加载某个对象，而是在第一次调用（使用 get 方法）时才加载这个对象到内存。它的实现方法实质上就是覆写该对象的 get 方法，并将该对象在初始化时需要实现的代码在 get 方法中实现。 而对于数据结构而言，惰性加载是指从一个数据对象通过方法获得里面的一个属性对象时，这个对应对象实际并没有随其父数据对象创建时一起保存在运行空间中，而是在其读取方法第一次被调用时才从其他数据源中加载到运行空间中，这样可以避免过早地导入过大的数据对象但并没有使用的空间占用浪费。 1.2 优点 不需要在 viewDidLoad 中实例化对象，简化代码，使结构清晰 提升初始化加载速度 减少内存占用 1.2 区分通过 load() 方法，在编译器就已经处理好类 1.2.1 非载类的加载步骤： 找到类的指针： classref_t *classlist = _getObjc2NonlazyClassList(hi, &amp;count); 强转为Class类实例 for (i = 0; i &lt; count; i++) &#123; Class cls = remapClass(classlist[i]) 添加到内存： addClassTableEntry(cls); 实现非懒加载类——实例化类的信息，如rw: realizeClassWithoutSwift(cls); 1.2.2 懒加载类的加载步骤 查找懒加载类的方法 向类发送消息，方法查找该类 lookUpImpOrForward 系统向一个没有实现的类的方法发送消息，通过isa查找方法缓存失败后，会进入到慢速查找 方法lookUpImpOrForward 里面，类是否实现过的判断： IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = nil; bool triedResolver = NO; runtimeLock.assertUnlocked(); // Optimistic cache lookup if (cache) &#123; imp = cache_getImp(cls, sel); if (imp) return imp; &#125; // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. runtimeLock.lock(); checkIsKnownClass(cls); if (!cls-&gt;isRealized()) &#123; cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); // runtimeLock may have been dropped but is now locked again &#125; 对方法进行实现 接下来，realizeClassMaybeSwiftAndLeaveLocked 方法的实现会落实到realizeClassMaybeSwiftMaybeRelock 这个方法，会返回真实的类的结构： static ClassrealizeClassMaybeSwiftAndLeaveLocked(Class cls, mutex_t&amp; lock)&#123; return realizeClassMaybeSwiftMaybeRelock(cls, lock, true);&#125; static ClassrealizeClassMaybeSwiftMaybeRelock(Class cls, mutex_t&amp; lock, bool leaveLocked)&#123; lock.assertLocked(); if (!cls-&gt;isSwiftStable_ButAllowLegacyForNow()) &#123; // Non-Swift class. Realize it now with the lock still held. // fixme wrong in the future for objc subclasses of swift classes realizeClassWithoutSwift(cls); if (!leaveLocked) lock.unlock(); &#125; else &#123; // Swift class. We need to drop locks and call the Swift // runtime to initialize it. lock.unlock(); cls = realizeSwiftClass(cls); assert(cls-&gt;isRealized()); // callback must have provoked realization if (leaveLocked) lock.lock(); &#125; return cls;&#125; 可以看到，在这个类里面，进到!cls-&gt;isSwiftStable_ButAllowLegacyForNow 这个选择，也就是非swift 类的情况下，对类cls进行了方法属性的实现，对的，没错，实现放方法，就放在realizeClassWithoutSwift里，这也是之前讨论过的非懒加载来初次实现的方法。 二、分类及其加载2.1 分类的结构为了搞清楚分类在底层的特点，先用代码一步一步来摸索 生成一个分类： @interface NSObject (Eat)- (void)eat;- (void)swallow;@end 输入编译代码，得到相应的.cpp 文件 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc NSObject+Eat.m 得到对应的cpp文件 打开这份.cpp 文件，熟悉的内容扑面而来 下面看到的是分类的结构： 其中包含了 name - 主类的名字 cls - 分类的名字 instanceMethods - 实例方法列表 classMethods - 类方法列表 protocols - 分类遵循的协议列表 properties - 属性列表 接下来看其中方法method_list的结构： 得到了两个结构体，原结构体如下： static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[2];&#125; 下面实现的结构体为： _OBJC_$_CATEGORY_INSTANCE_METHODS_NSObject_$_Eat __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123; sizeof(_objc_method), 2, &#123;&#123;(struct objc_selector *)&quot;eat&quot;, &quot;v16@0:8&quot;, (void *)_I_NSObject_Eat_eat&#125;, &#123;(struct objc_selector *)&quot;swallow&quot;, &quot;v16@0:8&quot;, (void *)_I_NSObject_Eat_swallow&#125;&#125;&#125; 两个结构体，其实是一一对应关系 占用内存：entsize —— sizeof(_objc_method) 方法数量：method_count - 2 方法列表：method_list - &#123;(struct objc_selector *)&quot;eat&quot;, &quot;v16@0:8&quot;, (void *)_I_NSObject_Eat_eat&#125;,&#123;(struct objc_selector *)&quot;swallow&quot;, &quot;v16@0:8&quot;, (void *)_I_NSObject_Eat_swallow&#125; 即 eat 和 swallow 两个方法 继续往下看，可以看到分类 _OBJC_$_CATEGORY_NSObject_$_Eat.cls 这个类指针指向了 主类OBJC_CLASS_$_NSObject 的地址 查询源码762，分类的结构如下： struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; 2.2 分类的加载流程2.3.1 初始化void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; 2.3.2 处理dyld镜像voidmap_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[])&#123; mutex_locker_t lock(runtimeLock); return map_images_nolock(count, paths, mhdrs);&#125; 2.3.4 解锁处理镜像void map_images_nolock(unsigned mhCount, const char * const mhPaths[], const struct mach_header * const mhdrs[])&#123; /*** 省去许多 ***/ if (hCount &gt; 0) &#123; _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses); &#125; firstTime = NO;&#125; 可以看到读取镜像后，核心业务代码为_read_images 这个方法， 处理了所有的类。 2.3.5 实现分类方法进到_read_images 方法，看到关于分类的在这里 这里逐一解释做了什么操作： 将分类与类表中存储。使用的是addUnattachedCategoryForClass 方法，看看具体如何实现的： 如图所示，分别是：获取存放分类的表、分类扩容、分类插入表里。 而分类插入到表里，是 分类——类进行key-value 对应存入的，具体的函数为： void *NXMapInsert(NXMapTable *table, const void *key, const void *value) 对方法的重新实现：remethodizeClass，来看看这个方法的实现 这是啥？脚趾头都知道，核心业务方法是 attachCategories(cls, cats, true /*flush caches*/);，点开继续看。 往类里添加分类 - attachCategories 所要做的，都写在上面了，就是做了3件事情： 开辟内存空间 遍历分类列表，把方法、属性、协议写到3组数组里 通过attatchList 方法， 依次写入到类的rw 的methods、properties、protocols 里 attachLists方法 - 粘贴方法&#x2F;属性&#x2F;协议的具体实现： 具体的代码如下： 这里可以看到，往类里添加分类的方法、属性、协议，一般有3种情况，处理如下： 多对多。处理方式是为新内容创建空间，将旧内容平移到后面，将新内容拷贝放置最前面。 0对1。即之前没有方法、属性或协议。这种比较简单，直接插入即可。 一对多。这种和多对多类似，将新的内容拷贝放入内存最前面 内存移动和拷贝 这里着重分析一下，平移，与拷贝。在C函数里，他们是这样的 /* dst ： destination ：目标地址 src ： source ：被移动的内存首地址 n ： 被移动的内存长度 memmove 将 src内存中移动 len长度部分到 dest memcpy 将 src内存中拷贝 n 长度部分到 dest */void *memcpy(void *__dst, const void *__src, size_t __n);void *memmove(void *__dst, const void *__src, size_t __len); 第一步平移操作： memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); dst：array()-&gt;lists + addedCount，即总数组的长度 src：被移动的数组为原内容（方法列表、属性、协议） n：移动了的部分：array()-&gt;lists，即偏移原来的部分 第二步操作 memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); dst：array()-&gt;lists + addedCount，即总数组的长度 src：被拷贝的数组为原内容（方法列表、属性、协议） len：拷贝了的部分：array()-&gt;lists，即偏移原来的部分 从这张图，可以清晰的看出，分类中的方法、属性和协议的添加次序，都是讲旧的移走，新的方法排最前面。 这也解释了为何分类会覆盖类原有的方法，原理是因为相应的方法、属性和协议，在内存段中，排列靠前。 2.3 分类与懒加载的搭配2.2.1 分类实现load 方法（非懒分类） 懒加载的类 + 非懒加载的分类 先实现非懒加载类的分类 具体是读取镜像 read_images 以及： addUnattachedCategoryForClass 将读到的分类插入到分类的表里，备用 请见代码实现： static void addUnattachedCategoryForClass(category_t *cat, Class cls, header_info *catHeader)&#123; runtimeLock.assertLocked(); // DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead NXMapTable *cats = unattachedCategories(); category_list *list; list = (category_list *)NXMapGet(cats, cls); if (!list) &#123; list = (category_list *) calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1); &#125; else &#123; list = (category_list *) realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1)); &#125; list-&gt;list[list-&gt;count++] = (locstamped_category_t)&#123;cat, catHeader&#125;; NXMapInsert(cats, cls, list);&#125; 分类督促懒加载类实现，不然分类无处依附。 这里使用的是prepare_load_methods方法 实现主类后，将分类粘贴到主类上 先进行 realizeClassWithoutSwift，然后 unattachedCategoriesForClass 贴到主类上 具体的实现步骤如下： read_images prepare_load_methods realizeClassWithoutSwift unattachedCategoriesForClass 非懒加载的类 + 非懒加载的分类 直接编译获取到。 这种情况是最普遍的，就是直接取 class 里的data()-&gt;ro，在ro 里找到对应的方法 获取到过程是： read_images - 读取镜像 realizeClassWithoutSwift（实现非懒加载类） methodizedClass - 实现方法 unattachedCategoriesForClass - 把内存里的类插入到表里 attachCategories - 往类后面粘贴分类结构 2.2 分类未实现load 方法（懒分类）如果分类并不主动实现 +load() 方法，就由编译时实现类与分类的查找实现 非懒加载类 + 懒加载的分类 通过镜像来查找实现 读取镜像 read_images realizeClassWithoutSwift（实现非懒加载类） methodizedClass 读取类里的 data-&gt;ro 信息 懒加载的类 + 懒加载的分类 因为懒加载的类在编译时并不会主动实现，所以通过方法查找一步一步找到 方法查找的消息传递 - lookupimporforward realizeClassWithoutSwift methodizedClass 2.3 总结 懒加载的分类: 编译时就已经决定处理好。 非懒加载分类：运行时再来处理。 以上和懒加载的类是刚刚相反。","categories":[],"tags":[{"name":"底层，源码，懒加载，分类","slug":"底层，源码，懒加载，分类","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82%EF%BC%8C%E6%BA%90%E7%A0%81%EF%BC%8C%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%8C%E5%88%86%E7%B1%BB/"}]},{"title":"【底层探索】- runtime面试题集","slug":"runtimeInterview","date":"2020-03-30T08:24:38.000Z","updated":"2024-08-07T07:10:46.702Z","comments":true,"path":"p/41032.html","permalink":"http://nilsli.com/p/41032.html","excerpt":"","text":"〇、引言前面一步步学习了对象、类、方法、类的加载等，这些其实都是Runtime 的基础，而Runtime 又是iOS开发语言 Objective C 的精髓，因此关于Runtime 的面试题举不胜举。 下面就简单的介绍几个，并提供解题思路，希望可以帮读者更清晰的理解Runtime。 一、什么是Runtime这个问题，问的是对Runtime 的基础理解。 Runtime是由C和C++汇编实现的一套API，为 OC 语言加入了面向对象，运行时的功能。 运行时（Runtime） 是指将数据类型确定推迟到了运行时。 举个例子： 关于类——类的扩展，在编译时作为类的一部分（ro）就已经确定好了，所以可以添加分类；而分类由于是运行时加载，只能添加属性以及对应的setter 和getter 方法，来达到模拟属性的目的。 二、方法的本质是什么？ 方法的本质，就是发送消息&#x2F;消息传递 让一个类（对象&#x2F;类）执行一个方法的过程，就是向它发送消息，它便开始消息查找的过程。主要包含以下几个过程： 快速查找（objc_msgSend），主要向类 cache_t 查找缓存的过的方法。 慢速查找：执行 lookUpImpOrForward 方法，递归自己，以及自己的父类，属性 rw 里的methodlist 中查找方法。 动态方法加解析（还是查找不到）：resolveInstanceMethod 方法，看是否自定义实现过 消息转发阶段： 快速转发—— forwardingTargetForSelector 寻找特定对象来执行方法 慢速转发—— methodSignatureForSelector（获取方法的签名）以及生成相应的invocation，由 forwardInvocation 方法进行消息分发，让有能力执行的类来执行该方法。 三、简述SEL 和IMP和之间关系 定义：SEL是内存中方法编号，IMP 是方法的具体实现 两者个点关系就好比一本书：SEL 是目录页里的 章节标题，而IMP 则是文章的页码，通过页码，可以看到具体内容。 SEL 是由read_images 就已经加载注册到内存表里。 四、能否往已注册的类添加成员变量？Q：已经注册好的类，能否再动态添加成员变量？为什么？ 答案是不可以。 我们通过Runtime还原一下场景。 注册好的类，实现的方法是，注册到内存里： objc_registerClassPair(LGPerson); 而实现objc_registerClassPair 这个方法，又实现了下面的内容: // Clear &quot;under construction&quot; bit, set &quot;done constructing&quot; bitcls-&gt;ISA()-&gt;changeInfo(RW_CONSTRUCTED, RW_CONSTRUCTING | RW_REALIZING);cls-&gt;changeInfo(RW_CONSTRUCTED, RW_CONSTRUCTING | RW_REALIZING); 即对类更改了状态，更改了什么状态？RW_CONSTRUCTED这个状态，即让类处于内存开辟&amp;注册到内存中—— // class allocated and registered#define RW_CONSTRUCTED (1&lt;&lt;25) 接下来，根据创建成员变量的函数为addIvar，创建业务代码如下 class_addIvar(LGPerson, &quot;lgName&quot;, sizeof(NSString *), log2(sizeof(NSString *)), &quot;@&quot;); 在源码中找到相对应的函数： 走到这一步，就戛然而止了……添加ivars 被拒绝——因为内存已固定，无法再添加新属性了。 原因：因为注册好的类，内存容量已经固定，无法动态添加了。 五、isKindOFClass 和 isMemberOfClass 的区别5.1 题目关于这两个函数，我们知道他们各自概念是： isKindOfClass——某个对象是否是类的成员，或者继承自该类的成员（即父子关系） isMemberOfClass——某个对象是否当前类的成员，并不考虑回溯的父子类关系。 这里有一道面试题，题目如下，要求回答各打印结果： BOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];//1BOOL re2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];// 0BOOL re3 = [(id)[Person class] isKindOfClass:[Person class]];//0BOOL re4 = [(id)[Person class] isMemberOfClass:[Person class]];// 0NSLog(@&quot; re1 :%hhd\\n re2 :%hhd\\n re3 :%hhd\\n re4 :%hhd\\n&quot;,re1,re2,re3,re4);BOOL re5 = [(id)[NSObject alloc] isKindOfClass:[NSObject class]];//1BOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]];// 1BOOL re7 = [(id)[Person alloc] isKindOfClass:[Person class]];//1BOOL re8 = [(id)[Person alloc] isMemberOfClass:[Person class]];// 1NSLog(@&quot; re5 :%hhd\\n re6 :%hhd\\n re7 :%hhd\\n re8 :%hhd\\n&quot;,re5,re6,re7,re8); 答案是什么呢？先别忙，先冷静分析一下 5.2 概念分析5.2.1 类方法的区别分析很明显，上半部4个判断，是判断类与类的归属，执行的是类方法判断，先看一下涉及到的两个方法的源码： 类方法的区别 +(void)isKindOfClass** 的实现 + (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125; +(BOOL)isMemberOfClass 的实现 + (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125; 从上面源码分析，可以看出，isKindOfClass 多了一步 tcls = tcls-&gt;superclass 的循环，即如果当前类不等于目标类，向上查找父类，看看父类与目标是否相等。 5.2.2 实例方法的区别 -(void)isKindOfClass 的实现 - (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125; 步骤为：先判断对象的类，看是否与目标类相同；否则通过tcls = tcls-&gt;superclass，递归寻找父类及其父类，是否与本类相等 -(void)isMemberOfClass 的实现 - (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125; 步骤为：判断对象指向的类，是否与目标类相同 5.2.3 答题好的，根据这个，一个一个来进行解答。 返回1：因为根元类的父类&#x3D;根元类 左边的NSObject class 为 NSObject 的元类，判断是否与本类NSobject 相等？ 答案是不一致。 但是此时会进入tcls = tcls-&gt;superclass 这个循环，查找本类的父类，而我们知道 NSObject 的元类的父类就是NSObject ，见下图。所以绕了一圈回来，NSObject &#x3D; NSObject 返回0：因为元类与本类不相等 和上一个问题一样，但是isMemberOfClass 在第一步就停下了，object_getClass((id)self) == cls 这里问到元类与本类是否相等，当然是否。 返回0：因为普通类的元类的父类与本类是不相等的 我们看右边是 Person Class 左边的 Person Class 判断条件是 isKindOfClass 所以，Person 开始找它的元类，看是否等于本类。我们看isa 的指向图可以得出，它的元类递归查找父类，一直都与本类不相等。所以返回为0 返回为0。因为 元类不等于本类 这个和第2条是一样的 **返回为1： ** 因为本类等于本类 给出的判断代码为： [(id)[NSObject alloc] isKindOfClass:[NSObject class]] 其中左边的[NSObject alloc] ，创建了一个 NSObject 的对象，而对他指向 isKindOfClass 即执行以下方法： for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; 创建的 Class tcls = [self class] ，其中tcls 即为 其父类 NSObject，取其与 NSObject 相比，相等，所以返回为1。 返回为1： 因为本类等于本类，同第5 题 返回为1：同第5题 返回为1： 同第5题 五、[self class] 与[super class] 区别5.1 提问：以下打印什么？#import &quot;Student.h&quot;#import &lt;objc/message.h&gt;@implementation Student- (instancetype)init&#123; self = [super init]; if (self) &#123; NSLog(@&quot;%@&quot;,NSStringFromClass([self class])); NSLog(@&quot;%@&quot;,NSStringFromClass([super class])); &#125;&#125; 5.2 源码分析因为问题都涉及到了 class 这个方法，在NSObject.mm 这个类里找一下，方法实现如下： - (Class)class &#123; return object_getClass(self);&#125;Class object_getClass(id obj)&#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125; 可以见到，在object_getClass 方法里，如果给的对象self ——obj 存在，返回的是它的元类，指针指向的是它的类，所以打印应该是 Student。 而第一行中，向super 发送消息了。 [self class] 方法，是向 对象（self）发送消息（class），走的流程是 objc_msgSend [super class]，是向 对象（self）发送消息（class），走的流程是 objc_msgSendSuper 那继续探寻objc_msgSendSuper 这个方法，可以看到他的结构如下： objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ ) OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 可见它执行的是 struct objc_super 类型的super， 原因：在OC中，super只是个符号标识符，objc_msgSendSuper最终接受对象还是 self 5.3 解答打印都是NSObject 六、weak 是什么及其实现原理6.1 分析在OC语言到开发中，我们经常对对象前面添加 weak 来实现弱引用，从而达到避免循环引用造成的内存泄漏。那么这个weak 究竟实现了什么，作为高级开发者，不得不仔细探究一下。 6.1.1 代码创建为了搞清楚weak 创建对象时内部的实现，创建一个weak 对象，打印试试，这时要把汇编断点打开 NSArray *arr = @[@&quot;jack&quot;, @&quot;tiga&quot;, @&quot;jade&quot;, @&quot;obu&quot;];id __weak abc = arr; 可以看到运行后，执行了这行代码： 可见创建后执行了关键代码 objc_initWeak，贴到源码里查看，实现如下： idobjc_initWeak(id *location, id newObj)&#123; if (!newObj) &#123; *location = nil; return nil; &#125; return storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object*)newObj);&#125; 返回到时storeWeak(id *location, objc_object *newObj)这个函数，依稀可以看出来，是一个将newObj 储存到location 的动作。继续往下分析如下： 6.1.2 源码解读 storeWeak 如果有新对象，创建新的散列表 if (haveNew) &#123; newTable = &amp;SideTables()[newObj]; 散列表结构如下： struct SideTable &#123; spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table; /*精简以后的内容*/&#125;; 可见散列表中有重要的3个属性 slock —— 自旋锁 refcnts——引用计数表，这里是App 维护的一张全局表，类型是 weak_table —— 全局的弱引用表，存储所有的弱引用对象，把对象当作key 来保持，打开看看，它的结构体实现是这样的： /** * The global weak references table. Stores object ids as keys, * and weak_entry_t structs as their values. */struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;&#125;; 共包含了整个应用里，弱引用实体和数量。 如果当前是创建的新弱引用haveNew，添加弱引用。 newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); 记录弱引用实体保存的内存地址： weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; append_referrer(entry, referrer); &#125; 插入对象到弱引用过程如下： 创建数组，插入到weak 表里 weak_entry_t new_entry(referent, referrer); weak_grow_maybe(weak_table); weak_entry_insert(weak_table, &amp;new_entry); 循环弱引用表，将引用实体插入，弱引用的计数增加 static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)&#123; weak_entry_t *weak_entries = weak_table-&gt;weak_entries; assert(weak_entries != nil); size_t begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask); size_t index = begin; size_t hash_displacement = 0; while (weak_entries[index].referent != nil) &#123; index = (index+1) &amp; weak_table-&gt;mask; if (index == begin) bad_weak_table(weak_entries); hash_displacement++; &#125; weak_entries[index] = *new_entry; weak_table-&gt;num_entries++; if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123; weak_table-&gt;max_hash_displacement = hash_displacement; &#125;&#125; 将弱引用的位值，存放在引用计数表里 if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; newObj-&gt;setWeaklyReferenced_nolock(); &#125; 并对isa 的weak引用属性设置为TRUE newisa.weakly_referenced = true; 添加到计数表的方法如下： void objc_object::sidetable_setWeaklyReferenced_nolock()&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.nonpointer);#endif SideTable&amp; table = SideTables()[this]; table.refcnts[this] |= SIDE_TABLE_WEAKLY_REFERENCED;&#125; 最终返回存储的内存地址的指针，指向这个新的对象 *location = (id)newObj; 6.3 weak 的释放6.1 查看 dealloc我们知道，对象的销毁，一般是在类的dealloc 后进行，所以目光放在 dealloc 的方法是先上 查看NSObject.mm 中，得知dealloc 如下 - (void)dealloc &#123; _objc_rootDealloc(self);&#125; 继续探寻 void_objc_rootDealloc(id obj)&#123; assert(obj); obj-&gt;rootDealloc();&#125; 继续继续，得到一个内联函数如下： inline voidobjc_object::rootDealloc()&#123; if (isTaggedPointer()) return; // fixme necessary? if (fastpath(isa.nonpointer &amp;&amp; !isa.weakly_referenced &amp;&amp; !isa.has_assoc &amp;&amp; !isa.has_cxx_dtor &amp;&amp; !isa.has_sidetable_rc)) &#123; assert(!sidetable_present()); free(this); &#125; else &#123; object_dispose((id)this); &#125;&#125; 目标放在object_dispose((id)this); 这一行，函数的名字——销毁对象，即当前对象的isa还有些弱引用（isa.weakly_referenced）或者关联对象（isa.has_assoc）未处理的业务，会比较复杂，需要特别处理。继续探寻如下： id object_dispose(id obj)&#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125; 继续查看解构过程objc_destructInstance(obj) 这个函数： void *objc_destructInstance(id obj) &#123; if (obj) &#123; // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); // This order is important. if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); obj-&gt;clearDeallocating(); &#125; return obj;&#125; if (cxx) object_cxxDestruct(obj); —— 处理析构C++ 的对象 _object_remove_assocations(obj); ——移除类的关联对象 那么要找寻如何移除弱引用，把目光放在obj-&gt;clearDeallocating(); 这行代码——又是一个内联函数，解释了如何dealloc 对象 inline void objc_object::clearDeallocating()&#123; if (slowpath(!isa.nonpointer)) &#123; // Slow path for raw pointer isa. sidetable_clearDeallocating(); &#125; else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) &#123; // Slow path for non-pointer isa with weak refs and/or side table data. clearDeallocating_slow(); &#125; assert(!sidetable_present());&#125; 很明显 clearDeallocating_slow() 才是需要找的，因为注释已经解释的很清楚： Slow path for non-pointer isa with weak refs and&#x2F;or side table data. 带弱引用或散列表数据的非指针的isa 慢速路径 NEVER_INLINE voidobjc_object::clearDeallocating_slow()&#123; assert(isa.nonpointer &amp;&amp; (isa.weakly_referenced || isa.has_sidetable_rc)); SideTable&amp; table = SideTables()[this]; table.lock(); if (isa.weakly_referenced) &#123; weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; if (isa.has_sidetable_rc) &#123; table.refcnts.erase(this); &#125; table.unlock();&#125; 分析关键代码： 如果当前isa 有弱引用，在弱引用表中，弱引用表清除当前的弱引用 if (isa.weakly_referenced) &#123; weak_clear_no_lock(&amp;table.weak_table, (id)this);&#125; weak_clear_no_lock 这个核心函数，具体做了什么工作，继续探究一下 void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123; objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); // zero out references weak_referrer_t *referrers; size_t count; if (entry-&gt;out_of_line()) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; if (*referrer == referent) &#123; *referrer = nil; &#125; // &#125; &#125; weak_entry_remove(weak_table, entry);&#125; 这里看上去业务挺多，其实核心也就两个: 移除指针 if (*referrer == referent) &#123; *referrer = nil;&#125; 移除实体： weak_entry_remove(weak_table, entry);/** * Remove entry from the zone&#x27;s table of weak references. */static void weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry)&#123; // remove entry if (entry-&gt;out_of_line()) free(entry-&gt;referrers); bzero(entry, sizeof(*entry)); weak_table-&gt;num_entries--; weak_compact_maybe(weak_table);&#125; 如果当前对象有引用计数存表不为0，引用计数表清楚本对象 if (isa.has_sidetable_rc) &#123; table.refcnts.erase(this);&#125; 6.3 回答 weak 的创建，在内存的散列表中的弱引用表里，存储关于该对象的弱引用，按照key-value 存入。 weak 的创建，正好相反，中dealloc 里，去弱引用表格里，找到引用进行弱引用实体销毁，以及弱引用的引用计数减少。 七、黑魔法·方法交换（Method Swizzling）坑点7.1 一般使用如下所示，对数组越界做保护： #import &quot;NSArray+Empty.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSArray (Empty)+ (void)load&#123; Method oriMethod = class_getInstanceMethod(NSClassFromString(@&quot;__NSArrayI&quot;), @selector(objectAtIndex:)); Method swiMethod = class_getInstanceMethod([self class], @selector(lj_objectAtIndex:)); method_exchangeImplementations(oriMethod, swiMethod);&#125;- (instancetype)lj_objectAtIndex: (NSUInteger)index&#123; if (index &gt; self.count -1 ) &#123; NSLog(@&quot;朋友，数组越界了&quot;); return nil; &#125; return [self lj_objectAtIndex:index];&#125; 试验一下结果如何： NSArray *arr = @[@&quot;jack&quot;, @&quot;tiga&quot;, @&quot;jade&quot;, @&quot;obu&quot;];NSString *name = [arr objectAtIndex:4]; 打印结果如下： 2020-05-03 23:52:50.759731+0800 SWZ[7438:461811] 朋友，数组越界了 可以看到，经过方法交换，本来使用 objectAtIndex 的方法，它的实现被交换了，被交换到 lj_objectAtIndex 的实现里，执行了越界保护，保证了代码的鲁棒性。 7.2 坑点1 - 重复使用以上是方法交换的一个简单的例子，对NSArray 添加方法实现方法交换。 7.2.1 症状那么会不会有什么漏洞呢？留意到方法实现是在 load 方法就实现，假设在实现方法之前，主动加载一次load 会怎么样？ 假设是这样： NSArray *arr = @[@&quot;jack&quot;, @&quot;tiga&quot;, @&quot;jade&quot;, @&quot;obu&quot;];[NSArray load];NSString *name = [arr objectAtIndex:4]; 结果，出现了越界崩溃 7.2.2 追踪分析往核心方法load 里添加一段打印标记，看看是否与他有关： 通过追踪，得知load 方法，执行了2次。想一想，执行load 本来是为了交换方法，那执行2次，意思是将原本交换过的方法实现，又交换回去了——白干了，这也是出现越界崩溃的原因。 7.2.3 解决解决的方法很简单，将该方法设置成单例，通过 onceToken 来保证交换过程只会走一次： + (void)load&#123; NSLog(@&quot;执行load!&quot;); static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Method oriMethod = class_getInstanceMethod(NSClassFromString(@&quot;__NSArrayI&quot;), @selector(objectAtIndex:)); Method swiMethod = class_getInstanceMethod([self class], @selector(lj_objectAtIndex:)); method_exchangeImplementations(oriMethod, swiMethod); &#125;);&#125; 这样，继续执行虽然执行2次load, 但是内部的交换实现，只会执行一次。 2020-05-04 00:13:53.061523+0800 SWZ[7778:482862] 执行load!2020-05-04 00:13:56.011281+0800 SWZ[7778:482862] 执行load! 结果如下，虽然load 执行2次，交换方法只执行1次 7.3 坑点2 - 待交换子类未实现7.3.1 症状先创建一个案发现场，如下： 父类某方法A并实现 子类继承父类 其他业务向子类交换该A方法 执行父类该方法A，查看结果 如下所示： 创建父类Animal，以及子类Dog， 其中父类拥有并实现run 的类方法 @interface Animal : NSObject- (void)run;@end @interface Dog : Animal@end 其他业务场景，向子类申请交换了 run 的实现，run 换成了play，在Dog.m 执行： + (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Method oriMethod = class_getInstanceMethod(self, @selector(run)); Method swiMethod = class_getInstanceMethod(self, @selector(play)); method_exchangeImplementations(oriMethod, swiMethod); &#125;);&#125;- (void)play&#123; NSLog(@&quot;%s&quot;, __func__);&#125; 检查此时子类与父类的的run 方法 生成两个实例，执行run 方法 Animal *a = [[Animal alloc] init];[a run];Dog *d = [[Dog alloc ] init];[d run]; 结果如下： 2020-05-04 00:51:33.474658+0800 SWZ[8188:509782] -[Dog(Exchange) play]2020-05-04 00:51:33.474795+0800 SWZ[8188:509782] -[Dog(Exchange) play] 总结：可见子类方法执行了新方法play，但是同时父类的run 方法也给换走了，执行了新的play方法 7.3.2. 追踪分析在分析之前，先明白现在的场景： 父类有该方法及其实现 子类并无该方法极其实现 可见，业务场景向子类交换了该方法，子类查询方法并未找到，于是递归向父类查找，在父类的方法列表里查找成功，进而完成了交换过程。而父类下次调用该方法，结果使用了交换来的新方法。 好一个坑爹滴子类…… 7.3.3 解决面对如此坑爹的子类，解决方法只有一个，方法没有——自己实现。 当子类需要交换某方法的时候，尝试向自己添加待交换走的方法，以防自己未实现，不得不去找父类交换： BOOL success = class_addMethod([Dog class], oriSEL, swiIMP, method_getTypeEncoding(oriMethod)); 然后，如果添加成功，即自身本来并未实现，借着添加的机会实现了。 接下来做的就是，将新添加的方法与目标方法交换： if (success) class_replaceMethod([Dog class], swiSEL, oriIMP, method_getTypeEncoding(oriMethod) ); 当然， 如果添加失败，即原本就有，那么按原来的逻辑，直接交换两种方法即可 贴一下完整的完善的逻辑如下： + (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; SEL oriSEL = @selector(run); SEL swiSEL = @selector(play); Method oriMethod = class_getInstanceMethod(self, @selector(run)); Method swiMethod = class_getInstanceMethod(self, @selector(play)); IMP oriIMP = method_getImplementation(oriMethod); IMP swiIMP = method_getImplementation(swiMethod); BOOL success = class_addMethod([Dog class], oriSEL, swiIMP, method_getTypeEncoding(oriMethod)); if (success) &#123; class_replaceMethod([Dog class], swiSEL, oriIMP, method_getTypeEncoding(oriMethod) ); &#125;else&#123; method_exchangeImplementations(oriMethod, swiMethod); &#125; &#125;);&#125; 7.4 坑点2 - 待交换子类父类实现7.4.1 症状上面的代码，解决了子类未实现不得不向父类索取，并拿出来交换的弊端。 那么如果该方法，父类都没实现呢？就是将父类的 run方法实现注释，会如何，再走一遍—— 不出意外，瘪犊子了。 7.4.2 追踪分析这里很明白得出结论是，想要像某个类交换方法，结果该类以及向上的父类都没实现，毫无意外会造成崩溃。该怎么办呢？ 先看一下一级一级的关系： 交换方法——&gt;找当前类要 找不到当前类的方法实现——找父类要 找不到父类的方法实现——崩溃 结合7.4 里的逻辑，追根溯源，是父类没有实现，那么需要做的是，先给父类添加一个空的实现，以避免崩溃。 然后在子类交换方法的过程中，子类会完善自身的添加方法实现，再去交换方法（这部分的逻辑是7.3） 7.4.3 解决在交换方法时，先判断原方法是否存在，如果不存在，添加一个空方法实现。 添加部分如下: if (!oriIMP) &#123; class_addMethod(self, oriSEL, swiIMP, method_getTypeEncoding(swiMethod)); method_setImplementation(swiMethod, imp_implementationWithBlock(^(id self, SEL _cmd)&#123; &#125;));&#125; 全文如下： + (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; SEL oriSEL = @selector(run); SEL swiSEL = @selector(play); Method oriMethod = class_getInstanceMethod(self, @selector(run)); Method swiMethod = class_getInstanceMethod(self, @selector(play)); IMP oriIMP = method_getImplementation(oriMethod); IMP swiIMP = method_getImplementation(swiMethod); if (!oriIMP) &#123; class_addMethod(self, oriSEL, swiIMP, method_getTypeEncoding(swiMethod)); method_setImplementation(swiMethod, imp_implementationWithBlock(^(id self, SEL _cmd)&#123; &#125;)); &#125; BOOL success = class_addMethod(self, oriSEL, swiIMP, method_getTypeEncoding(oriMethod)); if (success) &#123; class_replaceMethod([Dog class], swiSEL, oriIMP, method_getTypeEncoding(oriMethod) ); &#125;else&#123; method_exchangeImplementations(oriMethod, swiMethod); &#125; &#125;);&#125; Z、总结在这篇文章，初步汇总了一下关于Runtime 几个典型的问题，比如基础的SEL、IMP 的关系，以及self 和super 的区别，以及后面深一点的weak 的底层实现，还有业务上用得最多的黑魔法——方法交换使用过程中的几点坑，如果深刻理解了其内部实现，自然能避开这些坑。 希望在日后更深刻的理会这些原理，欢迎大家有问题留言交流。","categories":[],"tags":[{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/%E7%B1%BB/"},{"name":"2020","slug":"2020","permalink":"http://nilsli.com/tags/2020/"},{"name":"runtime","slug":"runtime","permalink":"http://nilsli.com/tags/runtime/"},{"name":"面试","slug":"面试","permalink":"http://nilsli.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"成员变量","slug":"成员变量","permalink":"http://nilsli.com/tags/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"}]},{"title":"【类的加载】-（1）类的启动","slug":"loadingClass","date":"2020-03-24T07:18:34.000Z","updated":"2024-08-07T07:10:46.672Z","comments":true,"path":"p/29664.html","permalink":"http://nilsli.com/p/29664.html","excerpt":"","text":"本页所使用的objc runtime 756.2，来自 Apple 开源文档 类的加载探寻系列:1、【类的加载】-（1）类的启动 2、【类的加载】-（2）懒加载类与分类 3、【类的加载】-（3）loading_images 1、objc_init 流程类的加载，初始化来自dyld 中的objc_init 这个步骤，查看一下源码，得到 void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; 序号 源代码 解释 1 environ_init() 环境变量、帮助文档配置 2 tls_init() 线程key 的绑定 3 static_init C++ 静态构造函数 4 lock_init() 锁配置 5 exception_init() 异常初始化 6 _dyld_objc_notify_register Dyld 通知注册 1.1 environ_init 在函数void environ_init(void) 里，读取环境变量 env 以及帮助注释 help， 相关代码如下： for (size_t i = 0; i &lt; sizeof(Settings)/sizeof(Settings[0]); i++) &#123; const option_t *opt = &amp;Settings[i]; if (PrintHelp) _objc_inform(&quot;%s: %s&quot;, opt-&gt;env, opt-&gt;help); if (PrintOptions &amp;&amp; *opt-&gt;var) _objc_inform(&quot;%s is set&quot;, opt-&gt;env);&#125; 运行代码，在控制台可以得到环境变量参数表： objc[27076]: OBJC_PRINT_IMAGES: log image and library names as they are loadedobjc[27076]: OBJC_PRINT_IMAGE_TIMES: measure duration of image loading stepsobjc[27076]: OBJC_PRINT_LOAD_METHODS: log calls to class and category +load methodsobjc[27076]: OBJC_PRINT_INITIALIZE_METHODS: log calls to class +initialize methodsobjc[27076]: OBJC_PRINT_RESOLVED_METHODS: log methods created by +resolveClassMethod: and +resolveInstanceMethod:objc[27076]: OBJC_PRINT_CLASS_SETUP: log progress of class and category setupobjc[27076]: OBJC_PRINT_PROTOCOL_SETUP: log progress of protocol setupobjc[27076]: OBJC_PRINT_IVAR_SETUP: log processing of non-fragile ivarsobjc[27076]: OBJC_PRINT_VTABLE_SETUP: log processing of class vtablesobjc[27076]: OBJC_PRINT_VTABLE_IMAGES: print vtable images showing overridden methodsobjc[27076]: OBJC_PRINT_CACHE_SETUP: log processing of method cachesobjc[27076]: OBJC_PRINT_FUTURE_CLASSES: log use of future classes for toll-free bridgingobjc[27076]: OBJC_PRINT_PREOPTIMIZATION: log preoptimization courtesy of dyld shared cacheobjc[27076]: OBJC_PRINT_CXX_CTORS: log calls to C++ ctors and dtors for instance variablesobjc[27076]: OBJC_PRINT_EXCEPTIONS: log exception handlingobjc[27076]: OBJC_PRINT_EXCEPTION_THROW: log backtrace of every objc_exception_throw()objc[27076]: OBJC_PRINT_ALT_HANDLERS: log processing of exception alt handlersobjc[27076]: OBJC_PRINT_REPLACED_METHODS: log methods replaced by category implementationsobjc[27076]: OBJC_PRINT_DEPRECATION_WARNINGS: warn about calls to deprecated runtime functionsobjc[27076]: OBJC_PRINT_POOL_HIGHWATER: log high-water marks for autorelease poolsobjc[27076]: OBJC_PRINT_CUSTOM_RR: log classes with un-optimized custom retain/release methodsobjc[27076]: OBJC_PRINT_CUSTOM_AWZ: log classes with un-optimized custom allocWithZone methodsobjc[27076]: OBJC_PRINT_RAW_ISA: log classes that require raw pointer isa fieldsobjc[27076]: OBJC_DEBUG_UNLOAD: warn about poorly-behaving bundles when unloadedobjc[27076]: OBJC_DEBUG_FRAGILE_SUPERCLASSES: warn about subclasses that may have been broken by subsequent changes to superclassesobjc[27076]: OBJC_DEBUG_NIL_SYNC: warn about @synchronized(nil), which does no synchronizationobjc[27076]: OBJC_DEBUG_NONFRAGILE_IVARS: capriciously rearrange non-fragile ivarsobjc[27076]: OBJC_DEBUG_ALT_HANDLERS: record more info about bad alt handler useobjc[27076]: OBJC_DEBUG_MISSING_POOLS: warn about autorelease with no pool in place, which may be a leakobjc[27076]: OBJC_DEBUG_POOL_ALLOCATION: halt when autorelease pools are popped out of order, and allow heap debuggers to track autorelease poolsobjc[27076]: OBJC_DEBUG_DUPLICATE_CLASSES: halt when multiple classes with the same name are presentobjc[27076]: OBJC_DEBUG_DONT_CRASH: halt the process by exiting instead of crashingobjc[27076]: OBJC_DISABLE_VTABLES: disable vtable dispatchobjc[27076]: OBJC_DISABLE_PREOPTIMIZATION: disable preoptimization courtesy of dyld shared cacheobjc[27076]: OBJC_DISABLE_TAGGED_POINTERS: disable tagged pointer optimization of NSNumber et al.objc[27076]: OBJC_DISABLE_TAG_OBFUSCATION: disable obfuscation of tagged pointersobjc[27076]: OBJC_DISABLE_NONPOINTER_ISA: disable non-pointer isa fieldsobjc[27076]: OBJC_DISABLE_INITIALIZE_FORK_SAFETY: disable safety checks for +initialize after fork 1.2 tls_init() 对线程的Key 的绑定。 这部分不展开讨论 void tls_init(void)&#123;#if SUPPORT_DIRECT_THREAD_KEYS _objc_pthread_key = TLS_DIRECT_KEY; pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);#else _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);#endif&#125; 1.3 static_init 实现系统级别的 C++ 静态构造函数。 相关源码： static void static_init()&#123; size_t count; auto inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count); for (size_t i = 0; i &lt; count; i++) &#123; inits[i](); &#125;&#125; 1.4 lock_init 锁的初始化，这里并没有进行实现，意味着可以进行重写，自定义一些操作。 相关源码： /************************************************************************ Lock management**********************************************************************/mutex_t runtimeLock;mutex_t selLock;mutex_t cacheUpdateLock;recursive_mutex_t loadMethodLock;void lock_init(void)&#123;&#125; 1.5 exception_init 异常的初始化：libobjc 的异常回调系统初始化，由map_images 调用。 即注册监听回调。 /************************************************************************ exception_init* Initialize libobjc&#x27;s exception handling system.* Called by map_images().**********************************************************************/void exception_init(void)&#123; old_terminate = std::set_terminate(&amp;_objc_terminate);&#125; 这个c++ 函数 set_terminate 会初始化静态的 异常回调。在OC 环境下，所有的异常抛出，都会到(*old_terminate)(); 这行代码里。 相关源码如下： static void (*old_terminate)(void) = nil;static void _objc_terminate(void)&#123; if (PrintExceptions) &#123; _objc_inform(&quot;EXCEPTIONS: terminating&quot;); &#125; if (! __cxa_current_exception_type()) &#123; // No current exception. (*old_terminate)(); &#125; else &#123; // There is a current exception. Check if it&#x27;s an objc exception. @try &#123; __cxa_rethrow(); &#125; @catch (id e) &#123; // It&#x27;s an objc object. Call Foundation&#x27;s handler, if any. (*uncaught_handler)((id)e); (*old_terminate)(); &#125; @catch (...) &#123; // It&#x27;s not an objc object. Continue to C++ terminate. (*old_terminate)(); &#125; &#125;&#125; 在业务代码里执行一个报错的方法： 类声明与实现 @interface Dog : NSObject- (void)bark;@end@implementation Dog @end 使用类执行为实现的方法 Dog *d = [Dog alloc];[d bark]; 异常抛出如下图所示： 1.6 _dyld_objc_notify_register（核心） objc 特有方法 注册回调。当镜像文件被映射(mapped)、未被映射(unmapped)、初始化(initialized) 使调用。 该方法由dyld 声明。 镜像文件加载完后，dyld 会回调”映射”函数，内容为一个包含objc-image-info 数据段的数组。 注册方法源码如下： _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image); 这里主要关注 map_images 的这个对象，其实现代码为： voidmap_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[])&#123; mutex_locker_t lock(runtimeLock); return map_images_nolock(count, paths, mhdrs);&#125; 读取镜像文件 继续探索 map_images_nolock 这个函数，读取镜像文件的关键行为 if (hCount &gt; 0) &#123; _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);&#125; 至此，这一部分到此就结束了，关于images 的流程，另外单独分析。 2、read_images - 读镜像文件2.1 初次进来: 创建容器哈希表根据源码，得知读取镜像的主要函数为read_image ，其函数具体为： void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)&#123;&#125; 读取镜像后，最先需要做的是，为这些景象里的内容找一个家——容器，也就是开辟表结构。 在源码里，这里分别通过NXCreateMapTable、NXCreateHashTable开辟了2个表，主要存储以下的内容： 未共享缓存的类 gdb_objc_realized_classes gdb_objc_realized_classes = NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize); 开辟内存空间类 - allocatedClasses allocatedClasses = NXCreateHashTable(NXPtrPrototype, 0, nil); 2.2 类的处理 从编译后的类列表中，取出所有的类，并进行下一步操作。 for (EACH_HEADER) &#123; classref_t *classlist = _getObjc2ClassList(hi, &amp;count);&#125; 取出系统类 Class cls = (Class)classlist[i]； 读取类 Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized); 懒加载相关，条件为 newCls != cls &amp;&amp; newCls， 即两个类不相等时 初始化懒加载所需内存空间 resolvedFutureClasses = (Class *) realloc(resolvedFutureClasses, (resolvedFutureClassCount+1) * sizeof(Class)); 懒加载的类添加到数组中来 resolvedFutureClasses[resolvedFutureClassCount++] = newCls; 2.3 方法编号处理 把未注册的方法名进行注册到一张HASH表里，形成方法名与方法的映射 static size_t UnfixedSelectors; &#123; mutex_locker_t lock(selLock); for (EACH_HEADER) &#123; if (hi-&gt;isPreoptimized()) continue; bool isBundle = hi-&gt;isBundle(); SEL *sels = _getObjc2SelectorRefs(hi, &amp;count); UnfixedSelectors += count; for (i = 0; i &lt; count; i++) &#123; const char *name = sel_cname(sels[i]); // 注册SEL的操作 sels[i] = sel_registerNameNoLock(name, isBundle); &#125; &#125; &#125; 注册到的表名为namedSelectors， 具体的实现在这里 NXMapInsert(namedSelectors, sel_getName(result), result); 2.4 协议处理 找到类遵守的协议，修复协议的引用。 关键字: readProtocol 、remapProtocolRef 相关源码，如下所示: 找到协议： for (EACH_HEADER) &#123; extern objc_class OBJC_CLASS_$_Protocol; Class cls = (Class)&amp;OBJC_CLASS_$_Protocol; NXMapTable *protocol_map = protocols(); protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count); for (i = 0; i &lt; count; i++) &#123; readProtocol(protolist[i], cls, protocol_map, isPreoptimized, isBundle); &#125; &#125; 修复协议引用（重映射）： for (EACH_HEADER) &#123; protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count); for (i = 0; i &lt; count; i++) &#123; remapProtocolRef(&amp;protolist[i]); &#125;&#125; 2.5 非懒加载处理 初始化所有非懒加载类，进行 rw ro 操作 for (EACH_HEADER) &#123; classref_t *classlist = _getObjc2NonlazyClassList(hi, &amp;count); addClassTableEntry(cls); realizeClassWithoutSwift(cls);&#125; 2.6 待处理的类 找到最新特征的类，以备CoreFoundation 需要操作它 if (resolvedFutureClasses) &#123; for (i = 0; i &lt; resolvedFutureClassCount; i++) &#123; Class cls = resolvedFutureClasses[i]; if (cls-&gt;isSwiftStable()) &#123; _objc_fatal(&quot;Swift class is not allowed to be future&quot;); &#125; realizeClassWithoutSwift(cls); cls-&gt;setInstancesRequireRawIsa(false/*inherited*/); &#125; free(resolvedFutureClasses);&#125; 2.7 分类处理 对非类进行处理，包括Class 的和metaClass 的 for (EACH_HEADER) &#123; category_t **catlist = _getObjc2CategoryList(hi, &amp;count); bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties(); for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); &#125;&#125; 3、类方法重点3.1 类的读取readClasses3.1.1 判断是否是未来处理的类 （popFutureNamedClass）如果是，就读取data，设置rw 和 ro if (Class newCls = popFutureNamedClass(mangledName)) &#123; // This name was previously allocated as a future class. // Copy objc_class to future class&#x27;s struct. // Preserve future&#x27;s rw data block. if (newCls-&gt;isAnySwift()) &#123; _objc_fatal(&quot;Can&#x27;t complete future class request for &#x27;%s&#x27; &quot; &quot;because the real class is too big.&quot;, cls-&gt;nameForLogging()); &#125; // 在这里，读取data(), 并进行设置 rw /ro class_rw_t *rw = newCls-&gt;data(); const class_ro_t *old_ro = rw-&gt;ro; memcpy(newCls, cls, sizeof(objc_class)); rw-&gt;ro = (class_ro_t *)newCls-&gt;data(); newCls-&gt;setData(rw); freeIfMutable((char *)old_ro-&gt;name); free((void *)old_ro); addRemappedClass(cls, newCls); replacing = cls; cls = newCls; &#125; 3.1.2 添加命名过的类addNamedClass(cls, mangledName, replacing); 3.1.3 把类插入到包含所有类的表里addClassTableEntry(cls); 具体的实现为如下： static void addClassTableEntry(Class cls, bool addMeta = true) &#123; runtimeLock.assertLocked(); // This class is allowed to be a known class via the shared cache or via // data segments, but it is not allowed to be in the dynamic table already. assert(!NXHashMember(allocatedClasses, cls)); if (!isKnownClass(cls)) NXHashInsert(allocatedClasses, cls); if (addMeta) addClassTableEntry(cls-&gt;ISA(), false);&#125; 3.2 realizeClassWithoutSwift 实现类的初次初始化，包括开辟rw数据的内存空间。 3.2.1 取出类里的 ro 部分（data）ro = (const class_ro_t *)cls-&gt;data(); 3.2.2 开辟rw 内存空间// Normal class. Allocate writeable class data.rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);rw-&gt;ro = ro;rw-&gt;flags = RW_REALIZED|RW_REALIZING;cls-&gt;setData(rw); 最终通过cls-&gt;setData(rw) , 将rw 作为data赋值给类 cls。 但是到这里，cls 仅仅是对数据部分做了初始化，里面的方法都没有写入。 如何验证？ 通过lldb 来进行验证吧： 通过p&#x2F;x 获取cls指针 偏移16位获得bits 的指针 将bits 强转为class_data_bits_t 的类型$2 读取$2点data() 方法。 过程可见下图，methods 属性下的list 为空，并没有方法列表的写入。 可见该过程，仅仅对cls 下rw 的属性的ro 、flags进行了赋值，而rw 并没有得到赋值 3.2.3 实现父类和元类关联3.2.3.1 子类链接父类上面的流程都是在初始化类的各种属性后，而类的结构最重要的一点是它与父类的关联，以及与元类的isa 指向。 所以下面的操作是 通过remapClass(cls-&gt;superclass)对父类进行映射查找 通过remapClass(cls-&gt;ISA)对元类进行查找 然后通过realizeClassWithoutSwift 进行递归，逐步得到相应的supercls以及metacls 的指针。 步骤依然是：类——元类——根元类——NSObject——nil（跳出） supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass));metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA())); 这两个失踪人口进行搜寻成功后，就可以将其指针对类进行关联 // Update superclass and metaclass in case of remappingcls-&gt;superclass = supercls;cls-&gt;initClassIsa(metacls); 3.2.3.2 父类链接子类如果找到父类，在父类添加双向链表的引用，将子类引用添加到父类的子类列表里，最终实现父类和子类建立关联 // Connect this class to its superclass&#x27;s subclass listsif (supercls) &#123; addSubclass(supercls, cls);&#125; else &#123; addRootClass(cls);&#125; 结论是：子类里添加父类链接，父类里也添加子类链接，你中有我，我中有你。 接下来看一下父类链接的具体实现： static void addSubclass(Class supercls, Class subcls)&#123; runtimeLock.assertLocked(); if (supercls &amp;&amp; subcls) &#123; assert(supercls-&gt;isRealized()); assert(subcls-&gt;isRealized()); subcls-&gt;data()-&gt;nextSiblingClass = supercls-&gt;data()-&gt;firstSubclass; supercls-&gt;data()-&gt;firstSubclass = subcls; if (supercls-&gt;hasCxxCtor()) &#123; subcls-&gt;setHasCxxCtor(); &#125; if (supercls-&gt;hasCxxDtor()) &#123; subcls-&gt;setHasCxxDtor(); &#125; if (supercls-&gt;hasCustomRR()) &#123; subcls-&gt;setHasCustomRR(true); &#125; if (supercls-&gt;hasCustomAWZ()) &#123; subcls-&gt;setHasCustomAWZ(true); &#125; // Special case: instancesRequireRawIsa does not propagate // from root class to root metaclass if (supercls-&gt;instancesRequireRawIsa() &amp;&amp; supercls-&gt;superclass) &#123; subcls-&gt;setInstancesRequireRawIsa(true); &#125; &#125;&#125; 实现为： 父类的第一个子类，赋值给子类的下一个兄弟类： subcls-&gt;data()-&gt;nextSiblingClass = supercls-&gt;data()-&gt;firstSubclass; 子类赋值给父类的第一个子类： supercls-&gt;data()-&gt;firstSubclass = subcls; 同时，子类继承父类的各种能力 hasCxxCtor hasCxxDtor hasCustomRR hasCustomAWZ instancesRequireRawIsa（适用NONPOINTER_ISA） 3.2.4 methodizeClass - rw 内容的填充 对之前创建的rw 进行方法、属性，协议的填充实现 对分类的实现 方法的填充实现 method_list_t *list = ro-&gt;baseMethods();if (list) &#123; prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); rw-&gt;methods.attachLists(&amp;list, 1);&#125; 属性填充实现 property_list_t *proplist = ro-&gt;baseProperties;if (proplist) &#123; rw-&gt;properties.attachLists(&amp;proplist, 1);&#125; 协议填充实现 protocol_list_t *protolist = ro-&gt;baseProtocols;if (protolist) &#123; rw-&gt;protocols.attachLists(&amp;protolist, 1);&#125; 根元类额外的实现 if (cls-&gt;isRootMetaclass()) &#123; // root metaclass addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO); &#125; 添加分类 // Attach categories.category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);attachCategories(cls, cats, false /*don&#x27;t flush caches*/); 提一下上面的方法实现中添加的机制，究竟是如何的？继续看源码，可以看到添加情况有3种 多对多 - 方法原已有多个，在需要添加多个 if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0]));&#125; 这里经历了3个步骤： 获取原方法数： array()-&gt;count 获取原方法数+新方法的总方法数： oldCount + addedCount 内存扩容：realloc 字节移动：内存中原方法平移：memmove 字节移动：新方法拷贝进入：memcpy 0 对多 - 方法原没有，在需要添加多个 list = addedLists[0]; 1 对多 // 1 list -&gt; many listsList* oldList = list;uint32_t oldCount = oldList ? 1 : 0;uint32_t newCount = oldCount + addedCount;setArray((array_t *)malloc(array_t::byteSize(newCount)));array()-&gt;count = newCount;if (oldList) array()-&gt;lists[addedCount] = oldList;memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); 另外，可以观察到无论是方法methods、属性properties、协议protocols，在添加时，使用的同样的方法attachLists， 这是因为作为同为class_rw_t类型下的属性，他们拥有同样的数据结构：二维数组。 其中方法列表和属性列表的根类型，均为entsize_list_tt 方法列表结构： class method_array_t : public list_array_tt&lt;method_t, method_list_t&gt; 属性列表结构： class property_array_t : public list_array_tt&lt;property_t, property_list_t&gt; 协议列表结构： class protocol_array_t : public list_array_tt&lt;protocol_ref_t, protocol_list_t&gt; 方法列表设计成二维数组，方便分类方法的批量插入： 4、小结 类的加载，流程分为环境的启动配置、加载镜像、读取类方法、对类内存空间初始化、子类-父类建立连接，以及最终rw填充方法，并对分类方法加入进行实现。","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"Class","slug":"Class","permalink":"http://nilsli.com/tags/Class/"}]},{"title":"【底层探索】dyld浅析","slug":"dyld-analyze","date":"2020-03-23T04:30:29.000Z","updated":"2024-08-07T07:10:46.619Z","comments":true,"path":"p/62973.html","permalink":"http://nilsli.com/p/62973.html","excerpt":"","text":"本页所使用的objc runtime 756.2，来自GITHUB 一、引言前文研究了对象、方法的基础，知道了对象&#x2F;类的结构，类方法的生成和传递原理。下面该进入到核心环节，就是类的加载了，在这一个模块，需要了解的有下面几点： OC 的库 app 的加载流程 image 的结构 回调函数 image 的加载流程 二、库2.1、静态库 是一个外部函数与变量的集合体 iOS 在编译时执行静态库，链接到相应代码 静态库的文件内容，通常包含一堆程序员自定的变量与函数，其内容不像动态链接库那么复杂，在编译期间由编译器与链接器将它集成至应用程序内，并制作成目标文件以及可以独立运作的可执行文件。 常见的iOS 环境下的静态库由 .a 文件，.framework 文件。java 环境下有.so 静态库 2.2、动态库 iOS 在运行时执行动态库，链接到相应的代码里。 .dylib 库文件 三、App 启动流程1. dyld startlibdyld.dylib`start 2. 加载镜像reloadAllImages: 3. 加载链接loadInsertedDylib 插入（insert）： 插入网线 链接（link）： 接通网络 四、dyld4.1 start4.2 递归初始化4.3 objc_init五、镜像 - images dyld Objc_init 六、回调函数 指针 注册 *snotif","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"dyld","slug":"dyld","permalink":"http://nilsli.com/tags/dyld/"}]},{"title":"方法的本质4_消息转发机制","slug":"messageSend","date":"2020-03-13T10:16:42.000Z","updated":"2024-08-07T07:10:46.686Z","comments":true,"path":"p/59010.html","permalink":"http://nilsli.com/p/59010.html","excerpt":"","text":"本页所使用的objc runtime 756.2，来自GITHUB 1、回顾上文消息方法的本质3_消息查找流程 一文总结了方法查找的流程，得到结论如下: 类的缓存里查找——找到——结束查找 类的方法列表里查找——找到——结束查找 递归父类缓存、方法列表查找——找到——结束查找 动态方法解析——（未分析） 以上未解决——异常崩溃——结束 下面继续学习源码，结合业务代码，深挖第四步 动态方法决议，来更深一步的学习消息转发机制。 2、问题这篇文章，希望弄清楚下面的问题 消息转发是什么 消息转发的场景 如何进行消息转发 3、动态方法决议3.1 入口 - class_resolveMethod之前的分析，知道了当查找缓存未命中后，会执行objc_msgSend_uncached 的方法，进行方法查找。 具体执行的是方法 _class_lookupMethodAndLoadCache3 。 runtime 源码如下： /************************************************************************ _class_lookupMethodAndLoadCache.* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().* This lookup avoids optimistic cache scan because the dispatcher * already tried that.**********************************************************************/IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123; return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/);&#125; 在源码中，知道了具体执行的方法是 lookUpImpOrForward，这个方法执行了众多流程，缓存、递归查找等。 如果都未命中，则会找到方法决议实现，代码如下： // No implementation found. Try method resolver once.if (resolver &amp;&amp; !triedResolver) &#123; runtimeLock.unlock(); _class_resolveMethod(cls, sel, inst); runtimeLock.lock(); // Don&#x27;t cache the result; we don&#x27;t hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry;&#125; 注意到执行 _class_resolveMethod(cls, sel, inst) 前后，使用了runtimeLock 进行了锁定与解锁，具体实现时互斥锁（参见Cooci老师的互斥锁-读写锁-条件锁），来保证内存安全。 查看一下class_resolveMethod 方法 Summary _class_resolveMethod Call +resolveClassMethod or +resolveInstanceMethod. Returns nothing; any result would be potentially out-of-date already. Does not check if the method already exists. class_resolveMethod 调用 +resolveClassMethod 或 +resolveInstanceMethod。 返回值为空；任何结果将可能已经过期。 如果方法已经存在，不会检查&#x2F;执行。 由此可见resolveMethod 只是一个入口，会具体调用如下方法： 类方法：+resolveInstanceMethod 实例方法：+resolveInstanceMethod 具体的源码，见下面的： void _class_resolveMethod(Class cls, SEL sel, id inst)&#123; if (! cls-&gt;isMetaClass()) &#123; // try [cls resolveInstanceMethod:sel] _class_resolveInstanceMethod(cls, sel, inst); &#125; else &#123; // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] _class_resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; _class_resolveInstanceMethod(cls, sel, inst); &#125; &#125;&#125; 代码 分析 备注 ! cls-&gt;isMetaClass() 是否元类 否，说明主体是实例 _class_resolveInstanceMethod 实例方法决议实现 _class_resolveClassMethod 类方法决议实现 _class_resolveInstanceMethod [第2个] 查看NSObject 决议实现 发生在lookUpImpOrNil 失败后 分析: 进入决议后，先确定是否是元类； 如果是元类，由于已知类方法存储在元类里，知道该方法主体是类，则会进入类方法决议 如果不是元类，即方法主题是实例，进入实例方法决议。 如果元类方法决议查找失败，根元类亦查找失败，由于根元类的isa 是指向自身的，所以用到了 _class_resolveInstanceMethod 的实例决议方法。 具体逻辑见下图： 3.2 类方法决议 - _class_resolveClassMethod捋清楚入口后，继续看类方法的决议，源码如下： /************************************************************************ _class_resolveClassMethod* Call +resolveClassMethod, looking for a method to be added to class cls.* cls should be a metaclass.* Does not check if the method already exists.**********************************************************************/static void _class_resolveClassMethod(Class cls, SEL sel, id inst)&#123; assert(cls-&gt;isMetaClass()); if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; // Resolver not implemented. return; &#125; BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(_class_getNonMetaClass(cls, inst), SEL_resolveClassMethod, sel); // Cache the result (good or bad) so the resolver doesn&#x27;t fire next time. // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); if (resolved &amp;&amp; PrintResolving) &#123; if (imp) &#123; _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot; &quot;dynamically resolved to %p&quot;, cls-&gt;isMetaClass() ? &#x27;+&#x27; : &#x27;-&#x27;, cls-&gt;nameForLogging(), sel_getName(sel), imp); &#125; else &#123; // Method resolver didn&#x27;t add anything? _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot; &quot;, but no new implementation of %c[%s %s] was found&quot;, cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? &#x27;+&#x27; : &#x27;-&#x27;, cls-&gt;nameForLogging(), sel_getName(sel)); &#125; &#125;&#125; 分析上文的源码，除了一些断言、异常的保护代码外，关键语句来到了这一句 BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;bool resolved = msg(_class_getNonMetaClass(cls, inst), SEL_resolveClassMethod, sel); 这里的函数msg 调用了3个参数 _class_getNonMetaClass(cls, inst) ：即类的本身 SEL_resolveClassMethod ： 决议的类方法 sel ：需要查找的方法编号 所以，关键的行为就是SEL_resolveClassMethod 方法，通过搜索，源码代码中均找不到。 回头看苹果给该方法写的注释： _class_resolveClassMethod Call +resolveClassMethod, looking for a method to be added to class cls. 意思是C 源码里写的方法，在OC 实现里，会执行+resolveClassMethod 的方法，即通过resolveClassMethod 来对该类进行决议——添加相应的类方法。 在OC里的实现即这个方法 + (BOOL)resolveClassMethod:(SEL)sel&#123; return NO;&#125; 至此，已经大概明白了决议的意义——当方法找不到实现时，转发到类&#x2F;实例决议方法里，看看开发者是否有自行实现。其最大的意义，恐怕是收集各种崩溃了。 3.3 实例方法决议 - class_resolveInstanceMethod实例方法决议的源码实现，与类方法决议类似，差别仅仅在决议执行方法，换成了SEL_resolveInstanceMethod，源码如下： BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;bool resolved = msg(cls, SEL_resolveInstanceMethod, sel); 当决议方法得到实现后，会提示，方法XX 已经被决议成为新的实现YY—— 否则会提示决议未找到: if (resolved &amp;&amp; PrintResolving) &#123; if (imp) &#123; _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot; &quot;dynamically resolved to %p&quot;, cls-&gt;isMetaClass() ? &#x27;+&#x27; : &#x27;-&#x27;, cls-&gt;nameForLogging(), sel_getName(sel), imp); &#125; else &#123; // Method resolver didn&#x27;t add anything? _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot; &quot;, but no new implementation of %c[%s %s] was found&quot;, cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? &#x27;+&#x27; : &#x27;-&#x27;, cls-&gt;nameForLogging(), sel_getName(sel)); &#125;&#125; 4、快速转发阶段4.1 快速转发方法forwardingTargetForSelector ：即将本类未实现的方法，交由指定的其他类来实现。 4.2 业务代码实现如下： 类Person, 与未实现的方法teach： @interface Person : NSObject- (void)teach; @end 类的转发方法——指定Teacher 这个类来执行 - (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(teach)) &#123; return [Teacher alloc]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 类Teacher 以及实现的方法teach NS_ASSUME_NONNULL_BEGIN@interface Teacher : NSObject- (void)teach;@endNS_ASSUME_NONNULL_END@implementation Teacher- (void)teach&#123; NSLog(@&quot;%s&quot;, __func__);&#125;@end 主业务执行，使类执行它为实现的方法teach: int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *person = [[Person alloc] init]; [person teach]; &#125; return 0;&#125; 执行结果，teacher类实现了teach： 2020-03-20 16:12:51.477020+0800 debug-objc[8565:349779] -[Teacher teach] 由此可见，forwardingTargetForSelector 的作用，是自身无法处理，交由其他对象（可能是类）来处理。 5、慢速转发阶段5.1 慢速转发方法methodSignatureForSelector，看看开发文档的描述： methodSignatureForSelector:Returns an NSMethodSignature object that contains a description of the method identified by a given selector. 返回一个NSMethodSignature 的签名对象，包含一个给定选择器的方法的描述 获取方法签名： methodSignatureForSelector 通过获取的签名，转发信息 –执行方法是 forwardInvocation往指定的对象传递方法和参数 5.2 业务代码实现:基础代码与快速转发一致，只是删除了forwardingTargetForSelector 的实现代码。 并在Person 类里实现如下代码 实现方法签名 // 获得方法签名- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSString *sel = NSStringFromSelector(aSelector); //生成签名 if ([sel isEqualToString:@&quot;run&quot;]) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; &#125;else &#123; return [super methodSignatureForSelector:aSelector]; &#125; &#125; “v” 是方法描述，更多的在这里： * 代表 char * char BOOL 代表 c : 代表 SEL ^type 代表 type * @ 代表 NSObject * 或 id ^@ 代表 NSError ** # 代表 NSObject v 代表 void 获取签名，进行配发信息 - (void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSLog(@&quot;-----%@-----&quot;,anInvocation); //取得消息 SEL selector = [anInvocation selector]; //转发 SomePerson *someP = [SomePerson new]; if ([someP respondsToSelector:selector]) &#123; //调用对象，进行转发 [anInvocation invokeWithTarget:someP]; &#125; else &#123; return [super forwardInvocation:anInvocation]; &#125;&#125; 执行teach 结果 2020-03-20 16:37:41.639718+0800 debug-objc[9325:370827] -[Teacher teach] 6、查找失败消息没有得到处理 崩溃退出，这里从forwardInvocation 的实现，可以追踪到相关的代码： - (void)forwardInvocation:(NSInvocation *)invocation &#123; [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];&#125; // Replaced by CF (throws an NSException)- (void)doesNotRecognizeSelector:(SEL)sel &#123; _objc_fatal(&quot;-[%s %s]: unrecognized selector sent to instance %p&quot;, object_getClassName(self), sel_getName(sel), self);&#125; 7、 总结又到了最受欢迎的总结时间。 答案： 消息转发是什么：向指定的对象或类，发送需要消息，请求交由对方执行 消息转发的场景：自我无法实现的场景下。 如何进行消息转发 快速转发：使用 forwardingTargetForSelector 进行定向转发 慢速转发：获取签名，使用forwardInvocation 转发 有图另外，总结经验再多，不如有图有真相…… 下面是objc_msgSend 查找总流程:","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/%E7%BB%93%E6%9E%84/"},{"name":"消息转发","slug":"消息转发","permalink":"http://nilsli.com/tags/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"},{"name":"objc","slug":"objc","permalink":"http://nilsli.com/tags/objc/"}]},{"title":"【休闲】西湖一瞥","slug":"glance-at-WestLake","date":"2020-03-09T12:11:20.000Z","updated":"2024-08-07T07:10:46.619Z","comments":true,"path":"p/37569.html","permalink":"http://nilsli.com/p/37569.html","excerpt":"","text":"逛次逛次的西湖今天过来平海路的Apple 直营店给电脑做大保健，顺便看了一眼西湖。 湖边景色依旧宜人，可惜游人寥寥。 期待一切顺利，然后恢复到游人如织的景色。","categories":[],"tags":[{"name":"休闲","slug":"休闲","permalink":"http://nilsli.com/tags/%E4%BC%91%E9%97%B2/"},{"name":"杭州","slug":"杭州","permalink":"http://nilsli.com/tags/%E6%9D%AD%E5%B7%9E/"},{"name":"西湖","slug":"西湖","permalink":"http://nilsli.com/tags/%E8%A5%BF%E6%B9%96/"},{"name":"Apple","slug":"Apple","permalink":"http://nilsli.com/tags/Apple/"}]},{"title":"方法的本质3_消息查找流程","slug":"wayOfCheckingMethod","date":"2020-03-06T08:33:26.000Z","updated":"2024-08-07T07:10:46.752Z","comments":true,"path":"p/64205.html","permalink":"http://nilsli.com/p/64205.html","excerpt":"","text":"本页所使用的objc runtime 756.2，来自GITHUB 1. 概念在前文中，已经总结了方法查找的流程，今天从代码层面上继续阐述。 isa 的指向图如下所示： 2. 方法查找流程2.1 从业务代码分析配置代码环境：，先从子类父类方法查找说起，先创建几个类，有: 父类 Person 继承自NSObject，有方法talk 子类 Student 继承自 Person，有方法 sayEnglish 扩展 NSObject + sayGerman，有方法 sayGerman 具体代码如下所示 主业务代码图： 由上图可以看出，我们生成的子类Student 对象，既可以执行自己的对象方法sayEnglish，也可以执行父类方法talk，当需要执行的方法——子类和父类都没有之后，也可以执行根类扩展方法sayGerman。 查找逻辑图可以初步理解为：子类——&gt; 父类——&gt; 父类的父类 ——&gt;根元类(NSObject) 类方法也是类似的，就不赘述 2.2 源码分析2.2.1 class_lookupMethodAndLoadCache3 - 慢速查找开启/************************************************************************ _class_lookupMethodAndLoadCache.* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().* This lookup avoids optimistic cache scan because the dispatcher * already tried that.**********************************************************************/IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123; return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/);&#125; 原来上文留下的class_lookupMethodAndLoadCache3 方法，最终执行的方法是lookUpImpOrForward，继续探究一下！ lookUpImpOrForward - 查找Imp 或转发消息乐观检查是否有缓存// Optimistic cache lookupif (cache) &#123; imp = cache_getImp(cls, sel); if (imp) return imp;&#125; 查找类是否缓存过// runtimeLock is held during isRealized and isInitialized checking// to prevent races against concurrent realization.// runtimeLock is held during method search to make// method-lookup + cache-fill atomic with respect to method addition.// Otherwise, a category could be added but ignored indefinitely because// the cache was re-filled with the old value after the cache flush on// behalf of the category.runtimeLock.lock();checkIsKnownClass(cls); 这里通过runtimeLock 锁住该部分内存，进行查找，执行了isKnownClass的方法，具体实现在这里 /************************************************************************ isKnownClass* Return true if the class is known to the runtime (located within the* shared cache, within the data segment of a loaded image, or has been* allocated with obj_allocateClassPair).**********************************************************************/static bool isKnownClass(Class cls) &#123; // The order of conditionals here is important for speed. We want to // put the most common cases first, but also the fastest cases // first. Checking the shared region is both fast and common. // Checking allocatedClasses is fast, but may not be common, // depending on what the program is doing. Checking if data segments // contain the address is slow, so do it last. return (sharedRegionContains(cls) || NXHashMember(allocatedClasses, cls) || dataSegmentsContain(cls));&#125; 在类的缓存（cache_t）找// Try this class&#x27;s cache. imp = cache_getImp(cls, sel); if (imp) goto done; 在类的方法列表里寻找// Try this class&#x27;s method lists.&#123; Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp = meth-&gt;imp; goto done; &#125;&#125; 在父类的缓存和方法列表寻找// Try superclass caches and method lists.&#123; unsigned attempts = unreasonableClassCount(); for (Class curClass = cls-&gt;superclass; curClass != nil; curClass = curClass-&gt;superclass) &#123; // Halt if there is a cycle in the superclass chain. if (--attempts == 0) &#123; _objc_fatal(&quot;Memory corruption in class list.&quot;); &#125; 父类缓存（Cache）找 // Superclass cache. imp = cache_getImp(curClass, sel); if (imp) &#123; if (imp != (IMP)_objc_msgForward_impcache) &#123; // Found the method in a superclass. Cache it in this class. log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; &#125; else &#123; // Found a forward:: entry in a superclass. // Stop searching, but don&#x27;t cache yet; call method // resolver for this class first. break; &#125; &#125; 父类方法列表找 // Superclass method list.Method meth = getMethodNoSuper_nolock(curClass, sel);if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done;&#125; 有可能内存覆盖，再给一次查找这里的核心方法是 // No implementation found. Try method resolver once.if (resolver &amp;&amp; !triedResolver) &#123; runtimeLock.unlock(); resolveMethod(cls, sel, inst); runtimeLock.lock(); // Don&#x27;t cache the result; we don&#x27;t hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry;&#125; 父类也没有——查找失败——报错// No implementation found, and method resolver didn&#x27;t help. // Use forwarding.imp = (IMP)_objc_msgForward_impcache; 但是这个_objc_msgForward_impcache 的实现可不好找，在源码里只看到了这些： #if !OBJC_OLD_DISPATCH_PROTOTYPESextern void _objc_msgForward_impcache(void); 最终通过搜索查找**_objc_msgForward_impcache**，在汇编源码找到了类似的代码得到这个叫做__objc_forward_handler 的代码块，搜索得知它继承自objc_defaultForwardHandler， 继续查找，得到最终的源码如下： OH MY GOD! 原来这就是传说中——让程序员捶胸顿足的方法查找失败的代码 至此，方法查找的流程已经捋完。 3. 小结方法查找的流程，就是在类里查找缓存与方法列表里挖掘的过程。 如上文阐述： 方法查找：缓存查找 —— 类的方法列表 —— 父类的方法列表 （递归）—— 动态方法解析 —— 结束","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/%E7%B1%BB/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/%E7%BB%93%E6%9E%84/"},{"name":"objc","slug":"objc","permalink":"http://nilsli.com/tags/objc/"}]},{"title":"方法的本质2_从objc_msgSend谈起","slug":"startToLearnObjcSend","date":"2020-02-24T02:47:05.000Z","updated":"2024-08-07T07:10:46.720Z","comments":true,"path":"p/23281.html","permalink":"http://nilsli.com/p/23281.html","excerpt":"","text":"方法的本质，就是消息传递… 本页所使用的objc runtime 756.2，来自GITHUB 一、引子：Runtime概念我们都知道，在运行OC代码时，类或者对象在调用方法时会用到runtime，那么，到底什么是运行时呢？ 寻找一些资料后可以给出概念： In computer science, runtime, run time or execution time is the time when the CPU is executing the machine code.在计算机科学里，runtime，run time 或execution time 是指CPU 执行机器语言的期间。—— 维基百科 Runtime 是一套由C、C++、汇编混合写成的为OC提供运行时功能的api。 先看苹果开发者文档里对runtime 的介绍的介绍： The Objective-C runtime is a runtime library that provides support for the dynamic properties of the Objective-C language, and as such is linked to by all Objective-C apps. Objective-C runtime library support functions are implemented in the shared library found at /usr/lib/libobjc.A.dylib. OC runtime 是一个给OC语言动态属性提供支持的运行时库，这些属性链接到所有的OC应用 。OC runtime库支持在shared library里实现的函数，这些函数库名为/usr/lib/libobjc.A.dylib 版本 legacy：经典版 modern：现代版，即objc2.0，我们目前用到的版本。 二、方法的本质概念方法的本质，就是objc_msgSend 的消息传递。先看苹果开发者文档里对objc_msgSend的介绍： Function objc_msgSendSends a message with a simple return value to an instance of a class. 发送一个有简单返回值的消息给类的实例 相关源码如下: objc_msgSend(id _Nullable self, SEL _Nonnull op, ...) 其中两个关键参数self 和 op 的解释如下: * @param self A pointer to the instance of the class that is to receive the message. ​ self 一个指向由类生产的实例的指针，用来接收消息 * @param op The selector of the method that handles the message. ​ op 方法： 处理消息的方法的选择器 可见，objc_msgSend 的核心信息，就是向对象主体（self）传递相应的方法&#x2F;消息（op）。 但是消息传递的机制到底怎样，还是用源码来解释。 源码分析开始生成一个main.m 内代码如下 int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; LGPerson *person = [LGPerson alloc]; [person sayHello]; // Setup code that might create autoreleased objects goes here. &#125; return NSApplicationMain(argc, argv);&#125; 其中LGPerson 的内部实现如下： @interface LGPerson : NSObject- (void)sayHello;- (void)sayNB;@end 在这里，着重查看LGPerson alloc 方法，以及其实例 person sayHello&#96; 在汇编里的实现 : 进入到目录下，输入编译代码： clang -rewrite-objc main.m 得到main.cpp 的文件 打开main.cpp 结构如下: #pragma clang assume_nonnull endint main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; LGPerson *person = ((LGPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;LGPerson&quot;), sel_registerName(&quot;alloc&quot;)); ((void (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(&quot;sayHello&quot;)); &#125; return NSApplicationMain(argc, argv);&#125; 上文代码中，可以简化为, Runtime 语法 OC 语法 (LGPerson ()(id, SEL))(void *) – (id)objc_getClass(“LGPerson”) [LGPerson class] sel_registerName(“alloc”) @selector(alloc) 即代码为： LGPerson *person = ((LGPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;LGPerson&quot;), sel_registerName(&quot;alloc&quot;));// 转换后LGPerson *person = objc_msgSend([LGPerson class], @selector(alloc)); 解释为: 向LGPerson 的类，发送了alloc 方法 扩展代码实践开始设定一个类Student #import &quot;Student.h&quot;interface Student : Person- (void)sayCode;@end OC语法#import &quot;Student.h&quot;Student *student = [Student new];[student sayCode]; NSObject 写法objc_msgSend(student, NSSelectorFromString(@&quot;sayCode&quot;)); sel_registerName 的函数APIobjc_msgSend(student, sel_registerName(&quot;sayCode&quot;)); 三、底层分析汇编源码 我们现在分析，当类对象发送消息是，底层发生了什么。 1、方法入口新建工程，输入如下代码，进行断点检测； 另外在Xcode 的Debug–Debug Workflow—Always show Disassembly 很明显，这里的Student sayCode 在汇编里，执行了 objc_msgSend 方法，继续查看 打开Xcode, 搜索objc_msgSend，找到相关结果如下： 由于研究的环境是移动平台，选择arm64，通过ENTRY _objc_msgSend结果进入 首先看到的代码如下： ENTRY _objc_msgSend UNWIND _objc_msgSend, NoFrame1 cmp p0, #0 // nil check and tagged pointer check#if SUPPORT_TAGGED_POINTERS2 b.le LNilOrTagged // (MSB tagged pointer looks negative)#else3 b.eq LReturnZero#endif 2、类Tagged Pointer 检查代码解析： 序号 代码 解释 1 cmp p0 #0 cmp &#x3D; compare检测0位寄存器 &#x3D; 空？，以及tagged point 检测 2 b.le LNilOrTagged &#x2F;&#x2F; 即1代码成立，跳转至LNilOrTagged的宏（下文叙述） 3 b.eq LReturnZero &#x2F;&#x2F; b.eq 即不成立，结果为空，返回并跳出 这一小节，主要是用来判断 tagged pointer 是否存在，存在则继续进行，否则跳出。 Tagged point是苹果推出的针对64位机器的特定的指针，概念如下： 苹果对于Tagged Pointer特点的介绍： Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。 在内存读取上有着3倍的效率，创建时比以前快106倍。 3、加载isa这一部分主要是通过加载的isa，获取当前底层的类的实现 // person - isa - 类ldr p13, [x0] // p13 = isaGetClassFromIsa_p16 p13 // p16 = class 序号 代码 解释 1 ldr p13, [x0] 将13位存储器isa 字，加载到0位寄存器LDR &#x3D; LoaD woRd 2 GetClassFromIsa_p16 p13 通过加载的isa，宏逻辑获取到当前的类GetClassFromIsa_p16 是一个汇编宏 GetClassFromIsa_p16 的汇编实现如下: .macro GetClassFromIsa_p16 /* src */#if SUPPORT_INDEXED_ISA // Indexed isa mov p16, $0 // optimistically set dst = src tbz p16, #ISA_INDEX_IS_NPI_BIT, 1f // done if not non-pointer isa // isa in p16 is indexed adrp x10, _objc_indexed_classes@PAGE add x10, x10, _objc_indexed_classes@PAGEOFF ubfx p16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS // extract index ldr p16, [x10, p16, UXTP #PTRSHIFT] // load class from array1:#elif __LP64__ // 64-bit packed isa and p16, $0, #ISA_MASK#else // 32-bit raw isa mov p16, $0#endif.endmacro 分析流程图如下： 4、用isa查询方法缓存当在3步，isa 拿到之后，现在要做的事情，就是对当前要执行的方法进行缓存查找。 LGetIsaDone: CacheLookup NORMAL // calls imp or objc_msgSend_uncached CacheLookup 在这里的做法是查询类里是否含有方法到缓存。 一般有两种结果：拿到缓存IMP，或者未曾缓存。 查询可以得到有三种查询方式: NORMAL 正常查找 GETIMP 获取IMP LOOKUP 慢速查询方法 根据源码，做了一些注释： 其中多次出现CheckMiss ,也是个汇编宏，使用在缓存查找失败后。 源码如下: .macro CheckMiss // miss if bucket-&gt;sel == 0.if $0 == GETIMP cbz p9, LGetImpMiss.elseif $0 == NORMAL cbz p9, __objc_msgSend_uncached.elseif $0 == LOOKUP cbz p9, __objc_msgLookup_uncached.else.abort oops.endif.endmacro 根据查找的模式位NORMAL, 对应的**__objc_msgSend_uncached **。 在源码中搜索，得到相关逻辑如下： STATIC_ENTRY __objc_msgSend_uncachedUNWIND __objc_msgSend_uncached, FrameWithNoSaves// THIS IS NOT A CALLABLE C FUNCTION// Out-of-band p16 is the class to searchMethodTableLookupTailCallFunctionPointer x17END_ENTRY __objc_msgSend_uncached 执行方法查找的核心方法，就是MethodTableLookup， 继续点开查看，得到的是 这里的内容，则是到objc_class 的 class_data_bits_t 里寻找方法的具体实现了，下一篇文章我们来讲。 四、小结这一篇，主要是开始从汇编的角度，来实现方法查找流程，流程草写了一下，图一定补。。。 拿到isa 查找Class 在Cache_t 查找bucket bucket 相同，返回IMP 否则 跳到BITS BITS 中 查找Rw 查找ro 查找methodList 总流程如下:","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/%E7%B1%BB/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/%E7%BB%93%E6%9E%84/"},{"name":"objc","slug":"objc","permalink":"http://nilsli.com/tags/objc/"},{"name":"msgSend","slug":"msgSend","permalink":"http://nilsli.com/tags/msgSend/"}]},{"title":"方法的本质1--cache_t方法缓存分析","slug":"analyzeOfCacheT","date":"2020-01-20T17:18:38.000Z","updated":"2024-08-07T07:10:46.591Z","comments":true,"path":"p/40097.html","permalink":"http://nilsli.com/p/40097.html","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 1.概念1.1 objc_class 结构前面探索了类的结构，知道了类的结构本质上是objc_class的结构体，而在 C 源码例， objc_class 结构体的结构如下： struct objc_class : objc_object &#123; // Class ISA; // 指向类的isa Class superclass; // 父类 cache_t cache; // 缓存的方法列表 // formerly cache pointer and vtable class_data_bits_t bits; // 缓存的属性和变量 // class_rw_t * plus custom rr/alloc flags 上一篇文章，具体分析了class_data_bits_t，那么上面的缓存cache_t 还没有展开学习，下面就继续进行讲解。","text":"本页所使用的objc runtime 756.2，来自GITHUB 1.概念1.1 objc_class 结构前面探索了类的结构，知道了类的结构本质上是objc_class的结构体，而在 C 源码例， objc_class 结构体的结构如下： struct objc_class : objc_object &#123; // Class ISA; // 指向类的isa Class superclass; // 父类 cache_t cache; // 缓存的方法列表 // formerly cache pointer and vtable class_data_bits_t bits; // 缓存的属性和变量 // class_rw_t * plus custom rr/alloc flags 上一篇文章，具体分析了class_data_bits_t，那么上面的缓存cache_t 还没有展开学习，下面就继续进行讲解。 1.2 Cache_t 结构:cache_t 是objc_class 的重要组成属性，它主要用来存储方法。 struct cache_t &#123; struct bucket_t *_buckets; // 缓存的方法列表 mask_t _mask; // 散列表的长度 mask_t _occupied; // 缓存过的方法数量 ******&#125; bucket 的定义 顾名思义是桶 ，装水的桶，装奥特曼的桶…… 在这里是一个hash表，计算公式是hash &#x3D; sel 地址%mask，其中mask 是存放空间的大小，初始值是4。 通过源码查看，可以知道结构体如下： struct bucket_t &#123;private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64.#if __arm64__ MethodCacheIMP _imp; // 方法实现 cache_key_t _key; // 方法编号#else cache_key_t _key; MethodCacheIMP _imp;#endif 可以看到，这里缓存了MethodCacheIMP 方法，其中 MethodCacheIMP 是IMP的子类： MethodCacheIMP ——对于方法实现 cache_key_t ——对应方法缓存编号 2. 实现2.1方法缓存入口 入口引起我们注意的是如下这段代码: void cache_fill(Class cls, SEL sel, IMP imp, id receiver)&#123;#if !DEBUG_TASK_THREADS mutex_locker_t lock(cacheUpdateLock); cache_fill_nolock(cls, sel, imp, receiver);#else _collecting_in_critical(); return;#endif&#125; 代码解释： cache_fill 方法的缓存写入操作 cache_fill_nolock 线程解锁后的缓存写入 断言保护这里的方法cache_fill_nolock 就是我们的方法入口，为追求速度，执行的内容是无锁操作下的缓存填充，即对开辟的内存空间，进行方法写入，实现源码如下： static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)&#123; cacheUpdateLock.assertLocked(); // Never cache before +initialize is done if (!cls-&gt;isInitialized()) return; // Make sure the entry wasn&#x27;t added to the cache by some other thread // before we grabbed the cacheUpdateLock. if (cache_getImp(cls, sel)) return; cache_t *cache = getCache(cls); cache_key_t key = getKey(sel); **** 代码解释： cacheUpdateLock.assertLocked() ：这里对内存区域锁定进行了跳出断言 if (!cls-&gt;isInitialized()) return; 对为初始化内存空间进行跳出断言 if (cache_getImp(cls, sel)) 对缓存空间已有该方法跳出断言 2.2 检查容量 在检查容量之前，cache_t 做了两个操作： 将类的引用地址转化成了cache 结构体: cache_t *cache = getCache(cls) 将方法编号sel 转换成了整型，方便寻址 cache_key_t key = getKey(sel) 容量为空检测 将方法缓存时，先确定是否为空对缓存。这里使用了 if (cache-&gt;isConstantEmptyCache()) &#123; // Cache is read-only. Replace it. cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE); &#125; 来判断空间是否为空，isConstantEmptyCache这个函数更详细的操作如下： return occupied() == 0 &amp;&amp; buckets() == emptyBucketsForCapacity(capacity(), false); 即occupied占位为空，而且容器桶 也无法从其他堆中空间共享空间，就必须重新开辟新的空间，开辟空间操作见 2.3。 扩容的条件： 扩容条件的操作为将当前容量 occupied + 1, 然后检查是否达到 3&#x2F;4，超过则需要扩容；否则不需要扩容，直接进行缓存的写入，下面的代码足够明了的解释； // Use the cache as-is if it is less than 3/4 fullmask_t newOccupied = cache-&gt;occupied() + 1;mask_t capacity = cache-&gt;capacity();if (cache-&gt;isConstantEmptyCache()) &#123; // Cache is read-only. Replace it. cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);&#125;else if (newOccupied &lt;= capacity / 4 * 3) &#123; // Cache is less than 3/4 full. Use it as-is.&#125;else &#123; // Cache is too full. Expand it. cache-&gt;expand();&#125; 代码详解： mask_t newOccupied &#x3D; cache-&gt;occupied() + 1 mask_t capacity &#x3D; cache-&gt;capacity(); if (newOccupied &lt;&#x3D; capacity &#x2F; 4 * 3) 这里的 newOccupied 是当前的占用容量+1, 与目前的总容量 capacity 的 3&#x2F;4 来做比较，这里使用占位+1 后来做比较，目的是提前准备，防止内存溢出。 2.3 内存扩容2.3.1 空间计算 扩容方法： 判断当前容量是否为空，若为空，就给初始化的内存为为4； 如果之前就有空间，则加倍。 void cache_t::expand()&#123; cacheUpdateLock.assertLocked(); uint32_t oldCapacity = capacity(); uint32_t newCapacity = oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE; if ((uint32_t)(mask_t)newCapacity != newCapacity) &#123; // mask overflow - can&#x27;t grow further // fixme this wastes one bit of mask newCapacity = oldCapacity; &#125; reallocate(oldCapacity, newCapacity);&#125; 代码详解： oldCapacity 定义了当前的容量 如果 oldCapacity 为空，则立刻开辟大小为4 的空间。 否则，给当前空间加倍，即 oldCapacity*2，并在新空间内进行缓存空间开辟 reallocate。 2.3.2 新建容器reallocate新开内存空间的操作步骤： 确定是否可以释放旧空间 将开辟的空间和内存方法绑定，并将mask 和占位值occupied 归零。 void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity)&#123; bool freeOld = canBeFreed(); bucket_t *oldBuckets = buckets(); bucket_t *newBuckets = allocateBuckets(newCapacity); // Cache&#x27;s old contents are not propagated. // This is thought to save cache memory at the cost of extra cache fills. // fixme re-measure this assert(newCapacity &gt; 0); assert((uintptr_t)(mask_t)(newCapacity-1) == newCapacity-1); setBucketsAndMask(newBuckets, newCapacity - 1); if (freeOld) &#123; cache_collect_free(oldBuckets, oldCapacity); cache_collect(false); &#125;&#125; 代码讲解： bool freeOld &#x3D; canBeFreed() 决定了是否可以释放旧内存。 bool cache_t::canBeFreed()&#123; return !isConstantEmptyCache();&#125; 这里的canBeFreed依赖于isConstantEmptyCache的取反，即需要之前方法缓存有占位，并且旧bucket 本身容量不为空。 即以下源码里返回为空： bool cache_t::isConstantEmptyCache()&#123; return occupied() == 0 &amp;&amp; buckets() == emptyBucketsForCapacity(capacity(), false);&#125;需要 occupied == 1, 以及 buckets() != emptyBucketsForCapacity(capacity(), false) setBucketsAndMask 用来初始化 新的bucket 和 occupied newCapacity - 1 更新索引，用来查询散列表里的元素。 cache_collect_free 用来释放旧容量（oldCapacity）下的旧方法数据（oldBuckets） 2.4 缓存写入2.4.1 查找缓存通过 cache-&gt;find 查找对应的缓存，如果没有找到，就添加新缓存，在这之前将占位occupied 添加1 ，实现源码如下： static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)&#123; *** // 找到对应的 bucket bucket_t *bucket = cache-&gt;find(key, receiver); if (bucket-&gt;key() == 0) cache-&gt;incrementOccupied(); bucket-&gt;set(key, imp); &#125; void cache_t::incrementOccupied() &#123; _occupied++; // 占位增加&#125; 2.4.2 未扩容过找到之前的bucket，按照编号和方法，写入缓存: bucket_t *bucket = cache-&gt;find(key, receiver);bucket-&gt;set(key, imp); 2.4.3 缓存写入实现void bucket_t::set(cache_key_t newKey, IMP newImp)&#123; assert(_key == 0 || _key == newKey); // objc_msgSend uses key and imp with no locks. // It is safe for objc_msgSend to see new imp but NULL key // (It will get a cache miss but not dispatch to the wrong place.) // It is unsafe for objc_msgSend to see old imp and new key. // Therefore we write new imp, wait a lot, then write new key. _imp = newImp; if (_key != newKey) &#123; mega_barrier(); _key = newKey; &#125;&#125; 代码详解： 注释中写明了： objc_msgSend 在无锁环境下使用key 和 imp 实现。 objc_msgSend 查看到新的imp 实现是安全的，除了空的key地址外。（可能会造成小的缓存丢失，但是并不会分发到错误的空间） objc_msgSend 旧的imp 和新的key 是不安全的，因此我们先写新imp，等一会儿，再写新的 key 代码中的 mega_barrier 就是 使用了阻塞，让方法先看到imp ，保证线程的安全。 3. 总结3.1 梳理cache_t 起源于 OC中的方法传递，也就是objc_msgSend 的实现。在类的方法传递时，为了追求，先去cache_t 中查找是否有缓存，如果有，可以直接调用，如果没有缓存，则需要对类进行一系列的内存空间确认，进行imp - key 的写入，并进行最终调用。 这一章节应该是目前分析最难的，花了大概三到四天弄明白，希望这艰难的一步能为以后的分析打好更好的基础。 3.2 流程图","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/%E7%B1%BB/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/%E7%BB%93%E6%9E%84/"},{"name":"cache_t","slug":"cache-t","permalink":"http://nilsli.com/tags/cache-t/"}]},{"title":"OC底层研究4--类的结构分析","slug":"StructOfClass","date":"2020-01-12T06:00:53.000Z","updated":"2024-08-07T07:10:46.589Z","comments":true,"path":"p/8549.html","permalink":"http://nilsli.com/p/8549.html","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 1.概念1.1 类Class 的类型 Class在源码里的真正类型为objc_class的结构体。 先查看源码——在Xcode按下Shift+Command+O，选择objc-runtime-new.h，搜索objc_class，可以得知，Class底层编译实现的前4行如下： 可知类结构如下： A. &#x2F;&#x2F;Class ISA ​ 继承自父类 objc_class 的 isa ，指向类的指针不需显示（内存占8位），这里它返回一个nonpointer的指针，相关源码如下： /// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; B. Class superclass; ​ 指向本类的父类（内存占8位） C. cache_t cache; ​ 存储指针和vtable，加速方法调用（内存占8位） D. class_data_bits_t bits; ​ 存储类的方法、属性、遵循的协议等信息的地方（内存占8位） E. 其他方法&#x2F;函数 – 不占内存 为何cache_t cache 这个变量占位位16，而不是8？ 原因是因为这里的cache_t是结构体，其占内存为根据内部属性结构而定，为防止溢出，给予16位字节，而不是指针所需的8位。 Talk is cheap, show me the code, 伸伸手指，点开cache_t 的内部结构","text":"本页所使用的objc runtime 756.2，来自GITHUB 1.概念1.1 类Class 的类型 Class在源码里的真正类型为objc_class的结构体。 先查看源码——在Xcode按下Shift+Command+O，选择objc-runtime-new.h，搜索objc_class，可以得知，Class底层编译实现的前4行如下： 可知类结构如下： A. &#x2F;&#x2F;Class ISA ​ 继承自父类 objc_class 的 isa ，指向类的指针不需显示（内存占8位），这里它返回一个nonpointer的指针，相关源码如下： /// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; B. Class superclass; ​ 指向本类的父类（内存占8位） C. cache_t cache; ​ 存储指针和vtable，加速方法调用（内存占8位） D. class_data_bits_t bits; ​ 存储类的方法、属性、遵循的协议等信息的地方（内存占8位） E. 其他方法&#x2F;函数 – 不占内存 为何cache_t cache 这个变量占位位16，而不是8？ 原因是因为这里的cache_t是结构体，其占内存为根据内部属性结构而定，为防止溢出，给予16位字节，而不是指针所需的8位。 Talk is cheap, show me the code, 伸伸手指，点开cache_t 的内部结构 我们来看看属性： bucket_t， 结构体，占8位字节 mask_t，点开后具体实现为如下： typedef uint32_t mask_t; ​ 为整型，占4个字节 mask_t typedef uint32_t mask_t; ​ 也是整形，占4个字节 共计8+4+4 &#x3D; 16个字节 1.2 objc_class继承在底层实现里，objc_class 继承自objc_object 的结构体 /// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; 1.3 关于NSobject 万物皆对象 - Class 继承自NSObject @interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot; Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125; 2. 类的属性与成员变量 属性的存储上面提到了类对象的结构原理，我们知道了类结构里，类型位class_data_bits_t 的bits下面我们来探寻一下，类里面的属性上怎么保存的。 我们在代码里生成一个类，分别有成员变量hobby，以及属性nickName 代码如下: @interface Person : NSObject&#123; NSString *hobby;&#125;@property (nonatomic, copy) NSString *nickName; 在主线代码引入: int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; LGPerson *person = [LGPerson alloc]; Class pClass = object_getClass(person); NSLog(@&quot;%@ -- %p&quot;, person, pClass); &#125; return 0;&#125; 然后打印得到的类pClass，通过x&#x2F;4gx 获取类结构如下： (lldb) x/4gx pClass0x1000023d0: 0x001d8001000023a9 0x0000000100b371400x1000023e0: 0x00000001003da280 0x0000000000000000 观察结果得知0x1000023d0 位pClass在内存中的首地址，根据内存偏移原则，加上16+8+8共32位，即可得到bits的结构。 0x1000023d0，偏移32位，得到0x1000023f0。注意，这里要用p打印指针，而非打印值用的po (lldb) p 0x1000023f04294976496 oh NO！得到的是具体的值，这里需要强转一下： (lldb) p (class_data_bits_t *)0x1000023f0(class_data_bits_t *) $3 = 0x00000001000023f0 得到$3 的值，并不是我们想要的结构，留意到objc_class里的方法 data() 方法: struct objc_class : objc_object &#123; // Class ISA; // 8 Class superclass; // 8 cache_t cache; // 16 不是8 // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125; data() 返回是class_rw_t，点进去看看， struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName; 留意到里面有 methods、properties、protocols等，原来这里等值便是类的相关属性方法等等结构。 现在对$3 执行data() 方法: (lldb) p $3-&gt;data()(class_rw_t *) $5 = 0x0000000000000000 对得到的$5 进行值打印: (lldb) p *$5(class_rw_t) $5 = &#123; flags = 2148139008 version = 0 ro = 0x0000000100002308 methods = &#123; list_array_tt&lt;method_t, method_list_t&gt; = &#123; = &#123; list = 0x0000000100002240 arrayAndFlag = 4294976064 &#125; &#125; &#125; properties = &#123; list_array_tt&lt;property_t, property_list_t&gt; = &#123; = &#123; list = 0x00000001000022f0 arrayAndFlag = 4294976240 &#125; &#125; &#125; protocols = &#123; list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123; = &#123; list = 0x0000000000000000 arrayAndFlag = 0 &#125; &#125; &#125; firstSubclass = nil nextSiblingClass = NSUUID demangledName = 0x0000000000000000&#125; 如上所示，$5 内结构一目了然，方法，属性，协议都显示了。 继续获取属性值: (lldb) p $5.properties(property_array_t) $7 = &#123; list_array_tt&lt;property_t, property_list_t&gt; = &#123; = &#123; list = 0x00000001000022f0 arrayAndFlag = 4294976240 &#125; &#125;&#125; 得到一个二维数组的$7，观察属性列表的类型为property_array_t，继承自list_array_tt，内部拥有 (lldb) p $7.list(property_list_t *) $8 = 0x00000001000022f0 再次对$8 进行* 取值，得到如下结果： (lldb) p *$8(property_list_t) $9 = &#123; entsize_list_tt&lt;property_t, property_list_t, 0&gt; = &#123; entsizeAndFlags = 16 count = 1 first = (name = &quot;nickName&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,C,N,V_nickName&quot;) &#125;&#125; 从结果可以看出，我们的属性，就保存在properties 里中。 成员变量的存储上面分析了属性的存储，但是我们没有看到成员变量 hobby,我们在properties 属性里，没有看到它，到底在哪里呢?下面我们继续查找。 既然不在properties 里，那尝试一下在$5 的 ro 里进行取值 (lldb) p $5.ro(const class_ro_t *) $10 = 0x0000000100002308 得到class_ro_t 类型的结构体，继续对他取值 (lldb) p *$10(const class_ro_t) $11 = &#123; flags = 388 instanceStart = 8 instanceSize = 24 reserved = 0 ivarLayout = 0x0000000100001f8a &quot;\\x02&quot; name = 0x0000000100001f81 &quot;LGPerson&quot; baseMethodList = 0x0000000100002240 baseProtocols = 0x0000000000000000 ivars = 0x00000001000022a8 weakIvarLayout = 0x0000000000000000 baseProperties = 0x00000001000022f0&#125; 值这里可以看到ivars，就是我们需要的变量列表，打印一下： (lldb) p $11.ivars(const ivar_list_t *const) $12 = 0x00000001000022a8 继续对 ivar_list_t 类型的$12 取值: (lldb) p *$12(const ivar_list_t) $13 = &#123; entsize_list_tt&lt;ivar_t, ivar_list_t, 0&gt; = &#123; entsizeAndFlags = 32 count = 2 first = &#123; offset = 0x0000000100002378 name = 0x0000000100001e64 &quot;hobby&quot; type = 0x0000000100001fa7 &quot;@\\&quot;NSString\\&quot;&quot; alignment_raw = 3 size = 8 &#125; &#125;&#125;(lldb) p $.first(const ivar_t) $13 = &#123; offset = 0x0000000100002378 name = 0x0000000100001e64 &quot;hobby&quot; type = 0x0000000100001fa7 &quot;@\\&quot;NSString\\&quot;&quot; alignment_raw = 3 size = 8&#125; 可以看到成员变量存在类的 ivars 属性里 3. 类的方法3.1 类的实例方法我们继续对类进行代码编辑，对Person类添加实例方法和类方法 - (void)sayHello; // 实例方法+ (void)sayHappy; // 类方法 还是对类结构$5 进行解析，这次我们打印它的 methods 属性 (lldb) p $5.methods(method_array_t) $14 = &#123; list_array_tt&lt;method_t, method_list_t&gt; = &#123; = &#123; list = 0x0000000100002240 arrayAndFlag = 4294976064 &#125; &#125;&#125; 得到的是method_array_t 类型的$14, 是个数组类型，继续打印: (lldb) p $14.list(method_list_t *) $15 = 0x0000000100002240 (lldb) p *$15(method_list_t) $16 = &#123; entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123; entsizeAndFlags = 26 count = 4 first = &#123; name = &quot;sayHello&quot; types = 0x0000000100001f8c &quot;v16@0:8&quot; imp = 0x0000000100001b90 (LGTest`-[LGPerson sayHello] at LGPerson.m:13) &#125; &#125;&#125; 可见，实例方法sayHello 方法，存储在类的methods属性里 3.2 类的类方法存储类方法在上述的过程中没有看到，那么它会在哪里呢? 为了找到它，我们重新回到最初的pClass (lldb) x/4gx pClass0x1000023b0: 0x001d800100002389 0x0000000100b371400x1000023c0: 0x00000001003da280 0x0000000000000000 得到isa值为0x001d800100002389，这时，唤出它的掩码 ISA_MASK 来获取它的元类 (lldb) p/x 0x001d800100002389 &amp; 0x0000000ffffffff8(long) $1 = 0x0000000100002388 继续对元类**$1**的结构进行解析： (lldb) x/4gx 0x00000001000023880x100002388: 0x001d800100b370f1 0x0000000100b370f00x100002398: 0x0000000100f946c0 0x0000000100000003 可知0x100002388是这个元类的地址，根据上文提到的内存便宜，我们继续加上2个16进制位，得到0x1000023a8，p一下： (lldb) p (class_data_bits_t *)$2(class_data_bits_t *) $3 = 0x00000001000023a8 继续执行上文实例方法类似的方案，执行data() — 取值 – 获取methods 的思路，具体代码如下： (lldb) p $3-&gt;data()(class_rw_t *) $4 = 0x0000000100f94620(lldb) p *$4(class_rw_t) $5 = &#123; flags = 2685075456 version = 7 ro = 0x00000001000021f8 methods = &#123; list_array_tt&lt;method_t, method_list_t&gt; = &#123; = &#123; list = 0x00000001000021d8 arrayAndFlag = 4294975960 &#125; &#125; &#125; properties = &#123; list_array_tt&lt;property_t, property_list_t&gt; = &#123; = &#123; list = 0x0000000000000000 arrayAndFlag = 0 &#125; &#125; &#125; protocols = &#123; list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123; = &#123; list = 0x0000000000000000 arrayAndFlag = 0 &#125; &#125; &#125; firstSubclass = nil nextSiblingClass = 0x00007fff942e6990 demangledName = 0x0000000000000000&#125;(lldb) p $5.methods(method_array_t) $10 = &#123; list_array_tt&lt;method_t, method_list_t&gt; = &#123; = &#123; list = 0x00000001000021d8 arrayAndFlag = 4294975960 &#125; &#125;&#125;(lldb) p $10.list(method_list_t *) $11 = 0x00000001000021d8(lldb) p *$11(method_list_t) $12 = &#123; entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123; entsizeAndFlags = 26 count = 1 first = &#123; name = &quot;sayHappy&quot; types = 0x0000000100001f8c &quot;v16@0:8&quot; imp = 0x0000000100001bc0 (LGTest`+[LGPerson sayHappy] at LGPerson.m:17) &#125; &#125;&#125;(lldb) 可见，类方法sayHappy 方法，存储在类的元类 methods属性里 4. 总结 类的本质上一个类型为objc_class的结构体，包含有isa、父类、属性、成员变量及方法列表等 类属性存在结构体的properties里 类的成员变量存在结构体的 ivars里 类的实例方法，存在结构体 的methods 属性里 类的类方法，存在父类的class_ro_t 里的methods里 如下图示：","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/%E7%B1%BB/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/%E7%BB%93%E6%9E%84/"}]},{"title":"2020新年感想","slug":"newyearnote","date":"2020-01-01T16:39:53.000Z","updated":"2024-08-07T07:10:46.692Z","comments":true,"path":"p/63353.html","permalink":"http://nilsli.com/p/63353.html","excerpt":"","text":"2020年是一个闰年，第一天从星期三开始。 今天看了小羊肖恩大电影，故事讲得真好看，小朋友全程开心，全情投入，大朋友也觉得耳目一新，深受感动。 这是我们带他看的第一部电影，新的一年，从第一开始。 用一句涂鸦来鼓舞自己 宁愿最后徒劳无功， 也不选择无动于衷。 希望今年也有始有终，有所收获。","categories":[],"tags":[{"name":"2020","slug":"2020","permalink":"http://nilsli.com/tags/2020/"},{"name":"感想","slug":"感想","permalink":"http://nilsli.com/tags/%E6%84%9F%E6%83%B3/"}]},{"title":"OC底层研究3--isa的初始化和指向分析","slug":"initialOfIsaNDirection","date":"2019-12-27T07:05:19.000Z","updated":"2024-08-07T07:10:46.647Z","comments":true,"path":"p/64820.html","permalink":"http://nilsli.com/p/64820.html","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 开始继续学习研究OC源码，这次研究的是isa的初始化和指向分析。 1. 概念什么是isa看看苹果文档的介绍： isa A Pointer to the class definition of which this object is an instance. isa ： 一个指向该对象的类的指针。 打开Xcode，找到objc.h，我们可以看看到如下代码 #if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class./// 一个展示OC类的未知的类型typedef struct objc_class *Class;/// Represents an instance of a class./// 展示一个类的实例struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class./// 一个指向类的实例的指针typedef struct objc_object *id;#endif 可以看出，Class 是一个objc_class 类型的结构体。 而id类型，则是objc_object 类型的结构体.","text":"本页所使用的objc runtime 756.2，来自GITHUB 开始继续学习研究OC源码，这次研究的是isa的初始化和指向分析。 1. 概念什么是isa看看苹果文档的介绍： isa A Pointer to the class definition of which this object is an instance. isa ： 一个指向该对象的类的指针。 打开Xcode，找到objc.h，我们可以看看到如下代码 #if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class./// 一个展示OC类的未知的类型typedef struct objc_class *Class;/// Represents an instance of a class./// 展示一个类的实例struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class./// 一个指向类的实例的指针typedef struct objc_object *id;#endif 可以看出，Class 是一个objc_class 类型的结构体。 而id类型，则是objc_object 类型的结构体. 2. isa 的初始化在此之前，先回顾一下对象初始化的流程图 在这里，初始化实例的isa，其中 cls 为初始化的类对象，hasCxxDtor 即为是否含有C++的析构器。 我们进入 initIsa(cls, true, hasCxxDtor) 这个函数，看看内部实现了什么 2.1 isa非nonpointerif (!nonpointer) &#123; isa.cls = cls;&#125; nonpointer概念: 表示是否对isa 指针开启指针优化 ​ 0: 纯isa指针 ​ 1: 不止是类对象的地址，还包含类信息、对象的引用计数等。 此时，如果为纯isa指针，将当前类 cls 赋值给 isa 的绑定属性 cls 为什么有这个绑定属性，而isa究竟是什么看结构呢？ 点击isa.cls = cls;中的cls查看它的结构，如下： union isa_t &#123; isa_t() &#123; &#125; // isa 初始化方法 isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 可以看见isa 是一个 union，联合体，里面包含了 isa_t 初始化方法 isa_t(uintptr_t value) 工厂方法 Class cls 绑定属性 结构体ISA_BITFIELD位域 ISA_BITFIELD概念 我们点开类型为struct的ISA_BITFIELD，结构如下： # if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) NONPOINTER_ISA效果图（手绘中，待补全……） 还原isa_t 的结构 我们这时发现，isa的整体结构可以替换为如下的样子: union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19; // ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; nonpointer: 表示是否对 isa 指针开启指针优化 0:纯isa指针，1:不止是类对象地址**,isa** 中包含了类信息、对象的引用计数等（占1位） has_assoc: 关联对象标志位，0没有，1存在（占1位） has_cxx_dtor: 该对象是否有 C++ 或者 Objc 的析构器**,如果有析构函数,则需要做析构逻辑,** 如果没有**,**则可以更快的释放对象（占1位） **shiftcls:**存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位用来存储类指针。（占33位） magic:用于调试器判断当前对象是真的对象还是没有初始化的空间 weakly_referenced:志对象是否被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放。（占6位） deallocating:标志对象是否正在释放内存（占1位） has_sidetable_rc:当对象引用计数大于 10 时，则需要借用该变量存储进位（占1位） extra_rc:当表示该对象的引用计数值，实际上是引用计数值减 1， 例如，如果对象的引用计数为 10，那么 extra_rc 为 9。如果引用计数大于 10， 则需要使用到下面的 has_sidetable_rc。（占1位） 2.2 isa是nonpointer类型 isa_t newisa(0);#if SUPPORT_INDEXED_ISA assert(cls-&gt;classArrayIndex() &gt; 0); newisa.bits = ISA_INDEX_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();#else newisa.bits = ISA_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;#endif 生成新的isa: isa_t newisa(0); c++ 析构器： newisa.has_cxx_dtor &#x3D; hasCxxDtor;&#96; 表示当前对象是否有C++的析构函数（destructor）,如果没有，释放时会快速的释放内存。 位域赋值 newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3; 对存储指针的值进行右移动3位赋值。 返回isa isa = newisa; 3. isa 的指向3.1 指向图：关于isa的指向以及子类父类的关系，苹果官方给出了一张图如下所示： 3.2 代码分析3.2.1 对象的isa我们执行一项代码如下，并对该行打断点： Person *object = [Person alloc]; 我们知道：对象里的 isa ——指向——&gt; 类。 3.2.2类的isa现在我们想知道类的内存空间结构，在控制台执行如下指令x/4gx Person.class，结果如下： (lldb) x/4gx Person.class0x100001130: 0x001d800100001109 0x0000000100b391400x100001140: 0x0000000101a46ed0 0x0000000200000007 由于isa是类对象的第一个属性，我们知道0x001d800100001109是改对象的isa，我们看看他指向哪里呢，使用p/x 指令试试: (lldb) p/x 0x001d800100001109(long) $16 = 0x001d800100001109 糟糕，查看不到结果？怎么回事？类的isa 格式需要强转，可以退一步，打印类的地址试试： po 0x100001130Person 原来如此，在内存空间里，名为Person的类的第一个位置，指向Person类，岂不是循环指向了？ 非也非也，这里指向的类，我们把它称为元类（meta-class） 类的isa ——指向——&gt; 元类 3.2.3 元类的isa我们现在获得元类的具体地址，找到isa 的MASK（掩码），值为0x00007ffffffffff8， 输入以下指令： (lldb) p/x 0x001d800100001109 &amp; 0x00007ffffffffff8(long) $17 = 0x0000000100001108(lldb) po 0x0000000100001108Person 得到元类地址为：0x0000000100001108，16进制打印一下： (lldb) x/4gx 0x00000001000011080x100001108: 0x001d800100b390f1 0x0000000100b390f00x100001118: 0x0000000100f5a480 0x0000000400000007 可以看到元类结构里，isa指针为 0x001d800100b390f1，继续获取它的指向，我们通过与掩码来计算： (lldb) p/x 0x001d800100b390f1 &amp; 0x00007ffffffffff8(long) $21 = 0x0000000100b390f0 好嘞，拿到内存指针地址为0x0000000100b390f0， 打印一下： po 0x0000000100b390f0NSObject 至此，我们可以看到元类的isa指向它的上一级元类，也就是跟元类(root meta-class)，为NSObject。 所以得出: 元类的isa ——指向——&gt; 根元类 3.2.4 根元类的isa我们打印下根元类结构： x/4gx 0x0000000100b390f00x100b390f0: 0x001d800100b390f1 0x0000000100b391400x100b39100: 0x0000000101a47020 0x0000000500000007 拿到它的isa，与掩码继续进行与运算 p/x 0x001d800100b390f1 &amp; 0x00007ffffffffff8(long) $27 = 0x0000000100b390f0 得到的结果0x0000000100b390f0，与根元类0x0000000100b390f0，完全吻合。 至此，我们得出结论：根元类的isa ——指向——&gt; 根类NSObject。 什么？你不信，这些都是猜测，证实一下？ 好的，创建如下代码 void TestNSObject()&#123; // NSObject实例对象 NSObject *object1 = [NSObject alloc]; // NSObject类 Class class = object_getClass(object1); // NSObject元类 Class metaClass = object_getClass(class); // NSObject根元类 Class rootMetaClass = object_getClass(metaClass); // NSObject根根元类 Class rootRootMetaClass = object_getClass(rootMetaClass); NSLog(@&quot;\\n%p 实例对象\\n%p 类\\n%p 元类\\n%p 根元类\\n%p 根根元类&quot;,object1,class,metaClass,rootMetaClass,rootRootMetaClass);&#125; 打印结果如下： 0x10066ddc0 实例对象0x7fff9294a118 类0x7fff9294a0f0 元类0x7fff9294a0f0 根元类0x7fff9294a0f0 根根元类 可见，除了NSObject 类是独有的创建，其他元类、根元类、根根元类，都是一样的，因为都是NSObject，所以结果得到了证明。 3.3 总结：我们再回到这幅图，最红是这样的： isa指向： 对象中的isa——&gt; 类 类中的isa ——&gt; 元类 元类中的isa —-&gt; 根元类 根元类中的isa —-&gt; 根元类 类继承关系： 子类 ———superClass——— 父类 父类 ———superClass——— 根元类 根元类 ———superClass——— NSObject NSObject ———superClass——— nil","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"对齐","slug":"对齐","permalink":"http://nilsli.com/tags/%E5%AF%B9%E9%BD%90/"},{"name":"内存","slug":"内存","permalink":"http://nilsli.com/tags/%E5%86%85%E5%AD%98/"}]},{"title":"OC底层研究2--内存对齐原理","slug":"memoryAlignPrinciple","date":"2019-12-22T03:05:11.000Z","updated":"2024-08-07T07:10:46.679Z","comments":true,"path":"p/43162.html","permalink":"http://nilsli.com/p/43162.html","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 开始继续学习研究OC源码，今天看的是OC的内存原理，以及对齐原理的分析。 1.概念内存对齐在数据结构中，是比较基础也比较重要的一环，对于iOS开发，研究底层更免不了要了解他们的原理，方便我们更透彻的学习iOS的原理。 我们先来一段维基百科的数据结构对齐的相关知识。 内存对齐，也可以理解为数据结构对齐（Data structure alignment），是代码编译后在内存的布局与使用方式。包括三方面内容：数据对齐、数据结构填充（padding）与包入（packing）。 下图是内存中各类型属性所占的空间大小：","text":"本页所使用的objc runtime 756.2，来自GITHUB 开始继续学习研究OC源码，今天看的是OC的内存原理，以及对齐原理的分析。 1.概念内存对齐在数据结构中，是比较基础也比较重要的一环，对于iOS开发，研究底层更免不了要了解他们的原理，方便我们更透彻的学习iOS的原理。 我们先来一段维基百科的数据结构对齐的相关知识。 内存对齐，也可以理解为数据结构对齐（Data structure alignment），是代码编译后在内存的布局与使用方式。包括三方面内容：数据对齐、数据结构填充（padding）与包入（packing）。 下图是内存中各类型属性所占的空间大小： 列举一下各数据类型所占字节（32位）： A char (one byte) will be 1-byte aligned. A short (two bytes) will be 2-byte aligned. An int (four bytes) will be 4-byte aligned. A long (four bytes) will be 4-byte aligned. A float (four bytes) will be 4-byte aligned. A double (eight bytes) will be 8-byte aligned on Windows and 4-byte aligned on Linux (8-byte with -malign-double compile time option). A long long (eight bytes) will be 4-byte aligned. A long double (ten bytes with C++Builder and DMC, eight bytes with Visual C++, twelve bytes with GCC) will be 8-byte aligned with C++Builder, 2-byte aligned with DMC, 8-byte aligned with Visual C++, and 4-byte aligned with GCC. Any pointer (four bytes) will be 4-byte aligned. (e.g.: char*, int*) 需要注意的是，在64位机上，有以下不同 A long (eight bytes) will be 8-byte aligned. A double (eight bytes) will be 8-byte aligned. A long long (eight bytes) will be 8-byte aligned. A long double (eight bytes with Visual C++, sixteen bytes with GCC) will be 8-byte aligned with Visual C++ and 16-byte aligned with GCC. Any pointer (eight bytes) will be 8-byte aligned. 2. 原则 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在32位机为４字节,则要从４的整数倍地址开始存储。 结构体作为成员: 如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.) **收尾工作:**结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐. 3. 实践3.1 属性8字节对齐：当创建对象时，其属性的按类型占据不同的内存空间，但是由于大小不一，需要进行补齐；原则则是以第一位补齐为8的倍数（64位系统是8为对齐，而32位系统是4位对齐）。 以下面的代码举例子 struct MyStruct &#123; double a; char b; // 第2行 char 在前 int 在后 int c; short d;&#125; MyStr1; struct MyStruct2 &#123; double a; int c; // 第2行 int 在前 char 在后 char b; short d;&#125; MyStr2; &#x2F;&#x2F; 我们打印一下各自的所占空间 NSLog(@&quot;%lu -- %lu&quot;,sizeof(MyStr1), sizeof(MyStr2)); 结果如下: 为何两者不一致? 我们来看第一个结构体对象的内部结构，排第一的属性double占8位，而char需要补齐7位成为8位，而剩余的int，short 则分别占4位，不需补齐，可以灵活堆在同一个内存区域。 struct MyStruct &#123; double a; // 8位 char b; // 1位 + 7 补齐 = 8 int c; // 4位 short d; // 4位&#125; MyStr1; 总计是 8 + 8 + 4 + 4 &#x3D; 24； 而第二个结构体对象，排第一的属性double占8位，而剩余的int，short ，short 总计都，不需补齐，可以灵活堆在同一个内存区域。 struct MyStruct2 &#123; double a; // 8 int c; // 4 char b; // 1 补齐1位 short d; // 2 &#125; MyStr2; 这里后3位，可以放到一个8位内存区间，即4 + 1 + 2，只需补齐1位至8位，可以灵活排列在一个内存空间内，所以本结构体对象总占内存为8+4+1+2 + 1（补齐1位） &#x3D; 16。 如果没有弄懂，我们找出源码来读一读：(&#x2F;objc&#x2F;Private Headers&#x2F;Project Headers&#x2F;objc-os.h) 创建对象 alloc alloc方法的实现——返回rootAlloc方法 返回callAlloc的实现 当缓存区没有对象时，创建对象 去内存区域创建对象 执行类的属性方法，确定创建的空间大小 对齐内存 内存对齐的返回：类的属性大小取决于指针大小 8字节对齐：实现方法 3.2 对象16字节对齐在OC 底层研究1–alloc和init原理 我们分析过，iOS环境下，为了容错处理，创建。 在 libmalloc&#x2F;src&#x2F;nano_malloc.c 第193行，我们发现如下的代码: 而其中NANO_REGIME_QUANTA_SIZE 为16， 为4那可以开始分析源码如下：```cppif (0 == size) &#123; size = NANO_REGIME_QUANTA_SIZE; // Historical behavior&#125; 这里的意思是，如果size为0，即创建空对象，返回16位默认空间。 而 k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM 是向右移动4位，即16字节对齐，那究竟是怎么实现的，我们不妨来看下，假定给定申请的内存size 为40，那么 40(size) + 16 - 1 = 550011 0111 // 55 的2进制显示0000 0011 // &gt;&gt; 右移动4位 == 30011 0000 // 执行 slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; 左移动4位slot_bytes = 48(0011 0000) er, 第205行中返回的slot_bytes 即是最终对齐后的内存空间位，即给入40，最终系统对齐后，返回48位(16的整数位)。 4 结论在iOS环境下，我们创建的对象和指针遵循16位对齐的原则，而其属性位8字节对齐。","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"对齐","slug":"对齐","permalink":"http://nilsli.com/tags/%E5%AF%B9%E9%BD%90/"},{"name":"内存","slug":"内存","permalink":"http://nilsli.com/tags/%E5%86%85%E5%AD%98/"}]},{"title":"OC 底层研究1--alloc和init原理","slug":"pricipleofalloc","date":"2019-12-16T07:31:51.000Z","updated":"2024-08-07T07:10:46.701Z","comments":true,"path":"p/19251.html","permalink":"http://nilsli.com/p/19251.html","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 1. 题目开始学习研究OC源码，今天看的是对象的初始化，也就是alloc以及init的分析。 2. 附流程图如下 3. 内容3.1引子我们先看一段代码，Person类的初始化，打印p1,p2,p3对象，以及指向他们的指针： Person *p1 = [Person alloc];Person *p2 = [p1 init];Person *p3 = [p1 init];NSLog(@&quot;%@ -- %p&quot;, p1, &amp;p1);NSLog(@&quot;%@ -- %p&quot;, p2, &amp;p2);NSLog(@&quot;%@ -- %p&quot;, p3, &amp;p3); 打印结果是： 这里为什么p1相同的情况下，经过init后的p2，p3 的地址都不一样呢，我们要用这个图来分析: 在这里，我们**[Person alloc]创建了一个p 对象的内存空间，而[p1 init]**则是创建同样是指向p1的指针p2，p3，因为和p1 内存空间一致，所以地址均为0x6000024f4950，但是指向该3个指针的指针不一样，所以&amp;p1, &amp;p2, &amp;p3 地址不一致。 3.2源码分析：alloc 步骤如下 1. alloc该步骤主要为创建对象，申请内存空间。相关objc源代码如下 + (id)alloc &#123; return _objc_rootAlloc(self);&#125;","text":"本页所使用的objc runtime 756.2，来自GITHUB 1. 题目开始学习研究OC源码，今天看的是对象的初始化，也就是alloc以及init的分析。 2. 附流程图如下 3. 内容3.1引子我们先看一段代码，Person类的初始化，打印p1,p2,p3对象，以及指向他们的指针： Person *p1 = [Person alloc];Person *p2 = [p1 init];Person *p3 = [p1 init];NSLog(@&quot;%@ -- %p&quot;, p1, &amp;p1);NSLog(@&quot;%@ -- %p&quot;, p2, &amp;p2);NSLog(@&quot;%@ -- %p&quot;, p3, &amp;p3); 打印结果是： 这里为什么p1相同的情况下，经过init后的p2，p3 的地址都不一样呢，我们要用这个图来分析: 在这里，我们**[Person alloc]创建了一个p 对象的内存空间，而[p1 init]**则是创建同样是指向p1的指针p2，p3，因为和p1 内存空间一致，所以地址均为0x6000024f4950，但是指向该3个指针的指针不一样，所以&amp;p1, &amp;p2, &amp;p3 地址不一致。 3.2源码分析：alloc 步骤如下 1. alloc该步骤主要为创建对象，申请内存空间。相关objc源代码如下 + (id)alloc &#123; return _objc_rootAlloc(self);&#125; 2. objc_rootAlloc基类对于alloc 的实现，此时cls不为空，源码如下： init方法： 类的init 如下 +(id)init&#123; return (id)self;&#125; 对象的init如下 - (id)init&#123; return _objc_rootAlloc(self);&#125; id_objc_rootAlloc(Class cls)&#123; return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);&#125; 此处init 方法仅仅为工厂初始方法，作为父类方法，方便子类重写。 3. callAlloc**callAlloc 的实现如下: // Call [cls alloc] or [cls allocWithZone:nil], with appropriate // shortcutting optimizations.static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123; if (slowpath(checkNil &amp;&amp; !cls)) return nil;#if __OBJC2__ if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123; // No alloc/allocWithZone implementation. Go straight to the allocator. // fixme store hasCustomAWZ in the non-meta class and // add it to canAllocFast&#x27;s summary if (fastpath(cls-&gt;canAllocFast())) &#123; // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls-&gt;hasCxxDtor(); id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize()); if (slowpath(!obj)) return callBadAllocHandler(cls); obj-&gt;initInstanceIsa(cls, dtor); return obj; &#125; else &#123; // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (slowpath(!obj)) return callBadAllocHandler(cls); return obj; &#125; &#125;#endif // No shortcuts available. if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc];&#125; 4. class_createInstance如上代码，如无捷径，类对象即创建实例 class_createInstance(Class cls, size_t extraBytes)&#123; return _class_createInstanceFromZone(cls, extraBytes, nil);&#125; 5. _class_createINstanceFramZone Cls-&gt;instanceSize 此时为对其寻址空间，统一为为每个对象开辟16位的位置，防止溢出。 size_t size = cls-&gt;instanceSize(extraBytes);// CF requires all objects be at least 16 bytes.if (outAllocatedSize) *outAllocatedSize = size; calloc 如果空间已开辟，则指定空间并返回，类似去学校报道，宿管阿姨带你去宿舍并交付钥匙给你，代码如下: if (zone) &#123; // malloc_zone_calloc 即为开辟内存 obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);&#125; else &#123; obj = (id)calloc(1, size);&#125; objc-&gt;initInstanceIsa 这一步为确定指针，即给宿舍贴上门牌号，相关代码如下： if (!zone &amp;&amp; fast) &#123; obj = (id)calloc(1, size); // 该行开辟了名为obj空间 if (!obj) return nil; obj-&gt;initInstanceIsa(cls, hasCxxDtor);&#125; 在这一环节，obj = (id)calloc(1, size) 该行开辟了名为obj空间。 而obj-&gt;initInstanceIsa(cls, hasCxxDtor) 则真正的将内存空间obj 与类cls 进行关联上。 4. 总结总的来说，alloc的过程，即时在堆区开辟空间给对象，并在栈区开辟指针（大小为8字节）指向该对象的内存区，即给定isa，以方便寻址。 以上，如果有更深入的理解，会再来补充，供参考。","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"alloc","slug":"alloc","permalink":"http://nilsli.com/tags/alloc/"}]},{"title":"使用Runtime获取第三方成员变量","slug":"runtimes","date":"2019-12-12T07:04:43.000Z","updated":"2024-08-07T07:10:46.720Z","comments":true,"path":"p/5621.html","permalink":"http://nilsli.com/p/5621.html","excerpt":"","text":"我们使用第三方库，有时候需要获取其成员变量。方法如下： 导入runtime #import &lt;objc/runtime.h&gt; 声明一个Person类 @interface Person : NSObject&#123; NSString *address;&#125;@property(nonatomic,strong)NSString *name;@property(nonatomic,assign)NSInteger age;@end 使用runtime获取私有属性 //遍历获取Person类所有的成员变量IvarList- (void) getAllIvarList &#123; unsigned int methodCount = 0; Ivar * ivars = class_copyIvarList([Person class], &amp;methodCount); for (unsigned int i = 0; i &lt; methodCount; i ++) &#123; Ivar ivar = ivars[i]; const char * name = ivar_getName(ivar); const char * type = ivar_getTypeEncoding(ivar); NSLog(@&quot;Person拥有的成员变量的类型为%s，名字为 %s &quot;,type, name); &#125; free(ivars);&#125; 打印结果如下： 2019-12-12 15:14:02.115744+0800 PersonRuntime[11576:1071364] Person拥有的成员变量的类型为@&quot;NSString&quot;，名字为 address 2019-12-12 15:14:02.115902+0800 PersonRuntime[11576:1071364] Person拥有的成员变量的类型为@&quot;NSString&quot;，名字为 _name 2019-12-12 15:14:02.115997+0800 PersonRuntime[11576:1071364] Person拥有的成员变量的类型为q，名字为 _age","categories":[],"tags":[{"name":"进阶","slug":"进阶","permalink":"http://nilsli.com/tags/%E8%BF%9B%E9%98%B6/"},{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"runtime","slug":"runtime","permalink":"http://nilsli.com/tags/runtime/"}]},{"title":"Flutter 深入学习","slug":"Flutter-beginer","date":"2019-10-31T10:00:19.000Z","updated":"2024-08-07T07:10:46.589Z","comments":true,"path":"p/2840.html","permalink":"http://nilsli.com/p/2840.html","excerpt":"引言Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。 1.快速开发毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。 2.富有表现力和灵活的UI快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。 3.原生性能Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。","text":"引言Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。 1.快速开发毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。 2.富有表现力和灵活的UI快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。 3.原生性能Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。 快速开发Flutter的热重载可帮助您快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以在亚秒内重载，并且不会丢失状态。 现代式，响应式框架使用Flutter的现代、响应式框架，和一系列基础widget，轻松构建您的用户界面。使用功能强大且灵活的API（针对2D、动画、手势、效果等）解决艰难的UI挑战。 示例代码： class CounterState extends State&lt;Counter&gt; &#123; int counter = 0; void increment() &#123; // 告诉Flutter state已经改变, Flutter会调用build()，更新显示 setState(() &#123; counter++; &#125;); &#125; Widget build(BuildContext context) &#123; // 当 setState 被调用时，这个方法都会重新执行. // Flutter 对此方法做了优化，使重新执行变的很快 // 所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget return new Row( children: &lt;Widget&gt;[ new RaisedButton( onPressed: increment, child: new Text(&#x27;Increment&#x27;), ), new Text(&#x27;Count: $counter&#x27;), ], ); &#125;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"Flutter","slug":"Flutter","permalink":"http://nilsli.com/tags/Flutter/"},{"name":"大前端，跨栈","slug":"大前端，跨栈","permalink":"http://nilsli.com/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF%EF%BC%8C%E8%B7%A8%E6%A0%88/"}]},{"title":"【译】产品经理vs项目经理：如何区别他们","slug":"pmvspm","date":"2019-08-23T07:16:02.000Z","updated":"2024-08-07T07:10:46.701Z","comments":true,"path":"p/56253.html","permalink":"http://nilsli.com/p/56253.html","excerpt":"（原链接在此）序言大公司和较大的团队常常存在许多战略部门与角色。因此，人们往往会对其中众多角色岗位一脸懵逼不足为奇。 不同的经理在团队中的关键职责是否那么容易区分呢？举个栗子，一个产品经理和项目经理的角色就有很多共同点。据说，这些经理中每一个人在他的生命中起码听过这样直接的问题：他们（产品经理、项目经理）有区别吗？不过，也别急着埋怨他们或者觉得难堪，就因为他们对这些职能弄不清楚。产品经理和项目经理是完全不同的角色。这篇文章的目标是定义清楚这两种在软件开发公司里的关键位置的区别，让你彻底甩掉疑惑。","text":"（原链接在此）序言大公司和较大的团队常常存在许多战略部门与角色。因此，人们往往会对其中众多角色岗位一脸懵逼不足为奇。 不同的经理在团队中的关键职责是否那么容易区分呢？举个栗子，一个产品经理和项目经理的角色就有很多共同点。据说，这些经理中每一个人在他的生命中起码听过这样直接的问题：他们（产品经理、项目经理）有区别吗？不过，也别急着埋怨他们或者觉得难堪，就因为他们对这些职能弄不清楚。产品经理和项目经理是完全不同的角色。这篇文章的目标是定义清楚这两种在软件开发公司里的关键位置的区别，让你彻底甩掉疑惑。 想象一下，你的组织需要进行人力资源优化以及一些人员裁减。如果你不得不决定团队里谁会留下，而谁该友好说再见。哪个经理你会选择留下？ 显然，做出选择并不容易。如果你被问到，说出谁对团队更重要，你肯定会发现难以回答。 这个问题有正确答案吗？让我们试着理清楚。 产品经理 vs 项目经理：谁的负担更重 产品 是你给客户或用户提出的最终结果。产品可以是可以触摸到的实物；也可能是软件平台或者服务。 项目 是一个包含着后续活动的计划。这些活动有设定好的启动和截止时间，以及一个结果。只有在最终结果达成后，项目才算完成。 举个栗子，你的产品是一个约会app。开发这个应用意味着不同的项目。其中一个是编写一个内容计划以及运行一个公司博客。这个项目有自己的截止时间和结束点。 比较两种角色最无聊（但并不正确！）的方式是去观察他们的薪资收入。下图显示了详细数据： 软件行业产品经理年收入（年份未知） IT行业产品项目经理年收入（年份未知） 产品经理和项目经理关键职能是什么？产品经理 在IT领域，产品经理负责管理软件开发。他们通常负责定义产品战略、功能有限顺序以及产品的最终交付上线。 他们负责创造想法和主动性来帮助实现战略和目标，促进内部和外部的相关部门交流；他们会访问潜在的和现有的客户，获取可能会对未来版本有帮助的反馈；他们也会和经销商一起工作，有成效地向用户展示产品细节；他们战略路线下工作，处理产品积压。 产品经理通常参加工业事件和会议，以停留在当前行业最前沿。因此，他们的核心职能列表如下： 产品战略 市场调研 期望与主动性 发布 损益问题 项目经理 在软件开发中行业，项目经理的职责与计划固定类型公司里的项目紧密相连。这些专家保证他们在正轨上运行，通过所有执行阶段，他们关心可能的制约和资源风险。 通常，他们较少关心具体的产品目标。他们分析所有的主动性和特性，来开发一个项目时间表。 作为一份工作，项目经理可能需要每天评估员工，他们的积极性来达成具体的目标。 项目经理管控项目知道他们完成，然后会评估要继续跟进的必要性。 他们的主要职责关联如下： 项目交付 资源 利用软件生命周期方法 状态更新 项目预算 产能 团队合作成功 问题解决方案 两种岗位可能的职业路线是什么？这些管理们毫无疑问的寻求职业成长。从一个工作（提升）到下一个水平的行动，需要坚强的经理技能和足够的经验。 典型的来说，产品经理李正成为高级产品经理或者产品管理负责人。项目经理们的职业路线通常说升级到高级项目经理和项目负责人角色。 在公司里哪一种角色更重要？如果你的公司同时需要产品经理和项目经理，那么组织结构上是完全合理的。如何定义，谁说更重要呢？ 可能，下面的问题会帮助你： 如果没有产品经理，团队能否运行良好？ 如果项目经理离开团队，会发生什么？ 很有可能，你的答案会显示两个角色都是重要且不可取代。他们的紧密合作是迈向成功的关键。 项目管理和产品管理工具选择项目管理和产品管理一个专业工具，需要考虑明确的公司需求、团队相关成员的数量、相关行业，以及其他的因素。 当下你可以尝试小型在线管理解决方案，它能满足经理们的必要需求。 一些流行的软件方案如Trello，Wrike, Hygger或Aha提供了所有产品管理和项目管理领域的强大的工具套装。 大部分这些工具会提供用户便利便利的tas面板（为看板和敏捷开发适配），跟踪系统，待办事项列表，确定优先事项，高级别评估，有用时间线，等等等等。 最后一句话让我们简单的总结一下上面提到的事情： 产品经理和项目经理角色可能被弄混，但他们是完全不同的。他们对于软件开发公司是同等重要。 产品经理驱动产品开发，主动性的工作，确定优先顺序以及制定战略决定。项目经理管控已经被开发和审批过的项目计划。 两个经理都需要专业管理软件来可视化和追踪产品和项目活动，并与团队通力合作。 你怎么区分项目和产品经理呢？哪些软件你尝试过，为什么？","categories":[],"tags":[{"name":"项目经理","slug":"项目经理","permalink":"http://nilsli.com/tags/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86/"},{"name":"产品经理","slug":"产品经理","permalink":"http://nilsli.com/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"},{"name":"IT","slug":"IT","permalink":"http://nilsli.com/tags/IT/"},{"name":"产品","slug":"产品","permalink":"http://nilsli.com/tags/%E4%BA%A7%E5%93%81/"},{"name":"项目","slug":"项目","permalink":"http://nilsli.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"iOS开发中的问题集锦","slug":"tips-on-swift","date":"2019-07-28T07:33:22.000Z","updated":"2024-08-07T07:10:46.734Z","comments":true,"path":"p/49163.html","permalink":"http://nilsli.com/p/49163.html","excerpt":"","text":"开发中难免遇到各式各样的小问题，平时收集一下，汇总如下，按Q（问题）和 A（解决方法）。 Q1遇到unable to index file详细内容： ​ 详细内容： unable to index file fatal: updating files failed A 解决： git reset HEAD qooxdoo Q2 hexo部署后，CNAME会被自动删除推送上去后，包含域名内容的CNAME 被删除，博客无法用域名解析。 A 解决： 出现这样的问题一般是CNAME 放在blog根目录下，正确是放在source 目录下。 然后执行 部署推送 hexo d -g 问题得到解决。 Q3 This copy of libswiftCore.dylib requires an OS version prior to 10.14.4.问题: 在掘金这篇文章, 尝试配置SPM，通过命令创建包时，执行swift run 后，出现如下问题 A 解决： cp -r /usr/lib/swift/*.dylib /Applications/Xcode.app/Contents/Frameworks Q4: Git 遇到了 early EOF index-pack failed$ git clone https://github.com/boostorg/boost.gitCloning into &#x27;boost&#x27;...remote: Counting objects: 183543, done.remote: Compressing objects: 100% (69361/69361), done.fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 解决： git config --add core.compression -1 ———————— 持续添加中","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"swift","slug":"swift","permalink":"http://nilsli.com/tags/swift/"},{"name":"小问题","slug":"小问题","permalink":"http://nilsli.com/tags/%E5%B0%8F%E9%97%AE%E9%A2%98/"},{"name":"git","slug":"git","permalink":"http://nilsli.com/tags/git/"}]},{"title":"【译】从阿波罗7号卫星上俯瞰加州南部","slug":"view-from-south-cali","date":"2019-07-24T07:03:19.000Z","updated":"2024-08-07T07:10:46.736Z","comments":true,"path":"p/21620.html","permalink":"http://nilsli.com/p/21620.html","excerpt":"","text":"这是从阿波罗7号上拍摄的加州南部的照片 图片来自 NASA 这片照片拍摄于1968年10月12日，由阿波罗7号航天器在执行它的绕地飞行第18圈时拍摄。拍摄时对地高度为124海里，加州海岸线上的穆古岬向南一直到欧申赛德，都能尽收眼底。透过云层，依稀能看见圣卡塔利娜岛屿。洛杉矶地区的近景则被从班宁市向西连绵100多英里直到马里海滩上空污染物所遮盖的模糊不清。在图片的上部（从左至右）能看见圣华金谷）在贝克斯菲尔德之外，特哈查比山脉,内华达山脉,欧文斯谷,死亡山谷以及莫哈韦沙漠。 阿波罗7号于1968年10月11日升空，被亲切称为”华尔特，华里和唐·修”, 是首次载人发射火箭计划。该计划在载人行动期间证明了指令&#x2F;服务仓任务模组技术、项目地面支援能力、阿波罗的空间交会能力，同时也实现了首次从太空进行实时电视直播。 原文链接","categories":[],"tags":[{"name":"NASA","slug":"NASA","permalink":"http://nilsli.com/tags/NASA/"},{"name":"太空","slug":"太空","permalink":"http://nilsli.com/tags/%E5%A4%AA%E7%A9%BA/"},{"name":"卫星","slug":"卫星","permalink":"http://nilsli.com/tags/%E5%8D%AB%E6%98%9F/"}]},{"title":"【译】SaaS发展历程","slug":"journey-of-SaaS","date":"2019-07-24T06:48:02.000Z","updated":"2024-08-07T07:10:46.655Z","comments":true,"path":"p/59473.html","permalink":"http://nilsli.com/p/59473.html","excerpt":"撰稿人：Neeraj Agrawal 梗概： 总结了成功的SaaS公司上市前的发展轨迹：找到 product-market fit，年入$200万（ARR），然后进入T2D3阶段 - 连续两年ARR翻三倍，然后连续三年翻两倍。ARR至少$1亿，然后上市。 所谓T2D3： 连续两年 triple（三倍），然后连续三年 double（两倍）。","text":"撰稿人：Neeraj Agrawal 梗概： 总结了成功的SaaS公司上市前的发展轨迹：找到 product-market fit，年入$200万（ARR），然后进入T2D3阶段 - 连续两年ARR翻三倍，然后连续三年翻两倍。ARR至少$1亿，然后上市。 所谓T2D3： 连续两年 triple（三倍），然后连续三年 double（两倍）。 原文【编者按】 作者 Neeraj Agrawal 是美国波斯顿著名科技行业投行 Batter Ventures 的一名普通合伙人。 “打造一个十亿级的SaaS企业软件公司需要怎么做？”，作为一个科技行业投资者，在从业一来，曾无数次被问到这个问题，然而很难回答。我敢打赌登山者们被问到他们到底如何征服山峦的主峰时，也会有同样的感受。问题的答案是一步步来——你不过是把一只脚从另一只脚前迈过去，当然——务实一点来讲，整个过程总是能分解成多个、清晰的步骤。 你不能在一天内翻越乞力马扎罗山，所以你也不可能迅速的弄出一套优秀的SaaS系统出来。相反的，你该将缩小焦点而且明确目标，接下来搞清楚下一步该怎样做，然后快速奔向目标。 “我的儿子在Battery Adventures工作” 我之所以开始思考在风险投资行业的工作和登山的相似性，要感谢一个意想不到的人：我的母亲。她和我的父亲在1960年代中期从当时还是英属的印度拉贾斯坦邦移居到皇后区（译注:纽约）。我的父母都是聪明，努力工作，务实的人，但他们都不理解他们的儿子在工作些什么。 我曾无数次的向我亲爱的、娇小的妈妈（她只有约1.5米高）描述我的工作，但她从没能清晰的记得我在做些什么。在最近的一次聚会上，她骄傲的告诉她的朋友：“我的儿子在Battery Adventures工作”。她的朋友笑了，因为他们对我不像我父亲一样是个医生，或者在大牌的银行——像高盛或是摩根斯坦利工作而倍感失望。 她的话引起我的思考。或许他把我的工作描述的比我认为的更好一些。或许思考如何建立一家公司最好的方式是去冒险，而非历险。而或许我在风投公司的角色就像一次冒险历程里的向导：是那些曾攀登过这座山很多次的那种人，事无巨细的了解攀登过程中的岩层与沟壑，能给足够勇敢的人提供指导来面对挑战。 我很荣幸曾在我15年风投任职生涯中，与许多世界级的创始人共事，其中包括许多B2B，SaaS企业软件公司，诸如Marketo、Omniture、Guidewire、Bazaarvoice以及Sprinklr（如需了解所有Battery 公司投资与撤出的详细清单，请点击这里）。 所以我从我个人的经历中分享一些故事和建议——姑且称之为“冒险”故事，作为向导来帮助那些里程碑上的企业者去到达他们的顶峰：估值十亿美元。 SaaS企业成功走向市场的7个阶段 我相信一个SaaS企业的走向市场会成功，会有7个关键阶段。大部分的阶段围绕这一个中心店，我称之为“三倍、三倍、两倍、两倍”（简称T2D3），反映一个公司的年度财报进展。 这并不是通往SaaS成功的唯一的步进之路，像Cornerstone、ExactTarget和SuccessFactors这样的公司他们所展示的一样，但是这是一条通往目标稳妥的路。每一个阶段需要不同的聚焦，比方说调整你的销售进程，发展你的团队和你的组织策略，以及国际上的扩张。 你会注意到我提到“市场进入策略”，因为SaaS公司发展中也有很多关键阶段。它们包含了选择合伙人、选择投资人、开发灵活的产品架构以及培养成功的企业文化，等等诸如此类。在这里，我们只着眼于“攀登”的技术。所以带上你的户外工具——我们要走向偏僻跑到，直奔顶峰了。 阶段1：达成一个伟大的产品-市场体系。 这包含了找到并且按重要性排列好消费者的通电，接着把你的产品准确指向这些痛点。很多创业者问我怎样知道他们实现了产品-市场体系。遗憾的是，没有确切的方法来测试证明。 我经常问一些特定行业的潜在消费者或者用户来描述他们的痛点。当我听到样本的稳定性时，我知道到位了。一旦产品成型，很容易来测试它是否让消费者觉得有对其帮助。– … 译制中，原链接在此","categories":[],"tags":[{"name":"创业","slug":"创业","permalink":"http://nilsli.com/tags/%E5%88%9B%E4%B8%9A/"},{"name":"SaaS","slug":"SaaS","permalink":"http://nilsli.com/tags/SaaS/"},{"name":"科技","slug":"科技","permalink":"http://nilsli.com/tags/%E7%A7%91%E6%8A%80/"}]},{"title":"如何在苹果AppStore 上下架应用","slug":"offline-app-from-app-store","date":"2018-07-24T07:46:11.000Z","updated":"2024-08-07T07:10:46.692Z","comments":true,"path":"p/51950.html","permalink":"http://nilsli.com/p/51950.html","excerpt":"序言：作为开发者，如何快捷的在苹果商店下架上架App，请看图吧如何下架1. 进入开发者中心 itunesConnect","text":"序言：作为开发者，如何快捷的在苹果商店下架上架App，请看图吧如何下架1. 进入开发者中心 itunesConnect 2. 选择相应的App 3. 如图，选择价格与销售范围—— 下架 4. 等等10分钟左右，再次搜索，此时AppStore 已经搜索不到该App了 此时的状态是： 重新上架1. 此时，也是选择 该应用的 价格与销售范围，选择【在所有地区供应】– 存储 2. 此时是立即上架，AppStore也是需要5-10分钟可以搜索到 就是这么简单，希望可以帮到你。","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"appstore","slug":"appstore","permalink":"http://nilsli.com/tags/appstore/"},{"name":"上架","slug":"上架","permalink":"http://nilsli.com/tags/%E4%B8%8A%E6%9E%B6/"},{"name":"下架","slug":"下架","permalink":"http://nilsli.com/tags/%E4%B8%8B%E6%9E%B6/"},{"name":"苹果商店","slug":"苹果商店","permalink":"http://nilsli.com/tags/%E8%8B%B9%E6%9E%9C%E5%95%86%E5%BA%97/"}]},{"title":"图解SDWebImage(读sdwebimage源码分析)","slug":"pic-of-sdwebimage","date":"2018-02-24T07:33:15.000Z","updated":"2024-08-07T07:10:46.695Z","comments":true,"path":"p/14198.html","permalink":"http://nilsli.com/p/14198.html","excerpt":"最近在看一些第三方库的源码，其中SDWebImage 尤其让人惊叹，尝试用XMind 画出原理，以后有机会， 会增加更多的细节图。 大纲如下：","text":"最近在看一些第三方库的源码，其中SDWebImage 尤其让人惊叹，尝试用XMind 画出原理，以后有机会， 会增加更多的细节图。 大纲如下： 图片缓存的实现如下： 以下为异步下载部分：","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"开发","slug":"开发","permalink":"http://nilsli.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"SDWebImage","slug":"SDWebImage","permalink":"http://nilsli.com/tags/SDWebImage/"}]},{"title":"通过Universal Link在微信页面中唤起原生App","slug":"wake-up-app-with-universal-link","date":"2017-06-24T07:39:05.000Z","updated":"2024-08-07T07:10:46.736Z","comments":true,"path":"p/7421.html","permalink":"http://nilsli.com/p/7421.html","excerpt":"因微信封杀，已失效，微信大刀威武！ 在某些电商项目，或者是社交媒体的分享页面中，我们经常会看到在页面的顶端或者底部遇到有【打开App】或者【下载App】这样的按钮。比较友好的产品经理，会做设备识别，以及检测APP是否安装，来做打开或者下载App 的需求。这些功能在Safari下使用location.href&#x3D;”scheme:&#x2F;&#x2F;example” 即可实现。但是在微信中，这方面做的比较恶心，微信下面几乎是全面屏蔽了唤起原生App 的功能，所有的启动都需要通过应用宝。 在iOS 9以后，苹果推出了Universal Link 这个概念，解决了使用A标签，以及iFrame 的弊端。WWDC2015 Session 509 有介绍,通过Universal Link，将App 与网页端建立连接桥，可以从Safari 或者其他前端浏览器来识别并唤醒App，甚至是微信环境下也可以冲破障碍。","text":"因微信封杀，已失效，微信大刀威武！ 在某些电商项目，或者是社交媒体的分享页面中，我们经常会看到在页面的顶端或者底部遇到有【打开App】或者【下载App】这样的按钮。比较友好的产品经理，会做设备识别，以及检测APP是否安装，来做打开或者下载App 的需求。这些功能在Safari下使用location.href&#x3D;”scheme:&#x2F;&#x2F;example” 即可实现。但是在微信中，这方面做的比较恶心，微信下面几乎是全面屏蔽了唤起原生App 的功能，所有的启动都需要通过应用宝。 在iOS 9以后，苹果推出了Universal Link 这个概念，解决了使用A标签，以及iFrame 的弊端。WWDC2015 Session 509 有介绍,通过Universal Link，将App 与网页端建立连接桥，可以从Safari 或者其他前端浏览器来识别并唤醒App，甚至是微信环境下也可以冲破障碍。 参考了苹果的原生介绍，做出了微信下唤醒自己的 App 效果如下： 实操如下服务器配置：准备独立域名。 一级域名，二级域名均可。 SSL 证书这里需要为服务器配置HTTPS 用的SSL 证书。 上传签名好的JSON 配置文件新建一个JSON文件，不需要后缀名，内容输入以下代码： &#123;&quot;applinks&quot;: &#123;&quot;apps&quot;: [],&quot;details&quot;: [&#123;&quot;appID&quot;: &quot;5B5Q4xxxx.com.xxxx.xxxx&quot;,&quot;paths&quot;: [ &quot;/html/1/*&quot;, &quot;/*&quot;]&#125;,]&#125;&#125; 这里的 appID 相关内容可以在Developer 中心找到相关的内容。如图，前半部分为Prefix 后半部分为ID，即你的App 的bundle id，两者通过.相连。 注意：这里的AppID中前半部分，在App 转让主体后会改变，需重新更新。 paths 则是用来唤醒App 所需要指定的JSON文件在服务器中的路径。用”&#x2F;* “ 是根目录，而&#x2F;html 则是指html目录下的。 填好后保存为apple-app-site-association 名，上传到域名指向的服务器根目录。 App配置： 在工程文件中，找到Targets - Capabilities - Associated Domains 将开关选为On，并添加你的域名，格式为applinks:你的域名.com iOS 移动端的代码配置 - (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123;if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb]) &#123;NSString *url = userActivity.webpageURL.description;// 这里可以通过拆分url 来传入参数，达到跳转原生页面的功能，如跳转某商品页[UIApplication sharedApplication] openURL:webpageURL];&#125;return YES;&#125; h5网页配置： h5网页中对需要唤起App 的按钮或者控件添加点击事件，事件的函数代码如下: function wakeUpApp()&#123;if (navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123;var loadDateTime = new Date();window.setTimeout(function() &#123;var timeOutDateTime = new Date();if (timeOutDateTime - loadDateTime &lt; 5000) &#123;window.location.href = &quot;http://a.app.qq.com/o/simple.jsp?pkgname=你的应用宝BundleID&quot;;&#125;else&#123;window.close();&#125;&#125;,25);window.location.href = &quot;https://yourdomainname.com/&quot;; &#125;else if (navigator.userAgent.match(/android/i)) &#123;var state = null;try &#123;state = window.open(&quot;apps custom url schemes &quot;, &#x27;_blank&#x27;);&#125; catch(e) &#123;&#125;if (state) &#123;window.close();&#125; else &#123;window.location.href = &quot;要跳转的页面URL&quot;;&#125;&#125;&#125; 注：代码中 yourdomainname.com 还可以后面添加 &#x2F;goodid&#x2F;123456 之类的属性id后缀，用来传递事件类型和id，方便移动端做更丰富的功能需求，比如通过goodid 识别要做的下一步动作是打开商品id 为123456 的商品详情页，等等。 配置完成，查看是否能唤起App，也可以通过如下图中，输入域名，长按来唤起App 做验证。 至此，大功告成。 值得注意的是，只能在iOS 9环境及以上实现该功能。iOS 8或者以下，只能采取老式的跳转至应用宝来实现。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"原生","slug":"原生","permalink":"http://nilsli.com/tags/%E5%8E%9F%E7%94%9F/"},{"name":"微信","slug":"微信","permalink":"http://nilsli.com/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"universallink","slug":"universallink","permalink":"http://nilsli.com/tags/universallink/"},{"name":"hyper","slug":"hyper","permalink":"http://nilsli.com/tags/hyper/"},{"name":"混合交互","slug":"混合交互","permalink":"http://nilsli.com/tags/%E6%B7%B7%E5%90%88%E4%BA%A4%E4%BA%92/"}]},{"title":"下棋","slug":"play-chess","date":"2016-03-24T07:52:01.000Z","updated":"2024-08-07T07:10:46.700Z","comments":true,"path":"p/31557.html","permalink":"http://nilsli.com/p/31557.html","excerpt":"","text":"在公园和大爷下象棋，有点紧张。走了第一步后，大爷沉默了很久说：“你是新手吧？”“大爷你怎么知道？”“我在这玩了几年，第一步走帅的真不多。”“不应该让领导先走吗？”","categories":[],"tags":[{"name":"休闲","slug":"休闲","permalink":"http://nilsli.com/tags/%E4%BC%91%E9%97%B2/"},{"name":"人生哲理","slug":"人生哲理","permalink":"http://nilsli.com/tags/%E4%BA%BA%E7%94%9F%E5%93%B2%E7%90%86/"}]}],"categories":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/categories/ios/"}],"tags":[{"name":"休闲","slug":"休闲","permalink":"http://nilsli.com/tags/%E4%BC%91%E9%97%B2/"},{"name":"数据结构","slug":"数据结构","permalink":"http://nilsli.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"http://nilsli.com/tags/%E6%A0%91/"},{"name":"二叉树","slug":"二叉树","permalink":"http://nilsli.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"霍夫曼树","slug":"霍夫曼树","permalink":"http://nilsli.com/tags/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91/"},{"name":"数据压缩","slug":"数据压缩","permalink":"http://nilsli.com/tags/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"},{"name":"线索化二叉树","slug":"线索化二叉树","permalink":"http://nilsli.com/tags/%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"opengl","slug":"opengl","permalink":"http://nilsli.com/tags/opengl/"},{"name":"metal","slug":"metal","permalink":"http://nilsli.com/tags/metal/"},{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"OpenGl","slug":"OpenGl","permalink":"http://nilsli.com/tags/OpenGl/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://nilsli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://nilsli.com/tags/OpenGL/"},{"name":"进阶","slug":"进阶","permalink":"http://nilsli.com/tags/%E8%BF%9B%E9%98%B6/"},{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"离屏渲染","slug":"离屏渲染","permalink":"http://nilsli.com/tags/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"},{"name":"offscreen","slug":"offscreen","permalink":"http://nilsli.com/tags/offscreen/"},{"name":"音频","slug":"音频","permalink":"http://nilsli.com/tags/%E9%9F%B3%E9%A2%91/"},{"name":"视频","slug":"视频","permalink":"http://nilsli.com/tags/%E8%A7%86%E9%A2%91/"},{"name":"音视频","slug":"音视频","permalink":"http://nilsli.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"block","slug":"block","permalink":"http://nilsli.com/tags/block/"},{"name":"原理","slug":"原理","permalink":"http://nilsli.com/tags/%E5%8E%9F%E7%90%86/"},{"name":"平衡二叉树","slug":"平衡二叉树","permalink":"http://nilsli.com/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"AVL","slug":"AVL","permalink":"http://nilsli.com/tags/AVL/"},{"name":"二分法","slug":"二分法","permalink":"http://nilsli.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"斐波那契","slug":"斐波那契","permalink":"http://nilsli.com/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"},{"name":"插值","slug":"插值","permalink":"http://nilsli.com/tags/%E6%8F%92%E5%80%BC/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://nilsli.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"图","slug":"图","permalink":"http://nilsli.com/tags/%E5%9B%BE/"},{"name":"拓扑","slug":"拓扑","permalink":"http://nilsli.com/tags/%E6%8B%93%E6%89%91/"},{"name":"多线程","slug":"多线程","permalink":"http://nilsli.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"锁","slug":"锁","permalink":"http://nilsli.com/tags/%E9%94%81/"},{"name":"算法","slug":"算法","permalink":"http://nilsli.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"KMP","slug":"KMP","permalink":"http://nilsli.com/tags/KMP/"},{"name":"字符串查找","slug":"字符串查找","permalink":"http://nilsli.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE/"},{"name":"RK","slug":"RK","permalink":"http://nilsli.com/tags/RK/"},{"name":"BF","slug":"BF","permalink":"http://nilsli.com/tags/BF/"},{"name":"字符查找","slug":"字符查找","permalink":"http://nilsli.com/tags/%E5%AD%97%E7%AC%A6%E6%9F%A5%E6%89%BE/"},{"name":"去重","slug":"去重","permalink":"http://nilsli.com/tags/%E5%8E%BB%E9%87%8D/"},{"name":"启动优化","slug":"启动优化","permalink":"http://nilsli.com/tags/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"},{"name":"调优","slug":"调优","permalink":"http://nilsli.com/tags/%E8%B0%83%E4%BC%98/"},{"name":"队列","slug":"队列","permalink":"http://nilsli.com/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"http://nilsli.com/tags/%E6%A0%88/"},{"name":"线性表","slug":"线性表","permalink":"http://nilsli.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"链表","slug":"链表","permalink":"http://nilsli.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"线程","slug":"线程","permalink":"http://nilsli.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"http://nilsli.com/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"GCD","slug":"GCD","permalink":"http://nilsli.com/tags/GCD/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82/"},{"name":"KVO","slug":"KVO","permalink":"http://nilsli.com/tags/KVO/"},{"name":"循环","slug":"循环","permalink":"http://nilsli.com/tags/%E5%BE%AA%E7%8E%AF/"},{"name":"KVC","slug":"KVC","permalink":"http://nilsli.com/tags/KVC/"},{"name":"理论","slug":"理论","permalink":"http://nilsli.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"基础","slug":"基础","permalink":"http://nilsli.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/%E7%B1%BB/"},{"name":"加载","slug":"加载","permalink":"http://nilsli.com/tags/%E5%8A%A0%E8%BD%BD/"},{"name":"load","slug":"load","permalink":"http://nilsli.com/tags/load/"},{"name":"底层，源码，懒加载，分类","slug":"底层，源码，懒加载，分类","permalink":"http://nilsli.com/tags/%E5%BA%95%E5%B1%82%EF%BC%8C%E6%BA%90%E7%A0%81%EF%BC%8C%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%8C%E5%88%86%E7%B1%BB/"},{"name":"2020","slug":"2020","permalink":"http://nilsli.com/tags/2020/"},{"name":"runtime","slug":"runtime","permalink":"http://nilsli.com/tags/runtime/"},{"name":"面试","slug":"面试","permalink":"http://nilsli.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"成员变量","slug":"成员变量","permalink":"http://nilsli.com/tags/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"Class","slug":"Class","permalink":"http://nilsli.com/tags/Class/"},{"name":"dyld","slug":"dyld","permalink":"http://nilsli.com/tags/dyld/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/%E7%BB%93%E6%9E%84/"},{"name":"消息转发","slug":"消息转发","permalink":"http://nilsli.com/tags/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"},{"name":"objc","slug":"objc","permalink":"http://nilsli.com/tags/objc/"},{"name":"杭州","slug":"杭州","permalink":"http://nilsli.com/tags/%E6%9D%AD%E5%B7%9E/"},{"name":"西湖","slug":"西湖","permalink":"http://nilsli.com/tags/%E8%A5%BF%E6%B9%96/"},{"name":"Apple","slug":"Apple","permalink":"http://nilsli.com/tags/Apple/"},{"name":"msgSend","slug":"msgSend","permalink":"http://nilsli.com/tags/msgSend/"},{"name":"cache_t","slug":"cache-t","permalink":"http://nilsli.com/tags/cache-t/"},{"name":"感想","slug":"感想","permalink":"http://nilsli.com/tags/%E6%84%9F%E6%83%B3/"},{"name":"对齐","slug":"对齐","permalink":"http://nilsli.com/tags/%E5%AF%B9%E9%BD%90/"},{"name":"内存","slug":"内存","permalink":"http://nilsli.com/tags/%E5%86%85%E5%AD%98/"},{"name":"alloc","slug":"alloc","permalink":"http://nilsli.com/tags/alloc/"},{"name":"Flutter","slug":"Flutter","permalink":"http://nilsli.com/tags/Flutter/"},{"name":"大前端，跨栈","slug":"大前端，跨栈","permalink":"http://nilsli.com/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF%EF%BC%8C%E8%B7%A8%E6%A0%88/"},{"name":"项目经理","slug":"项目经理","permalink":"http://nilsli.com/tags/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86/"},{"name":"产品经理","slug":"产品经理","permalink":"http://nilsli.com/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"},{"name":"IT","slug":"IT","permalink":"http://nilsli.com/tags/IT/"},{"name":"产品","slug":"产品","permalink":"http://nilsli.com/tags/%E4%BA%A7%E5%93%81/"},{"name":"项目","slug":"项目","permalink":"http://nilsli.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"swift","slug":"swift","permalink":"http://nilsli.com/tags/swift/"},{"name":"小问题","slug":"小问题","permalink":"http://nilsli.com/tags/%E5%B0%8F%E9%97%AE%E9%A2%98/"},{"name":"git","slug":"git","permalink":"http://nilsli.com/tags/git/"},{"name":"NASA","slug":"NASA","permalink":"http://nilsli.com/tags/NASA/"},{"name":"太空","slug":"太空","permalink":"http://nilsli.com/tags/%E5%A4%AA%E7%A9%BA/"},{"name":"卫星","slug":"卫星","permalink":"http://nilsli.com/tags/%E5%8D%AB%E6%98%9F/"},{"name":"创业","slug":"创业","permalink":"http://nilsli.com/tags/%E5%88%9B%E4%B8%9A/"},{"name":"SaaS","slug":"SaaS","permalink":"http://nilsli.com/tags/SaaS/"},{"name":"科技","slug":"科技","permalink":"http://nilsli.com/tags/%E7%A7%91%E6%8A%80/"},{"name":"appstore","slug":"appstore","permalink":"http://nilsli.com/tags/appstore/"},{"name":"上架","slug":"上架","permalink":"http://nilsli.com/tags/%E4%B8%8A%E6%9E%B6/"},{"name":"下架","slug":"下架","permalink":"http://nilsli.com/tags/%E4%B8%8B%E6%9E%B6/"},{"name":"苹果商店","slug":"苹果商店","permalink":"http://nilsli.com/tags/%E8%8B%B9%E6%9E%9C%E5%95%86%E5%BA%97/"},{"name":"开发","slug":"开发","permalink":"http://nilsli.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"SDWebImage","slug":"SDWebImage","permalink":"http://nilsli.com/tags/SDWebImage/"},{"name":"原生","slug":"原生","permalink":"http://nilsli.com/tags/%E5%8E%9F%E7%94%9F/"},{"name":"微信","slug":"微信","permalink":"http://nilsli.com/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"universallink","slug":"universallink","permalink":"http://nilsli.com/tags/universallink/"},{"name":"hyper","slug":"hyper","permalink":"http://nilsli.com/tags/hyper/"},{"name":"混合交互","slug":"混合交互","permalink":"http://nilsli.com/tags/%E6%B7%B7%E5%90%88%E4%BA%A4%E4%BA%92/"},{"name":"人生哲理","slug":"人生哲理","permalink":"http://nilsli.com/tags/%E4%BA%BA%E7%94%9F%E5%93%B2%E7%90%86/"}]}