<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【数据结构与算法】-双向链表和双向循环链表</title>
      <link href="/p/56790.html"/>
      <url>/p/56790.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】-循环链表(单向)</title>
      <link href="/p/54688.html"/>
      <url>/p/54688.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><blockquote><p>将单链表中终点结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相连的单链表称为单循环链表，简称循环链表（<em>circular linked list</em>）。</p></blockquote><p>我们先讨论的是单向循环链表，示意图如下所示:</p><p><img src="/p/54688/001.png" alt="单向循环链表结构图"></p><h3 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h3><h4 id="2-1-创建单向循环链表"><a href="#2-1-创建单向循环链表" class="headerlink" title="2.1 创建单向循环链表"></a>2.1 创建单向循环链表</h4><p>创建逻辑主要有下面的步骤:</p><p>先判断是否<strong>第一次</strong>创建？</p><ol><li>是（空链表）：创建一个结点，使新结点next 指向自身</li><li>否：使尾节点的next=新节点。新节点的next指向头节点</li></ol><p>下面用代码解释一下：</p><ol><li><p>先定义一个结点(结构体)，定一个别名：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//定义结点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Node<span class="token punctuation">{</span>   ElemType data<span class="token punctuation">;</span>   <span class="token keyword">struct</span> Node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Node <span class="token operator">*</span> LinkList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建一些变量，以供环境使用：</p><pre class="line-numbers language-c"><code class="language-c">Status <span class="token function">CreateList</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">int</span> item<span class="token punctuation">;</span>   LinkList temp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   LinkList target <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>接下来判断这个链表<code>*L</code> 是否为空：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>如果输入的链表是空的</strong>——则创建一个结点，使它的<code>next</code>指向自己：</p><pre class="line-numbers language-c"><code class="language-c">Status <span class="token function">CreateList</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入节点的值，输入0结束\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//如果输入的链表是空。则创建一个新的节点，使其next指针指向自己  (*head)->next=*head;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span>           <span class="token operator">*</span>L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">)</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-></span>data<span class="token operator">=</span>item<span class="token punctuation">;</span>           <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-></span>next<span class="token operator">=</span><span class="token operator">*</span>L<span class="token punctuation">;</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>如果链表不为空</strong>——则去<strong>寻找链表的尾结点</strong>。</p><p>这里寻找尾结点可以有两种实现方式：</p><ol><li><p>遍历尾结点，根据<strong>尾结点指针会指向首元结点</strong>来定位到尾结点。</p><ul><li>1、使得尾结点的next 指向新结点。</li><li>2、新结点的next 指向头结点。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">else</span><span class="token punctuation">{</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span>target <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span> target<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span> target <span class="token operator">=</span> target<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 为新结点开辟内存空间            </span>       temp<span class="token operator">=</span><span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 如开辟失败，返回错误            </span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>temp<span class="token punctuation">)</span> <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 新结点写入数据            </span>       temp<span class="token operator">-></span>data<span class="token operator">=</span>item<span class="token punctuation">;</span>       temp<span class="token operator">-></span>next<span class="token operator">=</span><span class="token operator">*</span>L<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//新节点指向头节点</span>       target<span class="token operator">-></span>next<span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//尾节点指向新节点</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建一个工具结点<code>r</code>，用它来灵活处理以后一个结点（<strong>后插法</strong>）</p><ol><li><p>新建一个 <code>r</code></p><pre class="line-numbers language-c"><code class="language-c">  LinkList r <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在该链表创建时，将唯一的结点赋值给<code>r</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//第一次创建</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>L <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token operator">*</span>L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-></span>data <span class="token operator">=</span> item<span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-></span>next <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span> r <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建新的结点，进行赋值，<code>next</code>指向原链表首结点</p><pre class="line-numbers language-c"><code class="language-c">temp <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>temp<span class="token punctuation">)</span> <span class="token keyword">return</span>  ERROR<span class="token punctuation">;</span>temp<span class="token operator">-></span>data <span class="token operator">=</span> item<span class="token punctuation">;</span>temp<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>把原最后一个结点的尾结点指向新结点，以及新结点赋值给工具结点<code>r</code></p><pre class="line-numbers language-c"><code class="language-c">r<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>这样，闭环完成，整个过程示意图可以用下面的图实现：</p></li></ol><p><img src="/p/54688/002.png" alt></p></li></ol><h4 id="2-2-单向循环链表插入数据"><a href="#2-2-单向循环链表插入数据" class="headerlink" title="2.2 单向循环链表插入数据"></a>2.2 单向循环链表插入数据</h4><p>分两种情况，插入点是否为首元结点</p><h5 id="2-2-1-插入点位首元结点"><a href="#2-2-1-插入点位首元结点" class="headerlink" title="2.2.1 插入点位首元结点"></a>2.2.1 插入点位首元结点</h5><ol><li>创建新结点并进行赋值</li><li>找到链表最后的结点——尾结点</li><li>让新结点的<code>next</code> 指向头结点</li><li>让尾结点的 <code>next</code> 指向新的头结点</li><li>让头结点指向<code>temp</code> ——临时的新结点</li></ol><p>具体代码实现如下：</p><pre class="line-numbers language-c"><code class="language-c">temp <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token punctuation">}</span>temp<span class="token operator">-></span>data <span class="token operator">=</span> num<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>target <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span> target<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span> target <span class="token operator">=</span> target<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>temp<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span>target<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token operator">*</span>L <span class="token operator">=</span> temp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如图所示：<br><img src="/p/54688/003.png" alt></p><h5 id="2-2-2-插入点非首元结点"><a href="#2-2-2-插入点非首元结点" class="headerlink" title="2.2.2 插入点非首元结点"></a>2.2.2 插入点非首元结点</h5><ol><li>创建新结点 <code>temp</code>，并判断成功与否</li><li>找到插入的位置，如果超过链表长度，则自动插入队尾</li><li>通过工具<code>target</code> 找到要插入位置的前一个结点，让 <code>target-&gt;next = temp</code></li><li>插入结点的前一个结点<code>next</code> 指向新结点，新结点<code>next</code>指向<code>target</code>原来的next 位</li></ol><p>具体代码实现如下：</p><pre class="line-numbers language-c"><code class="language-c">temp <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token punctuation">}</span>temp<span class="token operator">-></span>data <span class="token operator">=</span> num<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>target <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span> target<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token operator">*</span>L <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> place <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> target <span class="token operator">=</span> target<span class="token operator">-></span>next<span class="token punctuation">,</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>temp<span class="token operator">-></span>next <span class="token operator">=</span> target<span class="token operator">-></span>next<span class="token punctuation">;</span>target<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/p/54688/004.png" alt></p><h4 id="2-3-单向循环链表的删除"><a href="#2-3-单向循环链表的删除" class="headerlink" title="2.3 单向循环链表的删除"></a>2.3 单向循环链表的删除</h4><p>单向循环链表的删除，与顺序表的删除很类似，步骤都是先确定需要删除的位置，通过判断是否首元结点，做不同的操作。具体操作步骤如下：</p><h5 id="2-3-1-删除点为首元结点"><a href="#2-3-1-删除点为首元结点" class="headerlink" title="2.3.1 删除点为首元结点"></a>2.3.1 删除点为首元结点</h5><ul><li><p>如果本链表只剩首元结点，则直接将*L 置为空；</p><p>实施代码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-></span>next <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果本链表还剩其他结点</p><ol><li>找到尾结点 <code>target</code></li><li>尾结点 <code>next</code> 指向原来首元结点的下一个结点，即 <code>target-&gt;next = (*L)-&gt;next</code></li><li>用 <code>temp</code> 临时接收首元结点</li><li>新结点为首元结点</li><li>释放之前的接收的首元结点 <code>temp</code></li></ol><p>实施代码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 步骤 1⃣️</span><span class="token keyword">for</span> <span class="token punctuation">(</span>target <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span> target<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span> target <span class="token operator">=</span> target<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 步骤 2⃣️</span>temp <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 步骤 3⃣️</span><span class="token operator">*</span>L <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 步骤 4⃣️</span>target<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 步骤 5⃣️</span><span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><img src="/p/54688/005.png" alt></p><h5 id="2-3-2-删除点为非首元结点"><a href="#2-3-2-删除点为非首元结点" class="headerlink" title="2.3.2 删除点为非首元结点"></a>2.3.2 删除点为非首元结点</h5><ol><li>找到需要删除结点的上一个结点，用<code>target</code>表示</li><li>用<code>temp</code>临时接受需要删除的结点</li><li><code>target</code> 的<code>next</code> 指之前指向的下一个结点</li><li>释放<code>temp</code>结点</li></ol><p>实施代码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 步骤 1⃣️</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>target <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span>target<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token operator">*</span>L <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> place <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>target <span class="token operator">=</span> target<span class="token operator">-></span>next<span class="token punctuation">,</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 步骤 2⃣️</span>temp <span class="token operator">=</span> target<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 步骤 3⃣️</span>target<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 步骤 4⃣️</span><span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示意图如下：</p><p><img src="/p/54688/006.png" alt></p><h4 id="2-4-单向链表的查询"><a href="#2-4-单向链表的查询" class="headerlink" title="2.4 单向链表的查询"></a>2.4 单向链表的查询</h4><p>这里仅仅讨论下简单的链表查询，步骤如下：</p><ol><li>循环查找链表中给定值的结点</li><li>若查询的结点指向首元结点，并且此时尾结点值也不为所需，跳出</li></ol><p>实施代码如下：</p><pre class="line-numbers language-c"><code class="language-c">      <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    LinkList p<span class="token punctuation">;</span>    p <span class="token operator">=</span> L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1⃣️ 寻找链表中的结点 data == value</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">!=</span> value <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>next <span class="token operator">!=</span> L<span class="token punctuation">)</span> <span class="token punctuation">{</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2⃣️ 当尾结点指向头结点就会直接跳出循环,所以要额外增加一次判断尾结点的data == value;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">==</span> L <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>data <span class="token operator">!=</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h3><p>单向循环链表与顺序表有些许相似，但是不同点在于，它并非是按照序号排列，而是通过<strong>指针的指向</strong>进行连接，而且有首尾相连的特点。</p>]]></content>
      
      
      <categories>
          
          <category> ios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】- 线性表基础</title>
      <link href="/p/43366.html"/>
      <url>/p/43366.html</url>
      
        <content type="html"><![CDATA[<h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p>上文学到了数据结构和算法的一些基础知识，接下来从最基础的概念，线性表说起。</p><h2 id="一、线性表的定义和特点"><a href="#一、线性表的定义和特点" class="headerlink" title="一、线性表的定义和特点"></a>一、线性表的定义和特点</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><blockquote><p>定义：零个或多个数据元素的有限序列</p></blockquote><p>线性表，顾名思义，就是有着和线一样特性的表。比如我们乘坐的火车，通常是由许多节车厢组成，车厢首尾相连，最终形成一辆火车。这样的结构，就可以成为线性表。</p><h3 id="1-2-线性表的抽象数据类型"><a href="#1-2-线性表的抽象数据类型" class="headerlink" title="1.2 线性表的抽象数据类型"></a>1.2 线性表的抽象数据类型</h3><p>线性表的抽象类型定义如下：</p><pre><code>ADT 线性表（List）Data：线性表的数据对象集合为{a1,a2,......an},每个元素的类型均为DataType. 其中,除了第一个元素a1外,每一个元素有且只有一个直接前驱元素,除了最后一个元素an外,每个元素有且只有一个直接后继元素. 数据元素之间的关系是一对一的关系.Operation    InitList(*L) :        初始化操作，建立一个空的线性表L&lt;sub&gt;0&lt;/sub&gt;    ListEmpty(L) :    若线性表已存在，返回`true`; 否则返回`false`    ClearList(*L):     将线性表清空    GetElem(L, i, &amp;e): 将线性表L 中的第 i 个位置元素值返回给 e    LocateElm（L，e）：在线性表L 中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回 0 表示失败    ListInsert(*L, i, e): 在线性表L 中第 i 个位置插入新元素e    ListDelete(*L, i, *e): 删除线性表L 中第 i 个位置元素，并用 e 返回其值    ListLength(L):    返回线性表L 的元素个数endADT</code></pre><h3 id="1-3-线性表的顺序存储结构"><a href="#1-3-线性表的顺序存储结构" class="headerlink" title="1.3 线性表的顺序存储结构"></a>1.3 线性表的顺序存储结构</h3><h4 id="1-3-1-顺序存储定义"><a href="#1-3-1-顺序存储定义" class="headerlink" title="1.3.1 顺序存储定义"></a>1.3.1 顺序存储定义</h4><p>先来看看线性表两种物理结构的第一种：顺序存储结构</p><blockquote><p>定义：线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p></blockquote><p>示意图如下：</p><p><img src="/p/43366/001.png" alt="顺序存储示意图"> </p><h4 id="1-3-2-顺序存储方式"><a href="#1-3-2-顺序存储方式" class="headerlink" title="1.3.2 顺序存储方式"></a>1.3.2 顺序存储方式</h4><p>线性表的顺序存储结构，就是在内存中找了个空间，通过展位的方式，把一定内存空间给占了，然后把相同数据类型的数据元素一次存放在这块空地中。既然线性表的每个数据元素类型都相同，所以可以用C 语言的一维数组来实现顺序存储结构。</p><p>看看线性表的顺序存储的结构</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MAXSIZE 20</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>        ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span>Sqlist<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过观察可以发现，描述顺序存储结构需要三个属性：</p><ul><li>存储空间的起始位置：数组<code>data</code>，它的存储位置就是存储空间的存储位置。</li><li>线性表的最大存储容量：数组长度<code>MaxSize</code></li><li>线性表的当前长度: <code>length</code></li></ul><h4 id="1-3-3-数据长度与线性表长度区别"><a href="#1-3-3-数据长度与线性表长度区别" class="headerlink" title="1.3.3 数据长度与线性表长度区别"></a>1.3.3 数据长度与线性表长度区别</h4><ul><li>数组长度时存放线性表的存储空间的长度，存储分配后这个量<strong>一般是不变的</strong>。</li><li>线性表的长度时线性表中数据元素的个数，随着线性表的插入和删除操作的进行，这个量<strong>是变化的</strong>。</li><li>在任意时刻，线性表的长度应该<strong>小于等于</strong>数组的长度。</li></ul><h3 id="1-4-顺序表的基本操作"><a href="#1-4-顺序表的基本操作" class="headerlink" title="1.4 顺序表的基本操作"></a>1.4 顺序表的基本操作</h3><h4 id="1-4-1-顺序表的初始化"><a href="#1-4-1-顺序表的初始化" class="headerlink" title="1.4.1 顺序表的初始化"></a>1.4.1 顺序表的初始化</h4><pre class="line-numbers language-c"><code class="language-c">Status <span class="token function">InitList</span><span class="token punctuation">(</span>Sqlist <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//为顺序表分配一个大小为MAXSIZE 的数组空间</span>    L<span class="token operator">-></span>data <span class="token operator">=</span>  <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span> <span class="token operator">*</span> MAXSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//存储分配失败退出</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span>ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//空表长度为0</span>    L<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-2-顺序表的插入"><a href="#1-4-2-顺序表的插入" class="headerlink" title="1.4.2 顺序表的插入"></a>1.4.2 顺序表的插入</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L); 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span>Status <span class="token function">ListInsert</span><span class="token punctuation">(</span>Sqlist <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//i值不合法判断</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>i<span class="token operator">></span>L<span class="token operator">-></span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//存储空间已满</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>length <span class="token operator">==</span> MAXSIZE<span class="token punctuation">)</span> <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入数据不在表尾,则先移动出空余位置</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> L<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token operator">-></span>length<span class="token number">-1</span><span class="token punctuation">;</span> j<span class="token operator">>=</span>i<span class="token number">-1</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//插入位置以及之后的位置后移动1位</span>            L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//将新元素e 放入第i个位置上</span>    L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//长度+1;</span>    <span class="token operator">++</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-3-顺序表的取值"><a href="#1-4-3-顺序表的取值" class="headerlink" title="1.4.3 顺序表的取值"></a>1.4.3 顺序表的取值</h4><pre class="line-numbers language-c"><code class="language-c">Status <span class="token function">GetElem</span><span class="token punctuation">(</span>Sqlist L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//判断i值是否合理, 若不合理,返回ERROR</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">></span> L<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span>  ERROR<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//data[i-1]单元存储第i个数据元素.</span>    <span class="token operator">*</span>e <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-3-顺序表的删除"><a href="#1-4-3-顺序表的删除" class="headerlink" title="1.4.3 顺序表的删除"></a>1.4.3 顺序表的删除</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) 操作结果: 删除L的第i个数据元素,L的长度减1 */</span>Status <span class="token function">ListDelete</span><span class="token punctuation">(</span>Sqlist <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//线性表为空</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//i值不合法判断</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>i<span class="token operator">></span>L<span class="token operator">-></span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//被删除元素之后的元素向前移动</span>        L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//表长度-1;</span>    L<span class="token operator">-></span>length <span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-5-清空顺序表"><a href="#1-4-5-清空顺序表" class="headerlink" title="1.4.5 清空顺序表"></a>1.4.5 清空顺序表</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */</span>Status <span class="token function">ClearList</span><span class="token punctuation">(</span>Sqlist <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>    L<span class="token operator">-></span>length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-6-判断顺序表清空"><a href="#1-4-6-判断顺序表清空" class="headerlink" title="1.4.6 判断顺序表清空"></a>1.4.6 判断顺序表清空</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 初始条件：顺序线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */</span>Status <span class="token function">ListEmpty</span><span class="token punctuation">(</span>Sqlist L<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-7-获取顺序表长度"><a href="#1-4-7-获取顺序表长度" class="headerlink" title="1.4.7 获取顺序表长度"></a>1.4.7 获取顺序表长度</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* ListEmpty元素个数 */</span><span class="token keyword">int</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>Sqlist L<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-8-顺序输出List"><a href="#1-4-8-顺序输出List" class="headerlink" title="1.4.8 顺序输出List"></a>1.4.8 顺序输出List</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 初始条件：顺序线性表L已存在 */</span><span class="token comment" spellcheck="true">/* 操作结果：依次对L的每个数据元素输出 */</span>Status <span class="token function">TraverseList</span><span class="token punctuation">(</span>Sqlist L<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-9-顺序表查找元素并返回位置"><a href="#1-4-9-顺序表查找元素并返回位置" class="headerlink" title="1.4.9 顺序表查找元素并返回位置"></a>1.4.9 顺序表查找元素并返回位置</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 初始条件：顺序线性表L已存在 */</span><span class="token comment" spellcheck="true">/* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 */</span><span class="token comment" spellcheck="true">/* 若这样的数据元素不存在，则返回值为0 */</span><span class="token keyword">int</span> <span class="token function">LocateElem</span><span class="token punctuation">(</span>Sqlist L<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>e<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-顺序存储结构表的优缺点"><a href="#1-5-顺序存储结构表的优缺点" class="headerlink" title="1.5 顺序存储结构表的优缺点"></a>1.5 顺序存储结构表的优缺点</h3><ul><li><strong>优点</strong><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li><li>可以快速地存取表中任意位置的元素</li></ul></li><li><strong>缺点</strong><ul><li>插入和删除操作需要移动大量元素</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的“碎片”</li></ul></li></ul><h3 id="1-5-线性表的链式存储结构"><a href="#1-5-线性表的链式存储结构" class="headerlink" title="1.5 线性表的链式存储结构"></a>1.5 线性表的链式存储结构</h3><h4 id="1-5-1-定义"><a href="#1-5-1-定义" class="headerlink" title="1.5.1 定义"></a>1.5.1 定义</h4><p>上文提到，顺序存储结构哦的线性表，最大的特点就是插入和删除时，需要移动大量元素，这显然需要耗费时间。</p><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的人一位置。</p><p><img src="/p/43366/002.png" alt></p><p>以前在顺序结构中，每个数据元素只要存数据元素信息就可以了。现在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。</p><ul><li><p>我们把存储数据元素信息的域成为<strong>数据域</strong>。</p></li><li><p>把存储直接后继位置的域称为<strong>指针域</strong>。</p></li><li><p>指针域中存储的信息称做<strong>指针</strong>或<strong>链</strong>，这两部分信息组成数据元素的存储映像，称为<strong>结点</strong>（Node）</p></li><li><p>n个结点链接成一个链表，成为线性表的链式存储结构，因为此链表的每个节点中只包含一个指针域，所以叫<strong>单链表</strong>。</p></li><li><p>链表中第一个结点的存储位置叫做<strong>头指针</strong>。</p></li><li><p>单链表的第一个结点前附设一个结点，称为<strong>头结点</strong>。</p></li></ul><p><img src="/p/43366/003.png" alt></p><p>而单链表的逻辑结构如下:</p><p><img src="/p/43366/004.png" alt></p><h4 id="1-5-2-头指针与头结点的异同"><a href="#1-5-2-头指针与头结点的异同" class="headerlink" title="1.5.2 头指针与头结点的异同"></a>1.5.2 头指针与头结点的异同</h4><table><thead><tr><th>头指针</th><th>头结点</th></tr></thead><tbody><tr><td>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</td><td>头结点是为了操作的统一和方便设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</td></tr><tr><td>头指针具有标示作用，所以常用头指针冠以链表的名字</td><td>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了</td></tr><tr><td>无论链表是否为空，头指针均不为空。头指针式链表的必要元素</td><td>头结点不一定是链表必须要素</td></tr></tbody></table><h5 id="1-5-3-为什么要添加头结点"><a href="#1-5-3-为什么要添加头结点" class="headerlink" title="1.5.3 为什么要添加头结点"></a>1.5.3 为什么要添加头结点</h5><ul><li>便于首元结点处理</li><li>便于空表和非空表的统一处理</li></ul><h3 id="1-6-单链表"><a href="#1-6-单链表" class="headerlink" title="1.6 单链表"></a>1.6 单链表</h3><h4 id="1-6-1-单链表取值"><a href="#1-6-1-单链表取值" class="headerlink" title="1.6.1 单链表取值"></a>1.6.1 单链表取值</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//2.3 单链表取值</span><span class="token comment" spellcheck="true">/* 初始条件: 顺序线性表L已存在,1≤i≤ListLength(L); 操作结果：用e返回L中第i个数据元素的值 */</span>Status <span class="token function">GetElem</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//j: 计数.</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//声明结点p;</span>    LinkList p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将结点p 指向链表L的第一个结点;</span>    p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//j计算=1;</span>    j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p不为空,且计算j不等于i,则循环继续</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//p指向下一个结点</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token operator">++</span>j<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果p为空或者j>i,则返回error</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p <span class="token operator">||</span> j <span class="token operator">></span> i<span class="token punctuation">)</span> <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//e = p所指的结点的data</span>    <span class="token operator">*</span>e <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-6-2-单链表的插入"><a href="#1-6-2-单链表的插入" class="headerlink" title="1.6.2 单链表的插入"></a>1.6.2 单链表的插入</h4><p>单链表的插入操作，分为两种：</p><h5 id="1-6-2-1-前插法"><a href="#1-6-2-1-前插法" class="headerlink" title="1.6.2.1 前插法"></a>1.6.2.1 前插法</h5><p>将新结点插入在链表头结点前面，成为前插法</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 随机产生n个元素值,建立带表头结点的单链线性表L(前插法)*/</span><span class="token keyword">void</span> <span class="token function">CreateListHead</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    LinkList p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//建立1个带头结点的单链表</span>    <span class="token operator">*</span>L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//循环前插入随机数据</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//生成新结点</span>        p <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//i赋值给新结点的data</span>        p<span class="token operator">-></span>data <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//p->next = 头结点的L->next</span>        p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将结点P插入到头结点之后;</span>        <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c">    <span class="token comment" spellcheck="true">//3.1 前插法整理创建链表L</span>    iStatus <span class="token operator">=</span> <span class="token function">ClearList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CreateListHead</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"整理创建L的元素(前插法):\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ListTraverse</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-6-2-2-后插法"><a href="#1-6-2-2-后插法" class="headerlink" title="1.6.2.2 后插法"></a>1.6.2.2 后插法</h5><p>将新结点插入在链表的尾结点后面，称为后插法</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 随机产生n个元素值,建立带表头结点的单链线性表L(后插法)*/</span><span class="token keyword">void</span> <span class="token function">CreateListTail</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    LinkList p<span class="token punctuation">,</span>r<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//建立1个带头结点的单链表</span>    <span class="token operator">*</span>L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//r指向尾部的结点</span>    r <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//生成新结点</span>        p <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">-></span>data <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将表尾终端结点的指针指向新结点</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将当前的新结点定义为表尾终端结点</span>        r <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//将尾指针的next = null</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>    //3.2 后插法整理创建链表L    iStatus = ClearList(&amp;L);    CreateListTail(&amp;L, 20);    printf(&quot;整理创建L的元素(后插法):\n&quot;);    ListTraverse(L);</code></pre><h4 id="1-6-3-单链表的删除"><a href="#1-6-3-单链表的删除" class="headerlink" title="1.6.3 单链表的删除"></a>1.6.3 单链表的删除</h4><p>要删除单链表中指定元素，通插入元素一样，应该先找到该位置的钱去结点。</p><p>  <img src="/p/43366/005.png" alt="单链表删除"></p><p>用C代码实现如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//2.4 单链表删除元素</span><span class="token comment" spellcheck="true">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span>Status <span class="token function">ListDelete</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-></span>next<span class="token punctuation">;</span>    j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//查找第i-1个结点,p指向该结点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token operator">++</span>j<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//当i>n 或者 i&lt;1 时,删除位置不合理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>j<span class="token operator">></span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span>  ERROR<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//q指向要删除的结点</span>    q <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将q的后继赋值给p的后继</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将q结点中的数据给e</span>    <span class="token operator">*</span>e <span class="token operator">=</span> q<span class="token operator">-></span>data<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//让系统回收此结点,释放内存;</span>    <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 理论 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】- 基础篇</title>
      <link href="/p/43384.html"/>
      <url>/p/43384.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><h3 id="1-数据结构的起源"><a href="#1-数据结构的起源" class="headerlink" title="1 数据结构的起源"></a>1 数据结构的起源</h3><p>早期人们都把计算机理解为数值计算工具，就是感觉计算机当然是用来计算的，所以计算机解决问题，应该是先从具体问题中抽象出一个适当的数据模型，设计出一个解此数据类型的算法，然后再编写程序，得到一个实际的软件。</p><p>可现实中，我们更多的不是解决数值计算的问题，而是需要一些更科学有效的手段（比如表、树和图等数据结构）等帮助，才能更好地解决问题。</p><p>所以</p><blockquote><p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。</p></blockquote><h3 id="2-术语概念"><a href="#2-术语概念" class="headerlink" title="2 术语概念"></a>2 术语概念</h3><p>说到数据结构是什么，我们得先来谈谈什么叫做数据。</p><p>数据结构中，有5个基本概念：数据、数据元素、数据项、数据对象和数据结构。</p><p>他们之间的关系如下图所示：</p><p><img src="/p/43384/001.png" alt="基本数据单位"></p><p>具体到代码上，参考如下代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//声明一个结构体类型</span><span class="token keyword">struct</span> Teacher<span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//一种数据结构</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//数据项--名字</span>    <span class="token keyword">char</span> <span class="token operator">*</span>title<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数据项--职称</span>    <span class="token keyword">int</span>  age<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//数据项--年龄</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> Teacher t1<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//数据元素;</span>    <span class="token keyword">struct</span> Teacher tArray<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//数据对象;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-1数据"><a href="#1-2-1数据" class="headerlink" title="1.2.1数据"></a>1.2.1数据</h4><blockquote><p>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实数等数值类型，还包括字符及声音、图像、视频等非数值类型类型。</p><p>——《大话数据结构》</p></blockquote><p>比如我们平时使用搜索殷勤，有网页、mp3、图片、视频等分类。MP3 就是声音数据</p><p><strong>数据的特点</strong>:  </p><ul><li>可以输入到计算机  </li><li>可以被计算机程序处理</li></ul><h4 id="1-2-2-数据元素"><a href="#1-2-2-数据元素" class="headerlink" title="1.2.2 数据元素"></a>1.2.2 数据元素</h4><blockquote><p>组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。</p></blockquote><p>比如，在人类中，人就是数据元素。</p><p>而在动物类中，牛、马、羊、鸡等动物就是动物类的数据元素了。</p><h4 id="1-2-3-数据项"><a href="#1-2-3-数据项" class="headerlink" title="1.2.3 数据项"></a>1.2.3 数据项</h4><blockquote><p>一个数据元素由若干数据项组成。</p></blockquote><p>比如人这样的数据元素，可以有眼耳鼻舌口这些数据项，也有姓名、年龄、性别、出生地址、电话等数据项。</p><blockquote><p>数据项上数据不可分割的最小单位。</p></blockquote><h4 id="1-2-4-数据对象"><a href="#1-2-4-数据对象" class="headerlink" title="1.2.4 数据对象"></a>1.2.4 数据对象</h4><blockquote><p>性质相同的数据元素的集合，是数据的子集。</p></blockquote><p>性质相同的意思，是指数据元素具有相同数量和类型的数据项，比如，人都有姓名、生日、性别等相同的数据项。</p><h4 id="1-2-5-数据结构"><a href="#1-2-5-数据结构" class="headerlink" title="1.2.5 数据结构"></a>1.2.5 数据结构</h4><blockquote><p>是相互之间存在一种或多种特定关系的数据元素的集合。</p></blockquote><p>在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。而在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据之间存在的一种或多种特定关系，也就是数据的组织形式。</p><h3 id="3-逻辑结构与物理结构"><a href="#3-逻辑结构与物理结构" class="headerlink" title="3 逻辑结构与物理结构"></a>3 逻辑结构与物理结构</h3><p>按照观点的不同，我们把数据结构分为逻辑结构和物理结构。</p><h4 id="3-1-逻辑结构"><a href="#3-1-逻辑结构" class="headerlink" title="3.1 逻辑结构"></a>3.1 逻辑结构</h4><blockquote><p>是指数据对象中数据元素之间的相互关系</p></blockquote><p>逻辑关系按照类别分为线性结构与非线性结构：</p><h5 id="1-3-1-线性结构"><a href="#1-3-1-线性结构" class="headerlink" title="1.3.1 线性结构"></a>1.3.1 线性结构</h5><blockquote><p>线性结构中的数据元素是一对一的关系</p></blockquote><p><img src="/p/43384/002.png" alt="线性结构"></p><ol><li>线性表</li><li>栈和队列</li><li>字符串</li></ol><h5 id="1-3-2-非线性结构"><a href="#1-3-2-非线性结构" class="headerlink" title="1.3.2 非线性结构"></a>1.3.2 非线性结构</h5><blockquote><p>非线性结构中的数据元素是一对多或多对多的关系。</p></blockquote><ol><li>集合结构<br>集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。<br><img src="/p/43384/003.png" alt="集合结构"></li><li>树形结构<br>树形结构中的数据元素之间存在一种一对多的层次关系。<br><img src="/p/43384/004.png" alt="树形结构"></li><li>图形结构<br>图形结构中的数据元素是多对多的关系<br><img src="/p/43384/005.png" alt="图形结构"></li></ol><h4 id="3-2-物理结构"><a href="#3-2-物理结构" class="headerlink" title="3.2 物理结构"></a>3.2 物理结构</h4><blockquote><p>是指数据的逻辑结构在计算机中的存储形式。</p></blockquote><p>数据元素的存储形式有两种：顺序存储和链式存储。</p><h5 id="3-2-1-顺序存储结构"><a href="#3-2-1-顺序存储结构" class="headerlink" title="3.2.1 顺序存储结构"></a>3.2.1 顺序存储结构</h5><blockquote><p>把数据元素存放在抵制连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</p></blockquote><p>如下图所示：</p><p><img src="/p/43384/006.png" alt="顺序存储结构"></p><h5 id="3-2-2-链式存储结构"><a href="#3-2-2-链式存储结构" class="headerlink" title="3.2.2 链式存储结构"></a>3.2.2 链式存储结构</h5><blockquote><p>把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</p></blockquote><p>数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置，如图所示：</p><p><img src="/p/43384/007.png" alt="链式存储结构"></p><h3 id="4-抽象数据类型"><a href="#4-抽象数据类型" class="headerlink" title="4 抽象数据类型"></a>4 抽象数据类型</h3><h4 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h4><blockquote><p>数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p></blockquote><p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量的表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p><p>在C语言中，按照趣致的不同，数据类型可以分为两类：</p><ul><li>原子类型：不可以再分解的基本类型。包括整型、浮点型、字符类型等</li><li>结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。</li></ul><h4 id="4-2-抽象数据类型"><a href="#4-2-抽象数据类型" class="headerlink" title="4.2 抽象数据类型"></a>4.2 抽象数据类型</h4><p><strong>抽象是指抽出事物具有的普遍型的本质</strong>。我们对已有的数据类型进行抽象，就有了抽象数据类型。</p><blockquote><p>抽象数据类型（Abstract Data Type：ADT）：</p><p>是指一个数学模型及定义在该模型上的一组操作。</p></blockquote><p>抽象的意义在于数据类型的数字抽象特性。</p><p>抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。</p><h2 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><blockquote><p>是解决特定问题对求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p></blockquote><p>什么是算法？算法是<strong>描述解决问题的方法</strong>。</p><p>自唐代以来，历代更有许多专门论述“算法”的专著：</p><ul><li>唐代：《一位算法》 一卷，《算法》 一卷；</li><li>宋代：《算法绪论》 一卷、《算法秘诀》 一卷；最著名的是<a href="https://zh.wikipedia.org/wiki/杨辉" target="_blank" rel="noopener">杨辉</a>的《<a href="https://zh.wikipedia.org/wiki/杨辉算法" target="_blank" rel="noopener">杨辉算法</a>》；</li><li>元代：《<a href="https://zh.wikipedia.org/wiki/丁巨算法" target="_blank" rel="noopener">丁巨算法</a>》；</li><li>明代：<a href="https://zh.wikipedia.org/wiki/程大位" target="_blank" rel="noopener">程大位</a> 《<a href="https://zh.wikipedia.org/wiki/算法統宗" target="_blank" rel="noopener">算法统宗</a>》</li><li>清代：《开平算法》、《算法一得》、《<a href="https://zh.wikipedia.org/w/index.php?title=算法全书&action=edit&redlink=1" target="_blank" rel="noopener">算法全书</a>》。</li></ul><p>而英文名称“algorithm”来自于9世纪<a href="https://zh.wikipedia.org/wiki/波斯" target="_blank" rel="noopener">波斯</a>数学家<a href="https://zh.wikipedia.org/wiki/花拉子米" target="_blank" rel="noopener">花拉子米</a>（比阿勒·霍瓦里松，波斯语：خوارزمی ‎，拉丁转写：al-Khwarizmi），因为比阿勒·霍瓦里松在<a href="https://zh.wikipedia.org/wiki/数学" target="_blank" rel="noopener">数学</a>上提出了算法这个概念。“算法”原为“algorism”，即“al-Khwarizmi”的音转，意思是“<a href="https://zh.wikipedia.org/wiki/花拉子米" target="_blank" rel="noopener">花拉子米</a>”的运算法则，在18世纪演变为“algorithm”。</p><p><a href="https://zh.wikipedia.org/wiki/欧几里得算法" target="_blank" rel="noopener">欧几里得算法</a>被人们认为是史上第一个算法。</p><h3 id="2-2-特性"><a href="#2-2-特性" class="headerlink" title="2.2 特性"></a>2.2 特性</h3><p>算法具有五个基本特征：输入、输出、有穷性、确定性和可行性。</p><ol><li>有穷性<br>指算法在执行有限的步骤之后，自动结束而不会出现无限循环，而且每一个步骤在可接受的时间内完成。</li><li>确定性<br>算法的每一步骤都具有确定的含义，不会出现二义性。</li><li>可行性<br>算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成</li><li>输入输出<br>算法具有零个或多个输入</li></ol><h3 id="2-3-算法设计的要求"><a href="#2-3-算法设计的要求" class="headerlink" title="2.3 算法设计的要求"></a>2.3 算法设计的要求</h3><h4 id="2-3-1-正确性"><a href="#2-3-1-正确性" class="headerlink" title="2.3.1 正确性"></a>2.3.1 正确性</h4><blockquote><p>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反应问题的需求、能够得到问题的正确答案。</p></blockquote><p>大概分为以下四个层次：</p><ol><li>算法程序没有语法错误。</li><li>算法程序对于合法的输入数据能够产生满足要求的输出结果。</li><li>算法程序对于非法的输入数据能够得出满足规格说明的结果。</li><li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</li></ol><p>以上这四层含义里，层次1 要求最低，而层次4 时最困难的，实际开发中，我们几乎不可能逐一验证所有的输入都能得到正确的结果。</p><h4 id="2-3-2-可读性"><a href="#2-3-2-可读性" class="headerlink" title="2.3.2 可读性"></a>2.3.2 可读性</h4><blockquote><p>算法设计的另一目的是为了便于阅读、理解和交流。</p></blockquote><p>可读性时算法（也包括实现它的代码）好坏很重要的标志。</p><h4 id="2-3-3-健壮性"><a href="#2-3-3-健壮性" class="headerlink" title="2.3.3 健壮性"></a>2.3.3 健壮性</h4><blockquote><p>当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</p></blockquote><h4 id="2-3-4-时间效率高和存储量低"><a href="#2-3-4-时间效率高和存储量低" class="headerlink" title="2.3.4 时间效率高和存储量低"></a>2.3.4 时间效率高和存储量低</h4><blockquote><p>设计算法应该尽量满足时间效率高和存储量低的特点。</p></blockquote><p>在生活中，人们都希望花最少的钱，用最短的时间，办最大的事，算法也是一样的思想，最好用最少的存储空间，办成同样的事——就是好的算法。</p><h3 id="2-4-效率的度量方法"><a href="#2-4-效率的度量方法" class="headerlink" title="2.4 效率的度量方法"></a>2.4 效率的度量方法</h3><p>通过对算法的数据测试，利用计算机的计时功能，来计算不同算法的效率是高还是低。</p><h4 id="2-4-1-事后统计方法"><a href="#2-4-1-事后统计方法" class="headerlink" title="2.4.1 事后统计方法"></a>2.4.1 事后统计方法</h4><blockquote><p>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编织的程序的运行时间进行比较，从而确定算法效率的高低。</p></blockquote><h4 id="2-4-2-事前统计方法"><a href="#2-4-2-事前统计方法" class="headerlink" title="2.4.2 事前统计方法"></a>2.4.2 事前统计方法</h4><blockquote><p>在计算机程序编制前，依据统计方法对算法进行估算。</p></blockquote><p>我们发现，一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：</p><ol><li>算法采用的策略、方法</li><li>编译产生的代码质量</li><li>问题的输入规模</li><li>机器执行指令的速度</li></ol><p>抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，<strong>依赖于算法的好坏和问题的输入规模</strong>。所谓<strong>问题输入规模是指输入量的多少</strong>。</p><p>我们看看两种求和的算法：</p><ul><li><p>第一种算法</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">/* 执行 1次*/</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">/* 执行 n + 1 次*/</span><span class="token punctuation">{</span>                            sum <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">/* 执行 n 次*/</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">/* 执行 1 次*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第二种算法</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">/* 执行 1次*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>显然，第一种算法，执行了 1 + (n+1) + n + 1 次 = 2n + 3 次</p><p>而第二种算法是1+1+1 = 3 次。算法好坏显而易见。</p><p>最终，在分析程序的运行时间时，最重要的是吧程序看成是独立于程序设计语言的算法或一系列步骤。</p><h3 id="2-5-算法时间复杂度"><a href="#2-5-算法时间复杂度" class="headerlink" title="2.5 算法时间复杂度"></a>2.5 算法时间复杂度</h3><h4 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1 定义"></a>2.5.1 定义</h4><blockquote><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n) 随n 的变化情况并确定T(n) 的数量级。</p><p>算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n) 是问题规模 n 的某个函数。</p></blockquote><p>大写O() 来体现算法复杂度的激发，我们称之为大O记法。</p><p>上面求和算法的时间复杂度，分别为O(n) 和 O(1)</p><h4 id="2-5-2-推导大O-阶方法"><a href="#2-5-2-推导大O-阶方法" class="headerlink" title="2.5.2 推导大O 阶方法"></a>2.5.2 推导大O 阶方法</h4><ol><li>用常数1 取代运行时间中的所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li></ol><h4 id="2-5-3-常数阶"><a href="#2-5-3-常数阶" class="headerlink" title="2.5.3 常数阶"></a>2.5.3 常数阶</h4><p>下面这个算法，就是刚刚的第二个算法（高斯算法）。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">/* 执行 1次*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个算法的运行次函数是 f(n) = 3。根据我们推导大O阶的方法，第一步就是把常数3 改为1，再加上它没有最高阶项，所以这个算法的时间复杂度为O(1)</p><p>如果这里的第二行 sum = (1 + n) * n / 2 有10句，会是怎么样？</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">/* 执行 1次*/</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">/* 执行 1次*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，无论n 为多少，上面的代码就说3次和12次执行的差异。这种与问题的大小无关（n） 的多少，执行时间恒定的算法，我们称之为具有 O(1) 的时间复杂度</p><h4 id="2-5-4-线性阶"><a href="#2-5-4-线性阶" class="headerlink" title="2.5.4 线性阶"></a>2.5.4 线性阶</h4><p>我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。</p><p>下面这段代码，它的循环的时间复杂度为O(n)，因为循环体中的代码须要执行 n 次</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">/</span> <span class="token operator">*</span>    时间复杂度为O（<span class="token number">1</span>）的程序步骤序列    <span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-5-对数阶"><a href="#2-5-5-对数阶" class="headerlink" title="2.5.5 对数阶"></a>2.5.5 对数阶</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        count <span class="token operator">=</span> count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 时间复杂度为 O(1) 的程序步骤序列*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这行代码，由于每次 count 乘以 2 以后，就距离 n 更近了一份。</p><p>也就是说，有多少个2 相乘后大于 n，则会推出循环。</p><p>由 2<sup>x</sup>= n 得到 x = log<sub>2</sub>n 。所以这个循环的时间复杂度为O(logn)。</p><h4 id="2-5-6-平方阶"><a href="#2-5-6-平方阶" class="headerlink" title="2.5.6 平方阶"></a>2.5.6 平方阶</h4><p>下面的例子说一个循环嵌套，它的内循环时间复杂度为O(n)</p><pre class="line-numbers language-c"><code class="language-c">in i<span class="token punctuation">,</span>j<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token operator">/</span> <span class="token operator">*</span> 时间复杂度为 <span class="token function">O</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 的程序步骤序列<span class="token operator">*</span><span class="token operator">/</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而对于外层的循环，不过是内部这个时间复杂度 O(n) 的语句，再循环 n 次。所以这段代码的时间复杂度为 O(n<sup>2</sup>)。</p><h3 id="2-6-常见的时间复杂度"><a href="#2-6-常见的时间复杂度" class="headerlink" title="2.6 常见的时间复杂度"></a>2.6 常见的时间复杂度</h3><p>常见的时间复杂度如表所示</p><table><thead><tr><th>执行次数函数</th><th>阶</th><th>非正式术语</th></tr></thead><tbody><tr><td>12</td><td>O(1)</td><td>常数阶</td></tr><tr><td>2n + 3</td><td>O(<em>n</em>)</td><td>线性阶</td></tr><tr><td>3n<sup>2</sup> + 2n + 1</td><td>O(<em>n</em><sup>2</sup>)</td><td>平方阶</td></tr><tr><td>5 log<sub>2</sub>n + 20</td><td>O(log<em>n</em>)</td><td>对数阶</td></tr><tr><td>2n + 3n log<sub>2</sub>n + 19</td><td>O(nlog<em>n</em>)</td><td>nlogn 阶</td></tr><tr><td>6n<sup>3</sup> + 2 n<sup>2</sup> + 3n + 4</td><td>O(<em>n</em><sup>3</sup>)</td><td>立方阶</td></tr><tr><td>2 <sup>n</sup></td><td>O(2<sup>n</sup>)</td><td>指数阶</td></tr></tbody></table><p>常用的时间复杂度所消耗的时间从小到大依次是:</p><p>O(1) &lt; O(log<em>n</em>) &lt; O(<em>n</em>) &lt;  O(<em>n</em>log<em>n</em>) &lt; O(<em>n</em><sup>2</sup>) &lt; O(<em>n</em><sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p><h3 id="2-7-最坏情况与平均情况"><a href="#2-7-最坏情况与平均情况" class="headerlink" title="2.7 最坏情况与平均情况"></a>2.7 最坏情况与平均情况</h3><p>我们查找一个由 n 个随机数字数组中的某个数组，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的复杂度为O(n)，这是最坏的一种情况了。</p><p>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏时间的运行时间。</p><p>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，我们运行一段程序代码时，实习完看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。</p><p>对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。</p><p>另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。<strong>一般在没有特殊说明的情况下，都是指最坏时间复杂度。</strong></p><h3 id="2-8-算法空间复杂度"><a href="#2-8-算法空间复杂度" class="headerlink" title="2.8 算法空间复杂度"></a>2.8 算法空间复杂度</h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(&fnof;(n))，其中，n 为问题的规模，&fnof;(n) 为语句关于 n 所占存储空间的函数。</p><p>通常，我们都适用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 理论 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【底层探索】-懒加载与分类</title>
      <link href="/p/38312.html"/>
      <url>/p/38312.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、懒加载"><a href="#一、懒加载" class="headerlink" title="一、懒加载"></a>一、懒加载</h2><h2 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 底层，源码，懒加载，分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>runtime 面试题</title>
      <link href="/p/41032.html"/>
      <url>/p/41032.html</url>
      
        <content type="html"><![CDATA[<p>最近看到一道runtime 面试题，觉得有意思</p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>Q：已经注册好的类，能否再动态添加成员变量？为什么？</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>我们通过Runtime还原一下场景。</p><p>注册好的类，实现的方法是，注册到内存里：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">objc_registerClassPair</span><span class="token punctuation">(</span>LGPerson<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而实现<code>objc_registerClassPair</code> 这个方法，又实现了下面的内容:</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// Clear "under construction" bit, set "done constructing" bit</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">ISA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">changeInfo</span><span class="token punctuation">(</span>RW_CONSTRUCTED<span class="token punctuation">,</span> RW_CONSTRUCTING <span class="token operator">|</span> RW_REALIZING<span class="token punctuation">)</span><span class="token punctuation">;</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">changeInfo</span><span class="token punctuation">(</span>RW_CONSTRUCTED<span class="token punctuation">,</span> RW_CONSTRUCTING <span class="token operator">|</span> RW_REALIZING<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>即对类更改了状态，更改了什么状态？<strong>RW_CONSTRUCTED</strong>这个状态，即让类处于内存开辟&amp;注册到内存中——</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// class allocated and registered</span><span class="token macro property">#<span class="token directive keyword">define</span> RW_CONSTRUCTED        (1&lt;&lt;25)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来，根据创建成员变量的函数为<code>addIvar</code>，创建业务代码如下</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">class_addIvar</span><span class="token punctuation">(</span>LGPerson<span class="token punctuation">,</span> <span class="token string">"lgName"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">log2</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"@"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在源码中找到相对应的函数：</p><p><img src="/p/41032/001.png" alt="001"></p><p>走到这一步，就戛然而止了……添加ivars 被拒绝——因为内存已固定，无法再添加新属性了。</p><h3 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h3><p>答案是否。</p><p>因为注册好的类，内存容量已经固定，无法动态添加了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 类 </tag>
            
            <tag> 2020 </tag>
            
            <tag> runtime </tag>
            
            <tag> 面试 </tag>
            
            <tag> 成员变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>底层探索——类的加载</title>
      <link href="/p/29664.html"/>
      <url>/p/29664.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自 <a href="https://opensource.apple.com/tarballs/objc4" target="_blank" rel="noopener">Apple 开源文档</a></p></blockquote><h2 id="1、objc-init-流程"><a href="#1、objc-init-流程" class="headerlink" title="1、objc_init 流程"></a>1、objc_init 流程</h2><p>类的加载，初始化来自dyld 中的objc_init 这个步骤，查看一下源码，得到</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_objc_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">bool</span> initialized <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialized<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    initialized <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// fixme defer initialization until an objc-using image is found?</span>    <span class="token function">environ_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tls_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">static_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exception_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_dyld_objc_notify_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>map_images<span class="token punctuation">,</span> load_images<span class="token punctuation">,</span> unmap_image<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>序号</th><th>源代码</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td>environ_init()</td><td>环境变量、帮助文档配置</td></tr><tr><td>2</td><td>tls_init()</td><td>线程key 的绑定</td></tr><tr><td>3</td><td>static_init</td><td>C++ 静态构造函数</td></tr><tr><td>4</td><td>lock_init()</td><td>锁配置</td></tr><tr><td>5</td><td>exception_init()</td><td>异常初始化</td></tr><tr><td>6</td><td>_dyld_objc_notify_register</td><td>Dyld 通知注册</td></tr></tbody></table><h3 id="1-1-environ-init"><a href="#1-1-environ-init" class="headerlink" title="1.1 environ_init"></a>1.1 environ_init</h3><blockquote><p>在函数<code>void environ_init(void)</code> 里，读取环境变量 <code>env</code>  以及帮助注释 <code>help</code>，</p></blockquote><p>相关代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Settings<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Settings<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> option_t <span class="token operator">*</span>opt <span class="token operator">=</span> <span class="token operator">&amp;</span>Settings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>PrintHelp<span class="token punctuation">)</span> <span class="token function">_objc_inform</span><span class="token punctuation">(</span><span class="token string">"%s: %s"</span><span class="token punctuation">,</span> opt<span class="token operator">-</span><span class="token operator">></span>env<span class="token punctuation">,</span> opt<span class="token operator">-</span><span class="token operator">></span>help<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>PrintOptions <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>opt<span class="token operator">-</span><span class="token operator">></span>var<span class="token punctuation">)</span> <span class="token function">_objc_inform</span><span class="token punctuation">(</span><span class="token string">"%s is set"</span><span class="token punctuation">,</span> opt<span class="token operator">-</span><span class="token operator">></span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行代码，在控制台可以得到环境变量参数表：</p><pre class="line-numbers language-cpp"><code class="language-cpp">objc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_IMAGES<span class="token operator">:</span> log image <span class="token operator">and</span> library names as they are loadedobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_IMAGE_TIMES<span class="token operator">:</span> measure duration of image loading stepsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_LOAD_METHODS<span class="token operator">:</span> log calls to <span class="token keyword">class</span> <span class="token class-name">and</span> category <span class="token operator">+</span>load methodsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_INITIALIZE_METHODS<span class="token operator">:</span> log calls to <span class="token keyword">class</span> <span class="token operator">+</span>initialize methodsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_RESOLVED_METHODS<span class="token operator">:</span> log methods created by <span class="token operator">+</span>resolveClassMethod<span class="token operator">:</span> <span class="token operator">and</span> <span class="token operator">+</span>resolveInstanceMethod<span class="token operator">:</span>objc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_CLASS_SETUP<span class="token operator">:</span> log progress of <span class="token keyword">class</span> <span class="token class-name">and</span> category setupobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_PROTOCOL_SETUP<span class="token operator">:</span> log progress of protocol setupobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_IVAR_SETUP<span class="token operator">:</span> log processing of non<span class="token operator">-</span>fragile ivarsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_VTABLE_SETUP<span class="token operator">:</span> log processing of <span class="token keyword">class</span> <span class="token class-name">vtables</span>objc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_VTABLE_IMAGES<span class="token operator">:</span> print vtable images showing overridden methodsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_CACHE_SETUP<span class="token operator">:</span> log processing of method cachesobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_FUTURE_CLASSES<span class="token operator">:</span> log use of future classes <span class="token keyword">for</span> toll<span class="token operator">-</span>free bridgingobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_PREOPTIMIZATION<span class="token operator">:</span> log preoptimization courtesy of dyld shared cacheobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_CXX_CTORS<span class="token operator">:</span> log calls to C<span class="token operator">++</span> ctors <span class="token operator">and</span> dtors <span class="token keyword">for</span> instance variablesobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_EXCEPTIONS<span class="token operator">:</span> log exception handlingobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_EXCEPTION_THROW<span class="token operator">:</span> log backtrace of every <span class="token function">objc_exception_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span>objc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_ALT_HANDLERS<span class="token operator">:</span> log processing of exception alt handlersobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_REPLACED_METHODS<span class="token operator">:</span> log methods replaced by category implementationsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_DEPRECATION_WARNINGS<span class="token operator">:</span> warn about calls to deprecated runtime functionsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_POOL_HIGHWATER<span class="token operator">:</span> log high<span class="token operator">-</span>water marks <span class="token keyword">for</span> autorelease poolsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_CUSTOM_RR<span class="token operator">:</span> log classes with un<span class="token operator">-</span>optimized custom retain<span class="token operator">/</span>release methodsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_CUSTOM_AWZ<span class="token operator">:</span> log classes with un<span class="token operator">-</span>optimized custom allocWithZone methodsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_PRINT_RAW_ISA<span class="token operator">:</span> log classes that require raw pointer isa fieldsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DEBUG_UNLOAD<span class="token operator">:</span> warn about poorly<span class="token operator">-</span>behaving bundles when unloadedobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DEBUG_FRAGILE_SUPERCLASSES<span class="token operator">:</span> warn about subclasses that may have been broken by subsequent changes to superclassesobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DEBUG_NIL_SYNC<span class="token operator">:</span> warn about @<span class="token function">synchronized</span><span class="token punctuation">(</span>nil<span class="token punctuation">)</span><span class="token punctuation">,</span> which does no synchronizationobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DEBUG_NONFRAGILE_IVARS<span class="token operator">:</span> capriciously rearrange non<span class="token operator">-</span>fragile ivarsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DEBUG_ALT_HANDLERS<span class="token operator">:</span> record more info about bad alt handler useobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DEBUG_MISSING_POOLS<span class="token operator">:</span> warn about autorelease with no pool in place<span class="token punctuation">,</span> which may be a leakobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DEBUG_POOL_ALLOCATION<span class="token operator">:</span> halt when autorelease pools are popped out of order<span class="token punctuation">,</span> <span class="token operator">and</span> allow heap debuggers to track autorelease poolsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DEBUG_DUPLICATE_CLASSES<span class="token operator">:</span> halt when multiple classes with the same name are presentobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DEBUG_DONT_CRASH<span class="token operator">:</span> halt the process by exiting instead of crashingobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DISABLE_VTABLES<span class="token operator">:</span> disable vtable dispatchobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DISABLE_PREOPTIMIZATION<span class="token operator">:</span> disable preoptimization courtesy of dyld shared cacheobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DISABLE_TAGGED_POINTERS<span class="token operator">:</span> disable tagged pointer optimization of NSNumber et al<span class="token punctuation">.</span>objc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DISABLE_TAG_OBFUSCATION<span class="token operator">:</span> disable obfuscation of tagged pointersobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DISABLE_NONPOINTER_ISA<span class="token operator">:</span> disable non<span class="token operator">-</span>pointer isa fieldsobjc<span class="token punctuation">[</span><span class="token number">27076</span><span class="token punctuation">]</span><span class="token operator">:</span> OBJC_DISABLE_INITIALIZE_FORK_SAFETY<span class="token operator">:</span> disable safety checks <span class="token keyword">for</span> <span class="token operator">+</span>initialize after fork<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-tls-init"><a href="#1-2-tls-init" class="headerlink" title="1.2 tls_init()"></a>1.2 tls_init()</h3><blockquote><p>对线程的Key 的绑定。</p></blockquote><p>这部分不展开讨论</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">tls_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span>    _objc_pthread_key <span class="token operator">=</span> TLS_DIRECT_KEY<span class="token punctuation">;</span>    <span class="token function">pthread_key_init_np</span><span class="token punctuation">(</span>TLS_DIRECT_KEY<span class="token punctuation">,</span> <span class="token operator">&amp;</span>_objc_pthread_destroyspecific<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    _objc_pthread_key <span class="token operator">=</span> <span class="token function">tls_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_objc_pthread_destroyspecific<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-static-init"><a href="#1-3-static-init" class="headerlink" title="1.3 static_init"></a>1.3 static_init</h3><blockquote><p>实现系统级别的 C++ 静态构造函数。</p></blockquote><p><strong>相关源码</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">static_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    size_t count<span class="token punctuation">;</span>    <span class="token keyword">auto</span> inits <span class="token operator">=</span> <span class="token function">getLibobjcInitializers</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mh_dylib_header<span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        inits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-lock-init"><a href="#1-4-lock-init" class="headerlink" title="1.4 lock_init"></a>1.4 lock_init</h3><blockquote><p>锁的初始化，这里并没有进行实现，意味着可以进行重写，自定义一些操作。</p></blockquote><p><strong>相关源码：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/************************************************************************ Lock management**********************************************************************/</span>mutex_t runtimeLock<span class="token punctuation">;</span>mutex_t selLock<span class="token punctuation">;</span>mutex_t cacheUpdateLock<span class="token punctuation">;</span>recursive_mutex_t loadMethodLock<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-exception-init"><a href="#1-5-exception-init" class="headerlink" title="1.5 exception_init"></a>1.5 exception_init</h3><blockquote><p><strong>异常的初始化：</strong>libobjc 的异常回调系统初始化，由map_images 调用。</p></blockquote><p>即注册监听回调。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/************************************************************************ exception_init* Initialize libobjc's exception handling system.* Called by map_images().**********************************************************************/</span><span class="token keyword">void</span> <span class="token function">exception_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    old_terminate <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">set_terminate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_objc_terminate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个c++ 函数 <code>set_terminate</code> 会初始化静态的 异常回调。在OC 环境下，所有的异常抛出，都会到<code>(*old_terminate)();</code> 这行代码里。</p><p>相关源码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>old_terminate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> nil<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">_objc_terminate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>PrintExceptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">_objc_inform</span><span class="token punctuation">(</span><span class="token string">"EXCEPTIONS: terminating"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">__cxa_current_exception_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// No current exception.</span>        <span class="token punctuation">(</span><span class="token operator">*</span>old_terminate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// There is a current exception. Check if it's an objc exception.</span>        @<span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">__cxa_rethrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> @<span class="token keyword">catch</span> <span class="token punctuation">(</span>id e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// It's an objc object. Call Foundation's handler, if any.</span>            <span class="token punctuation">(</span><span class="token operator">*</span>uncaught_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span><span class="token operator">*</span>old_terminate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> @<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// It's not an objc object. Continue to C++ terminate.</span>            <span class="token punctuation">(</span><span class="token operator">*</span>old_terminate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在业务代码里执行一个报错的方法：</p><ul><li><p>类声明与实现</p><pre class="line-numbers language-cpp"><code class="language-cpp">@interface Dog <span class="token operator">:</span> NSObject<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>bark<span class="token punctuation">;</span>@end@implementation Dog@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用类执行为实现的方法</p><pre class="line-numbers language-cpp"><code class="language-cpp">Dog <span class="token operator">*</span>d <span class="token operator">=</span> <span class="token punctuation">[</span>Dog alloc<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span>d bark<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>异常抛出如下图所示：</p><p><img src="/p/29664/001.png" alt="objc_terminate 异常抛出"></p></li></ul><h3 id="1-6-dyld-objc-notify-register（核心）"><a href="#1-6-dyld-objc-notify-register（核心）" class="headerlink" title="1.6 _dyld_objc_notify_register（核心）"></a>1.6 _dyld_objc_notify_register（核心）</h3><blockquote><ol><li>objc 特有方法</li><li>注册回调。当镜像文件被映射(mapped)、未被映射(unmapped)、初始化(initialized) 使调用。</li><li>该方法由dyld 声明。</li><li>镜像文件加载完后，dyld 会回调”映射”函数，内容为一个包含objc-image-info 数据段的数组。</li></ol></blockquote><p>注册方法<strong>源码如下：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp">   <span class="token function">_dyld_objc_notify_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>map_images<span class="token punctuation">,</span> load_images<span class="token punctuation">,</span> unmap_image<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 这里主要关注 <code>map_images</code> 的这个对象，其实现代码为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">map_images</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> count<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> paths<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>           <span class="token keyword">const</span> <span class="token keyword">struct</span> mach_header <span class="token operator">*</span> <span class="token keyword">const</span> mhdrs<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    mutex_locker_t <span class="token function">lock</span><span class="token punctuation">(</span>runtimeLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">map_images_nolock</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> paths<span class="token punctuation">,</span> mhdrs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>读取镜像文件</strong></p><p>继续探索 <code>map_images_nolock</code> 这个函数，读取镜像文件的关键行为</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token keyword">if</span> <span class="token punctuation">(</span>hCount <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">_read_images</span><span class="token punctuation">(</span>hList<span class="token punctuation">,</span> hCount<span class="token punctuation">,</span> totalClasses<span class="token punctuation">,</span> unoptimizedTotalClasses<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>至此，这一部分到此就结束了，关于images 的流程，另外单独分析。</p><h2 id="2、read-images-读镜像文件"><a href="#2、read-images-读镜像文件" class="headerlink" title="2、read_images - 读镜像文件"></a>2、read_images - 读镜像文件</h2><h4 id="2-1-初次进来-创建容器哈希表"><a href="#2-1-初次进来-创建容器哈希表" class="headerlink" title="2.1 初次进来: 创建容器哈希表"></a>2.1 初次进来: 创建容器哈希表</h4><p>根据源码，得知读取镜像的主要函数为<code>read_image</code> ，其函数具体为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_read_images</span><span class="token punctuation">(</span>header_info <span class="token operator">*</span><span class="token operator">*</span>hList<span class="token punctuation">,</span> uint32_t hCount<span class="token punctuation">,</span> <span class="token keyword">int</span> totalClasses<span class="token punctuation">,</span> <span class="token keyword">int</span> unoptimizedTotalClasses<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>读取镜像后，最先需要做的是，为这些景象里的内容找一个家——容器，也就是开辟表结构。</p><p>在源码里，这里分别通过<code>NXCreateMapTable</code>、<code>NXCreateHashTable</code>开辟了2个表，主要存储以下的内容：</p><ul><li><p>未共享缓存的类 <code>gdb_objc_realized_classes</code></p><pre class="line-numbers language-cpp"><code class="language-cpp">gdb_objc_realized_classes <span class="token operator">=</span>    <span class="token function">NXCreateMapTable</span><span class="token punctuation">(</span>NXStrValueMapPrototype<span class="token punctuation">,</span> namedClassesSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>开辟内存空间类 - <code>allocatedClasses</code></p><pre class="line-numbers language-cpp"><code class="language-cpp">allocatedClasses <span class="token operator">=</span> <span class="token function">NXCreateHashTable</span><span class="token punctuation">(</span>NXPtrPrototype<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nil<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="2-2-类的处理"><a href="#2-2-类的处理" class="headerlink" title="2.2 类的处理"></a>2.2 类的处理</h4><blockquote><p>从编译后的类列表中，取出所有的类，并进行下一步操作。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>EACH_HEADER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        classref_t <span class="token operator">*</span>classlist <span class="token operator">=</span> <span class="token function">_getObjc2ClassList</span><span class="token punctuation">(</span>hi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>取出系统类</p><pre class="line-numbers language-cpp"><code class="language-cpp">Class <span class="token class-name">cls</span> <span class="token operator">=</span> <span class="token punctuation">(</span>Class<span class="token punctuation">)</span>classlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>读取类 </p><pre class="line-numbers language-cpp"><code class="language-cpp">Class <span class="token class-name">newCls</span> <span class="token operator">=</span> <span class="token function">readClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> headerIsBundle<span class="token punctuation">,</span> headerIsPreoptimized<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>懒加载相关，条件为 <code>newCls != cls &amp;&amp; newCls</code>， 即两个类不相等时</p><ol><li><p>初始化懒加载所需内存空间</p><pre class="line-numbers language-cpp"><code class="language-cpp">resolvedFutureClasses <span class="token operator">=</span> <span class="token punctuation">(</span>Class <span class="token operator">*</span><span class="token punctuation">)</span>                    <span class="token function">realloc</span><span class="token punctuation">(</span>resolvedFutureClasses<span class="token punctuation">,</span>                             <span class="token punctuation">(</span>resolvedFutureClassCount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Class<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>懒加载的类添加到数组中来</p><pre class="line-numbers language-cpp"><code class="language-cpp">resolvedFutureClasses<span class="token punctuation">[</span>resolvedFutureClassCount<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> newCls<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol></li></ul><h4 id="2-3-方法编号处理"><a href="#2-3-方法编号处理" class="headerlink" title="2.3 方法编号处理"></a>2.3 方法编号处理</h4><blockquote><p>把未注册的方法名进行注册到一张HASH表里，形成方法名与方法的映射</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">static</span> size_t UnfixedSelectors<span class="token punctuation">;</span>    <span class="token punctuation">{</span>        mutex_locker_t <span class="token function">lock</span><span class="token punctuation">(</span>selLock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>EACH_HEADER<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hi<span class="token operator">-</span><span class="token operator">></span><span class="token function">isPreoptimized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">bool</span> isBundle <span class="token operator">=</span> hi<span class="token operator">-</span><span class="token operator">></span><span class="token function">isBundle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            SEL <span class="token operator">*</span>sels <span class="token operator">=</span> <span class="token function">_getObjc2SelectorRefs</span><span class="token punctuation">(</span>hi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>            UnfixedSelectors <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name <span class="token operator">=</span> <span class="token function">sel_cname</span><span class="token punctuation">(</span>sels<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 注册SEL的操作</span>                sels<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">sel_registerNameNoLock</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> isBundle<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注册到的表名为<code>namedSelectors</code>， 具体的实现在这里</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">NXMapInsert</span><span class="token punctuation">(</span>namedSelectors<span class="token punctuation">,</span> <span class="token function">sel_getName</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-4-协议处理"><a href="#2-4-协议处理" class="headerlink" title="2.4 协议处理"></a>2.4 协议处理</h4><blockquote><p>找到类遵守的协议，修复协议的引用。</p><p>关键字: readProtocol 、remapProtocolRef</p></blockquote><p>相关源码，如下所示:</p><p><strong>找到协议：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>EACH_HEADER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">extern</span> objc_class <span class="token class-name">OBJC_CLASS_</span>$_Protocol<span class="token punctuation">;</span>        Class <span class="token class-name">cls</span> <span class="token operator">=</span> <span class="token punctuation">(</span>Class<span class="token punctuation">)</span><span class="token operator">&amp;</span>OBJC_CLASS_$_Protocol<span class="token punctuation">;</span>        NXMapTable <span class="token operator">*</span>protocol_map <span class="token operator">=</span> <span class="token function">protocols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        protocol_t <span class="token operator">*</span><span class="token operator">*</span>protolist <span class="token operator">=</span> <span class="token function">_getObjc2ProtocolList</span><span class="token punctuation">(</span>hi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">readProtocol</span><span class="token punctuation">(</span>protolist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> cls<span class="token punctuation">,</span> protocol_map<span class="token punctuation">,</span>                         isPreoptimized<span class="token punctuation">,</span> isBundle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修复协议引用（重映射）：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>EACH_HEADER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        protocol_t <span class="token operator">*</span><span class="token operator">*</span>protolist <span class="token operator">=</span> <span class="token function">_getObjc2ProtocolRefs</span><span class="token punctuation">(</span>hi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">remapProtocolRef</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>protolist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-非懒加载处理"><a href="#2-5-非懒加载处理" class="headerlink" title="2.5 非懒加载处理"></a>2.5 非懒加载处理</h4><blockquote><p>初始化所有非懒加载类，进行 <code>rw</code> <code>ro</code> 操作</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>EACH_HEADER<span class="token punctuation">)</span> <span class="token punctuation">{</span>      classref_t <span class="token operator">*</span>classlist <span class="token operator">=</span>          <span class="token function">_getObjc2NonlazyClassList</span><span class="token punctuation">(</span>hi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">addClassTableEntry</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">realizeClassWithoutSwift</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-6-待处理的类"><a href="#2-6-待处理的类" class="headerlink" title="2.6 待处理的类"></a>2.6 待处理的类</h4><blockquote><p>找到最新特征的类，以备CoreFoundation 需要操作它</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedFutureClasses<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> resolvedFutureClassCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Class <span class="token class-name">cls</span> <span class="token operator">=</span> resolvedFutureClasses<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">isSwiftStable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">_objc_fatal</span><span class="token punctuation">(</span><span class="token string">"Swift class is not allowed to be future"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">realizeClassWithoutSwift</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>            cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">setInstancesRequireRawIsa</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token comment" spellcheck="true">/*inherited*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">free</span><span class="token punctuation">(</span>resolvedFutureClasses<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-分类处理"><a href="#2-7-分类处理" class="headerlink" title="2.7 分类处理"></a>2.7 分类处理</h4><blockquote><p>对非类进行处理，包括<code>Class</code> 的和<code>metaClass</code> 的</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>EACH_HEADER<span class="token punctuation">)</span> <span class="token punctuation">{</span>       category_t <span class="token operator">*</span><span class="token operator">*</span>catlist <span class="token operator">=</span>           <span class="token function">_getObjc2CategoryList</span><span class="token punctuation">(</span>hi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">bool</span> hasClassProperties <span class="token operator">=</span> hi<span class="token operator">-</span><span class="token operator">></span><span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">hasCategoryClassProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           category_t <span class="token operator">*</span>cat <span class="token operator">=</span> catlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           Class <span class="token class-name">cls</span> <span class="token operator">=</span> <span class="token function">remapClass</span><span class="token punctuation">(</span>cat<span class="token operator">-</span><span class="token operator">></span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、类方法重点"><a href="#3、类方法重点" class="headerlink" title="3、类方法重点"></a>3、类方法重点</h2><h3 id="3-1-类的读取readClasses"><a href="#3-1-类的读取readClasses" class="headerlink" title="3.1 类的读取readClasses"></a>3.1 类的读取<code>readClasses</code></h3><h4 id="3-1-1-判断是否是未来处理的类-（popFutureNamedClass）"><a href="#3-1-1-判断是否是未来处理的类-（popFutureNamedClass）" class="headerlink" title="3.1.1 判断是否是未来处理的类 （popFutureNamedClass）"></a>3.1.1 <strong>判断是否是未来处理的类</strong> （<code>popFutureNamedClass</code>）</h4><p>如果是，就读取data，设置rw 和 ro</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>Class <span class="token class-name">newCls</span> <span class="token operator">=</span> <span class="token function">popFutureNamedClass</span><span class="token punctuation">(</span>mangledName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// This name was previously allocated as a future class.</span>        <span class="token comment" spellcheck="true">// Copy objc_class to future class's struct.</span>        <span class="token comment" spellcheck="true">// Preserve future's rw data block.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCls<span class="token operator">-</span><span class="token operator">></span><span class="token function">isAnySwift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">_objc_fatal</span><span class="token punctuation">(</span><span class="token string">"Can't complete future class request for '%s' "</span>                        <span class="token string">"because the real class is too big."</span><span class="token punctuation">,</span>                         cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">nameForLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 在这里，读取data(), 并进行设置 rw /ro</span>        class_rw_t <span class="token operator">*</span>rw <span class="token operator">=</span> newCls<span class="token operator">-</span><span class="token operator">></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> class_ro_t <span class="token operator">*</span>old_ro <span class="token operator">=</span> rw<span class="token operator">-</span><span class="token operator">></span>ro<span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>newCls<span class="token punctuation">,</span> cls<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>objc_class<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rw<span class="token operator">-</span><span class="token operator">></span>ro <span class="token operator">=</span> <span class="token punctuation">(</span>class_ro_t <span class="token operator">*</span><span class="token punctuation">)</span>newCls<span class="token operator">-</span><span class="token operator">></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newCls<span class="token operator">-</span><span class="token operator">></span><span class="token function">setData</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">freeIfMutable</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>old_ro<span class="token operator">-</span><span class="token operator">></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>old_ro<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addRemappedClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> newCls<span class="token punctuation">)</span><span class="token punctuation">;</span>        replacing <span class="token operator">=</span> cls<span class="token punctuation">;</span>        cls <span class="token operator">=</span> newCls<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-2-添加命名过的类"><a href="#3-1-2-添加命名过的类" class="headerlink" title="3.1.2 添加命名过的类"></a>3.1.2 添加命名过的类</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">addNamedClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> mangledName<span class="token punctuation">,</span> replacing<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-1-3-把类插入到包含所有类的表里"><a href="#3-1-3-把类插入到包含所有类的表里" class="headerlink" title="3.1.3 把类插入到包含所有类的表里"></a>3.1.3 把类插入到包含所有类的表里</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">addClassTableEntry</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体的实现为如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addClassTableEntry</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> addMeta <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    runtimeLock<span class="token punctuation">.</span><span class="token function">assertLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// This class is allowed to be a known class via the shared cache or via</span>    <span class="token comment" spellcheck="true">// data segments, but it is not allowed to be in the dynamic table already.</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">NXHashMember</span><span class="token punctuation">(</span>allocatedClasses<span class="token punctuation">,</span> cls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isKnownClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">NXHashInsert</span><span class="token punctuation">(</span>allocatedClasses<span class="token punctuation">,</span> cls<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>addMeta<span class="token punctuation">)</span>        <span class="token function">addClassTableEntry</span><span class="token punctuation">(</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">ISA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-realizeClassWithoutSwift"><a href="#3-2-realizeClassWithoutSwift" class="headerlink" title="3.2 realizeClassWithoutSwift"></a>3.2 realizeClassWithoutSwift</h3><blockquote><p>实现类的初次初始化，包括开辟rw数据的内存空间。</p></blockquote><h4 id="3-2-1-取出类里的-ro-部分（data）"><a href="#3-2-1-取出类里的-ro-部分（data）" class="headerlink" title="3.2.1 取出类里的 ro 部分（data）"></a>3.2.1 取出类里的 ro 部分（data）</h4><pre class="line-numbers language-cpp"><code class="language-cpp">ro <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> class_ro_t <span class="token operator">*</span><span class="token punctuation">)</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-2-2-开辟rw-内存空间"><a href="#3-2-2-开辟rw-内存空间" class="headerlink" title="3.2.2 开辟rw 内存空间"></a>3.2.2 开辟rw 内存空间</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Normal class. Allocate writeable class data.</span>rw <span class="token operator">=</span> <span class="token punctuation">(</span>class_rw_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>class_rw_t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>rw<span class="token operator">-</span><span class="token operator">></span>ro <span class="token operator">=</span> ro<span class="token punctuation">;</span>rw<span class="token operator">-</span><span class="token operator">></span>flags <span class="token operator">=</span> RW_REALIZED<span class="token operator">|</span>RW_REALIZING<span class="token punctuation">;</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">setData</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终通过<code>cls-&gt;setData(rw)</code> , 将rw 作为data赋值给类 cls。</p><p>但是到这里，cls 仅仅是对数据部分做了<strong>初始化</strong>，里面的方法都没有写入。</p><p>如何验证？</p><p>通过lldb 来进行验证吧：</p><ol><li>通过p/x 获取cls指针</li><li>偏移16位获得bits 的指针</li><li>将bits 强转为<code>class_data_bits_t</code> 的类型$2</li><li>读取$2点data() 方法。</li></ol><p>过程可见下图，methods 属性下的list 为空，并没有方法列表的写入。</p><p><img src="/p/29664/002.png" alt="通过lldb 得到的rw 部分"></p><p>可见该过程，仅仅对<code>cls</code> 下<code>rw</code> 的属性的<code>ro</code> 、<code>flags</code>进行了赋值，而<code>rw</code> 并没有得到赋值</p><h4 id="3-2-3-实现父类和元类关联"><a href="#3-2-3-实现父类和元类关联" class="headerlink" title="3.2.3 实现父类和元类关联"></a>3.2.3 实现父类和元类关联</h4><h5 id="3-2-3-1-子类链接父类"><a href="#3-2-3-1-子类链接父类" class="headerlink" title="3.2.3.1 子类链接父类"></a>3.2.3.1 子类链接父类</h5><p>上面的流程都是在初始化类的各种属性后，而类的结构最重要的一点是它与父类的关联，以及与元类的isa 指向。</p><p>所以下面的操作是</p><ul><li>通过<code>remapClass(cls-&gt;superclass)</code>对父类进行映射查找</li><li>通过<code>remapClass(cls-&gt;ISA)</code>对元类进行查找</li></ul><p>然后通过<code>realizeClassWithoutSwift</code> 进行递归，逐步得到相应的<code>supercls</code>以及<code>metacls</code> 的指针。</p><p>步骤依然是：<strong>类——元类——根元类——NSObject——nil</strong>（跳出）</p><pre class="line-numbers language-cpp"><code class="language-cpp">supercls <span class="token operator">=</span> <span class="token function">realizeClassWithoutSwift</span><span class="token punctuation">(</span><span class="token function">remapClass</span><span class="token punctuation">(</span>cls<span class="token operator">-</span><span class="token operator">></span>superclass<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>metacls <span class="token operator">=</span> <span class="token function">realizeClassWithoutSwift</span><span class="token punctuation">(</span><span class="token function">remapClass</span><span class="token punctuation">(</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">ISA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个失踪人口进行搜寻成功后，就可以将其指针对类进行关联</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Update superclass and metaclass in case of remapping</span>cls<span class="token operator">-</span><span class="token operator">></span>superclass <span class="token operator">=</span> supercls<span class="token punctuation">;</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">initClassIsa</span><span class="token punctuation">(</span>metacls<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="3-2-3-2-父类链接子类"><a href="#3-2-3-2-父类链接子类" class="headerlink" title="3.2.3.2 父类链接子类"></a>3.2.3.2 父类链接子类</h5><p>如果找到父类，在父类添加双向链表的引用，将子类引用添加到父类的子类列表里，最终实现父类和子类建立关联</p><pre><code>    // Connect this class to its superclass&#39;s subclass lists    if (supercls) {        addSubclass(supercls, cls);    } else {        addRootClass(cls);    }</code></pre><p>结论是：子类里添加父类链接，父类里也添加子类链接，你中有我，我中有你。</p><p><img src="/p/29664/003.png" alt="子类——父类关联图"></p><p>接下来看一下父类链接的具体实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addSubclass</span><span class="token punctuation">(</span>Class <span class="token class-name">supercls</span><span class="token punctuation">,</span> Class <span class="token class-name">subcls</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    runtimeLock<span class="token punctuation">.</span><span class="token function">assertLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>supercls  <span class="token operator">&amp;&amp;</span>  subcls<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">assert</span><span class="token punctuation">(</span>supercls<span class="token operator">-</span><span class="token operator">></span><span class="token function">isRealized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>subcls<span class="token operator">-</span><span class="token operator">></span><span class="token function">isRealized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subcls<span class="token operator">-</span><span class="token operator">></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>nextSiblingClass <span class="token operator">=</span> supercls<span class="token operator">-</span><span class="token operator">></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>firstSubclass<span class="token punctuation">;</span>        supercls<span class="token operator">-</span><span class="token operator">></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>firstSubclass <span class="token operator">=</span> subcls<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>supercls<span class="token operator">-</span><span class="token operator">></span><span class="token function">hasCxxCtor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            subcls<span class="token operator">-</span><span class="token operator">></span><span class="token function">setHasCxxCtor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>supercls<span class="token operator">-</span><span class="token operator">></span><span class="token function">hasCxxDtor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            subcls<span class="token operator">-</span><span class="token operator">></span><span class="token function">setHasCxxDtor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>supercls<span class="token operator">-</span><span class="token operator">></span><span class="token function">hasCustomRR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            subcls<span class="token operator">-</span><span class="token operator">></span><span class="token function">setHasCustomRR</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>supercls<span class="token operator">-</span><span class="token operator">></span><span class="token function">hasCustomAWZ</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            subcls<span class="token operator">-</span><span class="token operator">></span><span class="token function">setHasCustomAWZ</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Special case: instancesRequireRawIsa does not propagate </span>        <span class="token comment" spellcheck="true">// from root class to root metaclass</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>supercls<span class="token operator">-</span><span class="token operator">></span><span class="token function">instancesRequireRawIsa</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">&amp;&amp;</span>  supercls<span class="token operator">-</span><span class="token operator">></span>superclass<span class="token punctuation">)</span> <span class="token punctuation">{</span>            subcls<span class="token operator">-</span><span class="token operator">></span><span class="token function">setInstancesRequireRawIsa</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现为：</p><p>父类的第一个子类，赋值给子类的下一个兄弟类：</p><pre class="line-numbers language-cpp"><code class="language-cpp">subcls<span class="token operator">-</span><span class="token operator">></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>nextSiblingClass <span class="token operator">=</span> supercls<span class="token operator">-</span><span class="token operator">></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>firstSubclass<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>子类赋值给父类的第一个子类：</p><pre class="line-numbers language-cpp"><code class="language-cpp">supercls<span class="token operator">-</span><span class="token operator">></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>firstSubclass <span class="token operator">=</span> subcls<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时，子类继承父类的各种能力</p><ul><li>hasCxxCtor</li><li>hasCxxDtor</li><li>hasCustomRR</li><li>hasCustomAWZ</li><li>instancesRequireRawIsa（适用NONPOINTER_ISA）</li></ul><h4 id="3-2-4-methodizeClass-rw-内容的填充"><a href="#3-2-4-methodizeClass-rw-内容的填充" class="headerlink" title="3.2.4 methodizeClass - rw 内容的填充"></a>3.2.4 methodizeClass - rw 内容的填充</h4><blockquote><ol><li><p>对之前创建的rw 进行方法、属性，协议的填充实现</p></li><li><p>对分类的实现</p></li></ol></blockquote><ul><li><p>方法的填充实现</p><pre class="line-numbers language-cpp"><code class="language-cpp">    method_list_t <span class="token operator">*</span>list <span class="token operator">=</span> ro<span class="token operator">-</span><span class="token operator">></span><span class="token function">baseMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">prepareMethodLists</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">&amp;</span>list<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> YES<span class="token punctuation">,</span> <span class="token function">isBundleClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rw<span class="token operator">-</span><span class="token operator">></span>methods<span class="token punctuation">.</span><span class="token function">attachLists</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>list<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>属性填充实现</p><pre class="line-numbers language-cpp"><code class="language-cpp">    property_list_t <span class="token operator">*</span>proplist <span class="token operator">=</span> ro<span class="token operator">-</span><span class="token operator">></span>baseProperties<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>proplist<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rw<span class="token operator">-</span><span class="token operator">></span>properties<span class="token punctuation">.</span><span class="token function">attachLists</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>proplist<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>协议填充实现</p><pre class="line-numbers language-cpp"><code class="language-cpp">    protocol_list_t <span class="token operator">*</span>protolist <span class="token operator">=</span> ro<span class="token operator">-</span><span class="token operator">></span>baseProtocols<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>protolist<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rw<span class="token operator">-</span><span class="token operator">></span>protocols<span class="token punctuation">.</span><span class="token function">attachLists</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>protolist<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>根元类额外的实现</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">isRootMetaclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// root metaclass</span>        <span class="token function">addMethod</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> SEL_initialize<span class="token punctuation">,</span> <span class="token punctuation">(</span>IMP<span class="token punctuation">)</span><span class="token operator">&amp;</span>objc_noop_imp<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> NO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加分类</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// Attach categories.</span>    category_list <span class="token operator">*</span>cats <span class="token operator">=</span> <span class="token function">unattachedCategoriesForClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">/*realizing*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">attachCategories</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> cats<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment" spellcheck="true">/*don't flush caches*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>提一下上面的方法实现中添加的机制，究竟是如何的？继续看源码，可以看到添加情况有3种</p><ul><li><p>多对多 - 方法原已有多个，在需要添加多个</p><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// many lists -> many lists</span>            uint32_t oldCount <span class="token operator">=</span> <span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>count<span class="token punctuation">;</span>            uint32_t newCount <span class="token operator">=</span> oldCount <span class="token operator">+</span> addedCount<span class="token punctuation">;</span>            <span class="token function">setArray</span><span class="token punctuation">(</span><span class="token punctuation">(</span>array_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> array_t<span class="token operator">::</span><span class="token function">byteSize</span><span class="token punctuation">(</span>newCount<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>count <span class="token operator">=</span> newCount<span class="token punctuation">;</span>            <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>lists <span class="token operator">+</span> addedCount<span class="token punctuation">,</span> <span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>lists<span class="token punctuation">,</span>                     oldCount <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>lists<span class="token punctuation">,</span> addedLists<span class="token punctuation">,</span>                    addedCount <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里经历了3个步骤：</p><ul><li>获取原方法数： <code>array()-&gt;count</code></li><li>获取原方法数+新方法的总方法数： <code>oldCount + addedCount</code></li><li>内存扩容：<code>realloc</code></li><li>字节移动：内存中原方法平移：<code>memmove</code></li><li>字节移动：新方法拷贝进入：<code>memcpy</code></li></ul></li><li><p>0 对多 - 方法原没有，在需要添加多个</p><pre class="line-numbers language-cpp"><code class="language-cpp">list <span class="token operator">=</span> addedLists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>1 对多</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 1 list -> many lists</span>List<span class="token operator">*</span> oldList <span class="token operator">=</span> list<span class="token punctuation">;</span>uint32_t oldCount <span class="token operator">=</span> oldList <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>uint32_t newCount <span class="token operator">=</span> oldCount <span class="token operator">+</span> addedCount<span class="token punctuation">;</span><span class="token function">setArray</span><span class="token punctuation">(</span><span class="token punctuation">(</span>array_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>array_t<span class="token operator">::</span><span class="token function">byteSize</span><span class="token punctuation">(</span>newCount<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>count <span class="token operator">=</span> newCount<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>oldList<span class="token punctuation">)</span> <span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>lists<span class="token punctuation">[</span>addedCount<span class="token punctuation">]</span> <span class="token operator">=</span> oldList<span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>lists<span class="token punctuation">,</span> addedLists<span class="token punctuation">,</span>                    addedCount <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>另外，可以观察到无论是方法<code>methods</code>、属性<code>properties</code>、协议<code>protocols</code>，在添加时，使用的同样的方法<code>attachLists</code>， 这是因为作为同为<code>class_rw_t</code>类型下的属性，他们拥有同样的数据结构：二维数组。</p><p>其中方法列表和属性列表的根类型，均为<code>entsize_list_tt</code></p><p>方法列表结构：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">method_array_t</span> <span class="token operator">:</span>     <span class="token keyword">public</span> list_array_tt<span class="token operator">&lt;</span>method_t<span class="token punctuation">,</span> method_list_t<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>属性列表结构：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">property_array_t</span> <span class="token operator">:</span> <span class="token keyword">public</span> list_array_tt<span class="token operator">&lt;</span>property_t<span class="token punctuation">,</span> property_list_t<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>协议列表结构：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">protocol_array_t</span> <span class="token operator">:</span>     <span class="token keyword">public</span> list_array_tt<span class="token operator">&lt;</span>protocol_ref_t<span class="token punctuation">,</span> protocol_list_t<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>方法列表设计成二维数组，方便分类方法的批量插入：</p><p><img src="/p/29664/004.png" alt="method_array_t 结构图"></p><h2 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h2><blockquote><p>类的加载，流程分为环境的启动配置、加载镜像、读取类方法、对类内存空间初始化、子类-父类建立连接，以及最终rw填充方法，并对分类方法加入进行实现。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 源码 </tag>
            
            <tag> 底层 </tag>
            
            <tag> Class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【底层探索】dyld浅析</title>
      <link href="/p/62973.html"/>
      <url>/p/62973.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">GITHUB</a></p></blockquote><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>前文研究了对象、方法的基础，知道了对象/类的结构，类方法的生成和传递原理。下面该进入到核心环节，就是类的加载了，在这一个模块，需要了解的有下面几点：</p><ul><li>OC 的库</li><li>app 的加载流程</li><li>image 的结构</li><li>回调函数</li><li>image 的加载流程</li></ul><h2 id="二、库"><a href="#二、库" class="headerlink" title="二、库"></a>二、库</h2><h3 id="2-1、静态库"><a href="#2-1、静态库" class="headerlink" title="2.1、静态库"></a>2.1、静态库</h3><blockquote><p>是一个外部函数与变量的集合体</p><p>iOS 在<strong>编译时</strong>执行静态库，链接到相应代码</p></blockquote><p>静态库的文件内容，通常包含一堆程序员自定的变量与函数，其内容不像动态链接库那么复杂，在编译期间由编译器与链接器将它集成至应用程序内，并制作成目标文件以及可以独立运作的可执行文件。</p><p>常见的iOS 环境下的静态库由 <code>.a</code> 文件，<code>.framework</code> 文件。java 环境下有<code>.so</code> 静态库</p><h3 id="2-2、动态库"><a href="#2-2、动态库" class="headerlink" title="2.2、动态库"></a>2.2、动态库</h3><blockquote><p>iOS 在<strong>运行时</strong>执行动态库，链接到相应的代码里。</p></blockquote><p> .dylib 库文件</p><h2 id="三、App-启动流程"><a href="#三、App-启动流程" class="headerlink" title="三、App 启动流程"></a>三、App 启动流程</h2><h3 id="1-dyld-start"><a href="#1-dyld-start" class="headerlink" title="1. dyld start"></a>1. dyld start</h3><pre class="line-numbers language-cpp"><code class="language-cpp">libdyld<span class="token punctuation">.</span>dylib`start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-加载镜像"><a href="#2-加载镜像" class="headerlink" title="2. 加载镜像"></a>2. 加载镜像</h3><pre><code>reloadAllImages:</code></pre><h3 id="3-加载链接"><a href="#3-加载链接" class="headerlink" title="3. 加载链接"></a>3. 加载链接</h3><pre><code>loadInsertedDylib</code></pre><ul><li>插入（insert）： 插入网线</li><li>链接（link）： 接通网络</li></ul><h2 id="四、dyld"><a href="#四、dyld" class="headerlink" title="四、dyld"></a>四、dyld</h2><h3 id="4-1-start"><a href="#4-1-start" class="headerlink" title="4.1 start"></a>4.1 start</h3><h3 id="4-2-递归初始化"><a href="#4-2-递归初始化" class="headerlink" title="4.2 递归初始化"></a>4.2 递归初始化</h3><h3 id="4-3-objc-init"><a href="#4-3-objc-init" class="headerlink" title="4.3 objc_init"></a>4.3 objc_init</h3><h2 id="五、镜像-images"><a href="#五、镜像-images" class="headerlink" title="五、镜像 - images"></a>五、镜像 - images</h2><ul><li>dyld</li><li>Objc_init</li></ul><h2 id="六、回调函数"><a href="#六、回调函数" class="headerlink" title="六、回调函数"></a>六、回调函数</h2><ul><li>指针</li><li>注册</li><li>*snotif</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 底层 </tag>
            
            <tag> dyld </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法的本质4_消息转发机制</title>
      <link href="/p/59010.html"/>
      <url>/p/59010.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">GITHUB</a></p></blockquote><h3 id="1、回顾"><a href="#1、回顾" class="headerlink" title="1、回顾"></a>1、回顾</h3><p>上文消息<a href="http://nilsli.com/2020/03/06/wayOfCheckingMethod/">方法的本质3_消息查找流程</a> 一文总结了方法查找的流程，得到结论如下:</p><blockquote><ol><li>类的缓存里查找——找到——结束查找</li><li>类的方法列表里查找——找到——结束查找</li><li>递归父类缓存、方法列表查找——找到——结束查找</li><li>动态方法解析——（未分析）</li><li>以上未解决——异常崩溃——结束</li></ol></blockquote><p>下面继续学习源码，结合业务代码，深挖第四步 <strong>动态方法决议</strong>，来更深一步的学习<strong>消息转发机制</strong>。</p><h3 id="2、问题"><a href="#2、问题" class="headerlink" title="2、问题"></a>2、问题</h3><p>这篇文章，希望弄清楚下面的问题</p><ul><li><p>消息转发是什么</p></li><li><p>消息转发的场景</p></li><li><p>如何进行消息转发</p><h3 id="3、动态方法决议"><a href="#3、动态方法决议" class="headerlink" title="3、动态方法决议"></a>3、动态方法决议</h3></li></ul><h4 id="3-1-入口-class-resolveMethod"><a href="#3-1-入口-class-resolveMethod" class="headerlink" title="3.1 入口 - class_resolveMethod"></a>3.1 入口 - class_resolveMethod</h4><p>之前的分析，知道了当查找缓存未命中后，会执行<code>objc_msgSend_uncached</code> 的方法，进行方法查找。</p><p>具体执行的是方法 <code>_class_lookupMethodAndLoadCache3</code> 。</p><p>runtime 源码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/************************************************************************ _class_lookupMethodAndLoadCache.* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().* This lookup avoids optimistic cache scan because the dispatcher * already tried that.**********************************************************************/</span>IMP <span class="token function">_class_lookupMethodAndLoadCache3</span><span class="token punctuation">(</span>id obj<span class="token punctuation">,</span> SEL sel<span class="token punctuation">,</span> Class <span class="token class-name">cls</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">lookUpImpOrForward</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> obj<span class="token punctuation">,</span>                               YES<span class="token comment" spellcheck="true">/*initialize*/</span><span class="token punctuation">,</span> NO<span class="token comment" spellcheck="true">/*cache*/</span><span class="token punctuation">,</span> YES<span class="token comment" spellcheck="true">/*resolver*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在源码中，知道了具体执行的方法是 <code>lookUpImpOrForward</code>，这个方法执行了众多流程，缓存、递归查找等。</p><p>如果都未命中，则会找到<strong>方法决议</strong>实现，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// No implementation found. Try method resolver once.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolver  <span class="token operator">&amp;&amp;</span>  <span class="token operator">!</span>triedResolver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        runtimeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">_class_resolveMethod</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> inst<span class="token punctuation">)</span><span class="token punctuation">;</span>        runtimeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Don't cache the result; we don't hold the lock so it may have </span>        <span class="token comment" spellcheck="true">// changed already. Re-do the search from scratch instead.</span>        triedResolver <span class="token operator">=</span> YES<span class="token punctuation">;</span>        <span class="token keyword">goto</span> retry<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到执行 <code>_class_resolveMethod(cls, sel, inst)</code> 前后，使用了runtimeLock 进行了锁定与解锁，具体实现时互斥锁（参见Cooci老师的<a href="https://www.jianshu.com/p/32068ffa6136" target="_blank" rel="noopener">互斥锁-读写锁-条件锁</a>），来保证内存安全。</p><p>查看一下class_resolveMethod 方法</p><blockquote><p><strong>Summary</strong></p><p> _class_resolveMethod Call +resolveClassMethod or +resolveInstanceMethod. Returns nothing; any result would be potentially out-of-date already. Does not check if the method already exists.</p><p>class_resolveMethod 调用  +resolveClassMethod 或 +resolveInstanceMethod。</p><p>返回值为空；任何结果将可能已经过期。</p><p>如果方法已经存在，不会检查/执行。</p></blockquote><p>由此可见resolveMethod 只是一个入口，会具体调用如下方法：</p><ul><li>类方法：+resolveInstanceMethod</li><li>实例方法：+resolveInstanceMethod</li></ul><p>具体的源码，见下面的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_class_resolveMethod</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">,</span> SEL sel<span class="token punctuation">,</span> id inst<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">isMetaClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// try [cls resolveInstanceMethod:sel]</span>        <span class="token function">_class_resolveInstanceMethod</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> inst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// try [nonMetaClass resolveClassMethod:sel]</span>        <span class="token comment" spellcheck="true">// and [cls resolveInstanceMethod:sel]</span>        <span class="token function">_class_resolveClassMethod</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> inst<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">lookUpImpOrNil</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> inst<span class="token punctuation">,</span>                             NO<span class="token comment" spellcheck="true">/*initialize*/</span><span class="token punctuation">,</span> YES<span class="token comment" spellcheck="true">/*cache*/</span><span class="token punctuation">,</span> NO<span class="token comment" spellcheck="true">/*resolver*/</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            <span class="token function">_class_resolveInstanceMethod</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> inst<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>代码</th><th>分析</th><th>备注</th></tr></thead><tbody><tr><td>! cls-&gt;isMetaClass()</td><td>是否元类</td><td>否，说明主体是实例</td></tr><tr><td>_class_resolveInstanceMethod</td><td>实例方法决议实现</td><td></td></tr><tr><td>_class_resolveClassMethod</td><td>类方法决议实现</td><td></td></tr><tr><td>_class_resolveInstanceMethod</td><td>[第2个] 查看NSObject 决议实现</td><td>发生在lookUpImpOrNil 失败后</td></tr></tbody></table><p><strong>分析:</strong> </p><blockquote><p>进入决议后，先确定是否是元类；</p><p>如果是元类，由于已知类方法存储在元类里，知道该方法主体是类，则会进入类方法决议</p><p>如果不是元类，即方法主题是实例，进入实例方法决议。</p><p>如果元类方法决议查找失败，根元类亦查找失败，由于根元类的isa 是指向自身的，所以用到了 <code>_class_resolveInstanceMethod</code> 的实例决议方法。</p></blockquote><p>具体逻辑见下图：</p><p><img src="/p/59010/001.png" alt="001"></p><h4 id="3-2-类方法决议-class-resolveClassMethod"><a href="#3-2-类方法决议-class-resolveClassMethod" class="headerlink" title="3.2 类方法决议 - _class_resolveClassMethod"></a>3.2 类方法决议 - _class_resolveClassMethod</h4><p>捋清楚入口后，继续看类方法的决议，源码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/************************************************************************ _class_resolveClassMethod* Call +resolveClassMethod, looking for a method to be added to class cls.* cls should be a metaclass.* Does not check if the method already exists.**********************************************************************/</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">_class_resolveClassMethod</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">,</span> SEL sel<span class="token punctuation">,</span> id inst<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">isMetaClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">lookUpImpOrNil</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> SEL_resolveClassMethod<span class="token punctuation">,</span> inst<span class="token punctuation">,</span>                          NO<span class="token comment" spellcheck="true">/*initialize*/</span><span class="token punctuation">,</span> YES<span class="token comment" spellcheck="true">/*cache*/</span><span class="token punctuation">,</span> NO<span class="token comment" spellcheck="true">/*resolver*/</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Resolver not implemented.</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">BOOL</span> <span class="token punctuation">(</span><span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">(</span>Class<span class="token punctuation">,</span> SEL<span class="token punctuation">,</span> SEL<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">typeof</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span>objc_msgSend<span class="token punctuation">;</span>    <span class="token keyword">bool</span> resolved <span class="token operator">=</span> <span class="token function">msg</span><span class="token punctuation">(</span><span class="token function">_class_getNonMetaClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> inst<span class="token punctuation">)</span><span class="token punctuation">,</span>                         SEL_resolveClassMethod<span class="token punctuation">,</span> sel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Cache the result (good or bad) so the resolver doesn't fire next time.</span>    <span class="token comment" spellcheck="true">// +resolveClassMethod adds to self->ISA() a.k.a. cls</span>    IMP imp <span class="token operator">=</span> <span class="token function">lookUpImpOrNil</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> inst<span class="token punctuation">,</span>                              NO<span class="token comment" spellcheck="true">/*initialize*/</span><span class="token punctuation">,</span> YES<span class="token comment" spellcheck="true">/*cache*/</span><span class="token punctuation">,</span> NO<span class="token comment" spellcheck="true">/*resolver*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolved  <span class="token operator">&amp;&amp;</span>  PrintResolving<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>imp<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">_objc_inform</span><span class="token punctuation">(</span><span class="token string">"RESOLVE: method %c[%s %s] "</span>                         <span class="token string">"dynamically resolved to %p"</span><span class="token punctuation">,</span>                          cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">isMetaClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'+'</span> <span class="token operator">:</span> <span class="token string">'-'</span><span class="token punctuation">,</span>                          cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">nameForLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sel_getName</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">,</span> imp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Method resolver didn't add anything?</span>            <span class="token function">_objc_inform</span><span class="token punctuation">(</span><span class="token string">"RESOLVE: +[%s resolveClassMethod:%s] returned YES"</span>                         <span class="token string">", but no new implementation of %c[%s %s] was found"</span><span class="token punctuation">,</span>                         cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">nameForLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sel_getName</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">,</span>                          cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">isMetaClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'+'</span> <span class="token operator">:</span> <span class="token string">'-'</span><span class="token punctuation">,</span>                          cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">nameForLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sel_getName</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析上文的源码，除了一些断言、异常的保护代码外，关键语句来到了这一句</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token function">BOOL</span> <span class="token punctuation">(</span><span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">(</span>Class<span class="token punctuation">,</span> SEL<span class="token punctuation">,</span> SEL<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">typeof</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span>objc_msgSend<span class="token punctuation">;</span>    <span class="token keyword">bool</span> resolved <span class="token operator">=</span> <span class="token function">msg</span><span class="token punctuation">(</span><span class="token function">_class_getNonMetaClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> inst<span class="token punctuation">)</span><span class="token punctuation">,</span>                         SEL_resolveClassMethod<span class="token punctuation">,</span> sel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的函数<code>msg</code> 调用了3个参数</p><ul><li>_class_getNonMetaClass(cls, inst) ：即类的本身 </li><li>SEL_resolveClassMethod ： 决议的类方法</li><li>sel ：需要查找的方法编号</li></ul><p>所以，关键的行为就是<code>SEL_resolveClassMethod</code> 方法，通过搜索，源码代码中均找不到。</p><p>回头看苹果给该方法写的注释：</p><blockquote><p>_class_resolveClassMethod</p><p>Call +resolveClassMethod, looking for a method to be added to class cls.</p></blockquote><p>意思是C 源码里写的方法，在OC 实现里，会执行+resolveClassMethod 的方法，即通过resolveClassMethod 来对该类进行决议——添加相应的类方法。</p><p>在OC里的实现即这个方法</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">+</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>resolveClassMethod<span class="token operator">:</span><span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>sel<span class="token punctuation">{</span>    <span class="token keyword">return</span> NO<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>至此，已经大概明白了决议的意义——当方法找不到实现时，转发到类/实例决议方法里，看看开发者是否有自行实现。其最大的意义，恐怕是收集各种崩溃了。</p><h4 id="3-3-实例方法决议-class-resolveInstanceMethod"><a href="#3-3-实例方法决议-class-resolveInstanceMethod" class="headerlink" title="3.3 实例方法决议 - class_resolveInstanceMethod"></a>3.3 实例方法决议 - class_resolveInstanceMethod</h4><p>实例方法决议的源码实现，与类方法决议类似，差别仅仅在决议执行方法，换成了<code>SEL_resolveInstanceMethod</code>，源码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token function">BOOL</span> <span class="token punctuation">(</span><span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">(</span>Class<span class="token punctuation">,</span> SEL<span class="token punctuation">,</span> SEL<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">typeof</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span>objc_msgSend<span class="token punctuation">;</span>    <span class="token keyword">bool</span> resolved <span class="token operator">=</span> <span class="token function">msg</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> SEL_resolveInstanceMethod<span class="token punctuation">,</span> sel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当决议方法得到实现后，会提示，方法XX 已经被决议成为新的实现YY—— 否则会提示决议未找到:</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolved  <span class="token operator">&amp;&amp;</span>  PrintResolving<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>imp<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">_objc_inform</span><span class="token punctuation">(</span><span class="token string">"RESOLVE: method %c[%s %s] "</span>                         <span class="token string">"dynamically resolved to %p"</span><span class="token punctuation">,</span>                          cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">isMetaClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'+'</span> <span class="token operator">:</span> <span class="token string">'-'</span><span class="token punctuation">,</span>                          cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">nameForLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sel_getName</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">,</span> imp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Method resolver didn't add anything?</span>            <span class="token function">_objc_inform</span><span class="token punctuation">(</span><span class="token string">"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES"</span>                         <span class="token string">", but no new implementation of %c[%s %s] was found"</span><span class="token punctuation">,</span>                         cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">nameForLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sel_getName</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">,</span>                          cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">isMetaClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'+'</span> <span class="token operator">:</span> <span class="token string">'-'</span><span class="token punctuation">,</span>                          cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">nameForLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sel_getName</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、快速转发阶段"><a href="#4、快速转发阶段" class="headerlink" title="4、快速转发阶段"></a>4、快速转发阶段</h3><h4 id="4-1-快速转发方法"><a href="#4-1-快速转发方法" class="headerlink" title="4.1 快速转发方法"></a>4.1 快速转发方法</h4><p><strong>forwardingTargetForSelector</strong> ：即将本类未实现的方法，交由指定的其他类来实现。</p><h4 id="4-2-业务代码"><a href="#4-2-业务代码" class="headerlink" title="4.2 业务代码"></a>4.2 业务代码</h4><p>实现如下：</p><ul><li><p>类<code>Person</code>, 与未实现的方法<code>teach</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp">@interface Person <span class="token operator">:</span> NSObject<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>teach<span class="token punctuation">;</span>@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类的转发方法——指定<code>Teacher</code> 这个类来执行</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>forwardingTargetForSelector<span class="token operator">:</span><span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>aSelector <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>aSelector <span class="token operator">==</span> @<span class="token function">selector</span><span class="token punctuation">(</span>teach<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>Teacher alloc<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>super forwardingTargetForSelector<span class="token operator">:</span>aSelector<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>类<code>Teacher</code>  以及实现的方法<code>teach</code></p><pre class="line-numbers language-cpp"><code class="language-cpp">NS_ASSUME_NONNULL_BEGIN@interface Teacher <span class="token operator">:</span> NSObject<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>teach<span class="token punctuation">;</span>@endNS_ASSUME_NONNULL_END@implementation Teacher<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>teach<span class="token punctuation">{</span>    <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>主业务执行，使类执行它为实现的方法<code>teach</code>:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    @autoreleasepool <span class="token punctuation">{</span>        Person <span class="token operator">*</span>person <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Person alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">[</span>person teach<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行结果，<code>teacher</code>类实现了<code>teach</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">2020</span><span class="token operator">-</span><span class="token number">03</span><span class="token operator">-</span><span class="token number">20</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">51.477020</span><span class="token operator">+</span><span class="token number">0800</span> debug<span class="token operator">-</span>objc<span class="token punctuation">[</span><span class="token number">8565</span><span class="token operator">:</span><span class="token number">349779</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token punctuation">[</span>Teacher teach<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由此可见，forwardingTargetForSelector 的作用，是自身无法处理，交由其他对象（可能是类）来处理。</p></li></ul><h3 id="5、慢速转发阶段"><a href="#5、慢速转发阶段" class="headerlink" title="5、慢速转发阶段"></a>5、慢速转发阶段</h3><h4 id="5-1-慢速转发方法"><a href="#5-1-慢速转发方法" class="headerlink" title="5.1 慢速转发方法"></a>5.1 慢速转发方法</h4><p><strong>methodSignatureForSelector</strong>，看看开发文档的描述：</p><blockquote><h1 id="methodSignatureForSelector"><a href="#methodSignatureForSelector" class="headerlink" title="methodSignatureForSelector:"></a>methodSignatureForSelector:</h1><p>Returns an <code>NSMethodSignature</code> object that contains a description of the method identified by a given selector.</p><p>返回一个<code>NSMethodSignature</code> 的签名对象，包含一个给定选择器的方法的描述</p></blockquote><ul><li>获取方法签名： <code>methodSignatureForSelector</code></li><li>通过获取的签名，转发信息 –<br>执行方法是 <code>forwardInvocation</code>往指定的对象传递方法和参数</li></ul><h4 id="5-2-业务代码实现"><a href="#5-2-业务代码实现" class="headerlink" title="5.2 业务代码实现:"></a>5.2 业务代码实现:</h4><p>基础代码与快速转发一致，只是删除了<strong>forwardingTargetForSelector</strong> 的实现代码。</p><p>并在<code>Person</code> 类里实现如下代码</p><ul><li><p>实现方法签名</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 获得方法签名</span><span class="token operator">-</span> <span class="token punctuation">(</span>NSMethodSignature <span class="token operator">*</span><span class="token punctuation">)</span>methodSignatureForSelector<span class="token operator">:</span><span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>aSelector<span class="token punctuation">{</span>    NSString <span class="token operator">*</span>sel <span class="token operator">=</span> <span class="token function">NSStringFromSelector</span><span class="token punctuation">(</span>aSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//生成签名</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>sel isEqualToString<span class="token operator">:</span>@<span class="token string">"run"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>NSMethodSignature signatureWithObjCTypes<span class="token operator">:</span><span class="token string">"v@:"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>super methodSignatureForSelector<span class="token operator">:</span>aSelector<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>“v” 是方法描述，更多的在这里：</p><blockquote><p>*                     代表 char * </p><p>char BOOL     代表 c</p><p>:                       代表 SEL </p><p>^type               代表 type *</p><p>@                     代表 NSObject * 或 id</p><p>^@                   代表 NSError ** </p><p>#                      代表 NSObject </p><p>v                       代表 void</p></blockquote></li><li><p>获取签名，进行配发信息 </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>forwardInvocation<span class="token operator">:</span><span class="token punctuation">(</span>NSInvocation <span class="token operator">*</span><span class="token punctuation">)</span>anInvocation<span class="token punctuation">{</span>    <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"-----%@-----"</span><span class="token punctuation">,</span>anInvocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//取得消息</span>    SEL selector <span class="token operator">=</span> <span class="token punctuation">[</span>anInvocation selector<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//转发</span>    SomePerson <span class="token operator">*</span>someP <span class="token operator">=</span> <span class="token punctuation">[</span>SomePerson <span class="token keyword">new</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>someP respondsToSelector<span class="token operator">:</span>selector<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//调用对象，进行转发</span>        <span class="token punctuation">[</span>anInvocation invokeWithTarget<span class="token operator">:</span>someP<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>super forwardInvocation<span class="token operator">:</span>anInvocation<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>执行<code>teach</code> 结果</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">2020</span><span class="token operator">-</span><span class="token number">03</span><span class="token operator">-</span><span class="token number">20</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">37</span><span class="token operator">:</span><span class="token number">41.639718</span><span class="token operator">+</span><span class="token number">0800</span> debug<span class="token operator">-</span>objc<span class="token punctuation">[</span><span class="token number">9325</span><span class="token operator">:</span><span class="token number">370827</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token punctuation">[</span>Teacher teach<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="6、查找失败"><a href="#6、查找失败" class="headerlink" title="6、查找失败"></a>6、查找失败</h3><p>消息没有得到处理 崩溃退出，这里从<code>forwardInvocation</code> 的实现，可以追踪到相关的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>forwardInvocation<span class="token operator">:</span><span class="token punctuation">(</span>NSInvocation <span class="token operator">*</span><span class="token punctuation">)</span>invocation <span class="token punctuation">{</span>    <span class="token punctuation">[</span>self doesNotRecognizeSelector<span class="token operator">:</span><span class="token punctuation">(</span>invocation <span class="token operator">?</span> <span class="token punctuation">[</span>invocation selector<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Replaced by CF (throws an NSException)</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>doesNotRecognizeSelector<span class="token operator">:</span><span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>sel <span class="token punctuation">{</span>    <span class="token function">_objc_fatal</span><span class="token punctuation">(</span><span class="token string">"-[%s %s]: unrecognized selector sent to instance %p"</span><span class="token punctuation">,</span>                 <span class="token function">object_getClassName</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sel_getName</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7、-总结"><a href="#7、-总结" class="headerlink" title="7、 总结"></a>7、 总结</h3><p>又到了最受欢迎的总结时间。</p><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><blockquote><ul><li>消息转发是什么：向指定的对象或类，发送需要消息，请求交由对方执行</li><li>消息转发的场景：自我无法实现的场景下。</li><li>如何进行消息转发 <ul><li>快速转发：使用 <code>forwardingTargetForSelector</code> 进行定向转发</li><li>慢速转发：获取签名，使用<code>forwardInvocation</code> 转发</li></ul></li></ul></blockquote><h4 id="有图"><a href="#有图" class="headerlink" title="有图"></a>有图</h4><p>另外，总结经验再多，不如有图有真相……</p><p><img src="/p/59010/002.png" alt="消息转发流程简图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 底层 </tag>
            
            <tag> 结构 </tag>
            
            <tag> 消息转发 </tag>
            
            <tag> objc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【休闲】西湖一瞥</title>
      <link href="/p/37569.html"/>
      <url>/p/37569.html</url>
      
        <content type="html"><![CDATA[<h4 id="逛次逛次的西湖"><a href="#逛次逛次的西湖" class="headerlink" title="逛次逛次的西湖"></a>逛次逛次的西湖</h4><p>今天过来平海路的Apple 直营店给电脑做大保健，顺便看了一眼西湖。</p><p>湖边景色依旧宜人，可惜游人寥寥。</p><p>期待一切顺利，然后恢复到游人如织的景色。</p><p><img src="/p/37569/02.jpg" alt="步行街"></p><p><img src="/p/37569/03.jpg" alt="Apple 直营店，天才吧的天才在户外工作"></p><p><img src="/p/37569/01.jpg" alt="【全景模式】西湖一瞥"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 休闲 </tag>
            
            <tag> 杭州 </tag>
            
            <tag> 西湖 </tag>
            
            <tag> Apple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法的本质3_消息查找流程</title>
      <link href="/p/64205.html"/>
      <url>/p/64205.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">GITHUB</a></p></blockquote><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>在前文中，已经总结了方法查找的流程，今天从代码层面上继续阐述。</p><p>isa 的指向图如下所示：</p><p>   <img src="/p/64205/001.png" alt="消息的查找流程图"></p><h2 id="2-方法查找流程"><a href="#2-方法查找流程" class="headerlink" title="2. 方法查找流程"></a>2. 方法查找流程</h2><h3 id="2-1-从业务代码分析"><a href="#2-1-从业务代码分析" class="headerlink" title="2.1 从业务代码分析"></a>2.1 从业务代码分析</h3><p><strong>配置代码环境：</strong>，先从子类父类方法查找说起，先创建几个类，有:</p><ul><li><p>父类 <strong>Person</strong> 继承自<strong>NSObject</strong>，有方法<code>talk</code></p></li><li><p>子类 <strong>Student</strong> 继承自 <strong>Person</strong>，有方法 <code>sayEnglish</code></p></li><li><p>扩展 <strong>NSObject + sayGerman</strong>，有方法 <code>sayGerman</code></p></li></ul><p>具体代码如下所示</p><p><img src="/p/64205/003.png" alt="业务代码类结构"></p><p>主业务代码图：</p><p><img src="/p/64205/004.png" alt="业务执行方法图"></p><p>由上图可以看出，我们生成的子类<code>Student</code> 对象，既可以执行自己的对象方法<code>sayEnglish</code>，也可以执行父类方法<code>talk</code>，当需要执行的方法——子类和父类都没有之后，也可以执行根类扩展方法<code>sayGerman</code>。</p><blockquote><p>查找逻辑图可以初步理解为：子类——&gt; 父类——&gt; 父类的父类 ——&gt;根元类(NSObject)</p></blockquote><p>类方法也是类似的，就不赘述</p><h3 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h3><h4 id="2-2-1-class-lookupMethodAndLoadCache3-慢速查找开启"><a href="#2-2-1-class-lookupMethodAndLoadCache3-慢速查找开启" class="headerlink" title="2.2.1 class_lookupMethodAndLoadCache3 - 慢速查找开启"></a>2.2.1 <strong>class_lookupMethodAndLoadCache3</strong> - 慢速查找开启</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/************************************************************************ _class_lookupMethodAndLoadCache.* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().* This lookup avoids optimistic cache scan because the dispatcher * already tried that.**********************************************************************/</span>IMP <span class="token function">_class_lookupMethodAndLoadCache3</span><span class="token punctuation">(</span>id obj<span class="token punctuation">,</span> SEL sel<span class="token punctuation">,</span> Class <span class="token class-name">cls</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">lookUpImpOrForward</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> obj<span class="token punctuation">,</span>                               YES<span class="token comment" spellcheck="true">/*initialize*/</span><span class="token punctuation">,</span> NO<span class="token comment" spellcheck="true">/*cache*/</span><span class="token punctuation">,</span> YES<span class="token comment" spellcheck="true">/*resolver*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原来上文留下的<strong>class_lookupMethodAndLoadCache3</strong> 方法，最终执行的方法是<strong>lookUpImpOrForward</strong>，继续探究一下！</p><h4 id="lookUpImpOrForward-查找Imp-或转发消息"><a href="#lookUpImpOrForward-查找Imp-或转发消息" class="headerlink" title="lookUpImpOrForward - 查找Imp 或转发消息"></a><strong>lookUpImpOrForward</strong> - 查找Imp 或转发消息</h4><h5 id="乐观检查是否有缓存"><a href="#乐观检查是否有缓存" class="headerlink" title="乐观检查是否有缓存"></a>乐观检查是否有缓存</h5><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Optimistic cache lookup</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>   imp <span class="token operator">=</span> <span class="token function">cache_getImp</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>imp<span class="token punctuation">)</span> <span class="token keyword">return</span> imp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="查找类是否缓存过"><a href="#查找类是否缓存过" class="headerlink" title="查找类是否缓存过"></a>查找类是否缓存过</h5><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// runtimeLock is held during isRealized and isInitialized checking</span>    <span class="token comment" spellcheck="true">// to prevent races against concurrent realization.</span>    <span class="token comment" spellcheck="true">// runtimeLock is held during method search to make</span>    <span class="token comment" spellcheck="true">// method-lookup + cache-fill atomic with respect to method addition.</span>    <span class="token comment" spellcheck="true">// Otherwise, a category could be added but ignored indefinitely because</span>    <span class="token comment" spellcheck="true">// the cache was re-filled with the old value after the cache flush on</span>    <span class="token comment" spellcheck="true">// behalf of the category.</span>    runtimeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">checkIsKnownClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里通过<code>runtimeLock</code> 锁住该部分内存，进行查找，执行了<code>isKnownClass</code>的方法，具体实现在这里</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/************************************************************************ isKnownClass* Return true if the class is known to the runtime (located within the* shared cache, within the data segment of a loaded image, or has been* allocated with obj_allocateClassPair).**********************************************************************/</span><span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">isKnownClass</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// The order of conditionals here is important for speed. We want to</span>    <span class="token comment" spellcheck="true">// put the most common cases first, but also the fastest cases</span>    <span class="token comment" spellcheck="true">// first. Checking the shared region is both fast and common.</span>    <span class="token comment" spellcheck="true">// Checking allocatedClasses is fast, but may not be common,</span>    <span class="token comment" spellcheck="true">// depending on what the program is doing. Checking if data segments</span>    <span class="token comment" spellcheck="true">// contain the address is slow, so do it last.</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">sharedRegionContains</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token function">NXHashMember</span><span class="token punctuation">(</span>allocatedClasses<span class="token punctuation">,</span> cls<span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token function">dataSegmentsContain</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在类的缓存（cache-t）找"><a href="#在类的缓存（cache-t）找" class="headerlink" title="在类的缓存（cache_t）找"></a>在类的缓存（cache_t）找</h5><pre class="line-numbers language-cpp"><code class="language-cpp">   <span class="token comment" spellcheck="true">// Try this class's cache.</span>    imp <span class="token operator">=</span> <span class="token function">cache_getImp</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>imp<span class="token punctuation">)</span> <span class="token keyword">goto</span> done<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在类的方法列表里寻找"><a href="#在类的方法列表里寻找" class="headerlink" title="在类的方法列表里寻找"></a>在类的方法列表里寻找</h5><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// Try this class's method lists.</span>    <span class="token punctuation">{</span>        Method meth <span class="token operator">=</span> <span class="token function">getMethodNoSuper_nolock</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>meth<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">log_and_fill_cache</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> meth<span class="token operator">-</span><span class="token operator">></span>imp<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> inst<span class="token punctuation">,</span> cls<span class="token punctuation">)</span><span class="token punctuation">;</span>            imp <span class="token operator">=</span> meth<span class="token operator">-</span><span class="token operator">></span>imp<span class="token punctuation">;</span>            <span class="token keyword">goto</span> done<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在父类的缓存和方法列表寻找"><a href="#在父类的缓存和方法列表寻找" class="headerlink" title="在父类的缓存和方法列表寻找"></a>在父类的缓存和方法列表寻找</h5><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// Try superclass caches and method lists.</span>    <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> attempts <span class="token operator">=</span> <span class="token function">unreasonableClassCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Class <span class="token class-name">curClass</span> <span class="token operator">=</span> cls<span class="token operator">-</span><span class="token operator">></span>superclass<span class="token punctuation">;</span>             curClass <span class="token operator">!=</span> nil<span class="token punctuation">;</span>             curClass <span class="token operator">=</span> curClass<span class="token operator">-</span><span class="token operator">></span>superclass<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Halt if there is a cycle in the superclass chain.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>attempts <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">_objc_fatal</span><span class="token punctuation">(</span><span class="token string">"Memory corruption in class list."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>父类缓存（Cache）找</p><pre class="line-numbers language-cpp"><code class="language-cpp">           <span class="token comment" spellcheck="true">// Superclass cache.</span>            imp <span class="token operator">=</span> <span class="token function">cache_getImp</span><span class="token punctuation">(</span>curClass<span class="token punctuation">,</span> sel<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>imp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>imp <span class="token operator">!=</span> <span class="token punctuation">(</span>IMP<span class="token punctuation">)</span>_objc_msgForward_impcache<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Found the method in a superclass. Cache it in this class.</span>                    <span class="token function">log_and_fill_cache</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> imp<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> inst<span class="token punctuation">,</span> curClass<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">goto</span> done<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Found a forward:: entry in a superclass.</span>                    <span class="token comment" spellcheck="true">// Stop searching, but don't cache yet; call method </span>                    <span class="token comment" spellcheck="true">// resolver for this class first.</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>父类方法列表找</p><pre class="line-numbers language-cpp"><code class="language-cpp">            <span class="token comment" spellcheck="true">// Superclass method list.</span>            Method meth <span class="token operator">=</span> <span class="token function">getMethodNoSuper_nolock</span><span class="token punctuation">(</span>curClass<span class="token punctuation">,</span> sel<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>meth<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">log_and_fill_cache</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> meth<span class="token operator">-</span><span class="token operator">></span>imp<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> inst<span class="token punctuation">,</span> curClass<span class="token punctuation">)</span><span class="token punctuation">;</span>                imp <span class="token operator">=</span> meth<span class="token operator">-</span><span class="token operator">></span>imp<span class="token punctuation">;</span>                <span class="token keyword">goto</span> done<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h5 id="有可能内存覆盖，再给一次查找"><a href="#有可能内存覆盖，再给一次查找" class="headerlink" title="有可能内存覆盖，再给一次查找"></a>有可能内存覆盖，再给一次查找</h5><p>这里的核心方法是</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// No implementation found. Try method resolver once.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolver  <span class="token operator">&amp;&amp;</span>  <span class="token operator">!</span>triedResolver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        runtimeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolveMethod</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> inst<span class="token punctuation">)</span><span class="token punctuation">;</span>        runtimeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Don't cache the result; we don't hold the lock so it may have </span>        <span class="token comment" spellcheck="true">// changed already. Re-do the search from scratch instead.</span>        triedResolver <span class="token operator">=</span> YES<span class="token punctuation">;</span>        <span class="token keyword">goto</span> retry<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="父类也没有——查找失败——报错"><a href="#父类也没有——查找失败——报错" class="headerlink" title="父类也没有——查找失败——报错"></a>父类也没有——查找失败——报错</h5><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// No implementation found, and method resolver didn't help. </span>    <span class="token comment" spellcheck="true">// Use forwarding.</span>    imp <span class="token operator">=</span> <span class="token punctuation">(</span>IMP<span class="token punctuation">)</span>_objc_msgForward_impcache<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是这个<code>_objc_msgForward_impcache</code> 的实现可不好找，在源码里只看到了这些：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">_objc_msgForward_impcache</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最终通过搜索查找<strong>_objc_msgForward_impcache</strong>，在汇编源码找到了类似的代码<img src="/p/64205/005.png" alt="消息转发流程"><br>得到这个叫做__objc_forward_handler 的代码块，搜索得知它继承自objc_defaultForwardHandler，</p><p>继续查找，得到最终的源码如下：</p><p><img src="/p/64205/006.png" alt="消息查找失败报错"></p><p>OH MY GOD! 原来这就是传说中——让程序员捶胸顿足的方法查找失败的代码</p><p><img src="/p/64205/007.png" alt="消息查找失败报错"></p><p>至此，方法查找的流程已经捋完。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>方法查找的流程，就是在类里查找缓存与方法列表里挖掘的过程。</p><p>如上文阐述：</p><blockquote><p>方法查找：缓存查找 —— <strong>类</strong>的方法列表 —— 父类的方法列表 （递归）—— 动态方法解析 —— 结束</p></blockquote><p><img src="/p/64205/002.png" alt="消息转发流程"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 底层 </tag>
            
            <tag> 类 </tag>
            
            <tag> 结构 </tag>
            
            <tag> objc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法的本质2_从objc_msgSend谈起</title>
      <link href="/p/23281.html"/>
      <url>/p/23281.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>方法的本质，就是消息传递…</em></p></blockquote><blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">GITHUB</a></p></blockquote><h3 id="一、引子：Runtime"><a href="#一、引子：Runtime" class="headerlink" title="一、引子：Runtime"></a>一、引子：Runtime</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>我们都知道，在运行<strong>OC</strong>代码时，类或者对象在调用方法时会用到<u><strong>runtime</strong></u>，那么，到底什么是运行时呢？</p><p>寻找一些资料后可以给出概念：</p><blockquote><p>In computer science, runtime, run time or execution time is the time when the CPU is executing the machine code.<br>在计算机科学里，runtime，run time 或execution time 是指CPU 执行机器语言的期间。<br>—— 维基百科</p></blockquote><blockquote><p>Runtime 是一套由C、C++、汇编混合写成的为OC提供运行时功能的api。</p></blockquote><p>先看苹果<a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime" target="_blank" rel="noopener">开发者文档</a>里对runtime 的介绍的介绍：</p><blockquote><p>The Objective-C runtime is a runtime library that provides support for the dynamic properties of the Objective-C language, and as such is linked to by all Objective-C apps. Objective-C runtime library support functions are implemented in the shared library found at <code>/usr/lib/libobjc.A.dylib</code>.</p><p>OC runtime 是一个给OC语言动态属性提供支持的运行时库，这些属性链接到所有的OC应用 。OC runtime库支持在shared library里实现的函数，这些函数库名为<code>/usr/lib/libobjc.A.dylib</code></p></blockquote><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><blockquote><p>legacy：经典版</p><p>modern：现代版，即objc2.0，我们目前用到的版本。</p></blockquote><h3 id="二、方法的本质"><a href="#二、方法的本质" class="headerlink" title="二、方法的本质"></a>二、方法的本质</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>方法的本质，就是objc_msgSend  的消息传递。先看苹果<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="noopener">开发者文档</a>里对objc_msgSend的介绍：</p><blockquote><p>Function</p><h1 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h1><p>Sends a message with a simple return value to an instance of a class.</p><p><strong>发送一个有简单返回值的消息给类的实例</strong></p></blockquote><p>相关源码如下: </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">objc_msgSend</span><span class="token punctuation">(</span>id _Nullable self<span class="token punctuation">,</span> SEL _Nonnull op<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中两个关键参数<code>self</code> 和 <code>op</code> 的解释如下:</p><blockquote><p> * <strong>@param</strong> self A pointer to the instance of the class that is to receive the message.</p><p>​                    self  一个指向由类生产的实例的指针，用来接收消息</p><p> * <strong>@param</strong> op The selector of the method that handles the message.</p><p>​                    op 方法： 处理消息的方法的选择器</p></blockquote><p>可见，objc_msgSend 的核心信息，<u><strong>就是向对象主体（self）传递相应的方法/消息（op）</strong></u>。</p><p>但是<strong>消息传递的机制</strong>到底怎样，还是用源码来解释。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>开始生成一个main.m 内代码如下</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    @autoreleasepool <span class="token punctuation">{</span>        LGPerson <span class="token operator">*</span>person <span class="token operator">=</span> <span class="token punctuation">[</span>LGPerson alloc<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">[</span>person sayHello<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Setup code that might create autoreleased objects goes here.</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">NSApplicationMain</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中LGPerson 的内部实现如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">@interface LGPerson <span class="token operator">:</span> NSObject<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>sayHello<span class="token punctuation">;</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>sayNB<span class="token punctuation">;</span>@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，着重查看<strong>LGPerson</strong> <code>alloc</code> 方法，以及其实例 person sayHello` 在汇编里的实现 : </p><p>进入到目录下，输入编译代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">clang <span class="token operator">-</span>rewrite<span class="token operator">-</span>objc main<span class="token punctuation">.</span>m<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到main.cpp 的文件</p><p><img src="/p/23281/001.png" alt="编译c++ 指令"></p><p><img src="/p/23281/002.png" alt="cpp 生成后的结构图"></p><p>打开main.cpp 结构如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">pragma</span> clang assume_nonnull end</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* @autoreleasepool */</span> <span class="token punctuation">{</span> __AtAutoreleasePool __autoreleasepool<span class="token punctuation">;</span>         LGPerson <span class="token operator">*</span>person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>LGPerson <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> SEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>objc_msgSend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token function">objc_getClass</span><span class="token punctuation">(</span><span class="token string">"LGPerson"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sel_registerName</span><span class="token punctuation">(</span><span class="token string">"alloc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> SEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>objc_msgSend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>person<span class="token punctuation">,</span> <span class="token function">sel_registerName</span><span class="token punctuation">(</span><span class="token string">"sayHello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">NSApplicationMain</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上文代码中，可以简化为, </p><table><thead><tr><th>Runtime 语法</th><th>OC 语法</th></tr></thead><tbody><tr><td>(LGPerson <em>(</em>)(id, SEL))(void *)</td><td>–</td></tr><tr><td>(id)objc_getClass(“LGPerson”)</td><td>[LGPerson class]</td></tr><tr><td>sel_registerName(“alloc”)</td><td>@selector(alloc)</td></tr></tbody></table><p>即代码为：</p><pre class="line-numbers language-cpp"><code class="language-cpp">LGPerson <span class="token operator">*</span>person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>LGPerson <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> SEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>objc_msgSend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token function">objc_getClass</span><span class="token punctuation">(</span><span class="token string">"LGPerson"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sel_registerName</span><span class="token punctuation">(</span><span class="token string">"alloc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 转换后</span>LGPerson <span class="token operator">*</span>person <span class="token operator">=</span> <span class="token function">objc_msgSend</span><span class="token punctuation">(</span><span class="token punctuation">[</span>LGPerson <span class="token keyword">class</span><span class="token punctuation">]</span><span class="token punctuation">,</span> @<span class="token function">selector</span><span class="token punctuation">(</span>alloc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>解释为: 向<code>LGPerson</code> 的类，发送了<code>alloc</code> 方法</p><h4 id="扩展代码实践"><a href="#扩展代码实践" class="headerlink" title="扩展代码实践"></a>扩展代码实践</h4><p>开始设定一个类<code>Student</code> </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">import</span> "Student.h"</span>interface Student <span class="token operator">:</span> Person<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>sayCode<span class="token punctuation">;</span>@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="OC语法"><a href="#OC语法" class="headerlink" title="OC语法"></a>OC语法</h5><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">import</span> "Student.h"</span>Student <span class="token operator">*</span>student <span class="token operator">=</span> <span class="token punctuation">[</span>Student <span class="token keyword">new</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span>student sayCode<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="NSObject-写法"><a href="#NSObject-写法" class="headerlink" title="NSObject 写法"></a>NSObject 写法</h5><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">objc_msgSend</span><span class="token punctuation">(</span>student<span class="token punctuation">,</span> <span class="token function">NSSelectorFromString</span><span class="token punctuation">(</span>@<span class="token string">"sayCode"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="sel-registerName-的函数API"><a href="#sel-registerName-的函数API" class="headerlink" title="sel_registerName 的函数API"></a>sel_registerName 的函数API</h5><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">objc_msgSend</span><span class="token punctuation">(</span>student<span class="token punctuation">,</span> <span class="token function">sel_registerName</span><span class="token punctuation">(</span><span class="token string">"sayCode"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="三、底层分析"><a href="#三、底层分析" class="headerlink" title="三、底层分析"></a>三、底层分析</h3><h4 id="汇编源码"><a href="#汇编源码" class="headerlink" title="汇编源码"></a>汇编源码</h4><blockquote><p>我们现在分析，当类对象发送消息是，底层发生了什么。</p></blockquote><h5 id="1、方法入口"><a href="#1、方法入口" class="headerlink" title="1、方法入口"></a>1、方法入口</h5><p>新建工程，输入如下代码，进行断点检测；</p><p>另外在Xcode 的Debug–Debug Workflow—Always show Disassembly</p><p><img src="/p/23281/m0.png" alt="配置：打开汇编监视"></p><p><img src="/p/23281/m1.png" alt="OC方法调用，打开断点"></p><p><img src="/p/23281/m2.png" alt="按住Control 逐渐获得汇编函数"><img src="/p/23281/m3.png" alt="得到第一个方法传递函数：objc_msgSend"></p><p>很明显，这里的<strong>Student sayCode</strong> 在汇编里，执行了 <strong>objc_msgSend</strong> 方法，继续查看</p><p>打开<strong>Xcode</strong>, 搜索<strong>objc_msgSend</strong>，找到相关结果如下：</p><p><img src="/p/23281/003.png" alt="objc_msgSend 搜索结果"></p><p>由于研究的环境是移动平台，选择<strong>arm64</strong>，通过<code>ENTRY _objc_msgSend</code>结果进入</p><p>首先看到的代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">    ENTRY _objc_msgSend    UNWIND _objc_msgSend<span class="token punctuation">,</span> NoFrame<span class="token number">1</span>    cmp    p0<span class="token punctuation">,</span> #<span class="token number">0</span>            <span class="token comment" spellcheck="true">// nil check and tagged pointer check</span><span class="token macro property">#<span class="token directive keyword">if</span> SUPPORT_TAGGED_POINTERS</span><span class="token number">2</span>    b<span class="token punctuation">.</span>le    LNilOrTagged        <span class="token comment" spellcheck="true">//  (MSB tagged pointer looks negative)</span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token number">3</span>    b<span class="token punctuation">.</span>eq    LReturnZero<span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2、类Tagged-Pointer-检查"><a href="#2、类Tagged-Pointer-检查" class="headerlink" title="2、类Tagged Pointer 检查"></a>2、类Tagged Pointer 检查</h5><p>代码解析：</p><table><thead><tr><th align="center">序号</th><th>代码</th><th>解释</th></tr></thead><tbody><tr><td align="center">1</td><td>cmp p0 #0</td><td>cmp = compare<br>检测0位寄存器 = 空？，以及tagged point 检测</td></tr><tr><td align="center">2</td><td>b.le    LNilOrTagged</td><td>// 即1代码成立，跳转至LNilOrTagged的宏（下文叙述）</td></tr><tr><td align="center">3</td><td>b.eq    LReturnZero</td><td>// <code>b.eq</code> 即不成立，结果为空，返回并跳出</td></tr></tbody></table><p>这一小节，主要是用来判断 tagged pointer 是否存在，存在则继续进行，否则跳出。</p><p>Tagged point是苹果推出的针对64位机器的特定的指针，概念如下：</p><blockquote><p>苹果对于Tagged Pointer特点的介绍：</p><ol><li>Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate</li><li>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。</li><li>在内存读取上有着3倍的效率，创建时比以前快106倍。</li></ol></blockquote><h5 id="3、加载isa"><a href="#3、加载isa" class="headerlink" title="3、加载isa"></a>3、加载isa</h5><p>这一部分主要是通过加载的isa，获取当前底层的类的实现</p><pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token comment" spellcheck="true">// person - isa - 类</span>    ldr    p13<span class="token punctuation">,</span> <span class="token punctuation">[</span>x0<span class="token punctuation">]</span>                            <span class="token comment" spellcheck="true">// p13 = isa</span>    GetClassFromIsa_p16 p13        <span class="token comment" spellcheck="true">// p16 = class</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">序号</th><th>代码</th><th>解释</th></tr></thead><tbody><tr><td align="center">1</td><td>ldr    p13,  [x0]</td><td>将13位存储器isa 字，加载到0位寄存器<br>LDR = LoaD woRd</td></tr><tr><td align="center">2</td><td>GetClassFromIsa_p16 p13</td><td>通过加载的isa，宏逻辑获取到当前的类<br>GetClassFromIsa_p16 是一个汇编宏</td></tr></tbody></table><p><strong>GetClassFromIsa_p16</strong> 的汇编实现如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">.</span>macro GetClassFromIsa_p16 <span class="token comment" spellcheck="true">/* src */</span><span class="token macro property">#<span class="token directive keyword">if</span> SUPPORT_INDEXED_ISA</span>    <span class="token comment" spellcheck="true">// Indexed isa</span>    mov    p16<span class="token punctuation">,</span> $<span class="token number">0</span>            <span class="token comment" spellcheck="true">// optimistically set dst = src</span>    tbz    p16<span class="token punctuation">,</span> #ISA_INDEX_IS_NPI_BIT<span class="token punctuation">,</span> <span class="token number">1f</span>    <span class="token comment" spellcheck="true">// done if not non-pointer isa</span>    <span class="token comment" spellcheck="true">// isa in p16 is indexed</span>    adrp    x10<span class="token punctuation">,</span> _objc_indexed_classes@PAGE    add    x10<span class="token punctuation">,</span> x10<span class="token punctuation">,</span> _objc_indexed_classes@PAGEOFF    ubfx    p16<span class="token punctuation">,</span> p16<span class="token punctuation">,</span> #ISA_INDEX_SHIFT<span class="token punctuation">,</span> #ISA_INDEX_BITS  <span class="token comment" spellcheck="true">// extract index</span>    ldr    p16<span class="token punctuation">,</span> <span class="token punctuation">[</span>x10<span class="token punctuation">,</span> p16<span class="token punctuation">,</span> UXTP #PTRSHIFT<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// load class from array</span><span class="token number">1</span><span class="token operator">:</span><span class="token macro property">#<span class="token directive keyword">elif</span> __LP64__</span>    <span class="token comment" spellcheck="true">// 64-bit packed isa</span>    <span class="token operator">and</span>    p16<span class="token punctuation">,</span> $<span class="token number">0</span><span class="token punctuation">,</span> #ISA_MASK<span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token comment" spellcheck="true">// 32-bit raw isa</span>    mov    p16<span class="token punctuation">,</span> $<span class="token number">0</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">.</span>endmacro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析流程图如下：</p><p><img src="/p/23281/004.png" alt="GetClassFromIsa_p16 流程图"></p><h5 id="4、用isa查询方法缓存"><a href="#4、用isa查询方法缓存" class="headerlink" title="4、用isa查询方法缓存"></a>4、用isa查询方法缓存</h5><p>当在3步，isa 拿到之后，现在要做的事情，就是对当前要执行的方法进行缓存查找。</p><pre class="line-numbers language-cpp"><code class="language-cpp">LGetIsaDone<span class="token operator">:</span>    CacheLookup NORMAL        <span class="token comment" spellcheck="true">// calls imp or objc_msgSend_uncached</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>CacheLookup</strong> 在这里的做法是查询类里是否含有方法到缓存。 一般有两种结果：拿到缓存IMP，或者未曾缓存。</p><p>查询可以得到有三种查询方式:</p><ul><li>NORMAL    正常查找</li><li>GETIMP      获取IMP</li><li>LOOKUP     慢速查询方法</li></ul><p>根据源码，做了一些注释：</p><p><img src="/p/23281/005.png" alt="CacheLookup宏的流程"></p><p>其中多次出现<strong>CheckMiss</strong> ,也是个汇编宏，使用在缓存查找失败后。</p><p>源码如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">.</span>macro CheckMiss    <span class="token comment" spellcheck="true">// miss if bucket->sel == 0</span><span class="token punctuation">.</span><span class="token keyword">if</span> $<span class="token number">0</span> <span class="token operator">==</span> GETIMP    cbz    p9<span class="token punctuation">,</span> LGetImpMiss<span class="token punctuation">.</span>elseif $<span class="token number">0</span> <span class="token operator">==</span> NORMAL    cbz    p9<span class="token punctuation">,</span> __objc_msgSend_uncached<span class="token punctuation">.</span>elseif $<span class="token number">0</span> <span class="token operator">==</span> LOOKUP    cbz    p9<span class="token punctuation">,</span> __objc_msgLookup_uncached<span class="token punctuation">.</span><span class="token keyword">else</span><span class="token punctuation">.</span>abort oops<span class="token punctuation">.</span>endif<span class="token punctuation">.</span>endmacro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 根据查找的模式位NORMAL, 对应的*<em>__objc_msgSend_uncached *</em>。</p><p>在源码中搜索，得到相关逻辑如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">    STATIC_ENTRY __objc_msgSend_uncached    UNWIND __objc_msgSend_uncached<span class="token punctuation">,</span> FrameWithNoSaves    <span class="token comment" spellcheck="true">// THIS IS NOT A CALLABLE C FUNCTION</span>    <span class="token comment" spellcheck="true">// Out-of-band p16 is the class to search</span>    MethodTableLookup    TailCallFunctionPointer x17    END_ENTRY __objc_msgSend_uncached<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行方法查找的<strong>核心方法</strong>，就是<strong>MethodTableLookup</strong>， 继续点开查看，得到的是<img src="/p/23281/006.png" alt="方法列表查找"></p><p>这里的内容，则是到<strong>objc_class</strong> 的 <strong>class_data_bits_t</strong> 里寻找方法的具体实现了，下一篇文章我们来讲。</p><h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p>这一篇，主要是开始从汇编的角度，来实现方法查找流程，流程草写了一下，图一定补。。。</p><ul><li><input disabled type="checkbox"> 拿到isa</li><li><input disabled type="checkbox"> 查找Class</li><li><input disabled type="checkbox"> 在Cache_t 查找bucket<ul><li><input disabled type="checkbox"> bucket 相同，返回IMP</li><li><input disabled type="checkbox"> 否则 跳到BITS</li></ul></li><li><input disabled type="checkbox"> BITS 中<ul><li><input disabled type="checkbox"> 查找Rw <ul><li><input disabled type="checkbox"> 查找ro<ul><li><input disabled type="checkbox"> 查找methodList</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 底层 </tag>
            
            <tag> 类 </tag>
            
            <tag> 结构 </tag>
            
            <tag> objc </tag>
            
            <tag> msgSend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法的本质1--cache_t方法缓存分析</title>
      <link href="/p/40097.html"/>
      <url>/p/40097.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">GITHUB</a></p></blockquote><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><h4 id="1-1-objc-class-结构"><a href="#1-1-objc-class-结构" class="headerlink" title="1.1 objc_class 结构"></a>1.1 objc_class 结构</h4><p>前面探索了类的结构，知道了类的结构本质上是<strong>objc_class</strong>的结构体，而在 <strong>C</strong> 源码例， <strong>objc_class</strong> 结构体的结构如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> objc_class <span class="token operator">:</span> objc_object <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Class ISA;                 // 指向类的isa</span>    Class <span class="token class-name">superclass</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 父类</span>    cache_t cache<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 缓存的方法列表         // formerly cache pointer and vtable</span>    class_data_bits_t bits<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 缓存的属性和变量  // class_rw_t * plus custom rr/alloc flags</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上一篇文章，具体分析了class_data_bits_t，那么上面的缓存<strong>cache_t</strong> 还没有展开学习，下面就继续进行讲解。</p><a id="more"></a><h4 id="1-2-Cache-t-结构"><a href="#1-2-Cache-t-结构" class="headerlink" title="1.2 Cache_t 结构:"></a>1.2 Cache_t 结构:</h4><p><strong>cache_t</strong> 是<strong>objc_class</strong> 的重要组成属性，它主要用来存储方法。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> cache_t <span class="token punctuation">{</span>    <span class="token keyword">struct</span> bucket_t <span class="token operator">*</span>_buckets<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 缓存的方法列表</span>    mask_t _mask<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 散列表的长度</span>    mask_t _occupied<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 缓存过的方法数量</span>        <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>bucket 的定义</p><p>顾名思义是桶 ，装水的桶，装<strong>奥特曼</strong>的桶……</p><p>在这里是一个hash表，计算公式是hash = sel 地址%mask，其中mask 是存放空间的大小，初始值是4。</p></blockquote><p>通过源码查看，可以知道结构体如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> bucket_t <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// IMP-first is better for arm64e ptrauth and no worse for arm64.</span>    <span class="token comment" spellcheck="true">// SEL-first is better for armv7* and i386 and x86_64.</span><span class="token macro property">#<span class="token directive keyword">if</span> __arm64__</span>    MethodCacheIMP _imp<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 方法实现</span>    cache_key_t _key<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 方法编号</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    cache_key_t _key<span class="token punctuation">;</span>    MethodCacheIMP _imp<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，这里缓存了<strong>MethodCacheIMP</strong> 方法，其中 <strong>MethodCacheIMP</strong> 是<strong>IMP</strong>的子类：</p><blockquote><p><strong>MethodCacheIMP</strong>     ——对于方法实现</p><p><strong>cache_key_t</strong>                 ——对应方法缓存编号</p></blockquote><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><h4 id="2-1方法缓存入口"><a href="#2-1方法缓存入口" class="headerlink" title="2.1方法缓存入口"></a>2.1方法缓存入口</h4><ul><li>入口<br>引起我们注意的是如下这段代码:</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">cache_fill</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">,</span> SEL sel<span class="token punctuation">,</span> IMP imp<span class="token punctuation">,</span> id receiver<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">if</span> !DEBUG_TASK_THREADS</span>    mutex_locker_t <span class="token function">lock</span><span class="token punctuation">(</span>cacheUpdateLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cache_fill_nolock</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> imp<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token function">_collecting_in_critical</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码解释：</p><blockquote><p>cache_fill 方法的缓存写入操作</p><p>cache_fill_nolock 线程解锁后的缓存写入</p></blockquote><ul><li>断言保护<br>这里的方法<strong>cache_fill_nolock</strong> 就是我们的方法入口，<u>为追求速度</u>，执行的内容是无锁操作下的缓存填充，即对开辟的内存空间，进行方法写入，实现源码如下：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cache_fill_nolock</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">,</span> SEL sel<span class="token punctuation">,</span> IMP imp<span class="token punctuation">,</span> id receiver<span class="token punctuation">)</span><span class="token punctuation">{</span>    cacheUpdateLock<span class="token punctuation">.</span><span class="token function">assertLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Never cache before +initialize is done</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">isInitialized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Make sure the entry wasn't added to the cache by some other thread </span>    <span class="token comment" spellcheck="true">// before we grabbed the cacheUpdateLock.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cache_getImp</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> sel<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    cache_t <span class="token operator">*</span>cache <span class="token operator">=</span> <span class="token function">getCache</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>    cache_key_t key <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码解释：</p><blockquote><ol><li>cacheUpdateLock.assertLocked() ：这里对内存区域锁定进行了跳出断言</li><li>if (!cls-&gt;isInitialized()) return; 对为初始化内存空间进行跳出断言</li><li>if (cache_getImp(cls, sel)) 对缓存空间已有该方法跳出断言</li></ol></blockquote><h4 id="2-2-检查容量"><a href="#2-2-检查容量" class="headerlink" title="2.2 检查容量"></a>2.2 检查容量</h4><ul><li>在检查容量之前，<strong>cache_t</strong> 做了两个操作：</li></ul><blockquote><ol><li>将类的引用地址转化成了cache 结构体:  <code>cache_t *cache = getCache(cls)</code></li><li>将方法编号<code>sel</code> 转换成了整型，方便寻址 <code>cache_key_t key = getKey(sel)</code></li></ol></blockquote><ul><li><p>容量为空检测</p><p>将方法缓存时，先确定是否为空对缓存。这里使用了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token operator">-</span><span class="token operator">></span><span class="token function">isConstantEmptyCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Cache is read-only. Replace it.</span>        cache<span class="token operator">-</span><span class="token operator">></span><span class="token function">reallocate</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> capacity <span class="token operator">?</span><span class="token operator">:</span> INIT_CACHE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>来判断空间是否为空，<code>isConstantEmptyCache</code>这个函数更详细的操作如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">return</span> <span class="token function">occupied</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>  <span class="token operator">&amp;&amp;</span>          <span class="token function">buckets</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">emptyBucketsForCapacity</span><span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>即<code>occupied</code>占位为空，而且容器<strong>桶</strong> 也无法从其他堆中空间共享空间，就必须重新开辟新的空间，开辟空间操作见 <strong>2.3</strong>。</p></li><li><p>扩容的条件：</p><p>扩容条件的操作为将当前容量 <strong>occupied + 1</strong>, 然后检查是否达到 <strong>3/4</strong>，超过则需要<strong>扩容</strong>；否则不需要扩容，直接进行缓存的写入，下面的代码足够明了的解释；</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// Use the cache as-is if it is less than 3/4 full</span>    mask_t newOccupied <span class="token operator">=</span> cache<span class="token operator">-</span><span class="token operator">></span><span class="token function">occupied</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    mask_t capacity <span class="token operator">=</span> cache<span class="token operator">-</span><span class="token operator">></span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token operator">-</span><span class="token operator">></span><span class="token function">isConstantEmptyCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Cache is read-only. Replace it.</span>        cache<span class="token operator">-</span><span class="token operator">></span><span class="token function">reallocate</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> capacity <span class="token operator">?</span><span class="token operator">:</span> INIT_CACHE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newOccupied <span class="token operator">&lt;=</span> capacity <span class="token operator">/</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Cache is less than 3/4 full. Use it as-is.</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Cache is too full. Expand it.</span>        cache<span class="token operator">-</span><span class="token operator">></span><span class="token function">expand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码详解：</p><blockquote><p>mask_t newOccupied = cache-&gt;occupied() + 1</p><p>mask_t capacity = cache-&gt;capacity();</p><p>if (newOccupied &lt;= capacity / 4 * 3) </p></blockquote><p>这里的 <strong>newOccupied</strong> 是当前的占用容量+1, 与目前的总容量 <strong>capacity</strong> 的 3/4 来做比较，这里使用占位+1 后来做比较，目的是提前准备，防止内存溢出。</p></li></ul><h4 id="2-3-内存扩容"><a href="#2-3-内存扩容" class="headerlink" title="2.3 内存扩容"></a>2.3 内存扩容</h4><h5 id="2-3-1-空间计算"><a href="#2-3-1-空间计算" class="headerlink" title="2.3.1 空间计算"></a>2.3.1 空间计算</h5><blockquote><p>扩容方法：</p><p>判断当前容量是否为空，若为空，就给初始化的内存为为4；</p><p>如果之前就有空间，则加倍。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> cache_t<span class="token operator">::</span><span class="token function">expand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cacheUpdateLock<span class="token punctuation">.</span><span class="token function">assertLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    uint32_t oldCapacity <span class="token operator">=</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    uint32_t newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">?</span> oldCapacity<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">:</span> INIT_CACHE_SIZE<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token punctuation">(</span>mask_t<span class="token punctuation">)</span>newCapacity <span class="token operator">!=</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// mask overflow - can't grow further</span>        <span class="token comment" spellcheck="true">// fixme this wastes one bit of mask</span>        newCapacity <span class="token operator">=</span> oldCapacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">reallocate</span><span class="token punctuation">(</span>oldCapacity<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码详解：</p><blockquote><p><strong>oldCapacity</strong> 定义了当前的容量</p><ol><li>如果 <strong>oldCapacity</strong> 为空，则立刻开辟大小为<em>4</em> 的空间。</li><li>否则，给当前空间加倍，即 <strong>oldCapacity*2</strong>，并在新空间内进行缓存空间开辟 <strong>reallocate</strong>。</li></ol></blockquote><h5 id="2-3-2-新建容器reallocate"><a href="#2-3-2-新建容器reallocate" class="headerlink" title="2.3.2 新建容器reallocate"></a>2.3.2 新建容器reallocate</h5><p>新开内存空间的操作步骤：</p><ol><li>确定是否可以释放旧空间</li><li>将开辟的空间和内存方法绑定，并将<strong>mask</strong> 和占位值<strong>occupied</strong> 归零。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> cache_t<span class="token operator">::</span><span class="token function">reallocate</span><span class="token punctuation">(</span>mask_t oldCapacity<span class="token punctuation">,</span> mask_t newCapacity<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">bool</span> freeOld <span class="token operator">=</span> <span class="token function">canBeFreed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bucket_t <span class="token operator">*</span>oldBuckets <span class="token operator">=</span> <span class="token function">buckets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bucket_t <span class="token operator">*</span>newBuckets <span class="token operator">=</span> <span class="token function">allocateBuckets</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Cache's old contents are not propagated. </span>    <span class="token comment" spellcheck="true">// This is thought to save cache memory at the cost of extra cache fills.</span>    <span class="token comment" spellcheck="true">// fixme re-measure this</span>    <span class="token function">assert</span><span class="token punctuation">(</span>newCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span><span class="token punctuation">(</span>mask_t<span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">==</span> newCapacity<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBucketsAndMask</span><span class="token punctuation">(</span>newBuckets<span class="token punctuation">,</span> newCapacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>freeOld<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">cache_collect_free</span><span class="token punctuation">(</span>oldBuckets<span class="token punctuation">,</span> oldCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">cache_collect</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 代码讲解：</p><ul><li><p>bool freeOld = canBeFreed() 决定了是否可以释放旧内存。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> cache_t<span class="token operator">::</span><span class="token function">canBeFreed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token function">isConstantEmptyCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里的<code>canBeFreed</code>依赖于<code>isConstantEmptyCache</code>的取反，即需要之前方法缓存有占位，并且旧bucket 本身容量不为空。</p><p>即以下源码里返回为空：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> cache_t<span class="token operator">::</span><span class="token function">isConstantEmptyCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span>         <span class="token function">occupied</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>  <span class="token operator">&amp;&amp;</span>          <span class="token function">buckets</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">emptyBucketsForCapacity</span><span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>需要 occupied <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">,</span> 以及 <span class="token function">buckets</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">emptyBucketsForCapacity</span><span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>setBucketsAndMask 用来初始化 新的bucket 和 occupied</p><p>newCapacity - 1 更新索引，用来查询散列表里的元素。</p></li><li><p>cache_collect_free 用来释放旧容量（oldCapacity）下的旧方法数据（oldBuckets）</p></li></ul><h4 id="2-4-缓存写入"><a href="#2-4-缓存写入" class="headerlink" title="2.4 缓存写入"></a>2.4 缓存写入</h4><h5 id="2-4-1-查找缓存"><a href="#2-4-1-查找缓存" class="headerlink" title="2.4.1 查找缓存"></a>2.4.1 查找缓存</h5><p>通过 <code>cache-&gt;find</code> 查找对应的缓存，如果没有找到，就添加新缓存，在这之前将占位<code>occupied</code>  添加1 ，实现源码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cache_fill_nolock</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">,</span> SEL sel<span class="token punctuation">,</span> IMP imp<span class="token punctuation">,</span> id receiver<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>     <span class="token comment" spellcheck="true">// 找到对应的 bucket</span>    bucket_t <span class="token operator">*</span>bucket <span class="token operator">=</span> cache<span class="token operator">-</span><span class="token operator">></span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket<span class="token operator">-</span><span class="token operator">></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> cache<span class="token operator">-</span><span class="token operator">></span><span class="token function">incrementOccupied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bucket<span class="token operator">-</span><span class="token operator">></span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> imp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> cache_t<span class="token operator">::</span><span class="token function">incrementOccupied</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    _occupied<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 占位增加</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-4-2-未扩容过"><a href="#2-4-2-未扩容过" class="headerlink" title="2.4.2 未扩容过"></a>2.4.2 未扩容过</h5><p>找到之前的bucket，按照编号和方法，写入缓存:</p><pre class="line-numbers language-cpp"><code class="language-cpp">bucket_t <span class="token operator">*</span>bucket <span class="token operator">=</span> cache<span class="token operator">-</span><span class="token operator">></span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>bucket<span class="token operator">-</span><span class="token operator">></span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> imp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="2-4-3-缓存写入实现"><a href="#2-4-3-缓存写入实现" class="headerlink" title="2.4.3 缓存写入实现"></a>2.4.3 缓存写入实现</h5><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> bucket_t<span class="token operator">::</span><span class="token function">set</span><span class="token punctuation">(</span>cache_key_t newKey<span class="token punctuation">,</span> IMP newImp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>_key <span class="token operator">==</span> <span class="token number">0</span>  <span class="token operator">||</span>  _key <span class="token operator">==</span> newKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// objc_msgSend uses key and imp with no locks.</span>    <span class="token comment" spellcheck="true">// It is safe for objc_msgSend to see new imp but NULL key</span>    <span class="token comment" spellcheck="true">// (It will get a cache miss but not dispatch to the wrong place.)</span>    <span class="token comment" spellcheck="true">// It is unsafe for objc_msgSend to see old imp and new key.</span>    <span class="token comment" spellcheck="true">// Therefore we write new imp, wait a lot, then write new key.</span>    _imp <span class="token operator">=</span> newImp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_key <span class="token operator">!=</span> newKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">mega_barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        _key <span class="token operator">=</span> newKey<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码详解：</p><blockquote><p>注释中写明了：</p><p>objc_msgSend 在无锁环境下使用key 和 imp 实现。</p><p>objc_msgSend 查看到新的imp 实现是安全的，除了空的key地址外。（可能会造成小的缓存丢失，但是并不会分发到错误的空间）</p><p>objc_msgSend 旧的imp 和新的key 是不安全的，因此我们先写新imp，等一会儿，再写新的 key</p><p>代码中的 <code>mega_barrier</code> 就是 使用了阻塞，让方法先看到imp ，保证线程的安全。</p></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><h4 id="3-1-梳理"><a href="#3-1-梳理" class="headerlink" title="3.1 梳理"></a>3.1 梳理</h4><p><strong>cache_t</strong> 起源于 OC中的方法传递，也就是<strong>objc_msgSend</strong> 的实现。在类的方法传递时，为了追求，先去cache_t 中查找是否有缓存，如果有，可以直接调用，如果没有缓存，则需要对类进行一系列的内存空间确认，进行imp - key 的写入，并进行最终调用。</p><p>这一章节应该是目前分析最难的，花了大概三到四天弄明白，希望这艰难的一步能为以后的分析打好更好的基础。</p><h4 id="3-2-流程图"><a href="#3-2-流程图" class="headerlink" title="3.2 流程图"></a>3.2 流程图</h4><p><img src="/p/40097/004.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 底层 </tag>
            
            <tag> 类 </tag>
            
            <tag> 结构 </tag>
            
            <tag> cache_t </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层研究4--类的结构分析</title>
      <link href="/p/8549.html"/>
      <url>/p/8549.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">GITHUB</a></p></blockquote><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><h4 id="1-1-类Class-的类型"><a href="#1-1-类Class-的类型" class="headerlink" title="1.1 类Class 的类型"></a>1.1 类<strong>Class</strong> 的类型</h4><blockquote><p>Class在源码里的真正类型为<strong>objc_class</strong>的<strong>结构体</strong>。</p></blockquote><p>先查看源码——在Xcode按下<strong>Shift+Command+O</strong>，选择<strong>objc-runtime-new.h</strong>，搜索objc_class，可以得知，Class底层编译实现的前4行如下：</p><p><img src="/p/8549/01.png" alt></p><p>可知类结构如下：</p><ul><li><p>A. //<strong>Class ISA</strong>                                </p><p>​    继承自父类 <strong>objc_class</strong> 的 <strong>isa</strong> ，指向类的指针不需显示（内存占8位），这里它返回一个<strong>nonpointer</strong>的指针，相关源码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/// Represents an instance of a class.</span><span class="token keyword">struct</span> objc_object <span class="token punctuation">{</span>    Class <span class="token class-name">_Nonnull</span> isa  OBJC_ISA_AVAILABILITY<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>B. <strong>Class superclass;</strong>                    </p><p>​    指向本类的父类（内存占8位）</p></li><li><p>C. <strong>cache_t cache;</strong>                        </p><p>​    存储指针和vtable，加速方法调用（内存占8位）</p></li><li><p>D. <strong>class_data_bits_t bits;</strong>             </p><p>​    存储类的方法、属性、遵循的协议等信息的地方（内存占8位） </p></li><li><p>E. 其他方法/函数 – <strong>不占内存</strong></p></li></ul><p>为何cache_t cache 这个变量占位位16，而不是8？</p><p>原因是因为这里的<strong>cache_t</strong>是结构体，其占内存为根据内部属性结构而定，为防止溢出，给予<strong>16位字节</strong>，而不是指针所需的8位。</p><p>Talk is cheap, show me the code, 伸伸手指，点开cache_t 的内部结构</p><p><img src="/p/8549/02.png" alt></p><a id="more"></a><p>我们来看看属性：</p><ul><li>bucket_t， 结构体，占8位字节</li><li>mask_t，点开后具体实现为如下：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> uint32_t mask_t<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    为整型，占4个字节</p><ul><li>mask_t</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> uint32_t mask_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    也是整形，占4个字节</p><p>共计8+4+4 = <strong>16个字节</strong></p><h4 id="1-2-objc-class继承"><a href="#1-2-objc-class继承" class="headerlink" title="1.2 objc_class继承"></a>1.2 objc_class继承</h4><p>在底层实现里，<strong>objc_class</strong> 继承自<strong>objc_object</strong> 的<strong>结构体</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/// Represents an instance of a class.</span><span class="token keyword">struct</span> objc_object <span class="token punctuation">{</span>    Class <span class="token class-name">_Nonnull</span> isa  OBJC_ISA_AVAILABILITY<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-关于NSobject"><a href="#1-3-关于NSobject" class="headerlink" title="1.3 关于NSobject"></a>1.3 关于<strong>NSobject</strong></h4><p> 万物皆对象 - Class 继承自NSObject</p><pre class="line-numbers language-cpp"><code class="language-cpp">@interface NSObject <span class="token operator">&lt;</span>NSObject<span class="token operator">></span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">pragma</span> clang diagnostic push</span><span class="token macro property">#<span class="token directive keyword">pragma</span> clang diagnostic ignored "-Wobjc-interface-ivars"</span>    Class <span class="token class-name">isa</span>  OBJC_ISA_AVAILABILITY<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">pragma</span> clang diagnostic pop</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-类的属性与成员变量"><a href="#2-类的属性与成员变量" class="headerlink" title="2. 类的属性与成员变量"></a>2. 类的属性与成员变量</h3><ol><li><h4 id="属性的存储"><a href="#属性的存储" class="headerlink" title="属性的存储"></a>属性的存储</h4><p>上面提到了类对象的结构原理，我们知道了类结构里，类型位<strong>class_data_bits_t</strong> 的<strong>bits</strong>下面我们来探寻一下，类里面的属性上怎么保存的。</p><p>我们在代码里生成一个类，分别有成员变量<strong>hobby</strong>，以及属性<strong>nickName</strong></p><p>代码如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp">@interface Person <span class="token operator">:</span> NSObject<span class="token punctuation">{</span>    NSString <span class="token operator">*</span>hobby<span class="token punctuation">;</span><span class="token punctuation">}</span>@<span class="token function">property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> copy<span class="token punctuation">)</span> NSString <span class="token operator">*</span>nickName<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在主线代码引入:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    @autoreleasepool <span class="token punctuation">{</span>        LGPerson <span class="token operator">*</span>person <span class="token operator">=</span> <span class="token punctuation">[</span>LGPerson alloc<span class="token punctuation">]</span><span class="token punctuation">;</span>        Class <span class="token class-name">pClass</span>     <span class="token operator">=</span> <span class="token function">object_getClass</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"%@ -- %p"</span><span class="token punctuation">,</span> person<span class="token punctuation">,</span> pClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后打印得到的类<strong>pClass</strong>，通过x/4gx 获取类结构如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> x<span class="token operator">/</span>4gx pClass<span class="token class-name">0x1000023d0</span><span class="token operator">:</span> <span class="token number">0x001d8001000023a9</span> <span class="token number">0x0000000100b37140</span><span class="token number">0x1000023e0</span><span class="token operator">:</span> <span class="token number">0x00000001003da280</span> <span class="token number">0x0000000000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>观察结果得知<strong>0x1000023d0</strong> 位<strong>pClass</strong>在内存中的首地址，根据内存偏移原则，加上16+8+8共32位，即可得到<strong>bits</strong>的结构。</p><p>0x1000023d0，偏移32位，得到0x1000023f0。<strong>注意</strong>，这里要用<strong>p</strong>打印指针，而非打印值用的po</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p <span class="token number">0x1000023f0</span><span class="token number">4294976496</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>oh NO！得到的是具体的值，这里需要强转一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> <span class="token function">p</span> <span class="token punctuation">(</span>class_data_bits_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">0x1000023f0</span><span class="token punctuation">(</span>class_data_bits_t <span class="token operator">*</span><span class="token punctuation">)</span> $<span class="token number">3</span> <span class="token operator">=</span> <span class="token number">0x00000001000023f0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得到$3  的值，并不是我们想要的结构，留意到<strong>objc_class</strong>里的方法 data() 方法:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> objc_class <span class="token operator">:</span> objc_object <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Class ISA; // 8</span>    Class <span class="token class-name">superclass</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    cache_t cache<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 16 不是8         // formerly cache pointer and vtable</span>    class_data_bits_t bits<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// class_rw_t * plus custom rr/alloc flags</span>    class_rw_t <span class="token operator">*</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> bits<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>data() 返回是<strong>class_rw_t</strong>，点进去看看，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> class_rw_t <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Be warned that Symbolication knows the layout of this structure.</span>    uint32_t flags<span class="token punctuation">;</span>    uint32_t version<span class="token punctuation">;</span>    <span class="token keyword">const</span> class_ro_t <span class="token operator">*</span>ro<span class="token punctuation">;</span>    method_array_t methods<span class="token punctuation">;</span>    property_array_t properties<span class="token punctuation">;</span>    protocol_array_t protocols<span class="token punctuation">;</span>    Class <span class="token class-name">firstSubclass</span><span class="token punctuation">;</span>    Class <span class="token class-name">nextSiblingClass</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>demangledName<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>留意到里面有 <strong>methods</strong>、<strong>properties</strong>、<strong>protocols</strong>等，原来这里等值便是类的相关属性方法等等结构。</p><p>现在对$3 执行data() 方法:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p $<span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>class_rw_t <span class="token operator">*</span><span class="token punctuation">)</span> $<span class="token number">5</span> <span class="token operator">=</span> <span class="token number">0x0000000000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对得到的$5 进行值打印:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p <span class="token operator">*</span>$<span class="token function">5</span><span class="token punctuation">(</span>class_rw_t<span class="token punctuation">)</span> $<span class="token number">5</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  flags <span class="token operator">=</span> <span class="token number">2148139008</span>  version <span class="token operator">=</span> <span class="token number">0</span>  ro <span class="token operator">=</span> <span class="token number">0x0000000100002308</span>  methods <span class="token operator">=</span> <span class="token punctuation">{</span>    list_array_tt<span class="token operator">&lt;</span>method_t<span class="token punctuation">,</span> method_list_t<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>       <span class="token operator">=</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token number">0x0000000100002240</span>        arrayAndFlag <span class="token operator">=</span> <span class="token number">4294976064</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  properties <span class="token operator">=</span> <span class="token punctuation">{</span>    list_array_tt<span class="token operator">&lt;</span>property_t<span class="token punctuation">,</span> property_list_t<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>       <span class="token operator">=</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token number">0x00000001000022f0</span>        arrayAndFlag <span class="token operator">=</span> <span class="token number">4294976240</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  protocols <span class="token operator">=</span> <span class="token punctuation">{</span>    list_array_tt<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> protocol_list_t<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>       <span class="token operator">=</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token number">0x0000000000000000</span>        arrayAndFlag <span class="token operator">=</span> <span class="token number">0</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  firstSubclass <span class="token operator">=</span> nil  nextSiblingClass <span class="token operator">=</span> NSUUID  demangledName <span class="token operator">=</span> <span class="token number">0x0000000000000000</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示，$5 内结构一目了然，方法，属性，协议都显示了。</p><p>继续获取属性值:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p $<span class="token number">5</span><span class="token punctuation">.</span><span class="token function">properties</span><span class="token punctuation">(</span>property_array_t<span class="token punctuation">)</span> $<span class="token number">7</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  list_array_tt<span class="token operator">&lt;</span>property_t<span class="token punctuation">,</span> property_list_t<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>     <span class="token operator">=</span> <span class="token punctuation">{</span>      list <span class="token operator">=</span> <span class="token number">0x00000001000022f0</span>      arrayAndFlag <span class="token operator">=</span> <span class="token number">4294976240</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到一个二维数组的$7，观察属性列表的类型为<strong>property_array_t</strong>，继承自<strong>list_array_tt</strong>，内部拥有</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p $<span class="token number">7</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span>property_list_t <span class="token operator">*</span><span class="token punctuation">)</span> $<span class="token number">8</span> <span class="token operator">=</span> <span class="token number">0x00000001000022f0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次对$8 进行* 取值，得到如下结果：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p <span class="token operator">*</span>$<span class="token function">8</span><span class="token punctuation">(</span>property_list_t<span class="token punctuation">)</span> $<span class="token number">9</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  entsize_list_tt<span class="token operator">&lt;</span>property_t<span class="token punctuation">,</span> property_list_t<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>    entsizeAndFlags <span class="token operator">=</span> <span class="token number">16</span>    count <span class="token operator">=</span> <span class="token number">1</span>    first <span class="token operator">=</span> <span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"nickName"</span><span class="token punctuation">,</span> attributes <span class="token operator">=</span> <span class="token string">"T@\"NSString\",C,N,V_nickName"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果可以看出，我们的<strong>属性</strong>，就<strong>保存在properties</strong> 里中。</p></li><li><h4 id="成员变量的存储"><a href="#成员变量的存储" class="headerlink" title="成员变量的存储"></a>成员变量的存储</h4><p>上面分析了属性的存储，但是我们没有看到成员变量 <strong>hobby</strong>,我们在properties 属性里，没有看到它，到底在哪里呢?下面我们继续查找。</p><p>既然不在properties 里，那尝试一下在$5 的 <strong>ro</strong> 里进行取值</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p $<span class="token number">5</span><span class="token punctuation">.</span><span class="token function">ro</span><span class="token punctuation">(</span><span class="token keyword">const</span> class_ro_t <span class="token operator">*</span><span class="token punctuation">)</span> $<span class="token number">10</span> <span class="token operator">=</span> <span class="token number">0x0000000100002308</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得到<strong>class_ro_t</strong> 类型的结构体，继续对他取值</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p <span class="token operator">*</span>$<span class="token function">10</span><span class="token punctuation">(</span><span class="token keyword">const</span> class_ro_t<span class="token punctuation">)</span> $<span class="token number">11</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  flags <span class="token operator">=</span> <span class="token number">388</span>  instanceStart <span class="token operator">=</span> <span class="token number">8</span>  instanceSize <span class="token operator">=</span> <span class="token number">24</span>  reserved <span class="token operator">=</span> <span class="token number">0</span>  ivarLayout <span class="token operator">=</span> <span class="token number">0x0000000100001f8a</span> <span class="token string">"\x02"</span>  name <span class="token operator">=</span> <span class="token number">0x0000000100001f81</span> <span class="token string">"LGPerson"</span>  baseMethodList <span class="token operator">=</span> <span class="token number">0x0000000100002240</span>  baseProtocols <span class="token operator">=</span> <span class="token number">0x0000000000000000</span>  ivars <span class="token operator">=</span> <span class="token number">0x00000001000022a8</span>  weakIvarLayout <span class="token operator">=</span> <span class="token number">0x0000000000000000</span>  baseProperties <span class="token operator">=</span> <span class="token number">0x00000001000022f0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值这里可以看到ivars，就是我们需要的变量列表，打印一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p $<span class="token number">11</span><span class="token punctuation">.</span><span class="token function">ivars</span><span class="token punctuation">(</span><span class="token keyword">const</span> ivar_list_t <span class="token operator">*</span><span class="token keyword">const</span><span class="token punctuation">)</span> $<span class="token number">12</span> <span class="token operator">=</span> <span class="token number">0x00000001000022a8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>继续对 ivar_list_t 类型的$12 取值:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p <span class="token operator">*</span>$<span class="token function">12</span><span class="token punctuation">(</span><span class="token keyword">const</span> ivar_list_t<span class="token punctuation">)</span> $<span class="token number">13</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  entsize_list_tt<span class="token operator">&lt;</span>ivar_t<span class="token punctuation">,</span> ivar_list_t<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>    entsizeAndFlags <span class="token operator">=</span> <span class="token number">32</span>    count <span class="token operator">=</span> <span class="token number">2</span>    first <span class="token operator">=</span> <span class="token punctuation">{</span>      offset <span class="token operator">=</span> <span class="token number">0x0000000100002378</span>      name <span class="token operator">=</span> <span class="token number">0x0000000100001e64</span> <span class="token string">"hobby"</span>      type <span class="token operator">=</span> <span class="token number">0x0000000100001fa7</span> <span class="token string">"@\"NSString\""</span>      alignment_raw <span class="token operator">=</span> <span class="token number">3</span>      size <span class="token operator">=</span> <span class="token number">8</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p $<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token keyword">const</span> ivar_t<span class="token punctuation">)</span> $<span class="token number">13</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  offset <span class="token operator">=</span> <span class="token number">0x0000000100002378</span>  name <span class="token operator">=</span> <span class="token number">0x0000000100001e64</span> <span class="token string">"hobby"</span>  type <span class="token operator">=</span> <span class="token number">0x0000000100001fa7</span> <span class="token string">"@\"NSString\""</span>  alignment_raw <span class="token operator">=</span> <span class="token number">3</span>  size <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<strong>成员变量</strong>存在类的 <strong>ivars 属性</strong>里</p></li></ol><h3 id="3-类的方法"><a href="#3-类的方法" class="headerlink" title="3. 类的方法"></a>3. 类的方法</h3><h4 id="3-1-类的实例方法"><a href="#3-1-类的实例方法" class="headerlink" title="3.1 类的实例方法"></a>3.1 类的实例方法</h4><p>我们继续对类进行代码编辑，对<code>Person</code>类添加实例方法和类方法</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>sayHello<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 实例方法</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>sayHappy<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 类方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还是对类结构$5 进行解析，这次我们打印它的 <strong>methods</strong> 属性</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p $<span class="token number">5</span><span class="token punctuation">.</span><span class="token function">methods</span><span class="token punctuation">(</span>method_array_t<span class="token punctuation">)</span> $<span class="token number">14</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  list_array_tt<span class="token operator">&lt;</span>method_t<span class="token punctuation">,</span> method_list_t<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>     <span class="token operator">=</span> <span class="token punctuation">{</span>      list <span class="token operator">=</span> <span class="token number">0x0000000100002240</span>      arrayAndFlag <span class="token operator">=</span> <span class="token number">4294976064</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到的是<strong>method_array_t</strong> 类型的$14, 是个数组类型，继续打印:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p $<span class="token number">14</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span>method_list_t <span class="token operator">*</span><span class="token punctuation">)</span> $<span class="token number">15</span> <span class="token operator">=</span> <span class="token number">0x0000000100002240</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p <span class="token operator">*</span>$<span class="token function">15</span><span class="token punctuation">(</span>method_list_t<span class="token punctuation">)</span> $<span class="token number">16</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  entsize_list_tt<span class="token operator">&lt;</span>method_t<span class="token punctuation">,</span> method_list_t<span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>    entsizeAndFlags <span class="token operator">=</span> <span class="token number">26</span>    count <span class="token operator">=</span> <span class="token number">4</span>    first <span class="token operator">=</span> <span class="token punctuation">{</span>      name <span class="token operator">=</span> <span class="token string">"sayHello"</span>      types <span class="token operator">=</span> <span class="token number">0x0000000100001f8c</span> <span class="token string">"v16@0:8"</span>      imp <span class="token operator">=</span> <span class="token function">0x0000000100001b90</span> <span class="token punctuation">(</span>LGTest`<span class="token operator">-</span><span class="token punctuation">[</span>LGPerson sayHello<span class="token punctuation">]</span> at LGPerson<span class="token punctuation">.</span>m<span class="token operator">:</span><span class="token number">13</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，<strong>实例方法</strong><code>sayHello</code> 方法，存储在类的methods属性里</p><h4 id="3-2-类的类方法存储"><a href="#3-2-类的类方法存储" class="headerlink" title="3.2 类的类方法存储"></a>3.2 类的类方法存储</h4><p>类方法在上述的过程中没有看到，那么它会在哪里呢?</p><p>为了找到它，我们重新回到最初的<strong>pClass</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> x<span class="token operator">/</span>4gx pClass<span class="token class-name">0x1000023b0</span><span class="token operator">:</span> <span class="token number">0x001d800100002389</span> <span class="token number">0x0000000100b37140</span><span class="token number">0x1000023c0</span><span class="token operator">:</span> <span class="token number">0x00000001003da280</span> <span class="token number">0x0000000000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>得到<strong>isa</strong>值为<strong>0x001d800100002389</strong>，这时，唤出它的掩码 <strong>ISA_MASK</strong> 来获取它的元类</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p<span class="token operator">/</span>x <span class="token number">0x001d800100002389</span> <span class="token operator">&amp;</span> <span class="token function">0x0000000ffffffff8</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> $<span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0x0000000100002388</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>继续对元类<strong>$1</strong>的结构进行解析：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> x<span class="token operator">/</span>4gx <span class="token number">0x0000000100002388</span><span class="token number">0x100002388</span><span class="token operator">:</span> <span class="token number">0x001d800100b370f1</span> <span class="token number">0x0000000100b370f0</span><span class="token number">0x100002398</span><span class="token operator">:</span> <span class="token number">0x0000000100f946c0</span> <span class="token number">0x0000000100000003</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可知<strong>0x100002388</strong>是这个元类的地址，根据上文提到的内存便宜，我们继续加上2个16进制位，得到0x1000023a8，p一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> <span class="token function">p</span> <span class="token punctuation">(</span>class_data_bits_t <span class="token operator">*</span><span class="token punctuation">)</span>$<span class="token function">2</span><span class="token punctuation">(</span>class_data_bits_t <span class="token operator">*</span><span class="token punctuation">)</span> $<span class="token number">3</span> <span class="token operator">=</span> <span class="token number">0x00000001000023a8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>继续执行上文实例方法类似的方案，执行data() — 取值 – 获取methods 的思路，具体代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p $<span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>class_rw_t <span class="token operator">*</span><span class="token punctuation">)</span> $<span class="token number">4</span> <span class="token operator">=</span> <span class="token function">0x0000000100f94620</span><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p <span class="token operator">*</span>$<span class="token function">4</span><span class="token punctuation">(</span>class_rw_t<span class="token punctuation">)</span> $<span class="token number">5</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  flags <span class="token operator">=</span> <span class="token number">2685075456</span>  version <span class="token operator">=</span> <span class="token number">7</span>  ro <span class="token operator">=</span> <span class="token number">0x00000001000021f8</span>  methods <span class="token operator">=</span> <span class="token punctuation">{</span>    list_array_tt<span class="token operator">&lt;</span>method_t<span class="token punctuation">,</span> method_list_t<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>       <span class="token operator">=</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token number">0x00000001000021d8</span>        arrayAndFlag <span class="token operator">=</span> <span class="token number">4294975960</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  properties <span class="token operator">=</span> <span class="token punctuation">{</span>    list_array_tt<span class="token operator">&lt;</span>property_t<span class="token punctuation">,</span> property_list_t<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>       <span class="token operator">=</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token number">0x0000000000000000</span>        arrayAndFlag <span class="token operator">=</span> <span class="token number">0</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  protocols <span class="token operator">=</span> <span class="token punctuation">{</span>    list_array_tt<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> protocol_list_t<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>       <span class="token operator">=</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token number">0x0000000000000000</span>        arrayAndFlag <span class="token operator">=</span> <span class="token number">0</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  firstSubclass <span class="token operator">=</span> nil  nextSiblingClass <span class="token operator">=</span> <span class="token number">0x00007fff942e6990</span>  demangledName <span class="token operator">=</span> <span class="token number">0x0000000000000000</span><span class="token punctuation">}</span><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p $<span class="token number">5</span><span class="token punctuation">.</span><span class="token function">methods</span><span class="token punctuation">(</span>method_array_t<span class="token punctuation">)</span> $<span class="token number">10</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  list_array_tt<span class="token operator">&lt;</span>method_t<span class="token punctuation">,</span> method_list_t<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>     <span class="token operator">=</span> <span class="token punctuation">{</span>      list <span class="token operator">=</span> <span class="token number">0x00000001000021d8</span>      arrayAndFlag <span class="token operator">=</span> <span class="token number">4294975960</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p $<span class="token number">10</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span>method_list_t <span class="token operator">*</span><span class="token punctuation">)</span> $<span class="token number">11</span> <span class="token operator">=</span> <span class="token function">0x00000001000021d8</span><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p <span class="token operator">*</span>$<span class="token function">11</span><span class="token punctuation">(</span>method_list_t<span class="token punctuation">)</span> $<span class="token number">12</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  entsize_list_tt<span class="token operator">&lt;</span>method_t<span class="token punctuation">,</span> method_list_t<span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>    entsizeAndFlags <span class="token operator">=</span> <span class="token number">26</span>    count <span class="token operator">=</span> <span class="token number">1</span>    first <span class="token operator">=</span> <span class="token punctuation">{</span>      name <span class="token operator">=</span> <span class="token string">"sayHappy"</span>      types <span class="token operator">=</span> <span class="token number">0x0000000100001f8c</span> <span class="token string">"v16@0:8"</span>      imp <span class="token operator">=</span> <span class="token function">0x0000000100001bc0</span> <span class="token punctuation">(</span>LGTest`<span class="token operator">+</span><span class="token punctuation">[</span>LGPerson sayHappy<span class="token punctuation">]</span> at LGPerson<span class="token punctuation">.</span>m<span class="token operator">:</span><span class="token number">17</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，<strong>类方法</strong><code>sayHappy</code> 方法，存储在类的<strong>元类</strong> methods属性里</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li>类的本质上一个类型为<strong>objc_class</strong>的结构体，包含有isa、父类、属性、成员变量及方法列表等</li><li>类属性存在结构体的properties里</li><li>类的成员变量存在结构体的 ivars里</li><li>类的实例方法，存在结构体 的methods 属性里</li><li>类的类方法，存在父类的class_ro_t 里的methods里</li></ul><p>如下图示：</p><p><img src="/p/8549/03.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 底层 </tag>
            
            <tag> 类 </tag>
            
            <tag> 结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020新年感想</title>
      <link href="/p/63353.html"/>
      <url>/p/63353.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>2020年是一个闰年，第一天从星期三开始。</p></blockquote><p><img src="/p/63353/shaun-the-sheep-2_poster_goldposter_com_6.jpg" alt></p><p>今天看了小羊肖恩大电影，故事讲得真好看，小朋友全程开心，全情投入，大朋友也觉得耳目一新，深受感动。</p><p>这是我们带他看的第一部电影，新的一年，从第一开始。</p><p>用一句涂鸦来鼓舞自己</p><blockquote><p>宁愿最后徒劳无功，</p><p>也不选择无动于衷。</p></blockquote><p>希望今年也有始有终，有所收获。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 2020 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层研究3--isa的初始化和指向分析</title>
      <link href="/p/64820.html"/>
      <url>/p/64820.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">GITHUB</a></p></blockquote><p>开始继续学习研究OC源码，这次研究的是isa的初始化和指向分析。</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><h4 id="什么是isa"><a href="#什么是isa" class="headerlink" title="什么是isa"></a>什么是isa</h4><p>看看苹果文档的介绍：</p><blockquote><p>isa</p><p>A Pointer to the class definition of which this object is an instance.</p></blockquote><p><strong>isa</strong> ： 一个指向该对象的类的指针。</p><p>打开Xcode，找到objc.h，我们可以看看到如下代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">if</span> !OBJC_TYPES_DEFINED</span><span class="token comment" spellcheck="true">/// An opaque type that represents an Objective-C class.</span><span class="token comment" spellcheck="true">/// 一个展示OC类的未知的类型</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> objc_class <span class="token operator">*</span>Class<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/// Represents an instance of a class.</span><span class="token comment" spellcheck="true">/// 展示一个类的实例</span><span class="token keyword">struct</span> objc_object <span class="token punctuation">{</span>    Class <span class="token class-name">_Nonnull</span> isa  OBJC_ISA_AVAILABILITY<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/// A pointer to an instance of a class.</span><span class="token comment" spellcheck="true">/// 一个指向类的实例的指针</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> objc_object <span class="token operator">*</span>id<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，Class 是一个objc_class 类型的结构体。</p><p>而id类型，则是objc_object 类型的结构体.</p><a id="more"></a><h3 id="2-isa-的初始化"><a href="#2-isa-的初始化" class="headerlink" title="2. isa 的初始化"></a>2. isa 的初始化</h3><p>在此之前，先回顾一下对象初始化的流程图</p><img src="/p/64820/0001.png" style="zoom:67%;"><p>在这里，初始化实例的isa，其中 <code>cls</code> 为初始化的类对象，<code>hasCxxDtor</code> 即为是否含有C++的析构器。</p><p>我们进入 <code>initIsa(cls, true, hasCxxDtor)</code> 这个函数，看看内部实现了什么</p><h4 id="2-1-isa非nonpointer"><a href="#2-1-isa非nonpointer" class="headerlink" title="2.1 isa非nonpointer"></a>2.1 isa非<strong>nonpointer</strong></h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nonpointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    isa<span class="token punctuation">.</span>cls <span class="token operator">=</span> cls<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>nonpointer概念:</strong>  </p><p>表示是否对isa 指针开启指针优化</p></li></ul><p>​    <strong>0: 纯isa指针</strong></p><p>​    <strong>1: 不止是类对象的地址，还包含类信息、对象的引用计数等。</strong></p><p>此时，如果为纯isa指针，将当前类 <code>cls</code> 赋值给 <code>isa</code> 的绑定属性 <code>cls</code></p><p>为什么有这个<strong>绑定属性</strong>，而<code>isa</code>究竟是什么看结构呢？</p><p>点击<code>isa.cls = cls;</code>中的<code>cls</code>查看它的结构，如下：</p><pre class="line-numbers language-​cpp"><code class="language-​cpp">union isa_t {    isa_t() { }                    // isa 初始化方法    isa_t(uintptr_t value) : bits(value) { }    Class cls;    uintptr_t bits;#if defined(ISA_BITFIELD)    struct {         ISA_BITFIELD;  // defined in isa.h    };#endif};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看见isa 是一个 union，联合体，里面包含了</p><ul><li><code>isa_t</code>  初始化方法</li><li><code>isa_t(uintptr_t value)</code> 工厂方法</li><li><code>Class cls</code>  <strong>绑定属性</strong></li><li>结构体<code>ISA_BITFIELD</code>位域</li></ul><ol><li><p><strong>ISA_BITFIELD概念</strong></p><p>我们点开类型为<code>struct</code>的<code>ISA_BITFIELD</code>，结构如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property"># <span class="token directive keyword">if</span> __arm64__</span><span class="token macro property">#   <span class="token directive keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span><span class="token macro property">#   <span class="token directive keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span><span class="token macro property">#   <span class="token directive keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span><span class="token macro property">#   <span class="token directive keyword">define</span> ISA_BITFIELD                                                      \      uintptr_t nonpointer        : 1;                                       \      uintptr_t has_assoc         : 1;                                       \      uintptr_t has_cxx_dtor      : 1;                                       \      uintptr_t shiftcls          : 33; </span><span class="token comment" spellcheck="true">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \      uintptr_t magic             <span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">;</span>                                       \      uintptr_t weakly_referenced <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                                       \      uintptr_t deallocating      <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                                       \      uintptr_t has_sidetable_rc  <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                                       \      uintptr_t extra_rc          <span class="token operator">:</span> <span class="token number">19</span><span class="token macro property">#   <span class="token directive keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span><span class="token macro property">#   <span class="token directive keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>NONPOINTER_ISA</strong>效果图（手绘中，待补全……）</p></li><li><p>还原isa_t 的结构</p><p>我们这时发现，isa的整体结构可以替换为如下的样子:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">union</span> isa_t <span class="token punctuation">{</span>    <span class="token function">isa_t</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token function">isa_t</span><span class="token punctuation">(</span>uintptr_t value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">bits</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    Class <span class="token class-name">cls</span><span class="token punctuation">;</span>    uintptr_t bits<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> defined(ISA_BITFIELD)</span>    <span class="token keyword">struct</span> <span class="token punctuation">{</span>        uintptr_t nonpointer        <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                                       \        uintptr_t has_assoc         <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                                       \        uintptr_t has_cxx_dtor      <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                                       \        uintptr_t shiftcls          <span class="token operator">:</span> <span class="token number">33</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \        uintptr_t magic             <span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">;</span>                                       \        uintptr_t weakly_referenced <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                                       \        uintptr_t deallocating      <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                                       \        uintptr_t has_sidetable_rc  <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                                       \        uintptr_t extra_rc          <span class="token operator">:</span> <span class="token number">19</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//         ISA_BITFIELD;  // defined in isa.h</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li><p><strong>nonpointer</strong>: 表示是否对 <strong>isa</strong> 指针开启指针优化 <strong>0</strong>:纯<strong>isa</strong>指针，<strong>1</strong>:不止是类对象地址<strong>,isa</strong> 中包含了类信息、对象的引用计数等（占1位）</p></li><li><p><strong>has_assoc</strong>: 关联对象标志位，<strong>0</strong>没有，<strong>1</strong>存在（占1位）</p></li><li><p><strong>has_cxx_dtor</strong>: 该对象是否有 <strong>C++</strong> 或者 <strong>Objc</strong> 的析构器<strong>,</strong>如果有析构函数<strong>,</strong>则需要做析构逻辑<strong>,</strong> 如果没有<strong>,</strong>则可以更快的释放对象（占1位）</p></li><li><p><strong>shiftcls:</strong>存储类指针的值。开启指针优化的情况下，在 <strong>arm64</strong> 架构中有 <strong>33</strong> 位用来存储类指针。（占33位）</p></li><li><p><strong>magic</strong>:用于调试器判断当前对象是真的对象还是没有初始化的空间 <strong>weakly_referenced</strong>:志对象是否被指向或者曾经指向一个 <strong>ARC</strong> 的弱变量，没有弱引用的对象可以更快释放。（占6位）</p></li><li><p><strong>deallocating</strong>:标志对象是否正在释放内存（占1位）</p></li><li><p><strong>has_sidetable_rc</strong>:当对象引用计数大于 <strong>10</strong> 时，则需要借用该变量存储进位（占1位）</p></li><li><p><strong>extra_rc</strong>:当表示该对象的引用计数值，实际上是引用计数值减 <strong>1</strong>， 例如，如果对象的引用计数为 <strong>10</strong>，那么 <strong>extra_rc</strong> 为 <strong>9</strong>。如果引用计数大于 <strong>10</strong>， 则需要使用到下面的 <strong>has_sidetable_rc</strong>。（占1位）</p></li></ul><h4 id="2-2-isa是nonpointer类型"><a href="#2-2-isa是nonpointer类型" class="headerlink" title="2.2 isa是nonpointer类型"></a>2.2 isa<strong>是</strong>nonpointer类型</h4><pre class="line-numbers language-cpp"><code class="language-cpp">        isa_t <span class="token function">newisa</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> SUPPORT_INDEXED_ISA</span>        <span class="token function">assert</span><span class="token punctuation">(</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">classArrayIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newisa<span class="token punctuation">.</span>bits <span class="token operator">=</span> ISA_INDEX_MAGIC_VALUE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// isa.magic is part of ISA_MAGIC_VALUE</span>        <span class="token comment" spellcheck="true">// isa.nonpointer is part of ISA_MAGIC_VALUE</span>        newisa<span class="token punctuation">.</span>has_cxx_dtor <span class="token operator">=</span> hasCxxDtor<span class="token punctuation">;</span>        newisa<span class="token punctuation">.</span>indexcls <span class="token operator">=</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">classArrayIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>        newisa<span class="token punctuation">.</span>bits <span class="token operator">=</span> ISA_MAGIC_VALUE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// isa.magic is part of ISA_MAGIC_VALUE</span>        <span class="token comment" spellcheck="true">// isa.nonpointer is part of ISA_MAGIC_VALUE</span>        newisa<span class="token punctuation">.</span>has_cxx_dtor <span class="token operator">=</span> hasCxxDtor<span class="token punctuation">;</span>        newisa<span class="token punctuation">.</span>shiftcls <span class="token operator">=</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>cls <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>生成新的<code>isa</code>:</p><p><code>isa_t newisa(0);</code></p></li><li><p>c++ 析构器：</p><p>newisa.has_cxx_dtor = hasCxxDtor;` 表示当前对象是否有C++的析构函数（destructor）,如果没有，释放时会快速的释放内存。</p></li><li><p>位域赋值</p><p><code>newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</code>对存储指针的值进行右移动3位赋值。</p></li><li><p>返回isa</p><p><code>isa = newisa;</code></p></li></ul><h3 id="3-isa-的指向"><a href="#3-isa-的指向" class="headerlink" title="3. isa 的指向"></a>3. isa 的指向</h3><h4 id="3-1-指向图："><a href="#3-1-指向图：" class="headerlink" title="3.1 指向图："></a>3.1 指向图：</h4><p>关于isa的指向以及子类父类的关系，苹果官方给出了一张图如下所示：</p><img src="/p/64820/007.png" style="zoom:80%;"><h4 id="3-2-代码分析"><a href="#3-2-代码分析" class="headerlink" title="3.2 代码分析"></a>3.2 代码分析</h4><h5 id="3-2-1-对象的isa"><a href="#3-2-1-对象的isa" class="headerlink" title="3.2.1 对象的isa"></a>3.2.1 对象的<strong>isa</strong></h5><p>我们执行一项代码如下，并对该行打断点：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Person <span class="token operator">*</span>object <span class="token operator">=</span> <span class="token punctuation">[</span>Person alloc<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们知道：<strong>对象里的 isa ——指向——&gt; 类</strong>。</p><h5 id="3-2-2类的isa"><a href="#3-2-2类的isa" class="headerlink" title="3.2.2类的isa"></a>3.2.2类的<strong>isa</strong></h5><p>现在我们想知道类的内存空间结构，在控制台执行如下指令<code>x/4gx Person.class</code>，结果如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> x<span class="token operator">/</span>4gx Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token class-name">0x100001130</span><span class="token operator">:</span> <span class="token number">0x001d800100001109</span> <span class="token number">0x0000000100b39140</span><span class="token number">0x100001140</span><span class="token operator">:</span> <span class="token number">0x0000000101a46ed0</span> <span class="token number">0x0000000200000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于<code>isa</code>是类对象的第一个属性，我们知道<code>0x001d800100001109</code>是改对象的isa，我们看看他指向哪里呢，使用<code>p/x</code> 指令试试:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p<span class="token operator">/</span>x <span class="token function">0x001d800100001109</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> $<span class="token number">16</span> <span class="token operator">=</span> <span class="token number">0x001d800100001109</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>糟糕，查看不到结果？怎么回事？类的isa 格式需要强转，可以退一步，打印类的地址试试：</p><pre class="line-numbers language-cpp"><code class="language-cpp">po <span class="token number">0x100001130</span>Person<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原来如此，在内存空间里，名为Person的类的第一个位置，指向Person类，岂不是循环指向了？</p><p>非也非也，这里指向的类，我们把它称为元类（meta-class）</p><p><strong>类的isa ——指向——&gt; 元类</strong></p><h5 id="3-2-3-元类的isa"><a href="#3-2-3-元类的isa" class="headerlink" title="3.2.3 元类的isa"></a>3.2.3 元类的<strong>isa</strong></h5><p>我们现在获得元类的具体地址，找到<code>isa</code> 的<code>MASK</code>（掩码），值为<code>0x00007ffffffffff8</code>，</p><p>输入以下指令：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p<span class="token operator">/</span>x <span class="token number">0x001d800100001109</span> <span class="token operator">&amp;</span> <span class="token function">0x00007ffffffffff8</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> $<span class="token number">17</span> <span class="token operator">=</span> <span class="token function">0x0000000100001108</span><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> po <span class="token number">0x0000000100001108</span>Person<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>得到元类地址为：<strong>0x0000000100001108</strong>，16进制打印一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> x<span class="token operator">/</span>4gx <span class="token number">0x0000000100001108</span><span class="token number">0x100001108</span><span class="token operator">:</span> <span class="token number">0x001d800100b390f1</span> <span class="token number">0x0000000100b390f0</span><span class="token number">0x100001118</span><span class="token operator">:</span> <span class="token number">0x0000000100f5a480</span> <span class="token number">0x0000000400000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到元类结构里，isa指针为 <strong>0x001d800100b390f1</strong>，继续获取它的指向，我们通过与掩码来计算：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>lldb<span class="token punctuation">)</span> p<span class="token operator">/</span>x <span class="token number">0x001d800100b390f1</span> <span class="token operator">&amp;</span> <span class="token function">0x00007ffffffffff8</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> $<span class="token number">21</span> <span class="token operator">=</span> <span class="token number">0x0000000100b390f0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>好嘞，拿到内存指针地址为<strong>0x0000000100b390f0</strong>， 打印一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">po <span class="token number">0x0000000100b390f0</span>NSObject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至此，我们可以看到元类的<code>isa</code>指向它的上一级元类，也就是跟元类(root meta-class)，为NSObject。</p><p>所以得出: <strong>元类的isa ——指向——&gt; 根元类</strong></p><h5 id="3-2-4-根元类的isa"><a href="#3-2-4-根元类的isa" class="headerlink" title="3.2.4 根元类的isa"></a>3.2.4 根元类的<strong>isa</strong></h5><p>我们打印下根元类结构：</p><pre class="line-numbers language-cpp"><code class="language-cpp">x<span class="token operator">/</span>4gx <span class="token number">0x0000000100b390f0</span><span class="token number">0x100b390f0</span><span class="token operator">:</span> <span class="token number">0x001d800100b390f1</span> <span class="token number">0x0000000100b39140</span><span class="token number">0x100b39100</span><span class="token operator">:</span> <span class="token number">0x0000000101a47020</span> <span class="token number">0x0000000500000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>拿到它的isa，与掩码继续进行与运算</p><pre class="line-numbers language-cpp"><code class="language-cpp">p<span class="token operator">/</span>x <span class="token number">0x001d800100b390f1</span> <span class="token operator">&amp;</span> <span class="token function">0x00007ffffffffff8</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> $<span class="token number">27</span> <span class="token operator">=</span> <span class="token number">0x0000000100b390f0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得到的结果<strong>0x0000000100b390f0</strong>，与根元类<strong>0x0000000100b390f0</strong>，完全吻合。</p><p>至此，我们得出结论：<strong>根元类的isa ——指向——&gt; 根类NSObject</strong>。    </p><p>什么？你不信，这些都是猜测，证实一下？</p><p>好的，创建如下代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">TestNSObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// NSObject实例对象</span>    NSObject <span class="token operator">*</span>object1 <span class="token operator">=</span> <span class="token punctuation">[</span>NSObject alloc<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// NSObject类</span>    Class <span class="token class-name">class</span> <span class="token operator">=</span> <span class="token function">object_getClass</span><span class="token punctuation">(</span>object1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// NSObject元类</span>    Class <span class="token class-name">metaClass</span> <span class="token operator">=</span> <span class="token function">object_getClass</span><span class="token punctuation">(</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// NSObject根元类</span>    Class <span class="token class-name">rootMetaClass</span> <span class="token operator">=</span> <span class="token function">object_getClass</span><span class="token punctuation">(</span>metaClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// NSObject根根元类</span>    Class <span class="token class-name">rootRootMetaClass</span> <span class="token operator">=</span> <span class="token function">object_getClass</span><span class="token punctuation">(</span>rootMetaClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"\n%p 实例对象\n%p 类\n%p 元类\n%p 根元类\n%p 根根元类"</span><span class="token punctuation">,</span>object1<span class="token punctuation">,</span><span class="token keyword">class</span><span class="token punctuation">,</span>metaClass<span class="token punctuation">,</span>rootMetaClass<span class="token punctuation">,</span>rootRootMetaClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">0x10066ddc0</span> 实例对象<span class="token number">0x7fff9294a118</span> 类<span class="token number">0x7fff9294a0f0</span> 元类<span class="token number">0x7fff9294a0f0</span> 根元类<span class="token number">0x7fff9294a0f0</span> 根根元类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，除了NSObject 类是独有的创建，其他元类、根元类、根根元类，都是一样的，因为都是NSObject，所以结果得到了证明。</p><h4 id="3-3-总结："><a href="#3-3-总结：" class="headerlink" title="3.3 总结："></a>3.3 总结：</h4><p>我们再回到这幅图，最红是这样的：</p><img src="/p/64820/007.png" style="zoom:80%;"><ul><li><p>isa指向：</p><blockquote><ul><li>对象中的isa——&gt; 类</li><li>类中的isa ——&gt; 元类</li><li>元类中的isa —-&gt; 根元类</li><li>根元类中的isa —-&gt; 根元类</li></ul></blockquote></li><li><p>类继承关系：</p><blockquote><ul><li>子类 ———superClass——— 父类</li><li>父类 ———superClass——— 根元类</li><li>根元类 ———superClass———  NSObject</li><li>NSObject  ———superClass——— nil</li></ul></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 底层 </tag>
            
            <tag> 对齐 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层研究2--内存对齐原理</title>
      <link href="/p/43162.html"/>
      <url>/p/43162.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">GITHUB</a></p></blockquote><p>开始继续学习研究OC源码，今天看的是OC的内存原理，以及对齐原理的分析。</p><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>内存对齐在数据结构中，是比较基础也比较重要的一环，对于iOS开发，研究底层更免不了要了解他们的原理，方便我们更透彻的学习iOS的原理。</p><p>我们先来一段维基百科的<a href="https://en.wikipedia.org/wiki/Data_structure_alignment" target="_blank" rel="noopener">数据结构对齐</a>的相关知识。</p><blockquote><p>内存对齐，也可以理解为数据结构对齐（Data structure alignment），是代码编译后在内存的布局与使用方式。包括三方面内容：<strong>数据对齐</strong>、<strong>数据结构填充</strong>（padding）与<strong>包入</strong>（packing）。</p></blockquote><p>下图是内存中各类型属性所占的空间大小：</p><p><img src="/p/43162/010.png" alt></p><a id="more"></a><blockquote><p>列举一下各数据类型所占字节（32位）：</p><ul><li>A <strong>char</strong> (one byte) will be 1-byte aligned.</li><li>A <strong>short</strong> (two bytes) will be 2-byte aligned.</li><li>An <strong>int</strong> (four bytes) will be 4-byte aligned.</li><li>A <strong>long</strong> (four bytes) will be 4-byte aligned.</li><li>A <strong>float</strong> (four bytes) will be 4-byte aligned.</li><li>A <strong>double</strong> (eight bytes) will be 8-byte aligned on Windows and 4-byte aligned on Linux (8-byte with <em>-malign-double</em> compile time option).</li><li>A <strong>long long</strong> (eight bytes) will be 4-byte aligned.</li><li>A <strong>long double</strong> (ten bytes with C++Builder and DMC, eight bytes with Visual C++, twelve bytes with GCC) will be 8-byte aligned with C++Builder, 2-byte aligned with DMC, 8-byte aligned with Visual C++, and 4-byte aligned with GCC.</li><li>Any <strong>pointer</strong> (four bytes) will be 4-byte aligned. (e.g.: char<em>, int</em>)</li></ul></blockquote><p>需要注意的是，在64位机上，有以下不同</p><blockquote><ul><li>A <strong>long</strong> (eight bytes) will be 8-byte aligned.</li><li>A <strong>double</strong> (eight bytes) will be 8-byte aligned.</li><li>A <strong>long long</strong> (eight bytes) will be 8-byte aligned.</li><li>A <strong>long double</strong> (eight bytes with Visual C++, sixteen bytes with GCC) will be 8-byte aligned with Visual C++ and 16-byte aligned with GCC.</li><li>Any <strong>pointer</strong> (eight bytes) will be 8-byte aligned.</li></ul></blockquote><h4 id="2-原则"><a href="#2-原则" class="headerlink" title="2. 原则"></a>2. 原则</h4><ol><li><p><strong>数据成员对齐规则：</strong>结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在32位机为４字节,则要从４的整数倍地址开始存储。</p></li><li><p><strong>结构体作为成员:</strong> 如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)</p></li><li><p><strong>收尾工作:</strong>结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐.</p></li></ol><h4 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h4><h5 id="3-1-属性8字节对齐："><a href="#3-1-属性8字节对齐：" class="headerlink" title="3.1 属性8字节对齐："></a>3.1 属性8字节对齐：</h5><p>当创建对象时，其属性的按类型占据不同的内存空间，但是由于大小不一，需要进行补齐；原则则是以第一位补齐为8的倍数（64位系统是8为对齐，而32位系统是4位对齐）。</p><p>以下面的代码举例子</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> MyStruct <span class="token punctuation">{</span>    <span class="token keyword">double</span> a<span class="token punctuation">;</span>    <span class="token keyword">char</span> b<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第2行 char 在前 int 在后</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token keyword">short</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span> MyStr1<span class="token punctuation">;</span>                <span class="token keyword">struct</span> MyStruct2 <span class="token punctuation">{</span>    <span class="token keyword">double</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第2行 int 在前 char 在后</span>    <span class="token keyword">char</span> b<span class="token punctuation">;</span>    <span class="token keyword">short</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span> MyStr2<span class="token punctuation">;</span>                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>// 我们打印一下各自的所占空间</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"%lu -- %lu"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>MyStr1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>MyStr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下:</p><img src="/p/43162/001.png" style="zoom:50%;"><p>为何两者不一致?</p><p>我们来看第一个结构体对象的内部结构，排第一的属性double占8位，而char需要补齐7位成为8位，而剩余的int，short 则分别占4位，不需补齐，可以灵活堆在同一个内存区域。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> MyStruct <span class="token punctuation">{</span>    <span class="token keyword">double</span> a<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 8位</span>    <span class="token keyword">char</span> b<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 1位  + 7 补齐  = 8</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 4位</span>    <span class="token keyword">short</span> d<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 4位</span><span class="token punctuation">}</span> MyStr1<span class="token punctuation">;</span>            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总计是 8 + 8 + 4 + 4 = 24；</p><p>而第二个结构体对象，排第一的属性double占8位，而剩余的int，short ，short 总计都，不需补齐，可以灵活堆在同一个内存区域。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> MyStruct2 <span class="token punctuation">{</span>    <span class="token keyword">double</span> a<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 8 </span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 4        </span>    <span class="token keyword">char</span> b<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 1  补齐1位 </span>    <span class="token keyword">short</span> d<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 2   </span><span class="token punctuation">}</span> MyStr2<span class="token punctuation">;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里后3位，可以放到一个8位内存区间，即4 + 1 + 2，只需补齐1位至8位，可以灵活排列在一个内存空间内，所以本结构体对象总占内存为8+4+1+2 + 1（补齐1位） = 16。</p><p>如果没有弄懂，我们找出源码来读一读：(/objc/Private Headers/Project Headers/objc-os.h) </p><ol><li><p>创建对象 alloc<br><img src="/p/43162/1.png" alt></p></li><li><p>alloc方法的实现——返回rootAlloc方法<br><img src="/p/43162/2.png" alt></p></li><li><p>返回callAlloc的实现<br><img src="/p/43162/3.png" alt></p></li><li><p>当缓存区没有对象时，创建对象<br><img src="/p/43162/4.png" alt></p></li><li><p>去内存区域创建对象<br><img src="/p/43162/5.png" alt></p></li><li><p>执行类的属性方法，确定创建的空间大小<br><img src="/p/43162/6.png" alt></p></li><li><p>对齐内存<br><img src="/p/43162/7.png" alt></p></li><li><p>内存对齐的返回：类的属性大小取决于指针大小<br><img src="/p/43162/8.png" alt></p></li><li><p>8字节对齐：实现方法<br><img src="/p/43162/9.png" alt></p></li></ol><h5 id="3-2-对象16字节对齐"><a href="#3-2-对象16字节对齐" class="headerlink" title="3.2 对象16字节对齐"></a>3.2 对象16字节对齐</h5><p>在<a href="http://nilsli.com/2019/12/16/pricipleofalloc/">OC 底层研究1–alloc和init原理 </a>我们分析过，iOS环境下，为了容错处理，创建。</p><p>在 libmalloc/src/nano_malloc.c 第193行，我们发现如下的代码:</p><p><img src="/p/43162/002.png" alt></p><p>而其中<code>NANO_REGIME_QUANTA_SIZE</code> 为16，</p><p><code>SHIFT_NANO_QUANTUM</code> 为4</p><p>那可以开始分析源码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    size <span class="token operator">=</span> NANO_REGIME_QUANTA_SIZE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Historical behavior</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的意思是，如果size为0，即创建空对象，返回16位默认空间。</p><p>而 </p><pre class="line-numbers language-cpp"><code class="language-cpp">k <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">+</span> NANO_REGIME_QUANTA_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>></span> SHIFT_NANO_QUANTUM<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>是向右移动4位，即16字节对齐，那究竟是怎么实现的，我们不妨来看下，假定给定申请的内存size 为40，那么</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">40</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">16</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">=</span>  <span class="token number">55</span><span class="token number">0011</span> <span class="token number">0111</span>                        <span class="token comment" spellcheck="true">// 55 的2进制显示</span><span class="token number">0000</span> <span class="token number">0011</span>                        <span class="token comment" spellcheck="true">// >> 右移动4位  == 3</span><span class="token number">0011</span> <span class="token number">0000</span>                        <span class="token comment" spellcheck="true">// 执行 slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; 左移动4位</span>slot_bytes <span class="token operator">=</span> <span class="token function">48</span><span class="token punctuation">(</span><span class="token number">0011</span> <span class="token number">0000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>er,  第205行中返回的slot_bytes 即是最终对齐后的内存空间位，即给入40，最终系统对齐后，返回48位(16的整数位)。</p><h4 id="4-结论"><a href="#4-结论" class="headerlink" title="4 结论"></a>4 结论</h4><p>在iOS环境下，我们创建的对象和指针遵循16位对齐的原则，而其属性位8字节对齐。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 底层 </tag>
            
            <tag> 对齐 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC 底层研究1--alloc和init原理</title>
      <link href="/p/19251.html"/>
      <url>/p/19251.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页所使用的objc runtime 756.2，来自<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">GITHUB</a></p></blockquote><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>开始学习研究OC源码，今天看的是对象的初始化，也就是alloc以及init的分析。</p><h3 id="2-附流程图如下"><a href="#2-附流程图如下" class="headerlink" title="2. 附流程图如下"></a>2. 附流程图如下</h3><p> <img src="/p/19251/121601.png" alt></p><h3 id="3-内容"><a href="#3-内容" class="headerlink" title="3. 内容"></a>3. 内容</h3><h4 id="3-1引子"><a href="#3-1引子" class="headerlink" title="3.1引子"></a>3.1引子</h4><p>我们先看一段代码，Person类的初始化，打印p1,p2,p3对象，以及指向他们的指针：</p><pre class="line-numbers language-objective-c"><code class="language-objective-c">    Person *p1 = [Person alloc];    Person *p2 = [p1 init];    Person *p3 = [p1 init];    NSLog(@"%@ -- %p", p1, &p1);    NSLog(@"%@ -- %p", p2, &p2);    NSLog(@"%@ -- %p", p3, &p3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果是：</p><img src="/p/19251/121602.png" style="zoom:50%;"><p>这里为什么p1相同的情况下，经过init后的p2，p3 的地址都不一样呢，我们要用这个图来分析:</p><img src="/p/19251/121603.png" style="zoom:50%;"><p>在这里，我们<strong>[Person alloc]</strong>创建了一个p 对象的内存空间，而<strong>[p1 init]</strong>则是创建同样是指向p1的指针p2，p3，因为和p1 内存空间一致，所以地址均为0x6000024f4950，但是指向该3个指针的指针不一样，所以&amp;p1, &amp;p2, &amp;p3 地址不一致。 </p><h4 id="3-2源码分析："><a href="#3-2源码分析：" class="headerlink" title="3.2源码分析："></a>3.2源码分析：</h4><p>alloc 步骤如下</p><h6 id="1-alloc"><a href="#1-alloc" class="headerlink" title="1. alloc"></a><strong>1. alloc</strong></h6><p>该步骤主要为创建对象，<strong>申请内存空间</strong>。相关objc源代码如下</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">+</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>alloc <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">_objc_rootAlloc</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>　　<a id="more"></a></p><h6 id="2-objc-rootAlloc"><a href="#2-objc-rootAlloc" class="headerlink" title="2. objc_rootAlloc"></a><strong>2. objc_rootAlloc</strong></h6><p>基类对于alloc 的实现，此时cls不为空，源码如下：</p><p><strong>init方法：</strong></p><p>类的init 如下</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">+</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>init<span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>self<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对象的init如下</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>init<span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">_objc_rootAlloc</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">id<span class="token function">_objc_rootAlloc</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">callAlloc</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token comment" spellcheck="true">/*checkNil*/</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token comment" spellcheck="true">/*allocWithZone*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处init 方法仅仅为工厂初始方法，作为父类方法，方便子类重写。</p><h6 id="3-callAlloc"><a href="#3-callAlloc" class="headerlink" title="3. callAlloc**"></a>3. callAlloc**</h6><p>callAlloc 的实现如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span><span class="token comment" spellcheck="true">// shortcutting optimizations.</span><span class="token keyword">static</span> ALWAYS_INLINE id<span class="token function">callAlloc</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> checkNil<span class="token punctuation">,</span> <span class="token keyword">bool</span> allocWithZone<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">slowpath</span><span class="token punctuation">(</span>checkNil <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>cls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nil<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> __OBJC2__</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fastpath</span><span class="token punctuation">(</span><span class="token operator">!</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">ISA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">hasCustomAWZ</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// No alloc/allocWithZone implementation. Go straight to the allocator.</span>        <span class="token comment" spellcheck="true">// fixme store hasCustomAWZ in the non-meta class and </span>        <span class="token comment" spellcheck="true">// add it to canAllocFast's summary</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fastpath</span><span class="token punctuation">(</span>cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">canAllocFast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// No ctors, raw isa, etc. Go straight to the metal.</span>            <span class="token keyword">bool</span> dtor <span class="token operator">=</span> cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">hasCxxDtor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            id obj <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> cls<span class="token operator">-</span><span class="token operator">></span>bits<span class="token punctuation">.</span><span class="token function">fastInstanceSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">slowpath</span><span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">callBadAllocHandler</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>            obj<span class="token operator">-</span><span class="token operator">></span><span class="token function">initInstanceIsa</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> dtor<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> obj<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Has ctor or raw isa or something. Use the slower path.</span>            id obj <span class="token operator">=</span> <span class="token function">class_createInstance</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">slowpath</span><span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">callBadAllocHandler</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> obj<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token comment" spellcheck="true">// No shortcuts available.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>allocWithZone<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span>cls allocWithZone<span class="token operator">:</span>nil<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>cls alloc<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="4-class-createInstance"><a href="#4-class-createInstance" class="headerlink" title="4. class_createInstance"></a><strong>4. class_createInstance</strong></h6><p>如上代码，如无捷径，类对象即创建实例</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">class_createInstance</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">,</span> size_t extraBytes<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">_class_createInstanceFromZone</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> extraBytes<span class="token punctuation">,</span> nil<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="5-class-createINstanceFramZone"><a href="#5-class-createINstanceFramZone" class="headerlink" title="5. _class_createINstanceFramZone"></a><strong>5. _class_createINstanceFramZone</strong></h6><ol><li><p>Cls-&gt;instanceSize</p><p>此时为对其寻址空间，统一为为每个对象开辟16位的位置，防止溢出。</p><pre class="line-numbers language-cpp"><code class="language-cpp">    size_t size <span class="token operator">=</span> cls<span class="token operator">-</span><span class="token operator">></span><span class="token function">instanceSize</span><span class="token punctuation">(</span>extraBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// CF requires all objects be at least 16 bytes.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>outAllocatedSize<span class="token punctuation">)</span> <span class="token operator">*</span>outAllocatedSize <span class="token operator">=</span> size<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>calloc</p><p>如果空间已开辟，则指定空间并返回，类似去学校报道，宿管阿姨带你去宿舍并交付钥匙给你，代码如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">if</span> <span class="token punctuation">(</span>zone<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// malloc_zone_calloc 即为开辟内存</span>            obj <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token function">malloc_zone_calloc</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>malloc_zone_t <span class="token operator">*</span><span class="token punctuation">)</span>zone<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            obj <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>objc-&gt;initInstanceIsa</p><p>这一步为确定指针，即给宿舍贴上门牌号，相关代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>zone  <span class="token operator">&amp;&amp;</span>  fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>        obj <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 该行开辟了名为obj空间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">)</span> <span class="token keyword">return</span> nil<span class="token punctuation">;</span>        obj<span class="token operator">-</span><span class="token operator">></span><span class="token function">initInstanceIsa</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> hasCxxDtor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>在这一环节，<code>obj = (id)calloc(1, size)</code> 该行开辟了名为obj空间。</p><p>而<code>obj-&gt;initInstanceIsa(cls, hasCxxDtor)</code> 则真正的将内存空间obj 与类cls 进行关联上。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>总的来说，alloc的过程，即时在堆区开辟空间给对象，并在栈区开辟指针（大小为8字节）指向该对象的内存区，即给定isa，以方便寻址。</p><p>以上，如果有更深入的理解，会再来补充，供参考。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> 源码 </tag>
            
            <tag> 底层 </tag>
            
            <tag> alloc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Runtime获取第三方成员变量</title>
      <link href="/p/5621.html"/>
      <url>/p/5621.html</url>
      
        <content type="html"><![CDATA[<p>我们使用第三方库，有时候需要获取其成员变量。方法如下：</p><p><strong>导入runtime</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">import</span> &lt;objc/runtime.h></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>声明一个Person类</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp">@interface Person <span class="token operator">:</span> NSObject<span class="token punctuation">{</span>    NSString <span class="token operator">*</span>address<span class="token punctuation">;</span><span class="token punctuation">}</span>@<span class="token function">property</span><span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span>strong<span class="token punctuation">)</span>NSString <span class="token operator">*</span>name<span class="token punctuation">;</span>@<span class="token function">property</span><span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span>assign<span class="token punctuation">)</span>NSInteger age<span class="token punctuation">;</span>@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用runtime获取私有属性</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//遍历获取Person类所有的成员变量IvarList</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> getAllIvarList <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> methodCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    Ivar <span class="token operator">*</span> ivars <span class="token operator">=</span> <span class="token function">class_copyIvarList</span><span class="token punctuation">(</span><span class="token punctuation">[</span>Person <span class="token keyword">class</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>methodCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> methodCount<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Ivar ivar <span class="token operator">=</span> ivars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> name <span class="token operator">=</span> <span class="token function">ivar_getName</span><span class="token punctuation">(</span>ivar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> type <span class="token operator">=</span> <span class="token function">ivar_getTypeEncoding</span><span class="token punctuation">(</span>ivar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"Person拥有的成员变量的类型为%s，名字为 %s "</span><span class="token punctuation">,</span>type<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">free</span><span class="token punctuation">(</span>ivars<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>打印结果如下：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">12</span> <span class="token number">15</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">02.115744</span><span class="token operator">+</span><span class="token number">0800</span> PersonRuntime<span class="token punctuation">[</span><span class="token number">11576</span><span class="token operator">:</span><span class="token number">1071364</span><span class="token punctuation">]</span> Person拥有的成员变量的类型为@<span class="token string">"NSString"</span>，名字为 address <span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">12</span> <span class="token number">15</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">02.115902</span><span class="token operator">+</span><span class="token number">0800</span> PersonRuntime<span class="token punctuation">[</span><span class="token number">11576</span><span class="token operator">:</span><span class="token number">1071364</span><span class="token punctuation">]</span> Person拥有的成员变量的类型为@<span class="token string">"NSString"</span>，名字为 _name <span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">12</span> <span class="token number">15</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">02.115997</span><span class="token operator">+</span><span class="token number">0800</span> PersonRuntime<span class="token punctuation">[</span><span class="token number">11576</span><span class="token operator">:</span><span class="token number">1071364</span><span class="token punctuation">]</span> Person拥有的成员变量的类型为q，名字为 _age <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> runtime </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 深入学习</title>
      <link href="/p/2840.html"/>
      <url>/p/2840.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p><h5 id="1-快速开发"><a href="#1-快速开发" class="headerlink" title="1.快速开发"></a>1.快速开发</h5><p>毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。</p><h5 id="2-富有表现力和灵活的UI"><a href="#2-富有表现力和灵活的UI" class="headerlink" title="2.富有表现力和灵活的UI"></a>2.富有表现力和灵活的UI</h5><p>快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。</p><h5 id="3-原生性能"><a href="#3-原生性能" class="headerlink" title="3.原生性能"></a>3.原生性能</h5><p>Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。</p> <a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/flutterchina/website@1.0/images/homepage/header-illustration.png" alt="img"></p><h3 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h3><p>Flutter的热重载可帮助您快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以在亚秒内重载，并且不会丢失状态。</p><p><img src="https://cdn.jsdelivr.net/gh/flutterchina/website@1.0/images/intellij/hot-reload.gif" alt></p><h3 id="现代式，响应式框架"><a href="#现代式，响应式框架" class="headerlink" title="现代式，响应式框架"></a>现代式，响应式框架</h3><p>使用Flutter的现代、响应式框架，和一系列基础widget，轻松构建您的用户界面。使用功能强大且灵活的API（针对2D、动画、手势、效果等）解决艰难的UI挑战。</p><p>示例代码：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">CounterState</span> <span class="token keyword">extends</span> <span class="token class-name">State</span><span class="token operator">&lt;</span>Counter<span class="token operator">></span> <span class="token punctuation">{</span>  int counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 告诉Flutter state已经改变, Flutter会调用build()，更新显示</span>    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      counter<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  Widget <span class="token function">build</span><span class="token punctuation">(</span>BuildContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当 setState 被调用时，这个方法都会重新执行.</span>    <span class="token comment" spellcheck="true">// Flutter 对此方法做了优化，使重新执行变的很快</span>    <span class="token comment" spellcheck="true">// 所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Row</span><span class="token punctuation">(</span>      children<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">RaisedButton</span><span class="token punctuation">(</span>          onPressed<span class="token punctuation">:</span> increment<span class="token punctuation">,</span>          child<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string">'Increment'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string">'Count: $counter'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> iOS </tag>
            
            <tag> 大前端，跨栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】产品经理vs项目经理：如何区别他们</title>
      <link href="/p/56253.html"/>
      <url>/p/56253.html</url>
      
        <content type="html"><![CDATA[<h6 id="（原链接在此）"><a href="#（原链接在此）" class="headerlink" title="（原链接在此）"></a>（<a href="https://habr.com/en/company/hygger/blog/462919/" target="_blank" rel="noopener">原链接在此</a>）</h6><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>大公司和较大的团队常常存在许多战略部门与角色。因此，人们往往会对其中众多角色岗位一脸懵逼不足为奇。</p><p>不同的经理在团队中的关键职责是否那么容易区分呢？举个栗子，一个产品经理和项目经理的角色就有很多共同点。据说，这些经理中每一个人在他的生命中起码听过这样直接的问题：他们（产品经理、项目经理）有区别吗？不过，也别急着埋怨他们或者觉得难堪，就因为他们对这些职能弄不清楚。产品经理和项目经理是完全不同的角色。这篇文章的目标是定义清楚这两种在软件开发公司里的关键位置的区别，让你彻底甩掉疑惑。</p><p><img src="https://habrastorage.org/getpro/habr/post_images/eda/55f/a19/eda55fa19804f2f0d2fd819a7cf17ad8.jpg" alt></p><a id="more"></a><p>想象一下，你的组织需要进行人力资源优化以及一些人员裁减。如果你不得不决定团队里谁会留下，而谁该友好说再见。哪个经理你会选择留下？</p><p>显然，做出选择并不容易。如果你被问到，说出谁对团队更重要，你肯定会发现难以回答。</p><p>这个问题有正确答案吗？让我们试着理清楚。</p><h3 id="产品经理-vs-项目经理：谁的负担更重"><a href="#产品经理-vs-项目经理：谁的负担更重" class="headerlink" title="产品经理 vs 项目经理：谁的负担更重"></a>产品经理 vs 项目经理：谁的负担更重</h3><ul><li><strong>产品</strong> 是你给客户或用户提出的最终结果。产品可以是可以触摸到的实物；也可能是软件平台或者服务。</li><li><strong>项目</strong> 是一个包含着后续活动的计划。这些活动有设定好的启动和截止时间，以及一个结果。只有在最终结果达成后，项目才算完成。</li></ul><p>举个栗子，你的产品是一个约会app。开发这个应用意味着不同的项目。其中一个是编写一个内容计划以及运行一个公司博客。这个项目有自己的截止时间和结束点。</p><p>比较两种角色最无聊（但并不正确！）的方式是去观察他们的薪资收入。下图显示了详细数据：</p><p><img src="https://habrastorage.org/getpro/habr/post_images/2be/bac/2db/2bebac2db9299bdfad99da90e7b7d00f.jpg" alt></p><p>软件行业产品经理年收入（年份未知）</p><p><img src="https://habrastorage.org/getpro/habr/post_images/acb/312/75c/acb31275ce31fe44cc00238c5e695505.jpg" alt></p><p>IT行业产品项目经理年收入（年份未知）</p><h3 id="产品经理和项目经理关键职能是什么？"><a href="#产品经理和项目经理关键职能是什么？" class="headerlink" title="产品经理和项目经理关键职能是什么？"></a>产品经理和项目经理关键职能是什么？</h3><p><strong>产品经理</strong></p><p>在IT领域，产品经理负责管理软件开发。他们通常负责定义产品战略、功能有限顺序以及产品的最终交付上线。</p><p>他们负责创造想法和主动性来帮助实现战略和目标，促进内部和外部的相关部门交流；他们会访问潜在的和现有的客户，获取可能会对未来版本有帮助的反馈；他们也会和经销商一起工作，有成效地向用户展示产品细节；他们战略路线下工作，处理产品积压。</p><p>产品经理通常参加工业事件和会议，以停留在当前行业最前沿。因此，他们的核心职能列表如下：</p><ul><li>产品战略</li><li>市场调研</li><li>期望与主动性</li><li>发布</li><li>损益问题</li></ul><p><strong>项目经理</strong></p><p>在软件开发中行业，项目经理的职责与计划固定类型公司里的项目紧密相连。这些专家保证他们在正轨上运行，通过所有执行阶段，他们关心可能的制约和资源风险。</p><p>通常，他们较少关心具体的产品目标。他们分析所有的主动性和特性，来开发一个项目时间表。</p><p>作为一份工作，项目经理可能需要每天评估员工，他们的积极性来达成具体的目标。</p><p>项目经理管控项目知道他们完成，然后会评估要继续跟进的必要性。</p><p>他们的主要职责关联如下：</p><ul><li>项目交付</li><li>资源</li><li>利用软件生命周期方法</li><li>状态更新</li><li>项目预算</li><li>产能</li><li>团队合作成功</li><li>问题解决方案</li></ul><h4 id="两种岗位可能的职业路线是什么？"><a href="#两种岗位可能的职业路线是什么？" class="headerlink" title="两种岗位可能的职业路线是什么？"></a>两种岗位可能的职业路线是什么？</h4><p>这些管理们毫无疑问的寻求职业成长。从一个工作（提升）到下一个水平的行动，需要坚强的经理技能和足够的经验。</p><p>典型的来说，产品经理李正成为高级产品经理或者产品管理负责人。项目经理们的职业路线通常说升级到高级项目经理和项目负责人角色。</p><h4 id="在公司里哪一种角色更重要？"><a href="#在公司里哪一种角色更重要？" class="headerlink" title="在公司里哪一种角色更重要？"></a>在公司里哪一种角色更重要？</h4><p>如果你的公司同时需要产品经理和项目经理，那么组织结构上是完全合理的。如何定义，谁说更重要呢？</p><p>可能，下面的问题会帮助你：</p><ul><li>如果没有产品经理，团队能否运行良好？</li><li>如果项目经理离开团队，会发生什么？</li></ul><p>很有可能，你的答案会显示两个角色都是重要且不可取代。他们的紧密合作是迈向成功的关键。</p><h4 id="项目管理和产品管理工具"><a href="#项目管理和产品管理工具" class="headerlink" title="项目管理和产品管理工具"></a>项目管理和产品管理工具</h4><p>选择项目管理和产品管理一个专业工具，需要考虑明确的公司需求、团队相关成员的数量、相关行业，以及其他的因素。</p><p>当下你可以尝试小型在线管理解决方案，它能满足经理们的必要需求。</p><p>一些流行的软件方案如Trello，Wrike, Hygger或Aha提供了所有产品管理和项目管理领域的强大的工具套装。</p><p>大部分这些工具会提供用户便利便利的tas面板（为看板和敏捷开发适配），跟踪系统，待办事项列表，确定优先事项，高级别评估，有用时间线，等等等等。</p><h4 id="最后一句话"><a href="#最后一句话" class="headerlink" title="最后一句话"></a>最后一句话</h4><p>让我们简单的总结一下上面提到的事情：</p><ul><li>产品经理和项目经理角色可能被弄混，但他们是完全不同的。他们对于软件开发公司是同等重要。</li><li>产品经理驱动产品开发，主动性的工作，确定优先顺序以及制定战略决定。项目经理管控已经被开发和审批过的项目计划。</li><li>两个经理都需要专业管理软件来可视化和追踪产品和项目活动，并与团队通力合作。</li></ul><p><em>你怎么区分项目和产品经理呢？哪些软件你尝试过，为什么？</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目经理 </tag>
            
            <tag> 产品经理 </tag>
            
            <tag> IT </tag>
            
            <tag> 产品 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发中的问题集锦</title>
      <link href="/p/49163.html"/>
      <url>/p/49163.html</url>
      
        <content type="html"><![CDATA[<p>开发中难免遇到各式各样的小问题，平时收集一下，汇总如下，按Q（问题）和 A（解决方法）。</p><h4 id="Q1遇到unable-to-index-file"><a href="#Q1遇到unable-to-index-file" class="headerlink" title="Q1遇到unable to index file"></a>Q1遇到unable to index file</h4><p>详细内容：</p><p>​        详细内容：</p><pre class="line-numbers language-bash"><code class="language-bash">        unable to index <span class="token function">file</span>         fatal: updating files failed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>A 解决：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> reset HEAD qooxdoo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Q2-hexo部署后，CNAME会被自动删除"><a href="#Q2-hexo部署后，CNAME会被自动删除" class="headerlink" title="Q2  hexo部署后，CNAME会被自动删除"></a>Q2  hexo部署后，CNAME会被自动删除</h4><p>推送上去后，包含域名内容的CNAME 被删除，博客无法用域名解析。</p><p><strong>A 解决：</strong></p><p>出现这样的问题一般是CNAME 放在blog根目录下，正确是放在source 目录下。</p><p>然后执行 部署推送</p><p><code>hexo d -g</code></p><p>问题得到解决。</p><h4 id="Q3-This-copy-of-libswiftCore-dylib-requires-an-OS-version-prior-to-10-14-4"><a href="#Q3-This-copy-of-libswiftCore-dylib-requires-an-OS-version-prior-to-10-14-4" class="headerlink" title="Q3 This copy of libswiftCore.dylib requires an OS version prior to 10.14.4."></a>Q3 This copy of libswiftCore.dylib requires an OS version prior to 10.14.4.</h4><p>问题:</p><p>在掘金<a href="https://juejin.im/post/5a3cc9a351882560b76c5ddf" target="_blank" rel="noopener">这篇文章</a>, 尝试配置SPM，通过命令创建包时，执行<code>swift run</code> 后，出现如下问题</p><p><strong><img src="/p/49163/0806-001.png" alt="0806-001"></strong></p><p><strong>A 解决：</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cp</span> -r /usr/lib/swift/*.dylib /Applications/Xcode.app/Contents/Frameworks<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Q4-Git-遇到了-early-EOF-index-pack-failed"><a href="#Q4-Git-遇到了-early-EOF-index-pack-failed" class="headerlink" title="Q4: Git 遇到了 early EOF index-pack failed"></a>Q4: Git 遇到了 early EOF index-pack failed</h4><pre class="line-numbers language-cpp"><code class="language-cpp">$ git clone https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>boostorg<span class="token operator">/</span>boost<span class="token punctuation">.</span>gitCloning into <span class="token string">'boost'</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>remote<span class="token operator">:</span> Counting objects<span class="token operator">:</span> <span class="token number">183543</span><span class="token punctuation">,</span> done<span class="token punctuation">.</span>remote<span class="token operator">:</span> Compressing objects<span class="token operator">:</span> <span class="token number">100</span><span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">69361</span><span class="token operator">/</span><span class="token number">69361</span><span class="token punctuation">)</span><span class="token punctuation">,</span> done<span class="token punctuation">.</span>fatal<span class="token operator">:</span> The remote end hung up unexpectedlyfatal<span class="token operator">:</span> early <span class="token constant">EOF</span>fatal<span class="token operator">:</span> index<span class="token operator">-</span>pack failed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> config --add core.compression -1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>————————</p><p>持续添加中</p><p><img src="https://s3.amazonaws.com/com.twilio.prod.twilio-docs/images/iOSUsernotificationsSwift.width-1616.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> swift </tag>
            
            <tag> 小问题 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】从阿波罗7号卫星上俯瞰加州南部</title>
      <link href="/p/21620.html"/>
      <url>/p/21620.html</url>
      
        <content type="html"><![CDATA[<p>这是从阿波罗7号上拍摄的加州南部的照片</p><p><img src="https://www.nasa.gov/sites/default/files/thumbnails/image/as07-11-2022.jpg" alt></p><p>图片来自 <a href="http://nasa.org/" target="_blank" rel="noopener">NASA</a></p><p>这片照片拍摄于1968年10月12日，由阿波罗7号航天器在执行它的绕地飞行第18圈时拍摄。拍摄时对地高度为124海里，加州海岸线上的穆古岬向南一直到欧申赛德，都能尽收眼底。透过云层，依稀能看见圣卡塔利娜岛屿。洛杉矶地区的近景则被从班宁市向西连绵100多英里直到马里海滩上空污染物所遮盖的模糊不清。在图片的上部（从左至右）能看见圣华金谷）在贝克斯菲尔德之外，特哈查比山脉,内华达山脉,欧文斯谷,死亡山谷以及莫哈韦沙漠。</p><p>阿波罗7号于1968年10月11日升空，被亲切称为”华尔特，华里和唐·修”, 是首次载人发射火箭计划。该计划在载人行动期间证明了指令/服务仓任务模组技术、项目地面支援能力、阿波罗的空间交会能力，同时也实现了首次从太空进行实时电视直播。</p><p><a href="https://www.nasa.gov/image-feature/southern-california-as-seen-from-apollo-7" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> NASA </tag>
            
            <tag> 太空 </tag>
            
            <tag> 卫星 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】SaaS发展历程</title>
      <link href="/p/59473.html"/>
      <url>/p/59473.html</url>
      
        <content type="html"><![CDATA[<p>撰稿人：<a href="https://www.linkedin.com/in/neerajagrawal2000/" target="_blank" rel="noopener">Neeraj Agrawal</a></p><h3 id="梗概："><a href="#梗概：" class="headerlink" title="梗概："></a><strong>梗概：</strong></h3><p>　　总结了成功的SaaS公司上市前的发展轨迹：找到 product-market fit，年入$200万（ARR），然后进入T2D3阶段 - 连续两年ARR翻三倍，然后连续三年翻两倍。ARR至少$1亿，然后上市。</p><p><strong>所谓T2D3：</strong></p><p>　　连续两年 triple（三倍），然后连续三年 double（两倍）。<br>　　<br>　　<a id="more"></a></p><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a><strong>原文</strong></h3><p>【编者按】</p><p>作者 Neeraj Agrawal 是美国波斯顿著名科技行业投行 Batter Ventures 的一名普通合伙人。</p><p>　　“打造一个十亿级的SaaS企业软件公司需要怎么做？”，作为一个科技行业投资者，在从业一来，曾无数次被问到这个问题，然而很难回答。我敢打赌登山者们被问到他们到底如何征服山峦的主峰时，也会有同样的感受。问题的答案是一步步来——你不过是把一只脚从另一只脚前迈过去，当然——务实一点来讲，整个过程总是能分解成多个、清晰的步骤。</p><p>　　你不能在一天内翻越乞力马扎罗山，所以你也不可能迅速的弄出一套优秀的SaaS系统出来。相反的，你该将缩小焦点而且明确目标，接下来搞清楚下一步该怎样做，然后快速奔向目标。</p><h5 id="“我的儿子在Battery-Adventures工作”"><a href="#“我的儿子在Battery-Adventures工作”" class="headerlink" title="“我的儿子在Battery Adventures工作”"></a><strong>“我的儿子在Battery Adventures工作”</strong></h5><p>　　我之所以开始思考在风险投资行业的工作和登山的相似性，要感谢一个意想不到的人：我的母亲。她和我的父亲在1960年代中期从当时还是英属的印度拉贾斯坦邦移居到皇后区（译注:纽约）。我的父母都是聪明，努力工作，务实的人，但他们都不理解他们的儿子在工作些什么。</p><p>　　我曾无数次的向我亲爱的、娇小的妈妈（她只有约1.5米高）描述我的工作，但她从没能清晰的记得我在做些什么。在最近的一次聚会上，她骄傲的告诉她的朋友：“我的儿子在Battery Adventures工作”。她的朋友笑了，因为他们对我不像我父亲一样是个医生，或者在大牌的银行——像高盛或是摩根斯坦利工作而倍感失望。</p><p>　　她的话引起我的思考。或许他把我的工作描述的比我认为的更好一些。或许思考如何建立一家公司最好的方式是去冒险，而非历险。而或许我在风投公司的角色就像一次冒险历程里的向导：是那些曾攀登过这座山很多次的那种人，事无巨细的了解攀登过程中的岩层与沟壑，能给足够勇敢的人提供指导来面对挑战。</p><p>　　我很荣幸曾在我15年风投任职生涯中，与许多世界级的创始人共事，其中包括许多B2B，SaaS企业软件公司，诸如Marketo、Omniture、Guidewire、Bazaarvoice以及Sprinklr（如需了解所有Battery 公司投资与撤出的详细清单，请点击这里）。</p><p>　　所以我从我个人的经历中分享一些故事和建议——姑且称之为“冒险”故事，作为向导来帮助那些里程碑上的企业者去到达他们的顶峰：估值十亿美元。</p><h3 id="SaaS企业成功走向市场的7个阶段"><a href="#SaaS企业成功走向市场的7个阶段" class="headerlink" title="SaaS企业成功走向市场的7个阶段"></a>SaaS企业成功走向市场的7个阶段</h3><p>　　我相信一个SaaS企业的走向市场会成功，会有7个关键阶段。大部分的阶段围绕这一个中心店，我称之为“三倍、三倍、两倍、两倍”（简称T2D3），反映一个公司的年度财报进展。</p><p>　　这并不是通往SaaS成功的唯一的步进之路，像Cornerstone、ExactTarget和SuccessFactors这样的公司他们所展示的一样，但是这是一条通往目标稳妥的路。每一个阶段需要不同的聚焦，比方说调整你的销售进程，发展你的团队和你的组织策略，以及国际上的扩张。</p><p>　　你会注意到我提到“市场进入策略”，因为SaaS公司发展中也有很多关键阶段。它们包含了选择合伙人、选择投资人、开发灵活的产品架构以及培养成功的企业文化，等等诸如此类。在这里，我们只着眼于“攀登”的技术。所以带上你的户外工具——我们要走向偏僻跑到，直奔顶峰了。</p><h4 id="阶段1：达成一个伟大的产品-市场体系。"><a href="#阶段1：达成一个伟大的产品-市场体系。" class="headerlink" title="阶段1：达成一个伟大的产品-市场体系。"></a>阶段1：达成一个伟大的产品-市场体系。</h4><p>　　这包含了找到并且按重要性排列好消费者的通电，接着把你的产品准确指向这些痛点。很多创业者问我怎样知道他们实现了产品-市场体系。遗憾的是，没有确切的方法来测试证明。<br>　　我经常问一些特定行业的潜在消费者或者用户来描述他们的痛点。当我听到样本的稳定性时，我知道到位了。一旦产品成型，很容易来测试它是否让消费者觉得有对其帮助。–</p><p>…</p><p>译制中，<a href="https://techcrunch.com/2015/02/01/the-saas-travel-adventure" target="_blank" rel="noopener">原链接在此</a></p><p><img src="https://techcrunch.com/wp-content/uploads/2015/02/rockclimb.jpg?w=1390&crop=1" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 创业 </tag>
            
            <tag> SaaS </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在苹果AppStore 上下架应用</title>
      <link href="/p/51950.html"/>
      <url>/p/51950.html</url>
      
        <content type="html"><![CDATA[<h3 id="序言："><a href="#序言：" class="headerlink" title="序言："></a>序言：</h3><h6 id="作为开发者，如何快捷的在苹果商店下架上架App，请看图吧"><a href="#作为开发者，如何快捷的在苹果商店下架上架App，请看图吧" class="headerlink" title="作为开发者，如何快捷的在苹果商店下架上架App，请看图吧"></a>作为开发者，如何快捷的在苹果商店下架上架App，请看图吧</h6><h3 id="如何下架"><a href="#如何下架" class="headerlink" title="如何下架"></a>如何下架</h3><h4 id="1-进入开发者中心-itunesConnect"><a href="#1-进入开发者中心-itunesConnect" class="headerlink" title="1. 进入开发者中心 itunesConnect"></a>1. 进入开发者中心 itunesConnect</h4><p><img src="/p/51950/1.png" alt></p> <a id="more"></a><h4 id="2-选择相应的App"><a href="#2-选择相应的App" class="headerlink" title="2. 选择相应的App"></a>2. 选择相应的App</h4><p><img src="/p/51950/2.png" alt></p><h4 id="3-如图，选择价格与销售范围——-下架"><a href="#3-如图，选择价格与销售范围——-下架" class="headerlink" title="3. 如图，选择价格与销售范围—— 下架"></a>3. 如图，选择价格与销售范围—— 下架</h4><p><img src="/p/51950/3.png" alt></p><h4 id="4-等等10分钟左右，再次搜索，此时AppStore-已经搜索不到该App了"><a href="#4-等等10分钟左右，再次搜索，此时AppStore-已经搜索不到该App了" class="headerlink" title="4. 等等10分钟左右，再次搜索，此时AppStore 已经搜索不到该App了"></a>4. 等等10分钟左右，再次搜索，此时AppStore 已经搜索不到该App了</h4><p><img src="/p/51950/4.png" alt></p><p>此时的状态是：</p><p><img src="/p/51950/5.png" alt></p><h3 id="重新上架"><a href="#重新上架" class="headerlink" title="重新上架"></a>重新上架</h3><h4 id="1-此时，也是选择-该应用的-价格与销售范围，选择【在所有地区供应】–-存储"><a href="#1-此时，也是选择-该应用的-价格与销售范围，选择【在所有地区供应】–-存储" class="headerlink" title="1. 此时，也是选择 该应用的 价格与销售范围，选择【在所有地区供应】– 存储"></a>1. 此时，也是选择 该应用的 价格与销售范围，选择【在所有地区供应】– 存储</h4><p><img src="/p/51950/6.png" alt></p><h4 id="2-此时是立即上架，AppStore也是需要5-10分钟可以搜索到"><a href="#2-此时是立即上架，AppStore也是需要5-10分钟可以搜索到" class="headerlink" title="2. 此时是立即上架，AppStore也是需要5-10分钟可以搜索到"></a>2. 此时是立即上架，AppStore也是需要5-10分钟可以搜索到</h4><p><img src="/p/51950/7.png" alt></p><h6 id="就是这么简单，希望可以帮到你。"><a href="#就是这么简单，希望可以帮到你。" class="headerlink" title="就是这么简单，希望可以帮到你。"></a>就是这么简单，希望可以帮到你。</h6>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> appstore </tag>
            
            <tag> 上架 </tag>
            
            <tag> 下架 </tag>
            
            <tag> 苹果商店 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解SDWebImage(读sdwebimage源码分析)</title>
      <link href="/p/14198.html"/>
      <url>/p/14198.html</url>
      
        <content type="html"><![CDATA[<p>最近在看一些第三方库的源码，其中SDWebImage 尤其让人惊叹，尝试用XMind 画出原理，以后有机会， 会增加更多的细节图。</p><h4 id="大纲如下："><a href="#大纲如下：" class="headerlink" title="大纲如下："></a>大纲如下：</h4><p><img src="/p/14198/sd1.png" alt></p><a id="more"></a><h4 id="图片缓存的实现如下："><a href="#图片缓存的实现如下：" class="headerlink" title="图片缓存的实现如下："></a>图片缓存的实现如下：</h4><p><img src="/p/14198/sd2.png" alt></p><h4 id="以下为异步下载部分："><a href="#以下为异步下载部分：" class="headerlink" title="以下为异步下载部分："></a><strong>以下为异步下载部分：</strong></h4><p><img src="/p/14198/sd3.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> 开发 </tag>
            
            <tag> SDWebImage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Universal Link在微信页面中唤起原生App</title>
      <link href="/p/7421.html"/>
      <url>/p/7421.html</url>
      
        <content type="html"><![CDATA[<p>因微信封杀，已失效，微信大刀威武！</p><p>在某些电商项目，或者是社交媒体的分享页面中，我们经常会看到在页面的顶端或者底部遇到有【打开App】或者【下载App】这样的按钮。比较友好的产品经理，会做设备识别，以及检测APP是否安装，来做打开或者下载App 的需求。<br>这些功能在Safari下使用location.href=”scheme://example” 即可实现。<br>但是在微信中，这方面做的比较恶心，微信下面几乎是全面屏蔽了唤起原生App 的功能，所有的启动都需要通过应用宝。</p><p>在iOS 9以后，苹果推出了Universal Link 这个概念，解决了使用A标签，以及iFrame 的弊端。WWDC2015 Session 509 有介绍,通过Universal Link，将App 与网页端建立连接桥，可以从Safari 或者其他前端浏览器来识别并唤醒App，甚至是微信环境下也可以冲破障碍。</p><a id="more"></a><p>参考了苹果的原生介绍，做出了微信下唤醒自己的 App 效果如下：</p><p><img src="/p/7421/0.gif" alt></p><h3 id="实操如下"><a href="#实操如下" class="headerlink" title="实操如下"></a>实操如下</h3><h5 id="服务器配置："><a href="#服务器配置：" class="headerlink" title="服务器配置："></a>服务器配置：</h5><p>准备独立域名。</p><p>一级域名，二级域名均可。</p><h5 id="SSL-证书"><a href="#SSL-证书" class="headerlink" title="SSL 证书"></a>SSL 证书</h5><p>这里需要为服务器配置HTTPS 用的SSL 证书。</p><h5 id="上传签名好的JSON-配置文件"><a href="#上传签名好的JSON-配置文件" class="headerlink" title="上传签名好的JSON 配置文件"></a>上传签名好的JSON 配置文件</h5><p>新建一个JSON文件，不需要后缀名，内容输入以下代码：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token punctuation">{</span><span class="token string">"applinks"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"apps"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"details"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"appID"</span><span class="token punctuation">:</span> <span class="token string">"5B5Q4xxxx.com.xxxx.xxxx"</span><span class="token punctuation">,</span><span class="token string">"paths"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"/html/1/*"</span><span class="token punctuation">,</span> <span class="token string">"/*"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 appID 相关内容可以在Developer 中心找到相关的内容。如图，前半部分为Prefix 后半部分为ID，即你的App 的bundle id，两者通过.相连。</p><p><img src="/p/7421/1.png" alt></p><p>注意：这里的AppID中前半部分，在App 转让主体后会改变，需重新更新。</p><p>paths 则是用来唤醒App 所需要指定的JSON文件在服务器中的路径。用”/* “ 是根目录，而/html 则是指html目录下的。</p><p>填好后保存为apple-app-site-association 名，上传到域名指向的服务器根目录。</p><p>App配置：</p><p>在工程文件中，找到Targets - Capabilities - Associated Domains 将开关选为On，并添加你的域名，格式为applinks:你的域名.com</p><p><img src="/p/7421/2.png" alt></p><p>iOS 移动端的代码配置</p><pre class="line-numbers language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token constant">BOOL</span><span class="token punctuation">)</span>application<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token builtin">UIApplication</span> <span class="token operator">*</span><span class="token punctuation">)</span>application continueUserActivity<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token builtin">NSUserActivity</span> <span class="token operator">*</span><span class="token punctuation">)</span>userActivity restorationHandler<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token function">void</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token builtin">NSArray</span> <span class="token operator">*</span> _Nullable<span class="token punctuation">)</span><span class="token punctuation">)</span>restorationHandler<span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>userActivity<span class="token punctuation">.</span>activityType isEqualToString<span class="token punctuation">:</span><span class="token builtin">NSUserActivityTypeBrowsingWeb</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token builtin">NSString</span> <span class="token operator">*</span>url <span class="token operator">=</span> userActivity<span class="token punctuation">.</span>webpageURL<span class="token punctuation">.</span>description<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 这里可以通过拆分url 来传入参数，达到跳转原生页面的功能，如跳转某商品页</span><span class="token punctuation">[</span><span class="token builtin">UIApplication</span> sharedApplication<span class="token punctuation">]</span> openURL<span class="token punctuation">:</span>webpageURL<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token constant">YES</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>h5网页配置：</p><p>h5网页中对需要唤起App 的按钮或者控件添加点击事件，事件的函数代码如下:</p><pre class="line-numbers language-swift"><code class="language-swift">function <span class="token function">wakeUpApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>navigator<span class="token punctuation">.</span>userAgent<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token operator">/</span><span class="token punctuation">(</span>iPhone<span class="token operator">|</span>iPod<span class="token operator">|</span>iPad<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">?</span><span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> loadDateTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> timeOutDateTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>timeOutDateTime <span class="token operator">-</span> loadDateTime <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">"http://a.app.qq.com/o/simple.jsp?pkgname=你的应用宝BundleID"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>window<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">"https://yourdomainname.com/"</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>navigator<span class="token punctuation">.</span>userAgent<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token operator">/</span>android<span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> state <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>state <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"apps custom url schemes "</span><span class="token punctuation">,</span> <span class="token string">'_blank'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>window<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">"要跳转的页面URL"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：代码中 yourdomainname.com 还可以后面添加 /goodid/123456 之类的属性id后缀，用来传递事件类型和id，方便移动端做更丰富的功能需求，比如通过goodid 识别要做的下一步动作是打开商品id 为123456 的商品详情页，等等。</p><p>配置完成，查看是否能唤起App，也可以通过如下图中，输入域名，长按来唤起App 做验证。</p><p><img src="/p/7421/3.png" alt></p><p>至此，大功告成。</p><p>值得注意的是，只能在iOS 9环境及以上实现该功能。iOS 8或者以下，只能采取老式的跳转至应用宝来实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 原生 </tag>
            
            <tag> 微信 </tag>
            
            <tag> universallink </tag>
            
            <tag> hyper </tag>
            
            <tag> 混合交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下棋</title>
      <link href="/p/31557.html"/>
      <url>/p/31557.html</url>
      
        <content type="html"><![CDATA[<p>在公园和大爷下象棋，有点紧张。<br>走了第一步后，大爷沉默了很久说：<br>“你是新手吧？”<br>“大爷你怎么知道？”<br>“我在这玩了几年，第一步走帅的真不多。”<br>“不应该让领导先走吗？”</p><p> <img src="http://puui.qpic.cn/qqvideo_ori/0/l0626p7lcr5_496_280/0" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 休闲 </tag>
            
            <tag> 人生哲理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
