{"meta":{"title":"李佳的技术博客","subtitle":"「疾如風，徐如林，侵掠如火，不動如山」","description":null,"author":"李佳","url":"http://nilsli.com","root":"/"},"pages":[{"title":"[404]","date":"2020-03-17T15:07:11.484Z","updated":"2020-03-17T15:07:11.484Z","comments":true,"path":"404.html","permalink":"http://nilsli.com/404.html","excerpt":"","text":""},{"title":"contact","date":"2020-03-21T03:50:48.000Z","updated":"2020-03-21T03:50:48.559Z","comments":true,"path":"contact/index.html","permalink":"http://nilsli.com/contact/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-02-25T04:07:54.000Z","updated":"2020-03-17T15:07:11.642Z","comments":true,"path":"categories/index.html","permalink":"http://nilsli.com/categories/index.html","excerpt":"","text":""},{"title":"这是我自己","date":"2018-09-18T09:54:59.000Z","updated":"2020-03-17T15:07:11.642Z","comments":true,"path":"about/index.html","permalink":"http://nilsli.com/about/index.html","excerpt":"","text":"关于我毕业于对外经贸大学，对移动端有了较深了解，略懂前端、RN 技术。 在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流 邮件(myhonestjj#gmail.com, 把#换成@) 我的Github About MeGraduated from UIBE(University of International Business and Economics), know pretty much about Mobile Delevepment, familiar with Front End and React Native. Please feel free to contact me if you have any question when view this website, you can communicate with me in ways below: Gmail: myhonestjj#gmail.com(repalace # with @) Github: newjia’s Github"},{"title":"friends","date":"2020-03-21T03:51:27.000Z","updated":"2020-03-21T03:51:27.875Z","comments":true,"path":"friends/index.html","permalink":"http://nilsli.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-25T04:07:21.000Z","updated":"2020-03-17T15:07:11.685Z","comments":true,"path":"tags/index.html","permalink":"http://nilsli.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-17T15:07:11.683Z","updated":"2020-03-17T15:07:11.683Z","comments":true,"path":"images/2019/08/添加别名登录：.html","permalink":"http://nilsli.com/images/2019/08/添加别名登录：.html","excerpt":"","text":"添加别名登录：参考连接 1、首先创建本机的公钥和私钥，使用命令ssh-keygen。2、使用ssh-copy-id &lt;主机地址&gt; 来将公钥添加到目的主机。 ssh-copy-id 188.188.188.188 3、【在本地电脑】使用 vim ~/.ssh/config命令编辑文件，添加如下内容： HostName abc.com/188.188.188.188 Port 22 User root IdentityFile ~/.ssh/id_rsa.pub IdentitiesOnly yes"}],"posts":[{"title":"【数据结构与算法】-循环链表(单向)","slug":"circularList","date":"2020-04-02T08:06:27.000Z","updated":"2020-04-03T05:25:56.881Z","comments":true,"path":"2020/04/02/circularList/","link":"","permalink":"http://nilsli.com/2020/04/02/circularList/","excerpt":"","text":"一、定义 将单链表中终点结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相连的单链表称为单循环链表，简称循环链表（circular linked list）。 我们先讨论的是单向循环链表，示意图如下所示: 二、操作2.1 创建单向循环链表创建逻辑主要有下面的步骤: 先判断是否第一次创建？ 是（空链表）：创建一个结点，使新结点next 指向自身 否：使尾节点的next=新节点。新节点的next指向头节点 下面用代码解释一下： 先定义一个结点(结构体)，定一个别名： //定义结点 typedef struct Node{ ElemType data; struct Node *next; }Node; typedef struct Node * LinkList; 创建一些变量，以供环境使用： Status CreateList(LinkList *L){ int item; LinkList temp = NULL; LinkList target = NULL; 接下来判断这个链表*L 是否为空： if(*L==NULL) 如果输入的链表是空的——则创建一个结点，使它的next指向自己： Status CreateList(LinkList *L){ printf(\"输入节点的值，输入0结束\\n\"); while(1) { scanf(\"%d\",&amp;item); if(item==0) break; //如果输入的链表是空。则创建一个新的节点，使其next指针指向自己 (*head)->next=*head; if(*L==NULL) { *L = (LinkList)malloc(sizeof(Node)); if(!L)exit(0); (*L)->data=item; (*L)->next=*L; } 如果链表不为空——则去寻找链表的尾结点。 这里寻找尾结点可以有两种实现方式： 遍历尾结点，根据尾结点指针会指向首元结点来定位到尾结点。 1、使得尾结点的next 指向新结点。 2、新结点的next 指向头结点。 else{ for (target = *L; target->next != *L; target = target->next); // 为新结点开辟内存空间 temp=(LinkList)malloc(sizeof(Node)); // 如开辟失败，返回错误 if(!temp) return ERROR; // 新结点写入数据 temp->data=item; temp->next=*L; //新节点指向头节点 target->next=temp;//尾节点指向新节点 } 创建一个工具结点r，用它来灵活处理以后一个结点（后插法） 新建一个 r LinkList r = NULL; 在该链表创建时，将唯一的结点赋值给r //第一次创建 if(*L == NULL){ *L = (LinkList)malloc(sizeof(Node)); if(!*L) return ERROR; (*L)->data = item; (*L)->next = *L; r = *L; 创建新的结点，进行赋值，next指向原链表首结点 temp = (LinkList)malloc(sizeof(Node)); if(!temp) return ERROR; temp->data = item; temp->next = *L; 把原最后一个结点的尾结点指向新结点，以及新结点赋值给工具结点r r->next = temp; 这样，闭环完成，整个过程示意图可以用下面的图实现： 2.2 单向循环链表插入数据分两种情况，插入点是否为首元结点 2.2.1 插入点位首元结点 创建新结点并进行赋值 找到链表最后的结点——尾结点 让新结点的next 指向头结点 让尾结点的 next 指向新的头结点 让头结点指向temp ——临时的新结点 具体代码实现如下： temp = (LinkList)malloc(sizeof(Node)); if (temp == NULL) { return ERROR; } temp->data = num; for (target = *L; target->next != *L; target = target->next); temp->next = *L; target->next = temp; *L = temp; 如图所示： 2.2.2 插入点非首元结点 创建新结点 temp，并判断成功与否 找到插入的位置，如果超过链表长度，则自动插入队尾 通过工具target 找到要插入位置的前一个结点，让 target-&gt;next = temp 插入结点的前一个结点next 指向新结点，新结点next指向target原来的next 位 具体代码实现如下： temp = (LinkList)malloc(sizeof(Node)); if (temp == NULL) { return ERROR; } temp->data = num; for ( i = 1,target = *L; target->next != *L &amp;&amp; i != place - 1; target = target->next,i++) ; temp->next = target->next; target->next = temp; 2.3 单向循环链表的删除单向循环链表的删除，与顺序表的删除很类似，步骤都是先确定需要删除的位置，通过判断是否首元结点，做不同的操作。具体操作步骤如下： 2.3.1 删除点为首元结点 如果本链表只剩首元结点，则直接将*L 置为空； 实施代码如下： if((*L)->next == (*L)){ (*L) = NULL; return OK; } 如果本链表还剩其他结点 找到尾结点 target 尾结点 next 指向原来首元结点的下一个结点，即 target-&gt;next = (*L)-&gt;next 用 temp 临时接收首元结点 新结点为首元结点 释放之前的接收的首元结点 temp 实施代码如下： // 步骤 1⃣️ for (target = *L; target->next != *L; target = target->next); // 步骤 2⃣️ temp = *L; // 步骤 3⃣️ *L = (*L)->next; // 步骤 4⃣️ target->next = *L; // 步骤 5⃣️ free(temp); 2.3.2 删除点为非首元结点 找到需要删除结点的上一个结点，用target表示 用temp临时接受需要删除的结点 target 的next 指之前指向的下一个结点 释放temp结点 实施代码如下： // 步骤 1⃣️ for(i=1,target = *L;target->next != *L &amp;&amp; i != place -1;target = target->next,i++); // 步骤 2⃣️ temp = target->next; // 步骤 3⃣️ target->next = temp->next; // 步骤 4⃣️ free(temp); 2.4 单向链表的查询这里仅仅讨论下简单的链表查询，步骤如下： 循环查找链表中给定值的结点 若查询的结点指向首元结点，并且此时尾结点值也不为所需，跳出 实施代码如下： int i = 1; LinkList p; p = L; // 1⃣️ 寻找链表中的结点 data == value while (p->data != value &amp;&amp; p->next != L) { i++; p = p->next; } // 2⃣️ 当尾结点指向头结点就会直接跳出循环,所以要额外增加一次判断尾结点的data == value; if (p->next == L &amp;&amp; p->data != value) { return -1; } 三、小结单向循环链表与顺序表有些许相似，但是不同点在于，它并非是按照序号排列，而是通过指针的指向进行连接，而且有首尾相连的特点。","categories":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/categories/ios/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://nilsli.com/tags/链表/"},{"name":"循环","slug":"循环","permalink":"http://nilsli.com/tags/循环/"}]},{"title":"【数据结构与算法】- 线性表基础","slug":"linearlist","date":"2020-04-01T09:19:38.000Z","updated":"2020-04-02T08:09:20.551Z","comments":true,"path":"2020/04/01/linearlist/","link":"","permalink":"http://nilsli.com/2020/04/01/linearlist/","excerpt":"","text":"零、前言上文学到了数据结构和算法的一些基础知识，接下来从最基础的概念，线性表说起。 一、线性表的定义和特点1.1 定义 定义：零个或多个数据元素的有限序列 线性表，顾名思义，就是有着和线一样特性的表。比如我们乘坐的火车，通常是由许多节车厢组成，车厢首尾相连，最终形成一辆火车。这样的结构，就可以成为线性表。 1.2 线性表的抽象数据类型线性表的抽象类型定义如下： ADT 线性表（List） Data：线性表的数据对象集合为{a1,a2,......an},每个元素的类型均为DataType. 其中,除了第一个元素a1外,每一个元素有且只有一个直接前驱元素,除了最后一个元素an外,每个元素有且只有一个直接后继元素. 数据元素之间的关系是一对一的关系. Operation InitList(*L) : 初始化操作，建立一个空的线性表L&lt;sub&gt;0&lt;/sub&gt; ListEmpty(L) : 若线性表已存在，返回`true`; 否则返回`false` ClearList(*L): 将线性表清空 GetElem(L, i, &amp;e): 将线性表L 中的第 i 个位置元素值返回给 e LocateElm（L，e）：在线性表L 中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回 0 表示失败 ListInsert(*L, i, e): 在线性表L 中第 i 个位置插入新元素e ListDelete(*L, i, *e): 删除线性表L 中第 i 个位置元素，并用 e 返回其值 ListLength(L): 返回线性表L 的元素个数 endADT1.3 线性表的顺序存储结构1.3.1 顺序存储定义先来看看线性表两种物理结构的第一种：顺序存储结构 定义：线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。 示意图如下： 1.3.2 顺序存储方式线性表的顺序存储结构，就是在内存中找了个空间，通过展位的方式，把一定内存空间给占了，然后把相同数据类型的数据元素一次存放在这块空地中。既然线性表的每个数据元素类型都相同，所以可以用C 语言的一维数组来实现顺序存储结构。 看看线性表的顺序存储的结构 #define MAXSIZE 20 typedef int ElemType; typedef struct { ElemType data[MaxSize]; int length; }Sqlist; 通过观察可以发现，描述顺序存储结构需要三个属性： 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。 线性表的最大存储容量：数组长度MaxSize 线性表的当前长度: length 1.3.3 数据长度与线性表长度区别 数组长度时存放线性表的存储空间的长度，存储分配后这个量一般是不变的。 线性表的长度时线性表中数据元素的个数，随着线性表的插入和删除操作的进行，这个量是变化的。 在任意时刻，线性表的长度应该小于等于数组的长度。 1.4 顺序表的基本操作1.4.1 顺序表的初始化Status InitList(Sqlist *L){ //为顺序表分配一个大小为MAXSIZE 的数组空间 L->data = malloc(sizeof(ElemType) * MAXSIZE); //存储分配失败退出 if(!L->data) exit(ERROR); //空表长度为0 L->length = 0; return OK; } 1.4.2 顺序表的插入/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L); 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */ Status ListInsert(Sqlist *L,int i,ElemType e){ //i值不合法判断 if((i&lt;1) || (i>L->length+1)) return ERROR; //存储空间已满 if(L->length == MAXSIZE) return ERROR; //插入数据不在表尾,则先移动出空余位置 if(i &lt;= L->length){ for(int j = L->length-1; j>=i-1;j--){ //插入位置以及之后的位置后移动1位 L->data[j+1] = L->data[j]; } } //将新元素e 放入第i个位置上 L->data[i-1] = e; //长度+1; ++L->length; return OK; } 1.4.3 顺序表的取值Status GetElem(Sqlist L,int i, ElemType *e){ //判断i值是否合理, 若不合理,返回ERROR if(i&lt;1 || i > L.length) return ERROR; //data[i-1]单元存储第i个数据元素. *e = L.data[i-1]; return OK; } 1.4.3 顺序表的删除/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) 操作结果: 删除L的第i个数据元素,L的长度减1 */ Status ListDelete(Sqlist *L,int i){ //线性表为空 if(L->length == 0) return ERROR; //i值不合法判断 if((i&lt;1) || (i>L->length+1)) return ERROR; for(int j = i; j &lt; L->length;j++){ //被删除元素之后的元素向前移动 L->data[j-1] = L->data[j]; } //表长度-1; L->length --; return OK; } 1.4.5 清空顺序表/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */ Status ClearList(Sqlist *L) { L->length=0; return OK; } 1.4.6 判断顺序表清空/* 初始条件：顺序线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */ Status ListEmpty(Sqlist L) { if(L.length==0) return TRUE; else return FALSE; } 1.4.7 获取顺序表长度/* ListEmpty元素个数 */ int ListLength(Sqlist L) { return L.length; } 1.4.8 顺序输出List/* 初始条件：顺序线性表L已存在 */ /* 操作结果：依次对L的每个数据元素输出 */ Status TraverseList(Sqlist L) { int i; for(i=0;i&lt;L.length;i++) printf(\"%d\\n\",L.data[i]); printf(\"\\n\"); return OK; } 1.4.9 顺序表查找元素并返回位置/* 初始条件：顺序线性表L已存在 */ /* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 */ /* 若这样的数据元素不存在，则返回值为0 */ int LocateElem(Sqlist L,ElemType e) { int i; if (L.length==0) return 0; for(i=0;i&lt;L.length;i++) { if (L.data[i]==e) break; } if(i>=L.length) return 0; return i+1; } 1.5 顺序存储结构表的优缺点 优点 无须为表示表中元素之间的逻辑关系而增加额外的存储空间 可以快速地存取表中任意位置的元素 缺点 插入和删除操作需要移动大量元素 当线性表长度变化较大时，难以确定存储空间的容量 造成存储空间的“碎片” 1.5 线性表的链式存储结构1.5.1 定义上文提到，顺序存储结构哦的线性表，最大的特点就是插入和删除时，需要移动大量元素，这显然需要耗费时间。 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的人一位置。 以前在顺序结构中，每个数据元素只要存数据元素信息就可以了。现在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。 我们把存储数据元素信息的域成为数据域。 把存储直接后继位置的域称为指针域。 指针域中存储的信息称做指针或链，这两部分信息组成数据元素的存储映像，称为结点（Node） n个结点链接成一个链表，成为线性表的链式存储结构，因为此链表的每个节点中只包含一个指针域，所以叫单链表。 链表中第一个结点的存储位置叫做头指针。 单链表的第一个结点前附设一个结点，称为头结点。 而单链表的逻辑结构如下: 1.5.2 头指针与头结点的异同 头指针 头结点 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针 头结点是为了操作的统一和方便设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度） 头指针具有标示作用，所以常用头指针冠以链表的名字 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了 无论链表是否为空，头指针均不为空。头指针式链表的必要元素 头结点不一定是链表必须要素 1.5.3 为什么要添加头结点 便于首元结点处理 便于空表和非空表的统一处理 1.6 单链表1.6.1 单链表取值//2.3 单链表取值 /* 初始条件: 顺序线性表L已存在,1≤i≤ListLength(L); 操作结果：用e返回L中第i个数据元素的值 */ Status GetElem(LinkList L,int i,ElemType *e){ //j: 计数. int j; //声明结点p; LinkList p; //将结点p 指向链表L的第一个结点; p = L->next; //j计算=1; j = 1; //p不为空,且计算j不等于i,则循环继续 while (p &amp;&amp; j&lt;i) { //p指向下一个结点 p = p->next; ++j; } //如果p为空或者j>i,则返回error if(!p || j > i) return ERROR; //e = p所指的结点的data *e = p->data; return OK; } 1.6.2 单链表的插入单链表的插入操作，分为两种： 1.6.2.1 前插法将新结点插入在链表头结点前面，成为前插法 /* 随机产生n个元素值,建立带表头结点的单链线性表L(前插法)*/ void CreateListHead(LinkList *L, int n){ LinkList p; //建立1个带头结点的单链表 *L = (LinkList)malloc(sizeof(Node)); (*L)->next = NULL; //循环前插入随机数据 for(int i = 0; i &lt; n;i++) { //生成新结点 p = (LinkList)malloc(sizeof(Node)); //i赋值给新结点的data p->data = i; //p->next = 头结点的L->next p->next = (*L)->next; //将结点P插入到头结点之后; (*L)->next = p; } } //3.1 前插法整理创建链表L iStatus = ClearList(&amp;L); CreateListHead(&amp;L, 20); printf(\"整理创建L的元素(前插法):\\n\"); ListTraverse(L); 1.6.2.2 后插法将新结点插入在链表的尾结点后面，称为后插法 /* 随机产生n个元素值,建立带表头结点的单链线性表L(后插法)*/ void CreateListTail(LinkList *L, int n){ LinkList p,r; //建立1个带头结点的单链表 *L = (LinkList)malloc(sizeof(Node)); //r指向尾部的结点 r = *L; for (int i=0; i&lt;n; i++) { //生成新结点 p = (Node *)malloc(sizeof(Node)); p->data = i; //将表尾终端结点的指针指向新结点 r->next = p; //将当前的新结点定义为表尾终端结点 r = p; } //将尾指针的next = null r->next = NULL; } //3.2 后插法整理创建链表L iStatus = ClearList(&amp;L); CreateListTail(&amp;L, 20); printf(&quot;整理创建L的元素(后插法):\\n&quot;); ListTraverse(L);1.6.3 单链表的删除要删除单链表中指定元素，通插入元素一样，应该先找到该位置的钱去结点。 用C代码实现如下： //2.4 单链表删除元素 /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */ Status ListDelete(LinkList *L,int i,ElemType *e){ int j; LinkList p,q; p = (*L)->next; j = 1; //查找第i-1个结点,p指向该结点 while (p->next &amp;&amp; j&lt;(i-1)) { p = p->next; ++j; } //当i>n 或者 i&lt;1 时,删除位置不合理 if (!(p->next) || (j>i-1)) return ERROR; //q指向要删除的结点 q = p->next; //将q的后继赋值给p的后继 p->next = q->next; //将q结点中的数据给e *e = q->data; //让系统回收此结点,释放内存; free(q); return OK; }","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://nilsli.com/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://nilsli.com/tags/算法/"},{"name":"理论","slug":"理论","permalink":"http://nilsli.com/tags/理论/"},{"name":"基础","slug":"基础","permalink":"http://nilsli.com/tags/基础/"},{"name":"线性表","slug":"线性表","permalink":"http://nilsli.com/tags/线性表/"}]},{"title":"【数据结构与算法】- 基础篇","slug":"dataStructureNAlgorithmBasicTheory","date":"2020-03-31T09:01:00.000Z","updated":"2020-04-01T17:05:23.382Z","comments":true,"path":"2020/03/31/dataStructureNAlgorithmBasicTheory/","link":"","permalink":"http://nilsli.com/2020/03/31/dataStructureNAlgorithmBasicTheory/","excerpt":"","text":"一、数据结构1 数据结构的起源早期人们都把计算机理解为数值计算工具，就是感觉计算机当然是用来计算的，所以计算机解决问题，应该是先从具体问题中抽象出一个适当的数据模型，设计出一个解此数据类型的算法，然后再编写程序，得到一个实际的软件。 可现实中，我们更多的不是解决数值计算的问题，而是需要一些更科学有效的手段（比如表、树和图等数据结构）等帮助，才能更好地解决问题。 所以 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。 2 术语概念说到数据结构是什么，我们得先来谈谈什么叫做数据。 数据结构中，有5个基本概念：数据、数据元素、数据项、数据对象和数据结构。 他们之间的关系如下图所示： 具体到代码上，参考如下代码： //声明一个结构体类型 struct Teacher{ //一种数据结构 char *name; //数据项--名字 char *title; //数据项--职称 int age; //数据项--年龄 }; int main(int argc, const char * argv[]) { struct Teacher t1; //数据元素; struct Teacher tArray[10]; //数据对象; return 0; } 1.2.1数据 是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实数等数值类型，还包括字符及声音、图像、视频等非数值类型类型。 ——《大话数据结构》 比如我们平时使用搜索殷勤，有网页、mp3、图片、视频等分类。MP3 就是声音数据 数据的特点: 可以输入到计算机 可以被计算机程序处理 1.2.2 数据元素 组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 比如，在人类中，人就是数据元素。 而在动物类中，牛、马、羊、鸡等动物就是动物类的数据元素了。 1.2.3 数据项 一个数据元素由若干数据项组成。 比如人这样的数据元素，可以有眼耳鼻舌口这些数据项，也有姓名、年龄、性别、出生地址、电话等数据项。 数据项上数据不可分割的最小单位。 1.2.4 数据对象 性质相同的数据元素的集合，是数据的子集。 性质相同的意思，是指数据元素具有相同数量和类型的数据项，比如，人都有姓名、生日、性别等相同的数据项。 1.2.5 数据结构 是相互之间存在一种或多种特定关系的数据元素的集合。 在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。而在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据之间存在的一种或多种特定关系，也就是数据的组织形式。 3 逻辑结构与物理结构按照观点的不同，我们把数据结构分为逻辑结构和物理结构。 3.1 逻辑结构 是指数据对象中数据元素之间的相互关系 逻辑关系按照类别分为线性结构与非线性结构： 1.3.1 线性结构 线性结构中的数据元素是一对一的关系 线性表 栈和队列 字符串 1.3.2 非线性结构 非线性结构中的数据元素是一对多或多对多的关系。 集合结构集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。 树形结构树形结构中的数据元素之间存在一种一对多的层次关系。 图形结构图形结构中的数据元素是多对多的关系 3.2 物理结构 是指数据的逻辑结构在计算机中的存储形式。 数据元素的存储形式有两种：顺序存储和链式存储。 3.2.1 顺序存储结构 把数据元素存放在抵制连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 如下图所示： 3.2.2 链式存储结构 把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置，如图所示： 4 抽象数据类型4.1 数据类型 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量的表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。 在C语言中，按照趣致的不同，数据类型可以分为两类： 原子类型：不可以再分解的基本类型。包括整型、浮点型、字符类型等 结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。 4.2 抽象数据类型抽象是指抽出事物具有的普遍型的本质。我们对已有的数据类型进行抽象，就有了抽象数据类型。 抽象数据类型（Abstract Data Type：ADT）： 是指一个数学模型及定义在该模型上的一组操作。 抽象的意义在于数据类型的数字抽象特性。 抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。 二、算法2.1 定义 是解决特定问题对求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 什么是算法？算法是描述解决问题的方法。 自唐代以来，历代更有许多专门论述“算法”的专著： 唐代：《一位算法》 一卷，《算法》 一卷； 宋代：《算法绪论》 一卷、《算法秘诀》 一卷；最著名的是杨辉的《杨辉算法》； 元代：《丁巨算法》； 明代：程大位 《算法统宗》 清代：《开平算法》、《算法一得》、《算法全书》。 而英文名称“algorithm”来自于9世纪波斯数学家花拉子米（比阿勒·霍瓦里松，波斯语：خوارزمی ‎，拉丁转写：al-Khwarizmi），因为比阿勒·霍瓦里松在数学上提出了算法这个概念。“算法”原为“algorism”，即“al-Khwarizmi”的音转，意思是“花拉子米”的运算法则，在18世纪演变为“algorithm”。 欧几里得算法被人们认为是史上第一个算法。 2.2 特性算法具有五个基本特征：输入、输出、有穷性、确定性和可行性。 有穷性指算法在执行有限的步骤之后，自动结束而不会出现无限循环，而且每一个步骤在可接受的时间内完成。 确定性算法的每一步骤都具有确定的含义，不会出现二义性。 可行性算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成 输入输出算法具有零个或多个输入 2.3 算法设计的要求2.3.1 正确性 算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反应问题的需求、能够得到问题的正确答案。 大概分为以下四个层次： 算法程序没有语法错误。 算法程序对于合法的输入数据能够产生满足要求的输出结果。 算法程序对于非法的输入数据能够得出满足规格说明的结果。 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。 以上这四层含义里，层次1 要求最低，而层次4 时最困难的，实际开发中，我们几乎不可能逐一验证所有的输入都能得到正确的结果。 2.3.2 可读性 算法设计的另一目的是为了便于阅读、理解和交流。 可读性时算法（也包括实现它的代码）好坏很重要的标志。 2.3.3 健壮性 当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。 2.3.4 时间效率高和存储量低 设计算法应该尽量满足时间效率高和存储量低的特点。 在生活中，人们都希望花最少的钱，用最短的时间，办最大的事，算法也是一样的思想，最好用最少的存储空间，办成同样的事——就是好的算法。 2.4 效率的度量方法通过对算法的数据测试，利用计算机的计时功能，来计算不同算法的效率是高还是低。 2.4.1 事后统计方法 这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编织的程序的运行时间进行比较，从而确定算法效率的高低。 2.4.2 事前统计方法 在计算机程序编制前，依据统计方法对算法进行估算。 我们发现，一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素： 算法采用的策略、方法 编译产生的代码质量 问题的输入规模 机器执行指令的速度 抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。 我们看看两种求和的算法： 第一种算法 int i, sum = 0 n = 100; /* 执行 1次*/ for(i = 1; i &lt;= n; i++) /* 执行 n + 1 次*/ { sum += i; /* 执行 n 次*/ } print(\"%d\", sum); /* 执行 1 次*/ 第二种算法 int sum = 0, n = 100; /* 执行 1次*/ sum = (1 + n) * n/2; /* 执行 1次*/ printf(\"%d\", sum); /* 执行 1次*/ 显然，第一种算法，执行了 1 + (n+1) + n + 1 次 = 2n + 3 次 而第二种算法是1+1+1 = 3 次。算法好坏显而易见。 最终，在分析程序的运行时间时，最重要的是吧程序看成是独立于程序设计语言的算法或一系列步骤。 2.5 算法时间复杂度2.5.1 定义 在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n) 随n 的变化情况并确定T(n) 的数量级。 算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n) 是问题规模 n 的某个函数。 大写O() 来体现算法复杂度的激发，我们称之为大O记法。 上面求和算法的时间复杂度，分别为O(n) 和 O(1) 2.5.2 推导大O 阶方法 用常数1 取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是1，则去除与这个项相乘的常数 2.5.3 常数阶下面这个算法，就是刚刚的第二个算法（高斯算法）。 int sum = 0, n = 100; /* 执行 1次*/ sum = (1 + n) * n/2; /* 执行 1次*/ printf(\"%d\", sum); /* 执行 1次*/ 这个算法的运行次函数是 f(n) = 3。根据我们推导大O阶的方法，第一步就是把常数3 改为1，再加上它没有最高阶项，所以这个算法的时间复杂度为O(1) 如果这里的第二行 sum = (1 + n) * n / 2 有10句，会是怎么样？ int sum = 0, n = 100; /* 执行 1次*/ sum = (1 + n) * n/2; /* 执行 1次*/ sum = (1 + n) * n/2; /* 执行 1次*/ sum = (1 + n) * n/2; /* 执行 1次*/ sum = (1 + n) * n/2; /* 执行 1次*/ sum = (1 + n) * n/2; /* 执行 1次*/ sum = (1 + n) * n/2; /* 执行 1次*/ sum = (1 + n) * n/2; /* 执行 1次*/ sum = (1 + n) * n/2; /* 执行 1次*/ sum = (1 + n) * n/2; /* 执行 1次*/ sum = (1 + n) * n/2; /* 执行 1次*/ printf(\"%d\", sum); /* 执行 1次*/ 事实上，无论n 为多少，上面的代码就说3次和12次执行的差异。这种与问题的大小无关（n） 的多少，执行时间恒定的算法，我们称之为具有 O(1) 的时间复杂度 2.5.4 线性阶我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。 下面这段代码，它的循环的时间复杂度为O(n)，因为循环体中的代码须要执行 n 次 int i; for(i = 0; i &lt; n; i++) { / * 时间复杂度为O（1）的程序步骤序列 */ } 2.5.5 对数阶int count = 1; while (count &lt; n) { count = count * 2; /* 时间复杂度为 O(1) 的程序步骤序列*/ } 上面这行代码，由于每次 count 乘以 2 以后，就距离 n 更近了一份。 也就是说，有多少个2 相乘后大于 n，则会推出循环。 由 2x= n 得到 x = log2n 。所以这个循环的时间复杂度为O(logn)。 2.5.6 平方阶下面的例子说一个循环嵌套，它的内循环时间复杂度为O(n) in i,j; for(i = 0; i &lt; n; i++) { for (j = 0; j &lt; n; j++) { / * 时间复杂度为 O(1) 的程序步骤序列*/ } } 而对于外层的循环，不过是内部这个时间复杂度 O(n) 的语句，再循环 n 次。所以这段代码的时间复杂度为 O(n2)。 2.6 常见的时间复杂度常见的时间复杂度如表所示 执行次数函数 阶 非正式术语 12 O(1) 常数阶 2n + 3 O(n) 线性阶 3n2 + 2n + 1 O(n2) 平方阶 5 log2n + 20 O(logn) 对数阶 2n + 3n log2n + 19 O(nlogn) nlogn 阶 6n3 + 2 n2 + 3n + 4 O(n3) 立方阶 2 n O(2n) 指数阶 常用的时间复杂度所消耗的时间从小到大依次是: O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn) 2.7 最坏情况与平均情况我们查找一个由 n 个随机数字数组中的某个数组，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的复杂度为O(n)，这是最坏的一种情况了。 最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏时间的运行时间。 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，我们运行一段程序代码时，实习完看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。 对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。 另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。一般在没有特殊说明的情况下，都是指最坏时间复杂度。 2.8 算法空间复杂度算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(&fnof;(n))，其中，n 为问题的规模，&fnof;(n) 为语句关于 n 所占存储空间的函数。 通常，我们都适用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://nilsli.com/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://nilsli.com/tags/算法/"},{"name":"理论","slug":"理论","permalink":"http://nilsli.com/tags/理论/"},{"name":"基础","slug":"基础","permalink":"http://nilsli.com/tags/基础/"}]},{"title":"【底层探索】-懒加载与分类","slug":"lazyNcat","date":"2020-03-31T04:58:01.000Z","updated":"2020-04-01T15:06:03.730Z","comments":true,"path":"2020/03/31/lazyNcat/","link":"","permalink":"http://nilsli.com/2020/03/31/lazyNcat/","excerpt":"","text":"一、懒加载二、分类","categories":[],"tags":[{"name":"底层，源码，懒加载，分类","slug":"底层，源码，懒加载，分类","permalink":"http://nilsli.com/tags/底层，源码，懒加载，分类/"}]},{"title":"runtime 面试题","slug":"runtimeInterview","date":"2020-03-30T08:24:38.000Z","updated":"2020-04-01T15:06:03.742Z","comments":true,"path":"2020/03/30/runtimeInterview/","link":"","permalink":"http://nilsli.com/2020/03/30/runtimeInterview/","excerpt":"","text":"最近看到一道runtime 面试题，觉得有意思 问题：Q：已经注册好的类，能否再动态添加成员变量？为什么？ 分析：我们通过Runtime还原一下场景。 注册好的类，实现的方法是，注册到内存里： objc_registerClassPair(LGPerson); 而实现objc_registerClassPair 这个方法，又实现了下面的内容: // Clear \"under construction\" bit, set \"done constructing\" bit cls->ISA()->changeInfo(RW_CONSTRUCTED, RW_CONSTRUCTING | RW_REALIZING); cls->changeInfo(RW_CONSTRUCTED, RW_CONSTRUCTING | RW_REALIZING); 即对类更改了状态，更改了什么状态？RW_CONSTRUCTED这个状态，即让类处于内存开辟&amp;注册到内存中—— // class allocated and registered #define RW_CONSTRUCTED (1&lt;&lt;25) 接下来，根据创建成员变量的函数为addIvar，创建业务代码如下 class_addIvar(LGPerson, \"lgName\", sizeof(NSString *), log2(sizeof(NSString *)), \"@\"); 在源码中找到相对应的函数： 走到这一步，就戛然而止了……添加ivars 被拒绝——因为内存已固定，无法再添加新属性了。 回答：答案是否。 因为注册好的类，内存容量已经固定，无法动态添加了。","categories":[],"tags":[{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/类/"},{"name":"2020","slug":"2020","permalink":"http://nilsli.com/tags/2020/"},{"name":"runtime","slug":"runtime","permalink":"http://nilsli.com/tags/runtime/"},{"name":"面试","slug":"面试","permalink":"http://nilsli.com/tags/面试/"},{"name":"成员变量","slug":"成员变量","permalink":"http://nilsli.com/tags/成员变量/"}]},{"title":"底层探索——类的加载","slug":"loadingClass","date":"2020-03-24T07:18:34.000Z","updated":"2020-04-01T15:06:03.750Z","comments":true,"path":"2020/03/24/loadingClass/","link":"","permalink":"http://nilsli.com/2020/03/24/loadingClass/","excerpt":"","text":"本页所使用的objc runtime 756.2，来自 Apple 开源文档 1、objc_init 流程类的加载，初始化来自dyld 中的objc_init 这个步骤，查看一下源码，得到 void _objc_init(void) { static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image); } 序号 源代码 解释 1 environ_init() 环境变量、帮助文档配置 2 tls_init() 线程key 的绑定 3 static_init C++ 静态构造函数 4 lock_init() 锁配置 5 exception_init() 异常初始化 6 _dyld_objc_notify_register Dyld 通知注册 1.1 environ_init 在函数void environ_init(void) 里，读取环境变量 env 以及帮助注释 help， 相关代码如下： for (size_t i = 0; i &lt; sizeof(Settings)/sizeof(Settings[0]); i++) { const option_t *opt = &amp;Settings[i]; if (PrintHelp) _objc_inform(\"%s: %s\", opt->env, opt->help); if (PrintOptions &amp;&amp; *opt->var) _objc_inform(\"%s is set\", opt->env); } 运行代码，在控制台可以得到环境变量参数表： objc[27076]: OBJC_PRINT_IMAGES: log image and library names as they are loaded objc[27076]: OBJC_PRINT_IMAGE_TIMES: measure duration of image loading steps objc[27076]: OBJC_PRINT_LOAD_METHODS: log calls to class and category +load methods objc[27076]: OBJC_PRINT_INITIALIZE_METHODS: log calls to class +initialize methods objc[27076]: OBJC_PRINT_RESOLVED_METHODS: log methods created by +resolveClassMethod: and +resolveInstanceMethod: objc[27076]: OBJC_PRINT_CLASS_SETUP: log progress of class and category setup objc[27076]: OBJC_PRINT_PROTOCOL_SETUP: log progress of protocol setup objc[27076]: OBJC_PRINT_IVAR_SETUP: log processing of non-fragile ivars objc[27076]: OBJC_PRINT_VTABLE_SETUP: log processing of class vtables objc[27076]: OBJC_PRINT_VTABLE_IMAGES: print vtable images showing overridden methods objc[27076]: OBJC_PRINT_CACHE_SETUP: log processing of method caches objc[27076]: OBJC_PRINT_FUTURE_CLASSES: log use of future classes for toll-free bridging objc[27076]: OBJC_PRINT_PREOPTIMIZATION: log preoptimization courtesy of dyld shared cache objc[27076]: OBJC_PRINT_CXX_CTORS: log calls to C++ ctors and dtors for instance variables objc[27076]: OBJC_PRINT_EXCEPTIONS: log exception handling objc[27076]: OBJC_PRINT_EXCEPTION_THROW: log backtrace of every objc_exception_throw() objc[27076]: OBJC_PRINT_ALT_HANDLERS: log processing of exception alt handlers objc[27076]: OBJC_PRINT_REPLACED_METHODS: log methods replaced by category implementations objc[27076]: OBJC_PRINT_DEPRECATION_WARNINGS: warn about calls to deprecated runtime functions objc[27076]: OBJC_PRINT_POOL_HIGHWATER: log high-water marks for autorelease pools objc[27076]: OBJC_PRINT_CUSTOM_RR: log classes with un-optimized custom retain/release methods objc[27076]: OBJC_PRINT_CUSTOM_AWZ: log classes with un-optimized custom allocWithZone methods objc[27076]: OBJC_PRINT_RAW_ISA: log classes that require raw pointer isa fields objc[27076]: OBJC_DEBUG_UNLOAD: warn about poorly-behaving bundles when unloaded objc[27076]: OBJC_DEBUG_FRAGILE_SUPERCLASSES: warn about subclasses that may have been broken by subsequent changes to superclasses objc[27076]: OBJC_DEBUG_NIL_SYNC: warn about @synchronized(nil), which does no synchronization objc[27076]: OBJC_DEBUG_NONFRAGILE_IVARS: capriciously rearrange non-fragile ivars objc[27076]: OBJC_DEBUG_ALT_HANDLERS: record more info about bad alt handler use objc[27076]: OBJC_DEBUG_MISSING_POOLS: warn about autorelease with no pool in place, which may be a leak objc[27076]: OBJC_DEBUG_POOL_ALLOCATION: halt when autorelease pools are popped out of order, and allow heap debuggers to track autorelease pools objc[27076]: OBJC_DEBUG_DUPLICATE_CLASSES: halt when multiple classes with the same name are present objc[27076]: OBJC_DEBUG_DONT_CRASH: halt the process by exiting instead of crashing objc[27076]: OBJC_DISABLE_VTABLES: disable vtable dispatch objc[27076]: OBJC_DISABLE_PREOPTIMIZATION: disable preoptimization courtesy of dyld shared cache objc[27076]: OBJC_DISABLE_TAGGED_POINTERS: disable tagged pointer optimization of NSNumber et al. objc[27076]: OBJC_DISABLE_TAG_OBFUSCATION: disable obfuscation of tagged pointers objc[27076]: OBJC_DISABLE_NONPOINTER_ISA: disable non-pointer isa fields objc[27076]: OBJC_DISABLE_INITIALIZE_FORK_SAFETY: disable safety checks for +initialize after fork 1.2 tls_init() 对线程的Key 的绑定。 这部分不展开讨论 void tls_init(void) { #if SUPPORT_DIRECT_THREAD_KEYS _objc_pthread_key = TLS_DIRECT_KEY; pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific); #else _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific); #endif } 1.3 static_init 实现系统级别的 C++ 静态构造函数。 相关源码： static void static_init() { size_t count; auto inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count); for (size_t i = 0; i &lt; count; i++) { inits[i](); } } 1.4 lock_init 锁的初始化，这里并没有进行实现，意味着可以进行重写，自定义一些操作。 相关源码： /*********************************************************************** * Lock management **********************************************************************/ mutex_t runtimeLock; mutex_t selLock; mutex_t cacheUpdateLock; recursive_mutex_t loadMethodLock; void lock_init(void) { } 1.5 exception_init 异常的初始化：libobjc 的异常回调系统初始化，由map_images 调用。 即注册监听回调。 /*********************************************************************** * exception_init * Initialize libobjc's exception handling system. * Called by map_images(). **********************************************************************/ void exception_init(void) { old_terminate = std::set_terminate(&amp;_objc_terminate); } 这个c++ 函数 set_terminate 会初始化静态的 异常回调。在OC 环境下，所有的异常抛出，都会到(*old_terminate)(); 这行代码里。 相关源码如下： static void (*old_terminate)(void) = nil; static void _objc_terminate(void) { if (PrintExceptions) { _objc_inform(\"EXCEPTIONS: terminating\"); } if (! __cxa_current_exception_type()) { // No current exception. (*old_terminate)(); } else { // There is a current exception. Check if it's an objc exception. @try { __cxa_rethrow(); } @catch (id e) { // It's an objc object. Call Foundation's handler, if any. (*uncaught_handler)((id)e); (*old_terminate)(); } @catch (...) { // It's not an objc object. Continue to C++ terminate. (*old_terminate)(); } } } 在业务代码里执行一个报错的方法： 类声明与实现 @interface Dog : NSObject - (void)bark; @end @implementation Dog @end 使用类执行为实现的方法 Dog *d = [Dog alloc]; [d bark]; 异常抛出如下图所示： 1.6 _dyld_objc_notify_register（核心） objc 特有方法 注册回调。当镜像文件被映射(mapped)、未被映射(unmapped)、初始化(initialized) 使调用。 该方法由dyld 声明。 镜像文件加载完后，dyld 会回调”映射”函数，内容为一个包含objc-image-info 数据段的数组。 注册方法源码如下： _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image); 这里主要关注 map_images 的这个对象，其实现代码为： void map_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[]) { mutex_locker_t lock(runtimeLock); return map_images_nolock(count, paths, mhdrs); } 读取镜像文件 继续探索 map_images_nolock 这个函数，读取镜像文件的关键行为 if (hCount > 0) { _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses); } 至此，这一部分到此就结束了，关于images 的流程，另外单独分析。 2、read_images - 读镜像文件2.1 初次进来: 创建容器哈希表根据源码，得知读取镜像的主要函数为read_image ，其函数具体为： void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){} 读取镜像后，最先需要做的是，为这些景象里的内容找一个家——容器，也就是开辟表结构。 在源码里，这里分别通过NXCreateMapTable、NXCreateHashTable开辟了2个表，主要存储以下的内容： 未共享缓存的类 gdb_objc_realized_classes gdb_objc_realized_classes = NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize); 开辟内存空间类 - allocatedClasses allocatedClasses = NXCreateHashTable(NXPtrPrototype, 0, nil); 2.2 类的处理 从编译后的类列表中，取出所有的类，并进行下一步操作。 for (EACH_HEADER) { classref_t *classlist = _getObjc2ClassList(hi, &amp;count); } 取出系统类 Class cls = (Class)classlist[i]； 读取类 Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized); 懒加载相关，条件为 newCls != cls &amp;&amp; newCls， 即两个类不相等时 初始化懒加载所需内存空间 resolvedFutureClasses = (Class *) realloc(resolvedFutureClasses, (resolvedFutureClassCount+1) * sizeof(Class)); 懒加载的类添加到数组中来 resolvedFutureClasses[resolvedFutureClassCount++] = newCls; 2.3 方法编号处理 把未注册的方法名进行注册到一张HASH表里，形成方法名与方法的映射 static size_t UnfixedSelectors; { mutex_locker_t lock(selLock); for (EACH_HEADER) { if (hi->isPreoptimized()) continue; bool isBundle = hi->isBundle(); SEL *sels = _getObjc2SelectorRefs(hi, &amp;count); UnfixedSelectors += count; for (i = 0; i &lt; count; i++) { const char *name = sel_cname(sels[i]); // 注册SEL的操作 sels[i] = sel_registerNameNoLock(name, isBundle); } } } 注册到的表名为namedSelectors， 具体的实现在这里 NXMapInsert(namedSelectors, sel_getName(result), result); 2.4 协议处理 找到类遵守的协议，修复协议的引用。 关键字: readProtocol 、remapProtocolRef 相关源码，如下所示: 找到协议： for (EACH_HEADER) { extern objc_class OBJC_CLASS_$_Protocol; Class cls = (Class)&amp;OBJC_CLASS_$_Protocol; NXMapTable *protocol_map = protocols(); protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count); for (i = 0; i &lt; count; i++) { readProtocol(protolist[i], cls, protocol_map, isPreoptimized, isBundle); } } 修复协议引用（重映射）： for (EACH_HEADER) { protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count); for (i = 0; i &lt; count; i++) { remapProtocolRef(&amp;protolist[i]); } } 2.5 非懒加载处理 初始化所有非懒加载类，进行 rw ro 操作 for (EACH_HEADER) { classref_t *classlist = _getObjc2NonlazyClassList(hi, &amp;count); addClassTableEntry(cls); realizeClassWithoutSwift(cls); } 2.6 待处理的类 找到最新特征的类，以备CoreFoundation 需要操作它 if (resolvedFutureClasses) { for (i = 0; i &lt; resolvedFutureClassCount; i++) { Class cls = resolvedFutureClasses[i]; if (cls->isSwiftStable()) { _objc_fatal(\"Swift class is not allowed to be future\"); } realizeClassWithoutSwift(cls); cls->setInstancesRequireRawIsa(false/*inherited*/); } free(resolvedFutureClasses); } 2.7 分类处理 对非类进行处理，包括Class 的和metaClass 的 for (EACH_HEADER) { category_t **catlist = _getObjc2CategoryList(hi, &amp;count); bool hasClassProperties = hi->info()->hasCategoryClassProperties(); for (i = 0; i &lt; count; i++) { category_t *cat = catlist[i]; Class cls = remapClass(cat->cls); } } 3、类方法重点3.1 类的读取readClasses3.1.1 判断是否是未来处理的类 （popFutureNamedClass）如果是，就读取data，设置rw 和 ro if (Class newCls = popFutureNamedClass(mangledName)) { // This name was previously allocated as a future class. // Copy objc_class to future class's struct. // Preserve future's rw data block. if (newCls->isAnySwift()) { _objc_fatal(\"Can't complete future class request for '%s' \" \"because the real class is too big.\", cls->nameForLogging()); } // 在这里，读取data(), 并进行设置 rw /ro class_rw_t *rw = newCls->data(); const class_ro_t *old_ro = rw->ro; memcpy(newCls, cls, sizeof(objc_class)); rw->ro = (class_ro_t *)newCls->data(); newCls->setData(rw); freeIfMutable((char *)old_ro->name); free((void *)old_ro); addRemappedClass(cls, newCls); replacing = cls; cls = newCls; } 3.1.2 添加命名过的类addNamedClass(cls, mangledName, replacing); 3.1.3 把类插入到包含所有类的表里addClassTableEntry(cls); 具体的实现为如下： static void addClassTableEntry(Class cls, bool addMeta = true) { runtimeLock.assertLocked(); // This class is allowed to be a known class via the shared cache or via // data segments, but it is not allowed to be in the dynamic table already. assert(!NXHashMember(allocatedClasses, cls)); if (!isKnownClass(cls)) NXHashInsert(allocatedClasses, cls); if (addMeta) addClassTableEntry(cls->ISA(), false); } 3.2 realizeClassWithoutSwift 实现类的初次初始化，包括开辟rw数据的内存空间。 3.2.1 取出类里的 ro 部分（data）ro = (const class_ro_t *)cls->data(); 3.2.2 开辟rw 内存空间// Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); rw->ro = ro; rw->flags = RW_REALIZED|RW_REALIZING; cls->setData(rw); 最终通过cls-&gt;setData(rw) , 将rw 作为data赋值给类 cls。 但是到这里，cls 仅仅是对数据部分做了初始化，里面的方法都没有写入。 如何验证？ 通过lldb 来进行验证吧： 通过p/x 获取cls指针 偏移16位获得bits 的指针 将bits 强转为class_data_bits_t 的类型$2 读取$2点data() 方法。 过程可见下图，methods 属性下的list 为空，并没有方法列表的写入。 可见该过程，仅仅对cls 下rw 的属性的ro 、flags进行了赋值，而rw 并没有得到赋值 3.2.3 实现父类和元类关联3.2.3.1 子类链接父类上面的流程都是在初始化类的各种属性后，而类的结构最重要的一点是它与父类的关联，以及与元类的isa 指向。 所以下面的操作是 通过remapClass(cls-&gt;superclass)对父类进行映射查找 通过remapClass(cls-&gt;ISA)对元类进行查找 然后通过realizeClassWithoutSwift 进行递归，逐步得到相应的supercls以及metacls 的指针。 步骤依然是：类——元类——根元类——NSObject——nil（跳出） supercls = realizeClassWithoutSwift(remapClass(cls->superclass)); metacls = realizeClassWithoutSwift(remapClass(cls->ISA())); 这两个失踪人口进行搜寻成功后，就可以将其指针对类进行关联 // Update superclass and metaclass in case of remapping cls->superclass = supercls; cls->initClassIsa(metacls); 3.2.3.2 父类链接子类如果找到父类，在父类添加双向链表的引用，将子类引用添加到父类的子类列表里，最终实现父类和子类建立关联 // Connect this class to its superclass&#39;s subclass lists if (supercls) { addSubclass(supercls, cls); } else { addRootClass(cls); }结论是：子类里添加父类链接，父类里也添加子类链接，你中有我，我中有你。 接下来看一下父类链接的具体实现： static void addSubclass(Class supercls, Class subcls) { runtimeLock.assertLocked(); if (supercls &amp;&amp; subcls) { assert(supercls->isRealized()); assert(subcls->isRealized()); subcls->data()->nextSiblingClass = supercls->data()->firstSubclass; supercls->data()->firstSubclass = subcls; if (supercls->hasCxxCtor()) { subcls->setHasCxxCtor(); } if (supercls->hasCxxDtor()) { subcls->setHasCxxDtor(); } if (supercls->hasCustomRR()) { subcls->setHasCustomRR(true); } if (supercls->hasCustomAWZ()) { subcls->setHasCustomAWZ(true); } // Special case: instancesRequireRawIsa does not propagate // from root class to root metaclass if (supercls->instancesRequireRawIsa() &amp;&amp; supercls->superclass) { subcls->setInstancesRequireRawIsa(true); } } } 实现为： 父类的第一个子类，赋值给子类的下一个兄弟类： subcls->data()->nextSiblingClass = supercls->data()->firstSubclass; 子类赋值给父类的第一个子类： supercls->data()->firstSubclass = subcls; 同时，子类继承父类的各种能力 hasCxxCtor hasCxxDtor hasCustomRR hasCustomAWZ instancesRequireRawIsa（适用NONPOINTER_ISA） 3.2.4 methodizeClass - rw 内容的填充 对之前创建的rw 进行方法、属性，协议的填充实现 对分类的实现 方法的填充实现 method_list_t *list = ro->baseMethods(); if (list) { prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); rw->methods.attachLists(&amp;list, 1); } 属性填充实现 property_list_t *proplist = ro->baseProperties; if (proplist) { rw->properties.attachLists(&amp;proplist, 1); } 协议填充实现 protocol_list_t *protolist = ro->baseProtocols; if (protolist) { rw->protocols.attachLists(&amp;protolist, 1); } 根元类额外的实现 if (cls->isRootMetaclass()) { // root metaclass addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, \"\", NO); } 添加分类 // Attach categories. category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/); attachCategories(cls, cats, false /*don't flush caches*/); 提一下上面的方法实现中添加的机制，究竟是如何的？继续看源码，可以看到添加情况有3种 多对多 - 方法原已有多个，在需要添加多个 if (hasArray()) { // many lists -> many lists uint32_t oldCount = array()->count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()->count = newCount; memmove(array()->lists + addedCount, array()->lists, oldCount * sizeof(array()->lists[0])); memcpy(array()->lists, addedLists, addedCount * sizeof(array()->lists[0])); } 这里经历了3个步骤： 获取原方法数： array()-&gt;count 获取原方法数+新方法的总方法数： oldCount + addedCount 内存扩容：realloc 字节移动：内存中原方法平移：memmove 字节移动：新方法拷贝进入：memcpy 0 对多 - 方法原没有，在需要添加多个 list = addedLists[0]; 1 对多 // 1 list -> many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()->count = newCount; if (oldList) array()->lists[addedCount] = oldList; memcpy(array()->lists, addedLists, addedCount * sizeof(array()->lists[0])); 另外，可以观察到无论是方法methods、属性properties、协议protocols，在添加时，使用的同样的方法attachLists， 这是因为作为同为class_rw_t类型下的属性，他们拥有同样的数据结构：二维数组。 其中方法列表和属性列表的根类型，均为entsize_list_tt 方法列表结构： class method_array_t : public list_array_tt&lt;method_t, method_list_t> 属性列表结构： class property_array_t : public list_array_tt&lt;property_t, property_list_t> 协议列表结构： class protocol_array_t : public list_array_tt&lt;protocol_ref_t, protocol_list_t> 方法列表设计成二维数组，方便分类方法的批量插入： 4、小结 类的加载，流程分为环境的启动配置、加载镜像、读取类方法、对类内存空间初始化、子类-父类建立连接，以及最终rw填充方法，并对分类方法加入进行实现。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"Class","slug":"Class","permalink":"http://nilsli.com/tags/Class/"}]},{"title":"【底层探索】dyld浅析","slug":"dyld-analyze","date":"2020-03-23T04:30:29.000Z","updated":"2020-04-01T15:06:03.727Z","comments":true,"path":"2020/03/23/dyld-analyze/","link":"","permalink":"http://nilsli.com/2020/03/23/dyld-analyze/","excerpt":"","text":"本页所使用的objc runtime 756.2，来自GITHUB 一、引言前文研究了对象、方法的基础，知道了对象/类的结构，类方法的生成和传递原理。下面该进入到核心环节，就是类的加载了，在这一个模块，需要了解的有下面几点： OC 的库 app 的加载流程 image 的结构 回调函数 image 的加载流程 二、库2.1、静态库 是一个外部函数与变量的集合体 iOS 在编译时执行静态库，链接到相应代码 静态库的文件内容，通常包含一堆程序员自定的变量与函数，其内容不像动态链接库那么复杂，在编译期间由编译器与链接器将它集成至应用程序内，并制作成目标文件以及可以独立运作的可执行文件。 常见的iOS 环境下的静态库由 .a 文件，.framework 文件。java 环境下有.so 静态库 2.2、动态库 iOS 在运行时执行动态库，链接到相应的代码里。 .dylib 库文件 三、App 启动流程1. dyld startlibdyld.dylib`start 2. 加载镜像reloadAllImages:3. 加载链接loadInsertedDylib 插入（insert）： 插入网线 链接（link）： 接通网络 四、dyld4.1 start4.2 递归初始化4.3 objc_init五、镜像 - images dyld Objc_init 六、回调函数 指针 注册 *snotif","categories":[],"tags":[{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"dyld","slug":"dyld","permalink":"http://nilsli.com/tags/dyld/"}]},{"title":"方法的本质4_消息转发机制","slug":"messageSend","date":"2020-03-13T10:16:42.000Z","updated":"2020-04-01T15:06:03.737Z","comments":true,"path":"2020/03/13/messageSend/","link":"","permalink":"http://nilsli.com/2020/03/13/messageSend/","excerpt":"","text":"本页所使用的objc runtime 756.2，来自GITHUB 1、回顾上文消息方法的本质3_消息查找流程 一文总结了方法查找的流程，得到结论如下: 类的缓存里查找——找到——结束查找 类的方法列表里查找——找到——结束查找 递归父类缓存、方法列表查找——找到——结束查找 动态方法解析——（未分析） 以上未解决——异常崩溃——结束 下面继续学习源码，结合业务代码，深挖第四步 动态方法决议，来更深一步的学习消息转发机制。 2、问题这篇文章，希望弄清楚下面的问题 消息转发是什么 消息转发的场景 如何进行消息转发 3、动态方法决议 3.1 入口 - class_resolveMethod之前的分析，知道了当查找缓存未命中后，会执行objc_msgSend_uncached 的方法，进行方法查找。 具体执行的是方法 _class_lookupMethodAndLoadCache3 。 runtime 源码如下： /*********************************************************************** * _class_lookupMethodAndLoadCache. * Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp(). * This lookup avoids optimistic cache scan because the dispatcher * already tried that. **********************************************************************/ IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls) { return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/); } 在源码中，知道了具体执行的方法是 lookUpImpOrForward，这个方法执行了众多流程，缓存、递归查找等。 如果都未命中，则会找到方法决议实现，代码如下： // No implementation found. Try method resolver once. if (resolver &amp;&amp; !triedResolver) { runtimeLock.unlock(); _class_resolveMethod(cls, sel, inst); runtimeLock.lock(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; } 注意到执行 _class_resolveMethod(cls, sel, inst) 前后，使用了runtimeLock 进行了锁定与解锁，具体实现时互斥锁（参见Cooci老师的互斥锁-读写锁-条件锁），来保证内存安全。 查看一下class_resolveMethod 方法 Summary _class_resolveMethod Call +resolveClassMethod or +resolveInstanceMethod. Returns nothing; any result would be potentially out-of-date already. Does not check if the method already exists. class_resolveMethod 调用 +resolveClassMethod 或 +resolveInstanceMethod。 返回值为空；任何结果将可能已经过期。 如果方法已经存在，不会检查/执行。 由此可见resolveMethod 只是一个入口，会具体调用如下方法： 类方法：+resolveInstanceMethod 实例方法：+resolveInstanceMethod 具体的源码，见下面的： void _class_resolveMethod(Class cls, SEL sel, id inst) { if (! cls->isMetaClass()) { // try [cls resolveInstanceMethod:sel] _class_resolveInstanceMethod(cls, sel, inst); } else { // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] _class_resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { _class_resolveInstanceMethod(cls, sel, inst); } } } 代码 分析 备注 ! cls-&gt;isMetaClass() 是否元类 否，说明主体是实例 _class_resolveInstanceMethod 实例方法决议实现 _class_resolveClassMethod 类方法决议实现 _class_resolveInstanceMethod [第2个] 查看NSObject 决议实现 发生在lookUpImpOrNil 失败后 分析: 进入决议后，先确定是否是元类； 如果是元类，由于已知类方法存储在元类里，知道该方法主体是类，则会进入类方法决议 如果不是元类，即方法主题是实例，进入实例方法决议。 如果元类方法决议查找失败，根元类亦查找失败，由于根元类的isa 是指向自身的，所以用到了 _class_resolveInstanceMethod 的实例决议方法。 具体逻辑见下图： 3.2 类方法决议 - _class_resolveClassMethod捋清楚入口后，继续看类方法的决议，源码如下： /*********************************************************************** * _class_resolveClassMethod * Call +resolveClassMethod, looking for a method to be added to class cls. * cls should be a metaclass. * Does not check if the method already exists. **********************************************************************/ static void _class_resolveClassMethod(Class cls, SEL sel, id inst) { assert(cls->isMetaClass()); if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { // Resolver not implemented. return; } BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(_class_getNonMetaClass(cls, inst), SEL_resolveClassMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveClassMethod adds to self->ISA() a.k.a. cls IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); if (resolved &amp;&amp; PrintResolving) { if (imp) { _objc_inform(\"RESOLVE: method %c[%s %s] \" \"dynamically resolved to %p\", cls->isMetaClass() ? '+' : '-', cls->nameForLogging(), sel_getName(sel), imp); } else { // Method resolver didn't add anything? _objc_inform(\"RESOLVE: +[%s resolveClassMethod:%s] returned YES\" \", but no new implementation of %c[%s %s] was found\", cls->nameForLogging(), sel_getName(sel), cls->isMetaClass() ? '+' : '-', cls->nameForLogging(), sel_getName(sel)); } } } 分析上文的源码，除了一些断言、异常的保护代码外，关键语句来到了这一句 BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(_class_getNonMetaClass(cls, inst), SEL_resolveClassMethod, sel); 这里的函数msg 调用了3个参数 _class_getNonMetaClass(cls, inst) ：即类的本身 SEL_resolveClassMethod ： 决议的类方法 sel ：需要查找的方法编号 所以，关键的行为就是SEL_resolveClassMethod 方法，通过搜索，源码代码中均找不到。 回头看苹果给该方法写的注释： _class_resolveClassMethod Call +resolveClassMethod, looking for a method to be added to class cls. 意思是C 源码里写的方法，在OC 实现里，会执行+resolveClassMethod 的方法，即通过resolveClassMethod 来对该类进行决议——添加相应的类方法。 在OC里的实现即这个方法 + (BOOL)resolveClassMethod:(SEL)sel{ return NO; } 至此，已经大概明白了决议的意义——当方法找不到实现时，转发到类/实例决议方法里，看看开发者是否有自行实现。其最大的意义，恐怕是收集各种崩溃了。 3.3 实例方法决议 - class_resolveInstanceMethod实例方法决议的源码实现，与类方法决议类似，差别仅仅在决议执行方法，换成了SEL_resolveInstanceMethod，源码如下： BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(cls, SEL_resolveInstanceMethod, sel); 当决议方法得到实现后，会提示，方法XX 已经被决议成为新的实现YY—— 否则会提示决议未找到: if (resolved &amp;&amp; PrintResolving) { if (imp) { _objc_inform(\"RESOLVE: method %c[%s %s] \" \"dynamically resolved to %p\", cls->isMetaClass() ? '+' : '-', cls->nameForLogging(), sel_getName(sel), imp); } else { // Method resolver didn't add anything? _objc_inform(\"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES\" \", but no new implementation of %c[%s %s] was found\", cls->nameForLogging(), sel_getName(sel), cls->isMetaClass() ? '+' : '-', cls->nameForLogging(), sel_getName(sel)); } } 4、快速转发阶段4.1 快速转发方法forwardingTargetForSelector ：即将本类未实现的方法，交由指定的其他类来实现。 4.2 业务代码实现如下： 类Person, 与未实现的方法teach： @interface Person : NSObject - (void)teach; @end 类的转发方法——指定Teacher 这个类来执行 - (id)forwardingTargetForSelector:(SEL)aSelector { if (aSelector == @selector(teach)) { return [Teacher alloc]; } return [super forwardingTargetForSelector:aSelector]; } 类Teacher 以及实现的方法teach NS_ASSUME_NONNULL_BEGIN @interface Teacher : NSObject - (void)teach; @end NS_ASSUME_NONNULL_END @implementation Teacher - (void)teach{ NSLog(@\"%s\", __func__); } @end 主业务执行，使类执行它为实现的方法teach: int main(int argc, const char * argv[]) { @autoreleasepool { Person *person = [[Person alloc] init]; [person teach]; } return 0; } 执行结果，teacher类实现了teach： 2020-03-20 16:12:51.477020+0800 debug-objc[8565:349779] -[Teacher teach] 由此可见，forwardingTargetForSelector 的作用，是自身无法处理，交由其他对象（可能是类）来处理。 5、慢速转发阶段5.1 慢速转发方法methodSignatureForSelector，看看开发文档的描述： methodSignatureForSelector:Returns an NSMethodSignature object that contains a description of the method identified by a given selector. 返回一个NSMethodSignature 的签名对象，包含一个给定选择器的方法的描述 获取方法签名： methodSignatureForSelector 通过获取的签名，转发信息 –执行方法是 forwardInvocation往指定的对象传递方法和参数 5.2 业务代码实现:基础代码与快速转发一致，只是删除了forwardingTargetForSelector 的实现代码。 并在Person 类里实现如下代码 实现方法签名 // 获得方法签名 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { NSString *sel = NSStringFromSelector(aSelector); //生成签名 if ([sel isEqualToString:@\"run\"]) { return [NSMethodSignature signatureWithObjCTypes:\"v@:\"]; }else { return [super methodSignatureForSelector:aSelector]; } } “v” 是方法描述，更多的在这里： * 代表 char * char BOOL 代表 c : 代表 SEL ^type 代表 type * @ 代表 NSObject * 或 id ^@ 代表 NSError ** # 代表 NSObject v 代表 void 获取签名，进行配发信息 - (void)forwardInvocation:(NSInvocation *)anInvocation { NSLog(@\"-----%@-----\",anInvocation); //取得消息 SEL selector = [anInvocation selector]; //转发 SomePerson *someP = [SomePerson new]; if ([someP respondsToSelector:selector]) { //调用对象，进行转发 [anInvocation invokeWithTarget:someP]; } else { return [super forwardInvocation:anInvocation]; } } 执行teach 结果 2020-03-20 16:37:41.639718+0800 debug-objc[9325:370827] -[Teacher teach] 6、查找失败消息没有得到处理 崩溃退出，这里从forwardInvocation 的实现，可以追踪到相关的代码： - (void)forwardInvocation:(NSInvocation *)invocation { [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)]; } // Replaced by CF (throws an NSException) - (void)doesNotRecognizeSelector:(SEL)sel { _objc_fatal(\"-[%s %s]: unrecognized selector sent to instance %p\", object_getClassName(self), sel_getName(sel), self); } 7、 总结又到了最受欢迎的总结时间。 答案： 消息转发是什么：向指定的对象或类，发送需要消息，请求交由对方执行 消息转发的场景：自我无法实现的场景下。 如何进行消息转发 快速转发：使用 forwardingTargetForSelector 进行定向转发 慢速转发：获取签名，使用forwardInvocation 转发 有图另外，总结经验再多，不如有图有真相……","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/结构/"},{"name":"消息转发","slug":"消息转发","permalink":"http://nilsli.com/tags/消息转发/"},{"name":"objc","slug":"objc","permalink":"http://nilsli.com/tags/objc/"}]},{"title":"【休闲】西湖一瞥","slug":"glance-at-WestLake","date":"2020-03-09T12:11:20.000Z","updated":"2020-04-01T15:06:03.728Z","comments":true,"path":"2020/03/09/glance-at-WestLake/","link":"","permalink":"http://nilsli.com/2020/03/09/glance-at-WestLake/","excerpt":"","text":"逛次逛次的西湖今天过来平海路的Apple 直营店给电脑做大保健，顺便看了一眼西湖。 湖边景色依旧宜人，可惜游人寥寥。 期待一切顺利，然后恢复到游人如织的景色。","categories":[],"tags":[{"name":"休闲","slug":"休闲","permalink":"http://nilsli.com/tags/休闲/"},{"name":"杭州","slug":"杭州","permalink":"http://nilsli.com/tags/杭州/"},{"name":"西湖","slug":"西湖","permalink":"http://nilsli.com/tags/西湖/"},{"name":"Apple","slug":"Apple","permalink":"http://nilsli.com/tags/Apple/"}]},{"title":"方法的本质3_消息查找流程","slug":"wayOfCheckingMethod","date":"2020-03-06T08:33:26.000Z","updated":"2020-04-01T15:06:03.749Z","comments":true,"path":"2020/03/06/wayOfCheckingMethod/","link":"","permalink":"http://nilsli.com/2020/03/06/wayOfCheckingMethod/","excerpt":"","text":"本页所使用的objc runtime 756.2，来自GITHUB 1. 概念在前文中，已经总结了方法查找的流程，今天从代码层面上继续阐述。 isa 的指向图如下所示： 2. 方法查找流程2.1 从业务代码分析配置代码环境：，先从子类父类方法查找说起，先创建几个类，有: 父类 Person 继承自NSObject，有方法talk 子类 Student 继承自 Person，有方法 sayEnglish 扩展 NSObject + sayGerman，有方法 sayGerman 具体代码如下所示 主业务代码图： 由上图可以看出，我们生成的子类Student 对象，既可以执行自己的对象方法sayEnglish，也可以执行父类方法talk，当需要执行的方法——子类和父类都没有之后，也可以执行根类扩展方法sayGerman。 查找逻辑图可以初步理解为：子类——&gt; 父类——&gt; 父类的父类 ——&gt;根元类(NSObject) 类方法也是类似的，就不赘述 2.2 源码分析2.2.1 class_lookupMethodAndLoadCache3 - 慢速查找开启/*********************************************************************** * _class_lookupMethodAndLoadCache. * Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp(). * This lookup avoids optimistic cache scan because the dispatcher * already tried that. **********************************************************************/ IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls) { return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/); } 原来上文留下的class_lookupMethodAndLoadCache3 方法，最终执行的方法是lookUpImpOrForward，继续探究一下！ lookUpImpOrForward - 查找Imp 或转发消息乐观检查是否有缓存// Optimistic cache lookup if (cache) { imp = cache_getImp(cls, sel); if (imp) return imp; } 查找类是否缓存过 // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. runtimeLock.lock(); checkIsKnownClass(cls); 这里通过runtimeLock 锁住该部分内存，进行查找，执行了isKnownClass的方法，具体实现在这里 /*********************************************************************** * isKnownClass * Return true if the class is known to the runtime (located within the * shared cache, within the data segment of a loaded image, or has been * allocated with obj_allocateClassPair). **********************************************************************/ static bool isKnownClass(Class cls) { // The order of conditionals here is important for speed. We want to // put the most common cases first, but also the fastest cases // first. Checking the shared region is both fast and common. // Checking allocatedClasses is fast, but may not be common, // depending on what the program is doing. Checking if data segments // contain the address is slow, so do it last. return (sharedRegionContains(cls) || NXHashMember(allocatedClasses, cls) || dataSegmentsContain(cls)); } 在类的缓存（cache_t）找 // Try this class's cache. imp = cache_getImp(cls, sel); if (imp) goto done; 在类的方法列表里寻找 // Try this class's method lists. { Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) { log_and_fill_cache(cls, meth->imp, sel, inst, cls); imp = meth->imp; goto done; } } 在父类的缓存和方法列表寻找 // Try superclass caches and method lists. { unsigned attempts = unreasonableClassCount(); for (Class curClass = cls->superclass; curClass != nil; curClass = curClass->superclass) { // Halt if there is a cycle in the superclass chain. if (--attempts == 0) { _objc_fatal(\"Memory corruption in class list.\"); } 父类缓存（Cache）找 // Superclass cache. imp = cache_getImp(curClass, sel); if (imp) { if (imp != (IMP)_objc_msgForward_impcache) { // Found the method in a superclass. Cache it in this class. log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; } else { // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; } } 父类方法列表找 // Superclass method list. Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) { log_and_fill_cache(cls, meth->imp, sel, inst, curClass); imp = meth->imp; goto done; } 有可能内存覆盖，再给一次查找这里的核心方法是 // No implementation found. Try method resolver once. if (resolver &amp;&amp; !triedResolver) { runtimeLock.unlock(); resolveMethod(cls, sel, inst); runtimeLock.lock(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; } 父类也没有——查找失败——报错 // No implementation found, and method resolver didn't help. // Use forwarding. imp = (IMP)_objc_msgForward_impcache; 但是这个_objc_msgForward_impcache 的实现可不好找，在源码里只看到了这些： #if !OBJC_OLD_DISPATCH_PROTOTYPES extern void _objc_msgForward_impcache(void); 最终通过搜索查找_objc_msgForward_impcache，在汇编源码找到了类似的代码得到这个叫做__objc_forward_handler 的代码块，搜索得知它继承自objc_defaultForwardHandler， 继续查找，得到最终的源码如下： OH MY GOD! 原来这就是传说中——让程序员捶胸顿足的方法查找失败的代码 至此，方法查找的流程已经捋完。 3. 小结方法查找的流程，就是在类里查找缓存与方法列表里挖掘的过程。 如上文阐述： 方法查找：缓存查找 —— 类的方法列表 —— 父类的方法列表 （递归）—— 动态方法解析 —— 结束","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/类/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/结构/"},{"name":"objc","slug":"objc","permalink":"http://nilsli.com/tags/objc/"}]},{"title":"方法的本质2_从objc_msgSend谈起","slug":"startToLearnObjcSend","date":"2020-02-24T02:47:05.000Z","updated":"2020-04-01T15:06:03.745Z","comments":true,"path":"2020/02/24/startToLearnObjcSend/","link":"","permalink":"http://nilsli.com/2020/02/24/startToLearnObjcSend/","excerpt":"","text":"方法的本质，就是消息传递… 本页所使用的objc runtime 756.2，来自GITHUB 一、引子：Runtime概念我们都知道，在运行OC代码时，类或者对象在调用方法时会用到runtime，那么，到底什么是运行时呢？ 寻找一些资料后可以给出概念： In computer science, runtime, run time or execution time is the time when the CPU is executing the machine code.在计算机科学里，runtime，run time 或execution time 是指CPU 执行机器语言的期间。—— 维基百科 Runtime 是一套由C、C++、汇编混合写成的为OC提供运行时功能的api。 先看苹果开发者文档里对runtime 的介绍的介绍： The Objective-C runtime is a runtime library that provides support for the dynamic properties of the Objective-C language, and as such is linked to by all Objective-C apps. Objective-C runtime library support functions are implemented in the shared library found at /usr/lib/libobjc.A.dylib. OC runtime 是一个给OC语言动态属性提供支持的运行时库，这些属性链接到所有的OC应用 。OC runtime库支持在shared library里实现的函数，这些函数库名为/usr/lib/libobjc.A.dylib 版本 legacy：经典版 modern：现代版，即objc2.0，我们目前用到的版本。 二、方法的本质概念方法的本质，就是objc_msgSend 的消息传递。先看苹果开发者文档里对objc_msgSend的介绍： Function objc_msgSendSends a message with a simple return value to an instance of a class. 发送一个有简单返回值的消息给类的实例 相关源码如下: objc_msgSend(id _Nullable self, SEL _Nonnull op, ...) 其中两个关键参数self 和 op 的解释如下: * @param self A pointer to the instance of the class that is to receive the message. ​ self 一个指向由类生产的实例的指针，用来接收消息 * @param op The selector of the method that handles the message. ​ op 方法： 处理消息的方法的选择器 可见，objc_msgSend 的核心信息，就是向对象主体（self）传递相应的方法/消息（op）。 但是消息传递的机制到底怎样，还是用源码来解释。 源码分析开始生成一个main.m 内代码如下 int main(int argc, const char * argv[]) { @autoreleasepool { LGPerson *person = [LGPerson alloc]; [person sayHello]; // Setup code that might create autoreleased objects goes here. } return NSApplicationMain(argc, argv); } 其中LGPerson 的内部实现如下： @interface LGPerson : NSObject - (void)sayHello; - (void)sayNB; @end 在这里，着重查看LGPerson alloc 方法，以及其实例 person sayHello` 在汇编里的实现 : 进入到目录下，输入编译代码： clang -rewrite-objc main.m 得到main.cpp 的文件 打开main.cpp 结构如下: #pragma clang assume_nonnull end int main(int argc, const char * argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; LGPerson *person = ((LGPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"LGPerson\"), sel_registerName(\"alloc\")); ((void (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(\"sayHello\")); } return NSApplicationMain(argc, argv); } 上文代码中，可以简化为, Runtime 语法 OC 语法 (LGPerson ()(id, SEL))(void *) – (id)objc_getClass(“LGPerson”) [LGPerson class] sel_registerName(“alloc”) @selector(alloc) 即代码为： LGPerson *person = ((LGPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"LGPerson\"), sel_registerName(\"alloc\")); // 转换后 LGPerson *person = objc_msgSend([LGPerson class], @selector(alloc)); 解释为: 向LGPerson 的类，发送了alloc 方法 扩展代码实践开始设定一个类Student #import \"Student.h\" interface Student : Person - (void)sayCode; @end OC语法#import \"Student.h\" Student *student = [Student new]; [student sayCode]; NSObject 写法objc_msgSend(student, NSSelectorFromString(@\"sayCode\")); sel_registerName 的函数APIobjc_msgSend(student, sel_registerName(\"sayCode\")); 三、底层分析汇编源码 我们现在分析，当类对象发送消息是，底层发生了什么。 1、方法入口新建工程，输入如下代码，进行断点检测； 另外在Xcode 的Debug–Debug Workflow—Always show Disassembly 很明显，这里的Student sayCode 在汇编里，执行了 objc_msgSend 方法，继续查看 打开Xcode, 搜索objc_msgSend，找到相关结果如下： 由于研究的环境是移动平台，选择arm64，通过ENTRY _objc_msgSend结果进入 首先看到的代码如下： ENTRY _objc_msgSend UNWIND _objc_msgSend, NoFrame 1 cmp p0, #0 // nil check and tagged pointer check #if SUPPORT_TAGGED_POINTERS 2 b.le LNilOrTagged // (MSB tagged pointer looks negative) #else 3 b.eq LReturnZero #endif 2、类Tagged Pointer 检查代码解析： 序号 代码 解释 1 cmp p0 #0 cmp = compare检测0位寄存器 = 空？，以及tagged point 检测 2 b.le LNilOrTagged // 即1代码成立，跳转至LNilOrTagged的宏（下文叙述） 3 b.eq LReturnZero // b.eq 即不成立，结果为空，返回并跳出 这一小节，主要是用来判断 tagged pointer 是否存在，存在则继续进行，否则跳出。 Tagged point是苹果推出的针对64位机器的特定的指针，概念如下： 苹果对于Tagged Pointer特点的介绍： Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。 在内存读取上有着3倍的效率，创建时比以前快106倍。 3、加载isa这一部分主要是通过加载的isa，获取当前底层的类的实现 // person - isa - 类 ldr p13, [x0] // p13 = isa GetClassFromIsa_p16 p13 // p16 = class 序号 代码 解释 1 ldr p13, [x0] 将13位存储器isa 字，加载到0位寄存器LDR = LoaD woRd 2 GetClassFromIsa_p16 p13 通过加载的isa，宏逻辑获取到当前的类GetClassFromIsa_p16 是一个汇编宏 GetClassFromIsa_p16 的汇编实现如下: .macro GetClassFromIsa_p16 /* src */ #if SUPPORT_INDEXED_ISA // Indexed isa mov p16, $0 // optimistically set dst = src tbz p16, #ISA_INDEX_IS_NPI_BIT, 1f // done if not non-pointer isa // isa in p16 is indexed adrp x10, _objc_indexed_classes@PAGE add x10, x10, _objc_indexed_classes@PAGEOFF ubfx p16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS // extract index ldr p16, [x10, p16, UXTP #PTRSHIFT] // load class from array 1: #elif __LP64__ // 64-bit packed isa and p16, $0, #ISA_MASK #else // 32-bit raw isa mov p16, $0 #endif .endmacro 分析流程图如下： 4、用isa查询方法缓存当在3步，isa 拿到之后，现在要做的事情，就是对当前要执行的方法进行缓存查找。 LGetIsaDone: CacheLookup NORMAL // calls imp or objc_msgSend_uncached CacheLookup 在这里的做法是查询类里是否含有方法到缓存。 一般有两种结果：拿到缓存IMP，或者未曾缓存。 查询可以得到有三种查询方式: NORMAL 正常查找 GETIMP 获取IMP LOOKUP 慢速查询方法 根据源码，做了一些注释： 其中多次出现CheckMiss ,也是个汇编宏，使用在缓存查找失败后。 源码如下: .macro CheckMiss // miss if bucket->sel == 0 .if $0 == GETIMP cbz p9, LGetImpMiss .elseif $0 == NORMAL cbz p9, __objc_msgSend_uncached .elseif $0 == LOOKUP cbz p9, __objc_msgLookup_uncached .else .abort oops .endif .endmacro 根据查找的模式位NORMAL, 对应的*__objc_msgSend_uncached *。 在源码中搜索，得到相关逻辑如下： STATIC_ENTRY __objc_msgSend_uncached UNWIND __objc_msgSend_uncached, FrameWithNoSaves // THIS IS NOT A CALLABLE C FUNCTION // Out-of-band p16 is the class to search MethodTableLookup TailCallFunctionPointer x17 END_ENTRY __objc_msgSend_uncached 执行方法查找的核心方法，就是MethodTableLookup， 继续点开查看，得到的是 这里的内容，则是到objc_class 的 class_data_bits_t 里寻找方法的具体实现了，下一篇文章我们来讲。 四、小结这一篇，主要是开始从汇编的角度，来实现方法查找流程，流程草写了一下，图一定补。。。 拿到isa 查找Class 在Cache_t 查找bucket bucket 相同，返回IMP 否则 跳到BITS BITS 中 查找Rw 查找ro 查找methodList","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/类/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/结构/"},{"name":"objc","slug":"objc","permalink":"http://nilsli.com/tags/objc/"},{"name":"msgSend","slug":"msgSend","permalink":"http://nilsli.com/tags/msgSend/"}]},{"title":"方法的本质1--cache_t方法缓存分析","slug":"analyzeOfCacheT","date":"2020-01-20T17:18:38.000Z","updated":"2020-04-01T15:06:03.721Z","comments":true,"path":"2020/01/21/analyzeOfCacheT/","link":"","permalink":"http://nilsli.com/2020/01/21/analyzeOfCacheT/","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 1.概念1.1 objc_class 结构前面探索了类的结构，知道了类的结构本质上是objc_class的结构体，而在 C 源码例， objc_class 结构体的结构如下： struct objc_class : objc_object { // Class ISA; // 指向类的isa Class superclass; // 父类 cache_t cache; // 缓存的方法列表 // formerly cache pointer and vtable class_data_bits_t bits; // 缓存的属性和变量 // class_rw_t * plus custom rr/alloc flags 上一篇文章，具体分析了class_data_bits_t，那么上面的缓存cache_t 还没有展开学习，下面就继续进行讲解。","text":"本页所使用的objc runtime 756.2，来自GITHUB 1.概念1.1 objc_class 结构前面探索了类的结构，知道了类的结构本质上是objc_class的结构体，而在 C 源码例， objc_class 结构体的结构如下： struct objc_class : objc_object { // Class ISA; // 指向类的isa Class superclass; // 父类 cache_t cache; // 缓存的方法列表 // formerly cache pointer and vtable class_data_bits_t bits; // 缓存的属性和变量 // class_rw_t * plus custom rr/alloc flags 上一篇文章，具体分析了class_data_bits_t，那么上面的缓存cache_t 还没有展开学习，下面就继续进行讲解。 1.2 Cache_t 结构:cache_t 是objc_class 的重要组成属性，它主要用来存储方法。 struct cache_t { struct bucket_t *_buckets; // 缓存的方法列表 mask_t _mask; // 散列表的长度 mask_t _occupied; // 缓存过的方法数量 ****** } bucket 的定义 顾名思义是桶 ，装水的桶，装奥特曼的桶…… 在这里是一个hash表，计算公式是hash = sel 地址%mask，其中mask 是存放空间的大小，初始值是4。 通过源码查看，可以知道结构体如下： struct bucket_t { private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64. #if __arm64__ MethodCacheIMP _imp; // 方法实现 cache_key_t _key; // 方法编号 #else cache_key_t _key; MethodCacheIMP _imp; #endif 可以看到，这里缓存了MethodCacheIMP 方法，其中 MethodCacheIMP 是IMP的子类： MethodCacheIMP ——对于方法实现 cache_key_t ——对应方法缓存编号 2. 实现2.1方法缓存入口 入口引起我们注意的是如下这段代码: void cache_fill(Class cls, SEL sel, IMP imp, id receiver) { #if !DEBUG_TASK_THREADS mutex_locker_t lock(cacheUpdateLock); cache_fill_nolock(cls, sel, imp, receiver); #else _collecting_in_critical(); return; #endif } 代码解释： cache_fill 方法的缓存写入操作 cache_fill_nolock 线程解锁后的缓存写入 断言保护这里的方法cache_fill_nolock 就是我们的方法入口，为追求速度，执行的内容是无锁操作下的缓存填充，即对开辟的内存空间，进行方法写入，实现源码如下： static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver) { cacheUpdateLock.assertLocked(); // Never cache before +initialize is done if (!cls->isInitialized()) return; // Make sure the entry wasn't added to the cache by some other thread // before we grabbed the cacheUpdateLock. if (cache_getImp(cls, sel)) return; cache_t *cache = getCache(cls); cache_key_t key = getKey(sel); **** 代码解释： cacheUpdateLock.assertLocked() ：这里对内存区域锁定进行了跳出断言 if (!cls-&gt;isInitialized()) return; 对为初始化内存空间进行跳出断言 if (cache_getImp(cls, sel)) 对缓存空间已有该方法跳出断言 2.2 检查容量 在检查容量之前，cache_t 做了两个操作： 将类的引用地址转化成了cache 结构体: cache_t *cache = getCache(cls) 将方法编号sel 转换成了整型，方便寻址 cache_key_t key = getKey(sel) 容量为空检测 将方法缓存时，先确定是否为空对缓存。这里使用了 if (cache->isConstantEmptyCache()) { // Cache is read-only. Replace it. cache->reallocate(capacity, capacity ?: INIT_CACHE_SIZE); } 来判断空间是否为空，isConstantEmptyCache这个函数更详细的操作如下： return occupied() == 0 &amp;&amp; buckets() == emptyBucketsForCapacity(capacity(), false); 即occupied占位为空，而且容器桶 也无法从其他堆中空间共享空间，就必须重新开辟新的空间，开辟空间操作见 2.3。 扩容的条件： 扩容条件的操作为将当前容量 occupied + 1, 然后检查是否达到 3/4，超过则需要扩容；否则不需要扩容，直接进行缓存的写入，下面的代码足够明了的解释； // Use the cache as-is if it is less than 3/4 full mask_t newOccupied = cache->occupied() + 1; mask_t capacity = cache->capacity(); if (cache->isConstantEmptyCache()) { // Cache is read-only. Replace it. cache->reallocate(capacity, capacity ?: INIT_CACHE_SIZE); } else if (newOccupied &lt;= capacity / 4 * 3) { // Cache is less than 3/4 full. Use it as-is. } else { // Cache is too full. Expand it. cache->expand(); } 代码详解： mask_t newOccupied = cache-&gt;occupied() + 1 mask_t capacity = cache-&gt;capacity(); if (newOccupied &lt;= capacity / 4 * 3) 这里的 newOccupied 是当前的占用容量+1, 与目前的总容量 capacity 的 3/4 来做比较，这里使用占位+1 后来做比较，目的是提前准备，防止内存溢出。 2.3 内存扩容2.3.1 空间计算 扩容方法： 判断当前容量是否为空，若为空，就给初始化的内存为为4； 如果之前就有空间，则加倍。 void cache_t::expand() { cacheUpdateLock.assertLocked(); uint32_t oldCapacity = capacity(); uint32_t newCapacity = oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE; if ((uint32_t)(mask_t)newCapacity != newCapacity) { // mask overflow - can't grow further // fixme this wastes one bit of mask newCapacity = oldCapacity; } reallocate(oldCapacity, newCapacity); } 代码详解： oldCapacity 定义了当前的容量 如果 oldCapacity 为空，则立刻开辟大小为4 的空间。 否则，给当前空间加倍，即 oldCapacity*2，并在新空间内进行缓存空间开辟 reallocate。 2.3.2 新建容器reallocate新开内存空间的操作步骤： 确定是否可以释放旧空间 将开辟的空间和内存方法绑定，并将mask 和占位值occupied 归零。 void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity) { bool freeOld = canBeFreed(); bucket_t *oldBuckets = buckets(); bucket_t *newBuckets = allocateBuckets(newCapacity); // Cache's old contents are not propagated. // This is thought to save cache memory at the cost of extra cache fills. // fixme re-measure this assert(newCapacity > 0); assert((uintptr_t)(mask_t)(newCapacity-1) == newCapacity-1); setBucketsAndMask(newBuckets, newCapacity - 1); if (freeOld) { cache_collect_free(oldBuckets, oldCapacity); cache_collect(false); } } 代码讲解： bool freeOld = canBeFreed() 决定了是否可以释放旧内存。 bool cache_t::canBeFreed() { return !isConstantEmptyCache(); } 这里的canBeFreed依赖于isConstantEmptyCache的取反，即需要之前方法缓存有占位，并且旧bucket 本身容量不为空。 即以下源码里返回为空： bool cache_t::isConstantEmptyCache() { return occupied() == 0 &amp;&amp; buckets() == emptyBucketsForCapacity(capacity(), false); } 需要 occupied == 1, 以及 buckets() != emptyBucketsForCapacity(capacity(), false) setBucketsAndMask 用来初始化 新的bucket 和 occupied newCapacity - 1 更新索引，用来查询散列表里的元素。 cache_collect_free 用来释放旧容量（oldCapacity）下的旧方法数据（oldBuckets） 2.4 缓存写入2.4.1 查找缓存通过 cache-&gt;find 查找对应的缓存，如果没有找到，就添加新缓存，在这之前将占位occupied 添加1 ，实现源码如下： static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver) { *** // 找到对应的 bucket bucket_t *bucket = cache->find(key, receiver); if (bucket->key() == 0) cache->incrementOccupied(); bucket->set(key, imp); } void cache_t::incrementOccupied() { _occupied++; // 占位增加 } 2.4.2 未扩容过找到之前的bucket，按照编号和方法，写入缓存: bucket_t *bucket = cache->find(key, receiver); bucket->set(key, imp); 2.4.3 缓存写入实现void bucket_t::set(cache_key_t newKey, IMP newImp) { assert(_key == 0 || _key == newKey); // objc_msgSend uses key and imp with no locks. // It is safe for objc_msgSend to see new imp but NULL key // (It will get a cache miss but not dispatch to the wrong place.) // It is unsafe for objc_msgSend to see old imp and new key. // Therefore we write new imp, wait a lot, then write new key. _imp = newImp; if (_key != newKey) { mega_barrier(); _key = newKey; } } 代码详解： 注释中写明了： objc_msgSend 在无锁环境下使用key 和 imp 实现。 objc_msgSend 查看到新的imp 实现是安全的，除了空的key地址外。（可能会造成小的缓存丢失，但是并不会分发到错误的空间） objc_msgSend 旧的imp 和新的key 是不安全的，因此我们先写新imp，等一会儿，再写新的 key 代码中的 mega_barrier 就是 使用了阻塞，让方法先看到imp ，保证线程的安全。 3. 总结3.1 梳理cache_t 起源于 OC中的方法传递，也就是objc_msgSend 的实现。在类的方法传递时，为了追求，先去cache_t 中查找是否有缓存，如果有，可以直接调用，如果没有缓存，则需要对类进行一系列的内存空间确认，进行imp - key 的写入，并进行最终调用。 这一章节应该是目前分析最难的，花了大概三到四天弄明白，希望这艰难的一步能为以后的分析打好更好的基础。 3.2 流程图","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/类/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/结构/"},{"name":"cache_t","slug":"cache-t","permalink":"http://nilsli.com/tags/cache-t/"}]},{"title":"OC底层研究4--类的结构分析","slug":"StructOfClass","date":"2020-01-12T06:00:53.000Z","updated":"2020-04-01T15:06:03.706Z","comments":true,"path":"2020/01/12/StructOfClass/","link":"","permalink":"http://nilsli.com/2020/01/12/StructOfClass/","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 1.概念1.1 类Class 的类型 Class在源码里的真正类型为objc_class的结构体。 先查看源码——在Xcode按下Shift+Command+O，选择objc-runtime-new.h，搜索objc_class，可以得知，Class底层编译实现的前4行如下： 可知类结构如下： A. //Class ISA ​ 继承自父类 objc_class 的 isa ，指向类的指针不需显示（内存占8位），这里它返回一个nonpointer的指针，相关源码如下： /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; B. Class superclass; ​ 指向本类的父类（内存占8位） C. cache_t cache; ​ 存储指针和vtable，加速方法调用（内存占8位） D. class_data_bits_t bits; ​ 存储类的方法、属性、遵循的协议等信息的地方（内存占8位） E. 其他方法/函数 – 不占内存 为何cache_t cache 这个变量占位位16，而不是8？ 原因是因为这里的cache_t是结构体，其占内存为根据内部属性结构而定，为防止溢出，给予16位字节，而不是指针所需的8位。 Talk is cheap, show me the code, 伸伸手指，点开cache_t 的内部结构","text":"本页所使用的objc runtime 756.2，来自GITHUB 1.概念1.1 类Class 的类型 Class在源码里的真正类型为objc_class的结构体。 先查看源码——在Xcode按下Shift+Command+O，选择objc-runtime-new.h，搜索objc_class，可以得知，Class底层编译实现的前4行如下： 可知类结构如下： A. //Class ISA ​ 继承自父类 objc_class 的 isa ，指向类的指针不需显示（内存占8位），这里它返回一个nonpointer的指针，相关源码如下： /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; B. Class superclass; ​ 指向本类的父类（内存占8位） C. cache_t cache; ​ 存储指针和vtable，加速方法调用（内存占8位） D. class_data_bits_t bits; ​ 存储类的方法、属性、遵循的协议等信息的地方（内存占8位） E. 其他方法/函数 – 不占内存 为何cache_t cache 这个变量占位位16，而不是8？ 原因是因为这里的cache_t是结构体，其占内存为根据内部属性结构而定，为防止溢出，给予16位字节，而不是指针所需的8位。 Talk is cheap, show me the code, 伸伸手指，点开cache_t 的内部结构 我们来看看属性： bucket_t， 结构体，占8位字节 mask_t，点开后具体实现为如下： typedef uint32_t mask_t; ​ 为整型，占4个字节 mask_t typedef uint32_t mask_t; ​ 也是整形，占4个字节 共计8+4+4 = 16个字节 1.2 objc_class继承在底层实现里，objc_class 继承自objc_object 的结构体 /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; 1.3 关于NSobject 万物皆对象 - Class 继承自NSObject @interface NSObject &lt;NSObject> { #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY; #pragma clang diagnostic pop } 2. 类的属性与成员变量 属性的存储上面提到了类对象的结构原理，我们知道了类结构里，类型位class_data_bits_t 的bits下面我们来探寻一下，类里面的属性上怎么保存的。 我们在代码里生成一个类，分别有成员变量hobby，以及属性nickName 代码如下: @interface Person : NSObject{ NSString *hobby; } @property (nonatomic, copy) NSString *nickName; 在主线代码引入: int main(int argc, const char * argv[]) { @autoreleasepool { LGPerson *person = [LGPerson alloc]; Class pClass = object_getClass(person); NSLog(@\"%@ -- %p\", person, pClass); } return 0; } 然后打印得到的类pClass，通过x/4gx 获取类结构如下： (lldb) x/4gx pClass 0x1000023d0: 0x001d8001000023a9 0x0000000100b37140 0x1000023e0: 0x00000001003da280 0x0000000000000000 观察结果得知0x1000023d0 位pClass在内存中的首地址，根据内存偏移原则，加上16+8+8共32位，即可得到bits的结构。 0x1000023d0，偏移32位，得到0x1000023f0。注意，这里要用p打印指针，而非打印值用的po (lldb) p 0x1000023f0 4294976496 oh NO！得到的是具体的值，这里需要强转一下： (lldb) p (class_data_bits_t *)0x1000023f0 (class_data_bits_t *) $3 = 0x00000001000023f0 得到$3 的值，并不是我们想要的结构，留意到objc_class里的方法 data() 方法: struct objc_class : objc_object { // Class ISA; // 8 Class superclass; // 8 cache_t cache; // 16 不是8 // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } data() 返回是class_rw_t，点进去看看， struct class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName; 留意到里面有 methods、properties、protocols等，原来这里等值便是类的相关属性方法等等结构。 现在对$3 执行data() 方法: (lldb) p $3->data() (class_rw_t *) $5 = 0x0000000000000000 对得到的$5 进行值打印: (lldb) p *$5 (class_rw_t) $5 = { flags = 2148139008 version = 0 ro = 0x0000000100002308 methods = { list_array_tt&lt;method_t, method_list_t> = { = { list = 0x0000000100002240 arrayAndFlag = 4294976064 } } } properties = { list_array_tt&lt;property_t, property_list_t> = { = { list = 0x00000001000022f0 arrayAndFlag = 4294976240 } } } protocols = { list_array_tt&lt;unsigned long, protocol_list_t> = { = { list = 0x0000000000000000 arrayAndFlag = 0 } } } firstSubclass = nil nextSiblingClass = NSUUID demangledName = 0x0000000000000000 } 如上所示，$5 内结构一目了然，方法，属性，协议都显示了。 继续获取属性值: (lldb) p $5.properties (property_array_t) $7 = { list_array_tt&lt;property_t, property_list_t> = { = { list = 0x00000001000022f0 arrayAndFlag = 4294976240 } } } 得到一个二维数组的$7，观察属性列表的类型为property_array_t，继承自list_array_tt，内部拥有 (lldb) p $7.list (property_list_t *) $8 = 0x00000001000022f0 再次对$8 进行* 取值，得到如下结果： (lldb) p *$8 (property_list_t) $9 = { entsize_list_tt&lt;property_t, property_list_t, 0> = { entsizeAndFlags = 16 count = 1 first = (name = \"nickName\", attributes = \"T@\\\"NSString\\\",C,N,V_nickName\") } } 从结果可以看出，我们的属性，就保存在properties 里中。 成员变量的存储上面分析了属性的存储，但是我们没有看到成员变量 hobby,我们在properties 属性里，没有看到它，到底在哪里呢?下面我们继续查找。 既然不在properties 里，那尝试一下在$5 的 ro 里进行取值 (lldb) p $5.ro (const class_ro_t *) $10 = 0x0000000100002308 得到class_ro_t 类型的结构体，继续对他取值 (lldb) p *$10 (const class_ro_t) $11 = { flags = 388 instanceStart = 8 instanceSize = 24 reserved = 0 ivarLayout = 0x0000000100001f8a \"\\x02\" name = 0x0000000100001f81 \"LGPerson\" baseMethodList = 0x0000000100002240 baseProtocols = 0x0000000000000000 ivars = 0x00000001000022a8 weakIvarLayout = 0x0000000000000000 baseProperties = 0x00000001000022f0 } 值这里可以看到ivars，就是我们需要的变量列表，打印一下： (lldb) p $11.ivars (const ivar_list_t *const) $12 = 0x00000001000022a8 继续对 ivar_list_t 类型的$12 取值: (lldb) p *$12 (const ivar_list_t) $13 = { entsize_list_tt&lt;ivar_t, ivar_list_t, 0> = { entsizeAndFlags = 32 count = 2 first = { offset = 0x0000000100002378 name = 0x0000000100001e64 \"hobby\" type = 0x0000000100001fa7 \"@\\\"NSString\\\"\" alignment_raw = 3 size = 8 } } } (lldb) p $.first (const ivar_t) $13 = { offset = 0x0000000100002378 name = 0x0000000100001e64 \"hobby\" type = 0x0000000100001fa7 \"@\\\"NSString\\\"\" alignment_raw = 3 size = 8 } 可以看到成员变量存在类的 ivars 属性里 3. 类的方法3.1 类的实例方法我们继续对类进行代码编辑，对Person类添加实例方法和类方法 - (void)sayHello; // 实例方法 + (void)sayHappy; // 类方法 还是对类结构$5 进行解析，这次我们打印它的 methods 属性 (lldb) p $5.methods (method_array_t) $14 = { list_array_tt&lt;method_t, method_list_t> = { = { list = 0x0000000100002240 arrayAndFlag = 4294976064 } } } 得到的是method_array_t 类型的$14, 是个数组类型，继续打印: (lldb) p $14.list (method_list_t *) $15 = 0x0000000100002240 (lldb) p *$15 (method_list_t) $16 = { entsize_list_tt&lt;method_t, method_list_t, 3> = { entsizeAndFlags = 26 count = 4 first = { name = \"sayHello\" types = 0x0000000100001f8c \"v16@0:8\" imp = 0x0000000100001b90 (LGTest`-[LGPerson sayHello] at LGPerson.m:13) } } } 可见，实例方法sayHello 方法，存储在类的methods属性里 3.2 类的类方法存储类方法在上述的过程中没有看到，那么它会在哪里呢? 为了找到它，我们重新回到最初的pClass (lldb) x/4gx pClass 0x1000023b0: 0x001d800100002389 0x0000000100b37140 0x1000023c0: 0x00000001003da280 0x0000000000000000 得到isa值为0x001d800100002389，这时，唤出它的掩码 ISA_MASK 来获取它的元类 (lldb) p/x 0x001d800100002389 &amp; 0x0000000ffffffff8 (long) $1 = 0x0000000100002388 继续对元类$1的结构进行解析： (lldb) x/4gx 0x0000000100002388 0x100002388: 0x001d800100b370f1 0x0000000100b370f0 0x100002398: 0x0000000100f946c0 0x0000000100000003 可知0x100002388是这个元类的地址，根据上文提到的内存便宜，我们继续加上2个16进制位，得到0x1000023a8，p一下： (lldb) p (class_data_bits_t *)$2 (class_data_bits_t *) $3 = 0x00000001000023a8 继续执行上文实例方法类似的方案，执行data() — 取值 – 获取methods 的思路，具体代码如下： (lldb) p $3->data() (class_rw_t *) $4 = 0x0000000100f94620 (lldb) p *$4 (class_rw_t) $5 = { flags = 2685075456 version = 7 ro = 0x00000001000021f8 methods = { list_array_tt&lt;method_t, method_list_t> = { = { list = 0x00000001000021d8 arrayAndFlag = 4294975960 } } } properties = { list_array_tt&lt;property_t, property_list_t> = { = { list = 0x0000000000000000 arrayAndFlag = 0 } } } protocols = { list_array_tt&lt;unsigned long, protocol_list_t> = { = { list = 0x0000000000000000 arrayAndFlag = 0 } } } firstSubclass = nil nextSiblingClass = 0x00007fff942e6990 demangledName = 0x0000000000000000 } (lldb) p $5.methods (method_array_t) $10 = { list_array_tt&lt;method_t, method_list_t> = { = { list = 0x00000001000021d8 arrayAndFlag = 4294975960 } } } (lldb) p $10.list (method_list_t *) $11 = 0x00000001000021d8 (lldb) p *$11 (method_list_t) $12 = { entsize_list_tt&lt;method_t, method_list_t, 3> = { entsizeAndFlags = 26 count = 1 first = { name = \"sayHappy\" types = 0x0000000100001f8c \"v16@0:8\" imp = 0x0000000100001bc0 (LGTest`+[LGPerson sayHappy] at LGPerson.m:17) } } } (lldb) 可见，类方法sayHappy 方法，存储在类的元类 methods属性里 4. 总结 类的本质上一个类型为objc_class的结构体，包含有isa、父类、属性、成员变量及方法列表等 类属性存在结构体的properties里 类的成员变量存在结构体的 ivars里 类的实例方法，存在结构体 的methods 属性里 类的类方法，存在父类的class_ro_t 里的methods里 如下图示：","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/类/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/结构/"}]},{"title":"2020新年感想","slug":"newyearnote","date":"2020-01-01T16:39:53.000Z","updated":"2020-04-01T15:06:03.735Z","comments":true,"path":"2020/01/02/newyearnote/","link":"","permalink":"http://nilsli.com/2020/01/02/newyearnote/","excerpt":"","text":"2020年是一个闰年，第一天从星期三开始。 今天看了小羊肖恩大电影，故事讲得真好看，小朋友全程开心，全情投入，大朋友也觉得耳目一新，深受感动。 这是我们带他看的第一部电影，新的一年，从第一开始。 用一句涂鸦来鼓舞自己 宁愿最后徒劳无功， 也不选择无动于衷。 希望今年也有始有终，有所收获。","categories":[],"tags":[{"name":"2020","slug":"2020","permalink":"http://nilsli.com/tags/2020/"},{"name":"感想","slug":"感想","permalink":"http://nilsli.com/tags/感想/"}]},{"title":"OC底层研究3--isa的初始化和指向分析","slug":"initialOfIsaNDirection","date":"2019-12-27T07:05:19.000Z","updated":"2020-04-01T15:06:03.728Z","comments":true,"path":"2019/12/27/initialOfIsaNDirection/","link":"","permalink":"http://nilsli.com/2019/12/27/initialOfIsaNDirection/","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 开始继续学习研究OC源码，这次研究的是isa的初始化和指向分析。 1. 概念什么是isa看看苹果文档的介绍： isa A Pointer to the class definition of which this object is an instance. isa ： 一个指向该对象的类的指针。 打开Xcode，找到objc.h，我们可以看看到如下代码 #if !OBJC_TYPES_DEFINED /// An opaque type that represents an Objective-C class. /// 一个展示OC类的未知的类型 typedef struct objc_class *Class; /// Represents an instance of a class. /// 展示一个类的实例 struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. /// 一个指向类的实例的指针 typedef struct objc_object *id; #endif 可以看出，Class 是一个objc_class 类型的结构体。 而id类型，则是objc_object 类型的结构体.","text":"本页所使用的objc runtime 756.2，来自GITHUB 开始继续学习研究OC源码，这次研究的是isa的初始化和指向分析。 1. 概念什么是isa看看苹果文档的介绍： isa A Pointer to the class definition of which this object is an instance. isa ： 一个指向该对象的类的指针。 打开Xcode，找到objc.h，我们可以看看到如下代码 #if !OBJC_TYPES_DEFINED /// An opaque type that represents an Objective-C class. /// 一个展示OC类的未知的类型 typedef struct objc_class *Class; /// Represents an instance of a class. /// 展示一个类的实例 struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. /// 一个指向类的实例的指针 typedef struct objc_object *id; #endif 可以看出，Class 是一个objc_class 类型的结构体。 而id类型，则是objc_object 类型的结构体. 2. isa 的初始化在此之前，先回顾一下对象初始化的流程图 在这里，初始化实例的isa，其中 cls 为初始化的类对象，hasCxxDtor 即为是否含有C++的析构器。 我们进入 initIsa(cls, true, hasCxxDtor) 这个函数，看看内部实现了什么 2.1 isa非nonpointerif (!nonpointer) { isa.cls = cls; } nonpointer概念: 表示是否对isa 指针开启指针优化 ​ 0: 纯isa指针 ​ 1: 不止是类对象的地址，还包含类信息、对象的引用计数等。 此时，如果为纯isa指针，将当前类 cls 赋值给 isa 的绑定属性 cls 为什么有这个绑定属性，而isa究竟是什么看结构呢？ 点击isa.cls = cls;中的cls查看它的结构，如下： union isa_t { isa_t() { } // isa 初始化方法 isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; #if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // defined in isa.h }; #endif }; 可以看见isa 是一个 union，联合体，里面包含了 isa_t 初始化方法 isa_t(uintptr_t value) 工厂方法 Class cls 绑定属性 结构体ISA_BITFIELD位域 ISA_BITFIELD概念 我们点开类型为struct的ISA_BITFIELD，结构如下： # if __arm64__ # define ISA_MASK 0x0000000ffffffff8ULL # define ISA_MAGIC_MASK 0x000003f000000001ULL # define ISA_MAGIC_VALUE 0x000001a000000001ULL # define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19 # define RC_ONE (1ULL&lt;&lt;45) # define RC_HALF (1ULL&lt;&lt;18) NONPOINTER_ISA效果图（手绘中，待补全……） 还原isa_t 的结构 我们这时发现，isa的整体结构可以替换为如下的样子: union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; #if defined(ISA_BITFIELD) struct { uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19; // ISA_BITFIELD; // defined in isa.h }; #endif }; nonpointer: 表示是否对 isa 指针开启指针优化 0:纯isa指针，1:不止是类对象地址,isa 中包含了类信息、对象的引用计数等（占1位） has_assoc: 关联对象标志位，0没有，1存在（占1位） has_cxx_dtor: 该对象是否有 C++ 或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更快的释放对象（占1位） shiftcls:存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位用来存储类指针。（占33位） magic:用于调试器判断当前对象是真的对象还是没有初始化的空间 weakly_referenced:志对象是否被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放。（占6位） deallocating:标志对象是否正在释放内存（占1位） has_sidetable_rc:当对象引用计数大于 10 时，则需要借用该变量存储进位（占1位） extra_rc:当表示该对象的引用计数值，实际上是引用计数值减 1， 例如，如果对象的引用计数为 10，那么 extra_rc 为 9。如果引用计数大于 10， 则需要使用到下面的 has_sidetable_rc。（占1位） 2.2 isa是nonpointer类型 isa_t newisa(0); #if SUPPORT_INDEXED_ISA assert(cls->classArrayIndex() > 0); newisa.bits = ISA_INDEX_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls->classArrayIndex(); #else newisa.bits = ISA_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls >> 3; #endif 生成新的isa: isa_t newisa(0); c++ 析构器： newisa.has_cxx_dtor = hasCxxDtor;` 表示当前对象是否有C++的析构函数（destructor）,如果没有，释放时会快速的释放内存。 位域赋值 newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;对存储指针的值进行右移动3位赋值。 返回isa isa = newisa; 3. isa 的指向3.1 指向图：关于isa的指向以及子类父类的关系，苹果官方给出了一张图如下所示： 3.2 代码分析3.2.1 对象的isa我们执行一项代码如下，并对该行打断点： Person *object = [Person alloc]; 我们知道：对象里的 isa ——指向——&gt; 类。 3.2.2类的isa现在我们想知道类的内存空间结构，在控制台执行如下指令x/4gx Person.class，结果如下： (lldb) x/4gx Person.class 0x100001130: 0x001d800100001109 0x0000000100b39140 0x100001140: 0x0000000101a46ed0 0x0000000200000007 由于isa是类对象的第一个属性，我们知道0x001d800100001109是改对象的isa，我们看看他指向哪里呢，使用p/x 指令试试: (lldb) p/x 0x001d800100001109 (long) $16 = 0x001d800100001109 糟糕，查看不到结果？怎么回事？类的isa 格式需要强转，可以退一步，打印类的地址试试： po 0x100001130 Person 原来如此，在内存空间里，名为Person的类的第一个位置，指向Person类，岂不是循环指向了？ 非也非也，这里指向的类，我们把它称为元类（meta-class） 类的isa ——指向——&gt; 元类 3.2.3 元类的isa我们现在获得元类的具体地址，找到isa 的MASK（掩码），值为0x00007ffffffffff8， 输入以下指令： (lldb) p/x 0x001d800100001109 &amp; 0x00007ffffffffff8 (long) $17 = 0x0000000100001108 (lldb) po 0x0000000100001108 Person 得到元类地址为：0x0000000100001108，16进制打印一下： (lldb) x/4gx 0x0000000100001108 0x100001108: 0x001d800100b390f1 0x0000000100b390f0 0x100001118: 0x0000000100f5a480 0x0000000400000007 可以看到元类结构里，isa指针为 0x001d800100b390f1，继续获取它的指向，我们通过与掩码来计算： (lldb) p/x 0x001d800100b390f1 &amp; 0x00007ffffffffff8 (long) $21 = 0x0000000100b390f0 好嘞，拿到内存指针地址为0x0000000100b390f0， 打印一下： po 0x0000000100b390f0 NSObject 至此，我们可以看到元类的isa指向它的上一级元类，也就是跟元类(root meta-class)，为NSObject。 所以得出: 元类的isa ——指向——&gt; 根元类 3.2.4 根元类的isa我们打印下根元类结构： x/4gx 0x0000000100b390f0 0x100b390f0: 0x001d800100b390f1 0x0000000100b39140 0x100b39100: 0x0000000101a47020 0x0000000500000007 拿到它的isa，与掩码继续进行与运算 p/x 0x001d800100b390f1 &amp; 0x00007ffffffffff8 (long) $27 = 0x0000000100b390f0 得到的结果0x0000000100b390f0，与根元类0x0000000100b390f0，完全吻合。 至此，我们得出结论：根元类的isa ——指向——&gt; 根类NSObject。 什么？你不信，这些都是猜测，证实一下？ 好的，创建如下代码 void TestNSObject(){ // NSObject实例对象 NSObject *object1 = [NSObject alloc]; // NSObject类 Class class = object_getClass(object1); // NSObject元类 Class metaClass = object_getClass(class); // NSObject根元类 Class rootMetaClass = object_getClass(metaClass); // NSObject根根元类 Class rootRootMetaClass = object_getClass(rootMetaClass); NSLog(@\"\\n%p 实例对象\\n%p 类\\n%p 元类\\n%p 根元类\\n%p 根根元类\",object1,class,metaClass,rootMetaClass,rootRootMetaClass); } 打印结果如下： 0x10066ddc0 实例对象 0x7fff9294a118 类 0x7fff9294a0f0 元类 0x7fff9294a0f0 根元类 0x7fff9294a0f0 根根元类 可见，除了NSObject 类是独有的创建，其他元类、根元类、根根元类，都是一样的，因为都是NSObject，所以结果得到了证明。 3.3 总结：我们再回到这幅图，最红是这样的： isa指向： 对象中的isa——&gt; 类 类中的isa ——&gt; 元类 元类中的isa —-&gt; 根元类 根元类中的isa —-&gt; 根元类 类继承关系： 子类 ———superClass——— 父类 父类 ———superClass——— 根元类 根元类 ———superClass——— NSObject NSObject ———superClass——— nil","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"对齐","slug":"对齐","permalink":"http://nilsli.com/tags/对齐/"},{"name":"内存","slug":"内存","permalink":"http://nilsli.com/tags/内存/"}]},{"title":"OC底层研究2--内存对齐原理","slug":"memoryAlignPrinciple","date":"2019-12-22T03:05:11.000Z","updated":"2020-04-01T15:06:03.734Z","comments":true,"path":"2019/12/22/memoryAlignPrinciple/","link":"","permalink":"http://nilsli.com/2019/12/22/memoryAlignPrinciple/","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 开始继续学习研究OC源码，今天看的是OC的内存原理，以及对齐原理的分析。 1.概念内存对齐在数据结构中，是比较基础也比较重要的一环，对于iOS开发，研究底层更免不了要了解他们的原理，方便我们更透彻的学习iOS的原理。 我们先来一段维基百科的数据结构对齐的相关知识。 内存对齐，也可以理解为数据结构对齐（Data structure alignment），是代码编译后在内存的布局与使用方式。包括三方面内容：数据对齐、数据结构填充（padding）与包入（packing）。 下图是内存中各类型属性所占的空间大小：","text":"本页所使用的objc runtime 756.2，来自GITHUB 开始继续学习研究OC源码，今天看的是OC的内存原理，以及对齐原理的分析。 1.概念内存对齐在数据结构中，是比较基础也比较重要的一环，对于iOS开发，研究底层更免不了要了解他们的原理，方便我们更透彻的学习iOS的原理。 我们先来一段维基百科的数据结构对齐的相关知识。 内存对齐，也可以理解为数据结构对齐（Data structure alignment），是代码编译后在内存的布局与使用方式。包括三方面内容：数据对齐、数据结构填充（padding）与包入（packing）。 下图是内存中各类型属性所占的空间大小： 列举一下各数据类型所占字节（32位）： A char (one byte) will be 1-byte aligned. A short (two bytes) will be 2-byte aligned. An int (four bytes) will be 4-byte aligned. A long (four bytes) will be 4-byte aligned. A float (four bytes) will be 4-byte aligned. A double (eight bytes) will be 8-byte aligned on Windows and 4-byte aligned on Linux (8-byte with -malign-double compile time option). A long long (eight bytes) will be 4-byte aligned. A long double (ten bytes with C++Builder and DMC, eight bytes with Visual C++, twelve bytes with GCC) will be 8-byte aligned with C++Builder, 2-byte aligned with DMC, 8-byte aligned with Visual C++, and 4-byte aligned with GCC. Any pointer (four bytes) will be 4-byte aligned. (e.g.: char, int) 需要注意的是，在64位机上，有以下不同 A long (eight bytes) will be 8-byte aligned. A double (eight bytes) will be 8-byte aligned. A long long (eight bytes) will be 8-byte aligned. A long double (eight bytes with Visual C++, sixteen bytes with GCC) will be 8-byte aligned with Visual C++ and 16-byte aligned with GCC. Any pointer (eight bytes) will be 8-byte aligned. 2. 原则 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在32位机为４字节,则要从４的整数倍地址开始存储。 结构体作为成员: 如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.) 收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐. 3. 实践3.1 属性8字节对齐：当创建对象时，其属性的按类型占据不同的内存空间，但是由于大小不一，需要进行补齐；原则则是以第一位补齐为8的倍数（64位系统是8为对齐，而32位系统是4位对齐）。 以下面的代码举例子 struct MyStruct { double a; char b; // 第2行 char 在前 int 在后 int c; short d; } MyStr1; struct MyStruct2 { double a; int c; // 第2行 int 在前 char 在后 char b; short d; } MyStr2; // 我们打印一下各自的所占空间 NSLog(@\"%lu -- %lu\",sizeof(MyStr1), sizeof(MyStr2)); 结果如下: 为何两者不一致? 我们来看第一个结构体对象的内部结构，排第一的属性double占8位，而char需要补齐7位成为8位，而剩余的int，short 则分别占4位，不需补齐，可以灵活堆在同一个内存区域。 struct MyStruct { double a; // 8位 char b; // 1位 + 7 补齐 = 8 int c; // 4位 short d; // 4位 } MyStr1; 总计是 8 + 8 + 4 + 4 = 24； 而第二个结构体对象，排第一的属性double占8位，而剩余的int，short ，short 总计都，不需补齐，可以灵活堆在同一个内存区域。 struct MyStruct2 { double a; // 8 int c; // 4 char b; // 1 补齐1位 short d; // 2 } MyStr2; 这里后3位，可以放到一个8位内存区间，即4 + 1 + 2，只需补齐1位至8位，可以灵活排列在一个内存空间内，所以本结构体对象总占内存为8+4+1+2 + 1（补齐1位） = 16。 如果没有弄懂，我们找出源码来读一读：(/objc/Private Headers/Project Headers/objc-os.h) 创建对象 alloc alloc方法的实现——返回rootAlloc方法 返回callAlloc的实现 当缓存区没有对象时，创建对象 去内存区域创建对象 执行类的属性方法，确定创建的空间大小 对齐内存 内存对齐的返回：类的属性大小取决于指针大小 8字节对齐：实现方法 3.2 对象16字节对齐在OC 底层研究1–alloc和init原理 我们分析过，iOS环境下，为了容错处理，创建。 在 libmalloc/src/nano_malloc.c 第193行，我们发现如下的代码: 而其中NANO_REGIME_QUANTA_SIZE 为16， SHIFT_NANO_QUANTUM 为4 那可以开始分析源码如下： if (0 == size) { size = NANO_REGIME_QUANTA_SIZE; // Historical behavior } 这里的意思是，如果size为0，即创建空对象，返回16位默认空间。 而 k = (size + NANO_REGIME_QUANTA_SIZE - 1) >> SHIFT_NANO_QUANTUM 是向右移动4位，即16字节对齐，那究竟是怎么实现的，我们不妨来看下，假定给定申请的内存size 为40，那么 40(size) + 16 - 1 = 55 0011 0111 // 55 的2进制显示 0000 0011 // >> 右移动4位 == 3 0011 0000 // 执行 slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; 左移动4位 slot_bytes = 48(0011 0000) er, 第205行中返回的slot_bytes 即是最终对齐后的内存空间位，即给入40，最终系统对齐后，返回48位(16的整数位)。 4 结论在iOS环境下，我们创建的对象和指针遵循16位对齐的原则，而其属性位8字节对齐。","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"对齐","slug":"对齐","permalink":"http://nilsli.com/tags/对齐/"},{"name":"内存","slug":"内存","permalink":"http://nilsli.com/tags/内存/"}]},{"title":"OC 底层研究1--alloc和init原理","slug":"pricipleofalloc","date":"2019-12-16T07:31:51.000Z","updated":"2020-04-01T15:06:03.741Z","comments":true,"path":"2019/12/16/pricipleofalloc/","link":"","permalink":"http://nilsli.com/2019/12/16/pricipleofalloc/","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 1. 题目开始学习研究OC源码，今天看的是对象的初始化，也就是alloc以及init的分析。 2. 附流程图如下 3. 内容3.1引子我们先看一段代码，Person类的初始化，打印p1,p2,p3对象，以及指向他们的指针： Person *p1 = [Person alloc]; Person *p2 = [p1 init]; Person *p3 = [p1 init]; NSLog(@&quot;%@ -- %p&quot;, p1, &amp;p1); NSLog(@&quot;%@ -- %p&quot;, p2, &amp;p2); NSLog(@&quot;%@ -- %p&quot;, p3, &amp;p3); 打印结果是： 这里为什么p1相同的情况下，经过init后的p2，p3 的地址都不一样呢，我们要用这个图来分析: 在这里，我们[Person alloc]创建了一个p 对象的内存空间，而[p1 init]则是创建同样是指向p1的指针p2，p3，因为和p1 内存空间一致，所以地址均为0x6000024f4950，但是指向该3个指针的指针不一样，所以&amp;p1, &amp;p2, &amp;p3 地址不一致。 3.2源码分析：alloc 步骤如下 1. alloc该步骤主要为创建对象，申请内存空间。相关objc源代码如下 + (id)alloc { return _objc_rootAlloc(self); }","text":"本页所使用的objc runtime 756.2，来自GITHUB 1. 题目开始学习研究OC源码，今天看的是对象的初始化，也就是alloc以及init的分析。 2. 附流程图如下 3. 内容3.1引子我们先看一段代码，Person类的初始化，打印p1,p2,p3对象，以及指向他们的指针： Person *p1 = [Person alloc]; Person *p2 = [p1 init]; Person *p3 = [p1 init]; NSLog(@\"%@ -- %p\", p1, &p1); NSLog(@\"%@ -- %p\", p2, &p2); NSLog(@\"%@ -- %p\", p3, &p3); 打印结果是： 这里为什么p1相同的情况下，经过init后的p2，p3 的地址都不一样呢，我们要用这个图来分析: 在这里，我们[Person alloc]创建了一个p 对象的内存空间，而[p1 init]则是创建同样是指向p1的指针p2，p3，因为和p1 内存空间一致，所以地址均为0x6000024f4950，但是指向该3个指针的指针不一样，所以&amp;p1, &amp;p2, &amp;p3 地址不一致。 3.2源码分析：alloc 步骤如下 1. alloc该步骤主要为创建对象，申请内存空间。相关objc源代码如下 + (id)alloc { return _objc_rootAlloc(self); } 2. objc_rootAlloc基类对于alloc 的实现，此时cls不为空，源码如下： init方法： 类的init 如下 +(id)init{ return (id)self; } 对象的init如下 - (id)init{ return _objc_rootAlloc(self); } id _objc_rootAlloc(Class cls) { return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/); } 此处init 方法仅仅为工厂初始方法，作为父类方法，方便子类重写。 3. callAlloc**callAlloc 的实现如下: // Call [cls alloc] or [cls allocWithZone:nil], with appropriate // shortcutting optimizations. static ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false) { if (slowpath(checkNil &amp;&amp; !cls)) return nil; #if __OBJC2__ if (fastpath(!cls->ISA()->hasCustomAWZ())) { // No alloc/allocWithZone implementation. Go straight to the allocator. // fixme store hasCustomAWZ in the non-meta class and // add it to canAllocFast's summary if (fastpath(cls->canAllocFast())) { // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls->hasCxxDtor(); id obj = (id)calloc(1, cls->bits.fastInstanceSize()); if (slowpath(!obj)) return callBadAllocHandler(cls); obj->initInstanceIsa(cls, dtor); return obj; } else { // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (slowpath(!obj)) return callBadAllocHandler(cls); return obj; } } #endif // No shortcuts available. if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc]; } 4. class_createInstance如上代码，如无捷径，类对象即创建实例 class_createInstance(Class cls, size_t extraBytes) { return _class_createInstanceFromZone(cls, extraBytes, nil); } 5. _class_createINstanceFramZone Cls-&gt;instanceSize 此时为对其寻址空间，统一为为每个对象开辟16位的位置，防止溢出。 size_t size = cls->instanceSize(extraBytes); // CF requires all objects be at least 16 bytes. if (outAllocatedSize) *outAllocatedSize = size; calloc 如果空间已开辟，则指定空间并返回，类似去学校报道，宿管阿姨带你去宿舍并交付钥匙给你，代码如下: if (zone) { // malloc_zone_calloc 即为开辟内存 obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); } else { obj = (id)calloc(1, size); } objc-&gt;initInstanceIsa 这一步为确定指针，即给宿舍贴上门牌号，相关代码如下： if (!zone &amp;&amp; fast) { obj = (id)calloc(1, size); // 该行开辟了名为obj空间 if (!obj) return nil; obj->initInstanceIsa(cls, hasCxxDtor); } 在这一环节，obj = (id)calloc(1, size) 该行开辟了名为obj空间。 而obj-&gt;initInstanceIsa(cls, hasCxxDtor) 则真正的将内存空间obj 与类cls 进行关联上。 4. 总结总的来说，alloc的过程，即时在堆区开辟空间给对象，并在栈区开辟指针（大小为8字节）指向该对象的内存区，即给定isa，以方便寻址。 以上，如果有更深入的理解，会再来补充，供参考。","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"alloc","slug":"alloc","permalink":"http://nilsli.com/tags/alloc/"}]},{"title":"使用Runtime获取第三方成员变量","slug":"runtimes","date":"2019-12-12T07:04:43.000Z","updated":"2020-04-01T15:06:03.743Z","comments":true,"path":"2019/12/12/runtimes/","link":"","permalink":"http://nilsli.com/2019/12/12/runtimes/","excerpt":"","text":"我们使用第三方库，有时候需要获取其成员变量。方法如下： 导入runtime #import &lt;objc/runtime.h> 声明一个Person类 @interface Person : NSObject { NSString *address; } @property(nonatomic,strong)NSString *name; @property(nonatomic,assign)NSInteger age; @end 使用runtime获取私有属性 //遍历获取Person类所有的成员变量IvarList - (void) getAllIvarList { unsigned int methodCount = 0; Ivar * ivars = class_copyIvarList([Person class], &amp;methodCount); for (unsigned int i = 0; i &lt; methodCount; i ++) { Ivar ivar = ivars[i]; const char * name = ivar_getName(ivar); const char * type = ivar_getTypeEncoding(ivar); NSLog(@\"Person拥有的成员变量的类型为%s，名字为 %s \",type, name); } free(ivars); } 打印结果如下： 2019-12-12 15:14:02.115744+0800 PersonRuntime[11576:1071364] Person拥有的成员变量的类型为@\"NSString\"，名字为 address 2019-12-12 15:14:02.115902+0800 PersonRuntime[11576:1071364] Person拥有的成员变量的类型为@\"NSString\"，名字为 _name 2019-12-12 15:14:02.115997+0800 PersonRuntime[11576:1071364] Person拥有的成员变量的类型为q，名字为 _age","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"runtime","slug":"runtime","permalink":"http://nilsli.com/tags/runtime/"},{"name":"进阶","slug":"进阶","permalink":"http://nilsli.com/tags/进阶/"}]},{"title":"Flutter 深入学习","slug":"Flutter-beginer","date":"2019-10-31T10:00:19.000Z","updated":"2020-04-01T15:06:03.750Z","comments":true,"path":"2019/10/31/Flutter-beginer/","link":"","permalink":"http://nilsli.com/2019/10/31/Flutter-beginer/","excerpt":"引言Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。 1.快速开发毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。 2.富有表现力和灵活的UI快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。 3.原生性能Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。","text":"引言Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。 1.快速开发毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。 2.富有表现力和灵活的UI快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。 3.原生性能Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。 快速开发Flutter的热重载可帮助您快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以在亚秒内重载，并且不会丢失状态。 现代式，响应式框架使用Flutter的现代、响应式框架，和一系列基础widget，轻松构建您的用户界面。使用功能强大且灵活的API（针对2D、动画、手势、效果等）解决艰难的UI挑战。 示例代码： class CounterState extends State&lt;Counter> { int counter = 0; void increment() { // 告诉Flutter state已经改变, Flutter会调用build()，更新显示 setState(() { counter++; }); } Widget build(BuildContext context) { // 当 setState 被调用时，这个方法都会重新执行. // Flutter 对此方法做了优化，使重新执行变的很快 // 所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget return new Row( children: &lt;Widget>[ new RaisedButton( onPressed: increment, child: new Text('Increment'), ), new Text('Count: $counter'), ], ); } }","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://nilsli.com/tags/Flutter/"},{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"大前端，跨栈","slug":"大前端，跨栈","permalink":"http://nilsli.com/tags/大前端，跨栈/"}]},{"title":"【译】产品经理vs项目经理：如何区别他们","slug":"pmvspm","date":"2019-08-23T07:16:02.000Z","updated":"2020-04-01T15:06:03.740Z","comments":true,"path":"2019/08/23/pmvspm/","link":"","permalink":"http://nilsli.com/2019/08/23/pmvspm/","excerpt":"（原链接在此）序言大公司和较大的团队常常存在许多战略部门与角色。因此，人们往往会对其中众多角色岗位一脸懵逼不足为奇。 不同的经理在团队中的关键职责是否那么容易区分呢？举个栗子，一个产品经理和项目经理的角色就有很多共同点。据说，这些经理中每一个人在他的生命中起码听过这样直接的问题：他们（产品经理、项目经理）有区别吗？不过，也别急着埋怨他们或者觉得难堪，就因为他们对这些职能弄不清楚。产品经理和项目经理是完全不同的角色。这篇文章的目标是定义清楚这两种在软件开发公司里的关键位置的区别，让你彻底甩掉疑惑。","text":"（原链接在此）序言大公司和较大的团队常常存在许多战略部门与角色。因此，人们往往会对其中众多角色岗位一脸懵逼不足为奇。 不同的经理在团队中的关键职责是否那么容易区分呢？举个栗子，一个产品经理和项目经理的角色就有很多共同点。据说，这些经理中每一个人在他的生命中起码听过这样直接的问题：他们（产品经理、项目经理）有区别吗？不过，也别急着埋怨他们或者觉得难堪，就因为他们对这些职能弄不清楚。产品经理和项目经理是完全不同的角色。这篇文章的目标是定义清楚这两种在软件开发公司里的关键位置的区别，让你彻底甩掉疑惑。 想象一下，你的组织需要进行人力资源优化以及一些人员裁减。如果你不得不决定团队里谁会留下，而谁该友好说再见。哪个经理你会选择留下？ 显然，做出选择并不容易。如果你被问到，说出谁对团队更重要，你肯定会发现难以回答。 这个问题有正确答案吗？让我们试着理清楚。 产品经理 vs 项目经理：谁的负担更重 产品 是你给客户或用户提出的最终结果。产品可以是可以触摸到的实物；也可能是软件平台或者服务。 项目 是一个包含着后续活动的计划。这些活动有设定好的启动和截止时间，以及一个结果。只有在最终结果达成后，项目才算完成。 举个栗子，你的产品是一个约会app。开发这个应用意味着不同的项目。其中一个是编写一个内容计划以及运行一个公司博客。这个项目有自己的截止时间和结束点。 比较两种角色最无聊（但并不正确！）的方式是去观察他们的薪资收入。下图显示了详细数据： 软件行业产品经理年收入（年份未知） IT行业产品项目经理年收入（年份未知） 产品经理和项目经理关键职能是什么？产品经理 在IT领域，产品经理负责管理软件开发。他们通常负责定义产品战略、功能有限顺序以及产品的最终交付上线。 他们负责创造想法和主动性来帮助实现战略和目标，促进内部和外部的相关部门交流；他们会访问潜在的和现有的客户，获取可能会对未来版本有帮助的反馈；他们也会和经销商一起工作，有成效地向用户展示产品细节；他们战略路线下工作，处理产品积压。 产品经理通常参加工业事件和会议，以停留在当前行业最前沿。因此，他们的核心职能列表如下： 产品战略 市场调研 期望与主动性 发布 损益问题 项目经理 在软件开发中行业，项目经理的职责与计划固定类型公司里的项目紧密相连。这些专家保证他们在正轨上运行，通过所有执行阶段，他们关心可能的制约和资源风险。 通常，他们较少关心具体的产品目标。他们分析所有的主动性和特性，来开发一个项目时间表。 作为一份工作，项目经理可能需要每天评估员工，他们的积极性来达成具体的目标。 项目经理管控项目知道他们完成，然后会评估要继续跟进的必要性。 他们的主要职责关联如下： 项目交付 资源 利用软件生命周期方法 状态更新 项目预算 产能 团队合作成功 问题解决方案 两种岗位可能的职业路线是什么？这些管理们毫无疑问的寻求职业成长。从一个工作（提升）到下一个水平的行动，需要坚强的经理技能和足够的经验。 典型的来说，产品经理李正成为高级产品经理或者产品管理负责人。项目经理们的职业路线通常说升级到高级项目经理和项目负责人角色。 在公司里哪一种角色更重要？如果你的公司同时需要产品经理和项目经理，那么组织结构上是完全合理的。如何定义，谁说更重要呢？ 可能，下面的问题会帮助你： 如果没有产品经理，团队能否运行良好？ 如果项目经理离开团队，会发生什么？ 很有可能，你的答案会显示两个角色都是重要且不可取代。他们的紧密合作是迈向成功的关键。 项目管理和产品管理工具选择项目管理和产品管理一个专业工具，需要考虑明确的公司需求、团队相关成员的数量、相关行业，以及其他的因素。 当下你可以尝试小型在线管理解决方案，它能满足经理们的必要需求。 一些流行的软件方案如Trello，Wrike, Hygger或Aha提供了所有产品管理和项目管理领域的强大的工具套装。 大部分这些工具会提供用户便利便利的tas面板（为看板和敏捷开发适配），跟踪系统，待办事项列表，确定优先事项，高级别评估，有用时间线，等等等等。 最后一句话让我们简单的总结一下上面提到的事情： 产品经理和项目经理角色可能被弄混，但他们是完全不同的。他们对于软件开发公司是同等重要。 产品经理驱动产品开发，主动性的工作，确定优先顺序以及制定战略决定。项目经理管控已经被开发和审批过的项目计划。 两个经理都需要专业管理软件来可视化和追踪产品和项目活动，并与团队通力合作。 你怎么区分项目和产品经理呢？哪些软件你尝试过，为什么？","categories":[],"tags":[{"name":"项目经理","slug":"项目经理","permalink":"http://nilsli.com/tags/项目经理/"},{"name":"产品经理","slug":"产品经理","permalink":"http://nilsli.com/tags/产品经理/"},{"name":"IT","slug":"IT","permalink":"http://nilsli.com/tags/IT/"},{"name":"产品","slug":"产品","permalink":"http://nilsli.com/tags/产品/"},{"name":"项目","slug":"项目","permalink":"http://nilsli.com/tags/项目/"}]},{"title":"iOS开发中的问题集锦","slug":"tips-on-swift","date":"2019-07-28T07:33:22.000Z","updated":"2020-04-01T15:06:03.744Z","comments":true,"path":"2019/07/28/tips-on-swift/","link":"","permalink":"http://nilsli.com/2019/07/28/tips-on-swift/","excerpt":"","text":"开发中难免遇到各式各样的小问题，平时收集一下，汇总如下，按Q（问题）和 A（解决方法）。 Q1遇到unable to index file详细内容： ​ 详细内容： unable to index file fatal: updating files failed A 解决： git reset HEAD qooxdoo Q2 hexo部署后，CNAME会被自动删除推送上去后，包含域名内容的CNAME 被删除，博客无法用域名解析。 A 解决： 出现这样的问题一般是CNAME 放在blog根目录下，正确是放在source 目录下。 然后执行 部署推送 hexo d -g 问题得到解决。 Q3 This copy of libswiftCore.dylib requires an OS version prior to 10.14.4.问题: 在掘金这篇文章, 尝试配置SPM，通过命令创建包时，执行swift run 后，出现如下问题 A 解决： cp -r /usr/lib/swift/*.dylib /Applications/Xcode.app/Contents/Frameworks Q4: Git 遇到了 early EOF index-pack failed$ git clone https://github.com/boostorg/boost.git Cloning into 'boost'... remote: Counting objects: 183543, done. remote: Compressing objects: 100% (69361/69361), done. fatal: The remote end hung up unexpectedly fatal: early EOF fatal: index-pack failed 解决： git config --add core.compression -1 ———————— 持续添加中","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"swift","slug":"swift","permalink":"http://nilsli.com/tags/swift/"},{"name":"小问题","slug":"小问题","permalink":"http://nilsli.com/tags/小问题/"},{"name":"git","slug":"git","permalink":"http://nilsli.com/tags/git/"}]},{"title":"【译】从阿波罗7号卫星上俯瞰加州南部","slug":"view-from-south-cali","date":"2019-07-24T07:03:19.000Z","updated":"2020-04-01T15:06:03.746Z","comments":true,"path":"2019/07/24/view-from-south-cali/","link":"","permalink":"http://nilsli.com/2019/07/24/view-from-south-cali/","excerpt":"","text":"这是从阿波罗7号上拍摄的加州南部的照片 图片来自 NASA 这片照片拍摄于1968年10月12日，由阿波罗7号航天器在执行它的绕地飞行第18圈时拍摄。拍摄时对地高度为124海里，加州海岸线上的穆古岬向南一直到欧申赛德，都能尽收眼底。透过云层，依稀能看见圣卡塔利娜岛屿。洛杉矶地区的近景则被从班宁市向西连绵100多英里直到马里海滩上空污染物所遮盖的模糊不清。在图片的上部（从左至右）能看见圣华金谷）在贝克斯菲尔德之外，特哈查比山脉,内华达山脉,欧文斯谷,死亡山谷以及莫哈韦沙漠。 阿波罗7号于1968年10月11日升空，被亲切称为”华尔特，华里和唐·修”, 是首次载人发射火箭计划。该计划在载人行动期间证明了指令/服务仓任务模组技术、项目地面支援能力、阿波罗的空间交会能力，同时也实现了首次从太空进行实时电视直播。 原文链接","categories":[],"tags":[{"name":"NASA","slug":"NASA","permalink":"http://nilsli.com/tags/NASA/"},{"name":"太空","slug":"太空","permalink":"http://nilsli.com/tags/太空/"},{"name":"卫星","slug":"卫星","permalink":"http://nilsli.com/tags/卫星/"}]},{"title":"【译】SaaS发展历程","slug":"journey-of-SaaS","date":"2019-07-24T06:48:02.000Z","updated":"2020-04-01T15:06:03.729Z","comments":true,"path":"2019/07/24/journey-of-SaaS/","link":"","permalink":"http://nilsli.com/2019/07/24/journey-of-SaaS/","excerpt":"撰稿人：Neeraj Agrawal 梗概： 总结了成功的SaaS公司上市前的发展轨迹：找到 product-market fit，年入$200万（ARR），然后进入T2D3阶段 - 连续两年ARR翻三倍，然后连续三年翻两倍。ARR至少$1亿，然后上市。 所谓T2D3： 连续两年 triple（三倍），然后连续三年 double（两倍）。","text":"撰稿人：Neeraj Agrawal 梗概： 总结了成功的SaaS公司上市前的发展轨迹：找到 product-market fit，年入$200万（ARR），然后进入T2D3阶段 - 连续两年ARR翻三倍，然后连续三年翻两倍。ARR至少$1亿，然后上市。 所谓T2D3： 连续两年 triple（三倍），然后连续三年 double（两倍）。 原文【编者按】 作者 Neeraj Agrawal 是美国波斯顿著名科技行业投行 Batter Ventures 的一名普通合伙人。 “打造一个十亿级的SaaS企业软件公司需要怎么做？”，作为一个科技行业投资者，在从业一来，曾无数次被问到这个问题，然而很难回答。我敢打赌登山者们被问到他们到底如何征服山峦的主峰时，也会有同样的感受。问题的答案是一步步来——你不过是把一只脚从另一只脚前迈过去，当然——务实一点来讲，整个过程总是能分解成多个、清晰的步骤。 你不能在一天内翻越乞力马扎罗山，所以你也不可能迅速的弄出一套优秀的SaaS系统出来。相反的，你该将缩小焦点而且明确目标，接下来搞清楚下一步该怎样做，然后快速奔向目标。 “我的儿子在Battery Adventures工作” 我之所以开始思考在风险投资行业的工作和登山的相似性，要感谢一个意想不到的人：我的母亲。她和我的父亲在1960年代中期从当时还是英属的印度拉贾斯坦邦移居到皇后区（译注:纽约）。我的父母都是聪明，努力工作，务实的人，但他们都不理解他们的儿子在工作些什么。 我曾无数次的向我亲爱的、娇小的妈妈（她只有约1.5米高）描述我的工作，但她从没能清晰的记得我在做些什么。在最近的一次聚会上，她骄傲的告诉她的朋友：“我的儿子在Battery Adventures工作”。她的朋友笑了，因为他们对我不像我父亲一样是个医生，或者在大牌的银行——像高盛或是摩根斯坦利工作而倍感失望。 她的话引起我的思考。或许他把我的工作描述的比我认为的更好一些。或许思考如何建立一家公司最好的方式是去冒险，而非历险。而或许我在风投公司的角色就像一次冒险历程里的向导：是那些曾攀登过这座山很多次的那种人，事无巨细的了解攀登过程中的岩层与沟壑，能给足够勇敢的人提供指导来面对挑战。 我很荣幸曾在我15年风投任职生涯中，与许多世界级的创始人共事，其中包括许多B2B，SaaS企业软件公司，诸如Marketo、Omniture、Guidewire、Bazaarvoice以及Sprinklr（如需了解所有Battery 公司投资与撤出的详细清单，请点击这里）。 所以我从我个人的经历中分享一些故事和建议——姑且称之为“冒险”故事，作为向导来帮助那些里程碑上的企业者去到达他们的顶峰：估值十亿美元。 SaaS企业成功走向市场的7个阶段 我相信一个SaaS企业的走向市场会成功，会有7个关键阶段。大部分的阶段围绕这一个中心店，我称之为“三倍、三倍、两倍、两倍”（简称T2D3），反映一个公司的年度财报进展。 这并不是通往SaaS成功的唯一的步进之路，像Cornerstone、ExactTarget和SuccessFactors这样的公司他们所展示的一样，但是这是一条通往目标稳妥的路。每一个阶段需要不同的聚焦，比方说调整你的销售进程，发展你的团队和你的组织策略，以及国际上的扩张。 你会注意到我提到“市场进入策略”，因为SaaS公司发展中也有很多关键阶段。它们包含了选择合伙人、选择投资人、开发灵活的产品架构以及培养成功的企业文化，等等诸如此类。在这里，我们只着眼于“攀登”的技术。所以带上你的户外工具——我们要走向偏僻跑到，直奔顶峰了。 阶段1：达成一个伟大的产品-市场体系。 这包含了找到并且按重要性排列好消费者的通电，接着把你的产品准确指向这些痛点。很多创业者问我怎样知道他们实现了产品-市场体系。遗憾的是，没有确切的方法来测试证明。 我经常问一些特定行业的潜在消费者或者用户来描述他们的痛点。当我听到样本的稳定性时，我知道到位了。一旦产品成型，很容易来测试它是否让消费者觉得有对其帮助。– … 译制中，原链接在此","categories":[],"tags":[{"name":"创业","slug":"创业","permalink":"http://nilsli.com/tags/创业/"},{"name":"SaaS","slug":"SaaS","permalink":"http://nilsli.com/tags/SaaS/"},{"name":"科技","slug":"科技","permalink":"http://nilsli.com/tags/科技/"}]},{"title":"如何在苹果AppStore 上下架应用","slug":"offline-app-from-app-store","date":"2018-07-24T07:46:11.000Z","updated":"2020-04-01T15:06:03.737Z","comments":true,"path":"2018/07/24/offline-app-from-app-store/","link":"","permalink":"http://nilsli.com/2018/07/24/offline-app-from-app-store/","excerpt":"序言：作为开发者，如何快捷的在苹果商店下架上架App，请看图吧如何下架1. 进入开发者中心 itunesConnect","text":"序言：作为开发者，如何快捷的在苹果商店下架上架App，请看图吧如何下架1. 进入开发者中心 itunesConnect 2. 选择相应的App 3. 如图，选择价格与销售范围—— 下架 4. 等等10分钟左右，再次搜索，此时AppStore 已经搜索不到该App了 此时的状态是： 重新上架1. 此时，也是选择 该应用的 价格与销售范围，选择【在所有地区供应】– 存储 2. 此时是立即上架，AppStore也是需要5-10分钟可以搜索到 就是这么简单，希望可以帮到你。","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"appstore","slug":"appstore","permalink":"http://nilsli.com/tags/appstore/"},{"name":"上架","slug":"上架","permalink":"http://nilsli.com/tags/上架/"},{"name":"下架","slug":"下架","permalink":"http://nilsli.com/tags/下架/"},{"name":"苹果商店","slug":"苹果商店","permalink":"http://nilsli.com/tags/苹果商店/"}]},{"title":"图解SDWebImage(读sdwebimage源码分析)","slug":"pic-of-sdwebimage","date":"2018-02-24T07:33:15.000Z","updated":"2020-04-01T15:06:03.738Z","comments":true,"path":"2018/02/24/pic-of-sdwebimage/","link":"","permalink":"http://nilsli.com/2018/02/24/pic-of-sdwebimage/","excerpt":"最近在看一些第三方库的源码，其中SDWebImage 尤其让人惊叹，尝试用XMind 画出原理，以后有机会， 会增加更多的细节图。 大纲如下：","text":"最近在看一些第三方库的源码，其中SDWebImage 尤其让人惊叹，尝试用XMind 画出原理，以后有机会， 会增加更多的细节图。 大纲如下： 图片缓存的实现如下： 以下为异步下载部分：","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"开发","slug":"开发","permalink":"http://nilsli.com/tags/开发/"},{"name":"SDWebImage","slug":"SDWebImage","permalink":"http://nilsli.com/tags/SDWebImage/"}]},{"title":"通过Universal Link在微信页面中唤起原生App","slug":"wake-up-app-with-universal-link","date":"2017-06-24T07:39:05.000Z","updated":"2020-04-01T15:06:03.747Z","comments":true,"path":"2017/06/24/wake-up-app-with-universal-link/","link":"","permalink":"http://nilsli.com/2017/06/24/wake-up-app-with-universal-link/","excerpt":"因微信封杀，已失效，微信大刀威武！ 在某些电商项目，或者是社交媒体的分享页面中，我们经常会看到在页面的顶端或者底部遇到有【打开App】或者【下载App】这样的按钮。比较友好的产品经理，会做设备识别，以及检测APP是否安装，来做打开或者下载App 的需求。这些功能在Safari下使用location.href=”scheme://example” 即可实现。但是在微信中，这方面做的比较恶心，微信下面几乎是全面屏蔽了唤起原生App 的功能，所有的启动都需要通过应用宝。 在iOS 9以后，苹果推出了Universal Link 这个概念，解决了使用A标签，以及iFrame 的弊端。WWDC2015 Session 509 有介绍,通过Universal Link，将App 与网页端建立连接桥，可以从Safari 或者其他前端浏览器来识别并唤醒App，甚至是微信环境下也可以冲破障碍。","text":"因微信封杀，已失效，微信大刀威武！ 在某些电商项目，或者是社交媒体的分享页面中，我们经常会看到在页面的顶端或者底部遇到有【打开App】或者【下载App】这样的按钮。比较友好的产品经理，会做设备识别，以及检测APP是否安装，来做打开或者下载App 的需求。这些功能在Safari下使用location.href=”scheme://example” 即可实现。但是在微信中，这方面做的比较恶心，微信下面几乎是全面屏蔽了唤起原生App 的功能，所有的启动都需要通过应用宝。 在iOS 9以后，苹果推出了Universal Link 这个概念，解决了使用A标签，以及iFrame 的弊端。WWDC2015 Session 509 有介绍,通过Universal Link，将App 与网页端建立连接桥，可以从Safari 或者其他前端浏览器来识别并唤醒App，甚至是微信环境下也可以冲破障碍。 参考了苹果的原生介绍，做出了微信下唤醒自己的 App 效果如下： 实操如下服务器配置：准备独立域名。 一级域名，二级域名均可。 SSL 证书这里需要为服务器配置HTTPS 用的SSL 证书。 上传签名好的JSON 配置文件新建一个JSON文件，不需要后缀名，内容输入以下代码： { \"applinks\": { \"apps\": [], \"details\": [ { \"appID\": \"5B5Q4xxxx.com.xxxx.xxxx\", \"paths\": [ \"/html/1/*\", \"/*\"] }, ] } } 这里的 appID 相关内容可以在Developer 中心找到相关的内容。如图，前半部分为Prefix 后半部分为ID，即你的App 的bundle id，两者通过.相连。 注意：这里的AppID中前半部分，在App 转让主体后会改变，需重新更新。 paths 则是用来唤醒App 所需要指定的JSON文件在服务器中的路径。用”/* “ 是根目录，而/html 则是指html目录下的。 填好后保存为apple-app-site-association 名，上传到域名指向的服务器根目录。 App配置： 在工程文件中，找到Targets - Capabilities - Associated Domains 将开关选为On，并添加你的域名，格式为applinks:你的域名.com iOS 移动端的代码配置 - (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler { if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb]) { NSString *url = userActivity.webpageURL.description; // 这里可以通过拆分url 来传入参数，达到跳转原生页面的功能，如跳转某商品页 [UIApplication sharedApplication] openURL:webpageURL]; } return YES; } h5网页配置： h5网页中对需要唤起App 的按钮或者控件添加点击事件，事件的函数代码如下: function wakeUpApp(){ if (navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) { var loadDateTime = new Date(); window.setTimeout(function() { var timeOutDateTime = new Date(); if (timeOutDateTime - loadDateTime &lt; 5000) { window.location.href = \"http://a.app.qq.com/o/simple.jsp?pkgname=你的应用宝BundleID\"; }else{ window.close(); } }, 25); window.location.href = \"https://yourdomainname.com/\"; }else if (navigator.userAgent.match(/android/i)) { var state = null; try { state = window.open(\"apps custom url schemes \", '_blank'); } catch(e) {} if (state) { window.close(); } else { window.location.href = \"要跳转的页面URL\"; } } } 注：代码中 yourdomainname.com 还可以后面添加 /goodid/123456 之类的属性id后缀，用来传递事件类型和id，方便移动端做更丰富的功能需求，比如通过goodid 识别要做的下一步动作是打开商品id 为123456 的商品详情页，等等。 配置完成，查看是否能唤起App，也可以通过如下图中，输入域名，长按来唤起App 做验证。 至此，大功告成。 值得注意的是，只能在iOS 9环境及以上实现该功能。iOS 8或者以下，只能采取老式的跳转至应用宝来实现。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"原生","slug":"原生","permalink":"http://nilsli.com/tags/原生/"},{"name":"微信","slug":"微信","permalink":"http://nilsli.com/tags/微信/"},{"name":"universallink","slug":"universallink","permalink":"http://nilsli.com/tags/universallink/"},{"name":"hyper","slug":"hyper","permalink":"http://nilsli.com/tags/hyper/"},{"name":"混合交互","slug":"混合交互","permalink":"http://nilsli.com/tags/混合交互/"}]},{"title":"下棋","slug":"play-chess","date":"2016-03-24T07:52:01.000Z","updated":"2020-04-01T15:06:03.739Z","comments":true,"path":"2016/03/24/play-chess/","link":"","permalink":"http://nilsli.com/2016/03/24/play-chess/","excerpt":"","text":"在公园和大爷下象棋，有点紧张。走了第一步后，大爷沉默了很久说：“你是新手吧？”“大爷你怎么知道？”“我在这玩了几年，第一步走帅的真不多。”“不应该让领导先走吗？”","categories":[],"tags":[{"name":"休闲","slug":"休闲","permalink":"http://nilsli.com/tags/休闲/"},{"name":"人生哲理","slug":"人生哲理","permalink":"http://nilsli.com/tags/人生哲理/"}]}]}