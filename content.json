{"meta":{"title":"李佳的技术博客","subtitle":"「疾如風，徐如林，侵掠如火，不動如山」","description":"我就是我，","author":"李佳","url":"http://nilsli.com","root":"/"},"pages":[{"title":"[404]","date":"2020-03-17T15:07:11.484Z","updated":"2020-03-17T15:07:11.484Z","comments":true,"path":"404.html","permalink":"http://nilsli.com/404.html","excerpt":"","text":""},{"title":"这是我自己","date":"2018-09-18T09:54:59.000Z","updated":"2020-03-17T15:07:11.642Z","comments":true,"path":"about/index.html","permalink":"http://nilsli.com/about/index.html","excerpt":"","text":"关于我毕业于对外经贸大学，对移动端有了较深了解，略懂前端、RN 技术。 在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流 邮件(myhonestjj#gmail.com, 把#换成@) 我的Github About MeGraduated from UIBE(University of International Business and Economics), know pretty much about Mobile Delevepment, familiar with Front End and React Native. Please feel free to contact me if you have any question when view this website, you can communicate with me in ways below: Gmail: myhonestjj#gmail.com(repalace # with @) Github: newjia’s Github"},{"title":"文章分类","date":"2020-02-25T04:07:54.000Z","updated":"2020-03-17T15:07:11.642Z","comments":true,"path":"categories/index.html","permalink":"http://nilsli.com/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-03-21T03:50:48.000Z","updated":"2020-03-21T03:50:48.559Z","comments":true,"path":"contact/index.html","permalink":"http://nilsli.com/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-25T04:07:21.000Z","updated":"2020-03-17T15:07:11.685Z","comments":true,"path":"tags/index.html","permalink":"http://nilsli.com/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-03-21T03:51:27.000Z","updated":"2020-03-21T03:51:27.875Z","comments":true,"path":"friends/index.html","permalink":"http://nilsli.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-17T15:07:11.683Z","updated":"2020-03-17T15:07:11.683Z","comments":true,"path":"images/2019/08/添加别名登录：.html","permalink":"http://nilsli.com/images/2019/08/添加别名登录：.html","excerpt":"","text":"添加别名登录：参考连接 1、首先创建本机的公钥和私钥，使用命令ssh-keygen。2、使用ssh-copy-id &lt;主机地址&gt; 来将公钥添加到目的主机。 ssh-copy-id 188.188.188.188 3、【在本地电脑】使用 vim ~/.ssh/config命令编辑文件，添加如下内容： HostName abc.com/188.188.188.188 Port 22 User root IdentityFile ~/.ssh/id_rsa.pub IdentitiesOnly yes"}],"posts":[{"title":"底层探索——类的加载","slug":"loadingClass","date":"2020-03-24T07:18:34.000Z","updated":"2020-03-26T17:13:52.456Z","comments":true,"path":"2020/03/24/loadingClass/","link":"","permalink":"http://nilsli.com/2020/03/24/loadingClass/","excerpt":"","text":"本页所使用的objc runtime 756.2，来自 Apple 开源文档 1、objc_init 流程类的加载，初始化来自objc_init 这个步骤，查看一下源码，得到 void _objc_init(void) { static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image); } 序号 源代码 解释 1 environ_init() 环境变量、帮助文档配置 2 tls_init() 线程key 的绑定 3 static_init C++ 静态构造函数 4 lock_init() 锁配置 5 exception_init() 异常初始化 6 _dyld_objc_notify_register Dyld 通知注册 1.1 environ_init 在函数void environ_init(void) 里，读取环境变量 env 以及帮助注释 help， 相关代码如下： for (size_t i = 0; i &lt; sizeof(Settings)/sizeof(Settings[0]); i++) { const option_t *opt = &amp;Settings[i]; if (PrintHelp) _objc_inform(\"%s: %s\", opt->env, opt->help); if (PrintOptions &amp;&amp; *opt->var) _objc_inform(\"%s is set\", opt->env); } 运行代码，在控制台可以得到环境变量参数表： objc[27076]: OBJC_PRINT_IMAGES: log image and library names as they are loaded objc[27076]: OBJC_PRINT_IMAGE_TIMES: measure duration of image loading steps objc[27076]: OBJC_PRINT_LOAD_METHODS: log calls to class and category +load methods objc[27076]: OBJC_PRINT_INITIALIZE_METHODS: log calls to class +initialize methods objc[27076]: OBJC_PRINT_RESOLVED_METHODS: log methods created by +resolveClassMethod: and +resolveInstanceMethod: objc[27076]: OBJC_PRINT_CLASS_SETUP: log progress of class and category setup objc[27076]: OBJC_PRINT_PROTOCOL_SETUP: log progress of protocol setup objc[27076]: OBJC_PRINT_IVAR_SETUP: log processing of non-fragile ivars objc[27076]: OBJC_PRINT_VTABLE_SETUP: log processing of class vtables objc[27076]: OBJC_PRINT_VTABLE_IMAGES: print vtable images showing overridden methods objc[27076]: OBJC_PRINT_CACHE_SETUP: log processing of method caches objc[27076]: OBJC_PRINT_FUTURE_CLASSES: log use of future classes for toll-free bridging objc[27076]: OBJC_PRINT_PREOPTIMIZATION: log preoptimization courtesy of dyld shared cache objc[27076]: OBJC_PRINT_CXX_CTORS: log calls to C++ ctors and dtors for instance variables objc[27076]: OBJC_PRINT_EXCEPTIONS: log exception handling objc[27076]: OBJC_PRINT_EXCEPTION_THROW: log backtrace of every objc_exception_throw() objc[27076]: OBJC_PRINT_ALT_HANDLERS: log processing of exception alt handlers objc[27076]: OBJC_PRINT_REPLACED_METHODS: log methods replaced by category implementations objc[27076]: OBJC_PRINT_DEPRECATION_WARNINGS: warn about calls to deprecated runtime functions objc[27076]: OBJC_PRINT_POOL_HIGHWATER: log high-water marks for autorelease pools objc[27076]: OBJC_PRINT_CUSTOM_RR: log classes with un-optimized custom retain/release methods objc[27076]: OBJC_PRINT_CUSTOM_AWZ: log classes with un-optimized custom allocWithZone methods objc[27076]: OBJC_PRINT_RAW_ISA: log classes that require raw pointer isa fields objc[27076]: OBJC_DEBUG_UNLOAD: warn about poorly-behaving bundles when unloaded objc[27076]: OBJC_DEBUG_FRAGILE_SUPERCLASSES: warn about subclasses that may have been broken by subsequent changes to superclasses objc[27076]: OBJC_DEBUG_NIL_SYNC: warn about @synchronized(nil), which does no synchronization objc[27076]: OBJC_DEBUG_NONFRAGILE_IVARS: capriciously rearrange non-fragile ivars objc[27076]: OBJC_DEBUG_ALT_HANDLERS: record more info about bad alt handler use objc[27076]: OBJC_DEBUG_MISSING_POOLS: warn about autorelease with no pool in place, which may be a leak objc[27076]: OBJC_DEBUG_POOL_ALLOCATION: halt when autorelease pools are popped out of order, and allow heap debuggers to track autorelease pools objc[27076]: OBJC_DEBUG_DUPLICATE_CLASSES: halt when multiple classes with the same name are present objc[27076]: OBJC_DEBUG_DONT_CRASH: halt the process by exiting instead of crashing objc[27076]: OBJC_DISABLE_VTABLES: disable vtable dispatch objc[27076]: OBJC_DISABLE_PREOPTIMIZATION: disable preoptimization courtesy of dyld shared cache objc[27076]: OBJC_DISABLE_TAGGED_POINTERS: disable tagged pointer optimization of NSNumber et al. objc[27076]: OBJC_DISABLE_TAG_OBFUSCATION: disable obfuscation of tagged pointers objc[27076]: OBJC_DISABLE_NONPOINTER_ISA: disable non-pointer isa fields objc[27076]: OBJC_DISABLE_INITIALIZE_FORK_SAFETY: disable safety checks for +initialize after fork 1.2 tls_init() 对线程的Key 的绑定。 这部分不展开讨论 void tls_init(void) { #if SUPPORT_DIRECT_THREAD_KEYS _objc_pthread_key = TLS_DIRECT_KEY; pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific); #else _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific); #endif } 1.3 static_init 实现系统级别的 C++ 静态构造函数。 相关源码： static void static_init() { size_t count; auto inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count); for (size_t i = 0; i &lt; count; i++) { inits[i](); } } 1.4 lock_init 锁的初始化，这里并没有进行实现，意味着可以进行重写，自定义一些操作。 相关源码： /*********************************************************************** * Lock management **********************************************************************/ mutex_t runtimeLock; mutex_t selLock; mutex_t cacheUpdateLock; recursive_mutex_t loadMethodLock; void lock_init(void) { } 1.5 exception_init 异常的初始化：libobjc 的异常回调系统初始化，由map_images 调用。 即注册监听回调。 /*********************************************************************** * exception_init * Initialize libobjc's exception handling system. * Called by map_images(). **********************************************************************/ void exception_init(void) { old_terminate = std::set_terminate(&amp;_objc_terminate); } 这个c++ 函数 set_terminate 会初始化静态的 异常回调。在OC 环境下，所有的异常抛出，都会到(*old_terminate)(); 这行代码里。 相关源码如下： static void (*old_terminate)(void) = nil; static void _objc_terminate(void) { if (PrintExceptions) { _objc_inform(\"EXCEPTIONS: terminating\"); } if (! __cxa_current_exception_type()) { // No current exception. (*old_terminate)(); } else { // There is a current exception. Check if it's an objc exception. @try { __cxa_rethrow(); } @catch (id e) { // It's an objc object. Call Foundation's handler, if any. (*uncaught_handler)((id)e); (*old_terminate)(); } @catch (...) { // It's not an objc object. Continue to C++ terminate. (*old_terminate)(); } } } 在业务代码里执行一个报错的方法： 类声明与实现 @interface Dog : NSObject - (void)bark; @end @implementation Dog @end 使用类执行为实现的方法 Dog *d = [Dog alloc]; [d bark]; 异常抛出如下图所示： 1.6 _dyld_objc_notify_register（核心） objc 特有方法 注册回调。当镜像文件被映射(mapped)、未被映射(unmapped)、初始化(initialized) 使调用。 该方法由dyld 声明。 镜像文件加载完后，dyld 会回调”映射”函数，内容为一个包含objc-image-info 数据段的数组。 注册方法源码如下： _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image); 这里主要关注 map_images 的这个对象，其实现代码为： void map_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[]) { mutex_locker_t lock(runtimeLock); return map_images_nolock(count, paths, mhdrs); } 读取镜像文件 继续探索 map_images_nolock 这个函数，读取镜像文件的关键行为 if (hCount > 0) { _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses); } 至此，这一部分到此就结束了，关于images 的流程，另外单独分析。 2、read_images - 读镜像文件2.1 初次进来: 创建容器哈希表根据源码，得知读取镜像的主要函数为read_image ，其函数具体为： void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){} 读取镜像后，最先需要做的是，为这些景象里的内容找一个家——容器，也就是开辟表结构。 在源码里，这里分别通过NXCreateMapTable、NXCreateHashTable开辟了2个表，主要存储以下的内容： 未共享缓存的类 gdb_objc_realized_classes gdb_objc_realized_classes = NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize); 开辟内存空间类 - allocatedClasses allocatedClasses = NXCreateHashTable(NXPtrPrototype, 0, nil); 2.2 类的处理 从编译后的类列表中，取出所有的类，并进行下一步操作。 for (EACH_HEADER) { classref_t *classlist = _getObjc2ClassList(hi, &amp;count); } 取出系统类 Class cls = (Class)classlist[i]； 读取类 Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized); 懒加载相关，条件为 newCls != cls &amp;&amp; newCls， 即两个类不相等时 初始化懒加载所需内存空间 resolvedFutureClasses = (Class *) realloc(resolvedFutureClasses, (resolvedFutureClassCount+1) * sizeof(Class)); 懒加载的类添加到数组中来 resolvedFutureClasses[resolvedFutureClassCount++] = newCls; 2.3 方法编号处理 把未注册的方法名进行注册到一张HASH表里，形成方法名与方法的映射 static size_t UnfixedSelectors; { mutex_locker_t lock(selLock); for (EACH_HEADER) { if (hi->isPreoptimized()) continue; bool isBundle = hi->isBundle(); SEL *sels = _getObjc2SelectorRefs(hi, &amp;count); UnfixedSelectors += count; for (i = 0; i &lt; count; i++) { const char *name = sel_cname(sels[i]); // 注册SEL的操作 sels[i] = sel_registerNameNoLock(name, isBundle); } } } 注册到的表名为namedSelectors， 具体的实现在这里 NXMapInsert(namedSelectors, sel_getName(result), result); 2.4 协议处理 找到类遵守的协议，修复协议的引用。 关键字: readProtocol 、remapProtocolRef 相关源码，如下所示: 找到协议： for (EACH_HEADER) { extern objc_class OBJC_CLASS_$_Protocol; Class cls = (Class)&amp;OBJC_CLASS_$_Protocol; NXMapTable *protocol_map = protocols(); protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count); for (i = 0; i &lt; count; i++) { readProtocol(protolist[i], cls, protocol_map, isPreoptimized, isBundle); } } 修复协议引用（重映射）： for (EACH_HEADER) { protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count); for (i = 0; i &lt; count; i++) { remapProtocolRef(&amp;protolist[i]); } } 2.5 非懒加载处理 初始化所有非懒加载类，进行 rw ro 操作 for (EACH_HEADER) { classref_t *classlist = _getObjc2NonlazyClassList(hi, &amp;count); addClassTableEntry(cls); realizeClassWithoutSwift(cls); } 2.6 待处理的类 找到最新特征的类，以备CoreFoundation 需要操作它 if (resolvedFutureClasses) { for (i = 0; i &lt; resolvedFutureClassCount; i++) { Class cls = resolvedFutureClasses[i]; if (cls->isSwiftStable()) { _objc_fatal(\"Swift class is not allowed to be future\"); } realizeClassWithoutSwift(cls); cls->setInstancesRequireRawIsa(false/*inherited*/); } free(resolvedFutureClasses); } 2.7 分类处理 对非类进行处理，包括Class 的和metaClass 的 for (EACH_HEADER) { category_t **catlist = _getObjc2CategoryList(hi, &amp;count); bool hasClassProperties = hi->info()->hasCategoryClassProperties(); for (i = 0; i &lt; count; i++) { category_t *cat = catlist[i]; Class cls = remapClass(cat->cls); } } 3、类方法重点3.1 类的读取readClasses3.1.1 判断是否是未来处理的类 （popFutureNamedClass）如果是，就读取data，设置rw 和 ro if (Class newCls = popFutureNamedClass(mangledName)) { // This name was previously allocated as a future class. // Copy objc_class to future class's struct. // Preserve future's rw data block. if (newCls->isAnySwift()) { _objc_fatal(\"Can't complete future class request for '%s' \" \"because the real class is too big.\", cls->nameForLogging()); } // 在这里，读取data(), 并进行设置 rw /ro class_rw_t *rw = newCls->data(); const class_ro_t *old_ro = rw->ro; memcpy(newCls, cls, sizeof(objc_class)); rw->ro = (class_ro_t *)newCls->data(); newCls->setData(rw); freeIfMutable((char *)old_ro->name); free((void *)old_ro); addRemappedClass(cls, newCls); replacing = cls; cls = newCls; } 3.1.2 添加命名过的类addNamedClass(cls, mangledName, replacing); 3.1.3 把类插入到包含所有类的表里addClassTableEntry(cls); 具体的实现为如下： static void addClassTableEntry(Class cls, bool addMeta = true) { runtimeLock.assertLocked(); // This class is allowed to be a known class via the shared cache or via // data segments, but it is not allowed to be in the dynamic table already. assert(!NXHashMember(allocatedClasses, cls)); if (!isKnownClass(cls)) NXHashInsert(allocatedClasses, cls); if (addMeta) addClassTableEntry(cls->ISA(), false); } 3.2 swift 相关 - realizeClassWithoutSwift","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"Class","slug":"Class","permalink":"http://nilsli.com/tags/Class/"}]},{"title":"类的加载","slug":"dyld-analyze","date":"2020-03-23T04:30:29.000Z","updated":"2020-03-26T05:10:14.451Z","comments":true,"path":"2020/03/23/dyld-analyze/","link":"","permalink":"http://nilsli.com/2020/03/23/dyld-analyze/","excerpt":"","text":"本页所使用的objc runtime 756.2，来自GITHUB 一、引言前文研究了对象、方法的基础，知道了对象/类的结构，类方法的生成和传递原理。下面该进入到核心环节，就是类的加载了，在这一个模块，需要了解的有下面几点： OC 的库 app 的加载流程 image 的结构 回调函数 image 的加载流程 二、库2.1、静态库 是一个外部函数与变量的集合体 iOS 在编译时执行静态库，链接到相应代码 静态库的文件内容，通常包含一堆程序员自定的变量与函数，其内容不像动态链接库那么复杂，在编译期间由编译器与链接器将它集成至应用程序内，并制作成目标文件以及可以独立运作的可执行文件。 常见的iOS 环境下的静态库由 .a 文件，.framework 文件。java 环境下有.so 静态库 2.2、动态库 iOS 在运行时执行动态库，链接到相应的代码里。 .dylib 库文件 三、App 启动流程1. dyld startlibdyld.dylib`start 2. 加载镜像reloadAllImages:3. 加载链接loadInsertedDylib 插入（insert）： 插入网线 链接（link）： 接通网络 四、dyld4.1 start4.2 递归初始化4.3 objc_init五、镜像 - images dyld Objc_init 六、回调函数 指针 注册 *snotif","categories":[],"tags":[{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"dyld","slug":"dyld","permalink":"http://nilsli.com/tags/dyld/"}]},{"title":"方法的本质4_消息转发机制","slug":"messageSend","date":"2020-03-13T10:16:42.000Z","updated":"2020-03-21T04:03:41.414Z","comments":true,"path":"2020/03/13/messageSend/","link":"","permalink":"http://nilsli.com/2020/03/13/messageSend/","excerpt":"","text":"本页所使用的objc runtime 756.2，来自GITHUB 1、回顾上文消息方法的本质3_消息查找流程 一文总结了方法查找的流程，得到结论如下: 类的缓存里查找——找到——结束查找 类的方法列表里查找——找到——结束查找 递归父类缓存、方法列表查找——找到——结束查找 动态方法解析——（未分析） 以上未解决——异常崩溃——结束 下面继续学习源码，结合业务代码，深挖第四步 动态方法决议，来更深一步的学习消息转发机制。 2、问题这篇文章，希望弄清楚下面的问题 消息转发是什么 消息转发的场景 如何进行消息转发 3、动态方法决议 3.1 入口 - class_resolveMethod之前的分析，知道了当查找缓存未命中后，会执行objc_msgSend_uncached 的方法，进行方法查找。 具体执行的是方法 _class_lookupMethodAndLoadCache3 。 runtime 源码如下： /*********************************************************************** * _class_lookupMethodAndLoadCache. * Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp(). * This lookup avoids optimistic cache scan because the dispatcher * already tried that. **********************************************************************/ IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls) { return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/); } 在源码中，知道了具体执行的方法是 lookUpImpOrForward，这个方法执行了众多流程，缓存、递归查找等。 如果都未命中，则会找到方法决议实现，代码如下： // No implementation found. Try method resolver once. if (resolver &amp;&amp; !triedResolver) { runtimeLock.unlock(); _class_resolveMethod(cls, sel, inst); runtimeLock.lock(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; } 注意到执行 _class_resolveMethod(cls, sel, inst) 前后，使用了runtimeLock 进行了锁定与解锁，具体实现时互斥锁（参见Cooci老师的互斥锁-读写锁-条件锁），来保证内存安全。 查看一下class_resolveMethod 方法 Summary _class_resolveMethod Call +resolveClassMethod or +resolveInstanceMethod. Returns nothing; any result would be potentially out-of-date already. Does not check if the method already exists. class_resolveMethod 调用 +resolveClassMethod 或 +resolveInstanceMethod。 返回值为空；任何结果将可能已经过期。 如果方法已经存在，不会检查/执行。 由此可见resolveMethod 只是一个入口，会具体调用如下方法： 类方法：+resolveInstanceMethod 实例方法：+resolveInstanceMethod 具体的源码，见下面的： void _class_resolveMethod(Class cls, SEL sel, id inst) { if (! cls->isMetaClass()) { // try [cls resolveInstanceMethod:sel] _class_resolveInstanceMethod(cls, sel, inst); } else { // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] _class_resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { _class_resolveInstanceMethod(cls, sel, inst); } } } 代码 分析 备注 ! cls-&gt;isMetaClass() 是否元类 否，说明主体是实例 _class_resolveInstanceMethod 实例方法决议实现 _class_resolveClassMethod 类方法决议实现 _class_resolveInstanceMethod [第2个] 查看NSObject 决议实现 发生在lookUpImpOrNil 失败后 分析: 进入决议后，先确定是否是元类； 如果是元类，由于已知类方法存储在元类里，知道该方法主体是类，则会进入类方法决议 如果不是元类，即方法主题是实例，进入实例方法决议。 如果元类方法决议查找失败，根元类亦查找失败，由于根元类的isa 是指向自身的，所以用到了 _class_resolveInstanceMethod 的实例决议方法。 具体逻辑见下图： 3.2 类方法决议 - _class_resolveClassMethod捋清楚入口后，继续看类方法的决议，源码如下： /*********************************************************************** * _class_resolveClassMethod * Call +resolveClassMethod, looking for a method to be added to class cls. * cls should be a metaclass. * Does not check if the method already exists. **********************************************************************/ static void _class_resolveClassMethod(Class cls, SEL sel, id inst) { assert(cls->isMetaClass()); if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { // Resolver not implemented. return; } BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(_class_getNonMetaClass(cls, inst), SEL_resolveClassMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveClassMethod adds to self->ISA() a.k.a. cls IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); if (resolved &amp;&amp; PrintResolving) { if (imp) { _objc_inform(\"RESOLVE: method %c[%s %s] \" \"dynamically resolved to %p\", cls->isMetaClass() ? '+' : '-', cls->nameForLogging(), sel_getName(sel), imp); } else { // Method resolver didn't add anything? _objc_inform(\"RESOLVE: +[%s resolveClassMethod:%s] returned YES\" \", but no new implementation of %c[%s %s] was found\", cls->nameForLogging(), sel_getName(sel), cls->isMetaClass() ? '+' : '-', cls->nameForLogging(), sel_getName(sel)); } } } 分析上文的源码，除了一些断言、异常的保护代码外，关键语句来到了这一句 BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(_class_getNonMetaClass(cls, inst), SEL_resolveClassMethod, sel); 这里的函数msg 调用了3个参数 _class_getNonMetaClass(cls, inst) ：即类的本身 SEL_resolveClassMethod ： 决议的类方法 sel ：需要查找的方法编号 所以，关键的行为就是SEL_resolveClassMethod 方法，通过搜索，源码代码中均找不到。 回头看苹果给该方法写的注释： _class_resolveClassMethod Call +resolveClassMethod, looking for a method to be added to class cls. 意思是C 源码里写的方法，在OC 实现里，会执行+resolveClassMethod 的方法，即通过resolveClassMethod 来对该类进行决议——添加相应的类方法。 在OC里的实现即这个方法 + (BOOL)resolveClassMethod:(SEL)sel{ return NO; } 至此，已经大概明白了决议的意义——当方法找不到实现时，转发到类/实例决议方法里，看看开发者是否有自行实现。其最大的意义，恐怕是收集各种崩溃了。 3.3 实例方法决议 - class_resolveInstanceMethod实例方法决议的源码实现，与类方法决议类似，差别仅仅在决议执行方法，换成了SEL_resolveInstanceMethod，源码如下： BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(cls, SEL_resolveInstanceMethod, sel); 当决议方法得到实现后，会提示，方法XX 已经被决议成为新的实现YY—— 否则会提示决议未找到: if (resolved &amp;&amp; PrintResolving) { if (imp) { _objc_inform(\"RESOLVE: method %c[%s %s] \" \"dynamically resolved to %p\", cls->isMetaClass() ? '+' : '-', cls->nameForLogging(), sel_getName(sel), imp); } else { // Method resolver didn't add anything? _objc_inform(\"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES\" \", but no new implementation of %c[%s %s] was found\", cls->nameForLogging(), sel_getName(sel), cls->isMetaClass() ? '+' : '-', cls->nameForLogging(), sel_getName(sel)); } } 4、快速转发阶段4.1 快速转发方法forwardingTargetForSelector ：即将本类未实现的方法，交由指定的其他类来实现。 4.2 业务代码实现如下： 类Person, 与未实现的方法teach： @interface Person : NSObject - (void)teach; @end 类的转发方法——指定Teacher 这个类来执行 - (id)forwardingTargetForSelector:(SEL)aSelector { if (aSelector == @selector(teach)) { return [Teacher alloc]; } return [super forwardingTargetForSelector:aSelector]; } 类Teacher 以及实现的方法teach NS_ASSUME_NONNULL_BEGIN @interface Teacher : NSObject - (void)teach; @end NS_ASSUME_NONNULL_END @implementation Teacher - (void)teach{ NSLog(@\"%s\", __func__); } @end 主业务执行，使类执行它为实现的方法teach: int main(int argc, const char * argv[]) { @autoreleasepool { Person *person = [[Person alloc] init]; [person teach]; } return 0; } 执行结果，teacher类实现了teach： 2020-03-20 16:12:51.477020+0800 debug-objc[8565:349779] -[Teacher teach] 由此可见，forwardingTargetForSelector 的作用，是自身无法处理，交由其他对象（可能是类）来处理。 5、慢速转发阶段5.1 慢速转发方法methodSignatureForSelector，看看开发文档的描述： methodSignatureForSelector:Returns an NSMethodSignature object that contains a description of the method identified by a given selector. 返回一个NSMethodSignature 的签名对象，包含一个给定选择器的方法的描述 获取方法签名： methodSignatureForSelector 通过获取的签名，转发信息 –执行方法是 forwardInvocation往指定的对象传递方法和参数 5.2 业务代码实现:基础代码与快速转发一致，只是删除了forwardingTargetForSelector 的实现代码。 并在Person 类里实现如下代码 实现方法签名 // 获得方法签名 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { NSString *sel = NSStringFromSelector(aSelector); //生成签名 if ([sel isEqualToString:@\"run\"]) { return [NSMethodSignature signatureWithObjCTypes:\"v@:\"]; }else { return [super methodSignatureForSelector:aSelector]; } } “v” 是方法描述，更多的在这里： * 代表 char * char BOOL 代表 c : 代表 SEL ^type 代表 type * @ 代表 NSObject * 或 id ^@ 代表 NSError ** # 代表 NSObject v 代表 void 获取签名，进行配发信息 - (void)forwardInvocation:(NSInvocation *)anInvocation { NSLog(@\"-----%@-----\",anInvocation); //取得消息 SEL selector = [anInvocation selector]; //转发 SomePerson *someP = [SomePerson new]; if ([someP respondsToSelector:selector]) { //调用对象，进行转发 [anInvocation invokeWithTarget:someP]; } else { return [super forwardInvocation:anInvocation]; } } 执行teach 结果 2020-03-20 16:37:41.639718+0800 debug-objc[9325:370827] -[Teacher teach] 6、查找失败消息没有得到处理 崩溃退出，这里从forwardInvocation 的实现，可以追踪到相关的代码： - (void)forwardInvocation:(NSInvocation *)invocation { [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)]; } // Replaced by CF (throws an NSException) - (void)doesNotRecognizeSelector:(SEL)sel { _objc_fatal(\"-[%s %s]: unrecognized selector sent to instance %p\", object_getClassName(self), sel_getName(sel), self); } 7、 总结又到了最受欢迎的总结时间。 答案： 消息转发是什么：向指定的对象或类，发送需要消息，请求交由对方执行 消息转发的场景：自我无法实现的场景下。 如何进行消息转发 快速转发：使用 forwardingTargetForSelector 进行定向转发 慢速转发：获取签名，使用forwardInvocation 转发 有图另外，总结经验再多，不如有图有真相……","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/结构/"},{"name":"消息转发","slug":"消息转发","permalink":"http://nilsli.com/tags/消息转发/"},{"name":"objc","slug":"objc","permalink":"http://nilsli.com/tags/objc/"}]},{"title":"【休闲】西湖一瞥","slug":"glance-at-WestLake","date":"2020-03-09T12:11:20.000Z","updated":"2020-03-17T15:07:11.496Z","comments":true,"path":"2020/03/09/glance-at-WestLake/","link":"","permalink":"http://nilsli.com/2020/03/09/glance-at-WestLake/","excerpt":"","text":"逛次逛次的西湖今天过来平海路的Apple 直营店给电脑做大保健，顺便看了一眼西湖。 湖边景色依旧宜人，可惜游人寥寥。 期待一切顺利，然后恢复到游人如织的景色。","categories":[],"tags":[{"name":"休闲","slug":"休闲","permalink":"http://nilsli.com/tags/休闲/"},{"name":"杭州","slug":"杭州","permalink":"http://nilsli.com/tags/杭州/"},{"name":"西湖","slug":"西湖","permalink":"http://nilsli.com/tags/西湖/"},{"name":"Apple","slug":"Apple","permalink":"http://nilsli.com/tags/Apple/"}]},{"title":"方法的本质3_消息查找流程","slug":"wayOfCheckingMethod","date":"2020-03-06T08:33:26.000Z","updated":"2020-03-21T04:03:57.787Z","comments":true,"path":"2020/03/06/wayOfCheckingMethod/","link":"","permalink":"http://nilsli.com/2020/03/06/wayOfCheckingMethod/","excerpt":"","text":"本页所使用的objc runtime 756.2，来自GITHUB 1. 概念在前文中，已经总结了方法查找的流程，今天从代码层面上继续阐述。 isa 的指向图如下所示： 2. 方法查找流程2.1 从业务代码分析配置代码环境：，先从子类父类方法查找说起，先创建几个类，有: 父类 Person 继承自NSObject，有方法talk 子类 Student 继承自 Person，有方法 sayEnglish 扩展 NSObject + sayGerman，有方法 sayGerman 具体代码如下所示 主业务代码图： 由上图可以看出，我们生成的子类Student 对象，既可以执行自己的对象方法sayEnglish，也可以执行父类方法talk，当需要执行的方法——子类和父类都没有之后，也可以执行根类扩展方法sayGerman。 查找逻辑图可以初步理解为：子类——&gt; 父类——&gt; 父类的父类 ——&gt;根元类(NSObject) 类方法也是类似的，就不赘述 2.2 源码分析2.2.1 class_lookupMethodAndLoadCache3 - 慢速查找开启/*********************************************************************** * _class_lookupMethodAndLoadCache. * Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp(). * This lookup avoids optimistic cache scan because the dispatcher * already tried that. **********************************************************************/ IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls) { return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/); } 原来上文留下的class_lookupMethodAndLoadCache3 方法，最终执行的方法是lookUpImpOrForward，继续探究一下！ lookUpImpOrForward - 查找Imp 或转发消息乐观检查是否有缓存// Optimistic cache lookup if (cache) { imp = cache_getImp(cls, sel); if (imp) return imp; } 查找类是否缓存过 // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. runtimeLock.lock(); checkIsKnownClass(cls); 这里通过runtimeLock 锁住该部分内存，进行查找，执行了isKnownClass的方法，具体实现在这里 /*********************************************************************** * isKnownClass * Return true if the class is known to the runtime (located within the * shared cache, within the data segment of a loaded image, or has been * allocated with obj_allocateClassPair). **********************************************************************/ static bool isKnownClass(Class cls) { // The order of conditionals here is important for speed. We want to // put the most common cases first, but also the fastest cases // first. Checking the shared region is both fast and common. // Checking allocatedClasses is fast, but may not be common, // depending on what the program is doing. Checking if data segments // contain the address is slow, so do it last. return (sharedRegionContains(cls) || NXHashMember(allocatedClasses, cls) || dataSegmentsContain(cls)); } 在类的缓存（cache_t）找 // Try this class's cache. imp = cache_getImp(cls, sel); if (imp) goto done; 在类的方法列表里寻找 // Try this class's method lists. { Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) { log_and_fill_cache(cls, meth->imp, sel, inst, cls); imp = meth->imp; goto done; } } 在父类的缓存和方法列表寻找 // Try superclass caches and method lists. { unsigned attempts = unreasonableClassCount(); for (Class curClass = cls->superclass; curClass != nil; curClass = curClass->superclass) { // Halt if there is a cycle in the superclass chain. if (--attempts == 0) { _objc_fatal(\"Memory corruption in class list.\"); } 父类缓存（Cache）找 // Superclass cache. imp = cache_getImp(curClass, sel); if (imp) { if (imp != (IMP)_objc_msgForward_impcache) { // Found the method in a superclass. Cache it in this class. log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; } else { // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; } } 父类方法列表找 // Superclass method list. Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) { log_and_fill_cache(cls, meth->imp, sel, inst, curClass); imp = meth->imp; goto done; } 有可能内存覆盖，再给一次查找这里的核心方法是 // No implementation found. Try method resolver once. if (resolver &amp;&amp; !triedResolver) { runtimeLock.unlock(); resolveMethod(cls, sel, inst); runtimeLock.lock(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; } 父类也没有——查找失败——报错 // No implementation found, and method resolver didn't help. // Use forwarding. imp = (IMP)_objc_msgForward_impcache; 但是这个_objc_msgForward_impcache 的实现可不好找，在源码里只看到了这些： #if !OBJC_OLD_DISPATCH_PROTOTYPES extern void _objc_msgForward_impcache(void); 最终通过搜索查找_objc_msgForward_impcache，在汇编源码找到了类似的代码得到这个叫做__objc_forward_handler 的代码块，搜索得知它继承自objc_defaultForwardHandler， 继续查找，得到最终的源码如下： OH MY GOD! 原来这就是传说中——让程序员捶胸顿足的方法查找失败的代码 至此，方法查找的流程已经捋完。 3. 小结方法查找的流程，就是在类里查找缓存与方法列表里挖掘的过程。 如上文阐述： 方法查找：缓存查找 —— 类的方法列表 —— 父类的方法列表 （递归）—— 动态方法解析 —— 结束","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/类/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/结构/"},{"name":"objc","slug":"objc","permalink":"http://nilsli.com/tags/objc/"}]},{"title":"方法的本质2_从objc_msgSend谈起","slug":"startToLearnObjcSend","date":"2020-02-24T02:47:05.000Z","updated":"2020-03-17T15:07:11.581Z","comments":true,"path":"2020/02/24/startToLearnObjcSend/","link":"","permalink":"http://nilsli.com/2020/02/24/startToLearnObjcSend/","excerpt":"","text":"方法的本质，就是消息传递… 本页所使用的objc runtime 756.2，来自GITHUB 一、引子：Runtime概念我们都知道，在运行OC代码时，类或者对象在调用方法时会用到runtime，那么，到底什么是运行时呢？ 寻找一些资料后可以给出概念： In computer science, runtime, run time or execution time is the time when the CPU is executing the machine code.在计算机科学里，runtime，run time 或execution time 是指CPU 执行机器语言的期间。—— 维基百科 Runtime 是一套由C、C++、汇编混合写成的为OC提供运行时功能的api。 先看苹果开发者文档里对runtime 的介绍的介绍： The Objective-C runtime is a runtime library that provides support for the dynamic properties of the Objective-C language, and as such is linked to by all Objective-C apps. Objective-C runtime library support functions are implemented in the shared library found at /usr/lib/libobjc.A.dylib. OC runtime 是一个给OC语言动态属性提供支持的运行时库，这些属性链接到所有的OC应用 。OC runtime库支持在shared library里实现的函数，这些函数库名为/usr/lib/libobjc.A.dylib 版本 legacy：经典版 modern：现代版，即objc2.0，我们目前用到的版本。 二、方法的本质概念方法的本质，就是objc_msgSend 的消息传递。先看苹果开发者文档里对objc_msgSend的介绍： Function objc_msgSendSends a message with a simple return value to an instance of a class. 发送一个有简单返回值的消息给类的实例 相关源码如下: objc_msgSend(id _Nullable self, SEL _Nonnull op, ...) 其中两个关键参数self 和 op 的解释如下: * @param self A pointer to the instance of the class that is to receive the message. ​ self 一个指向由类生产的实例的指针，用来接收消息 * @param op The selector of the method that handles the message. ​ op 方法： 处理消息的方法的选择器 可见，objc_msgSend 的核心信息，就是向对象主体（self）传递相应的方法/消息（op）。 但是消息传递的机制到底怎样，还是用源码来解释。 源码分析开始生成一个main.m 内代码如下 int main(int argc, const char * argv[]) { @autoreleasepool { LGPerson *person = [LGPerson alloc]; [person sayHello]; // Setup code that might create autoreleased objects goes here. } return NSApplicationMain(argc, argv); } 其中LGPerson 的内部实现如下： @interface LGPerson : NSObject - (void)sayHello; - (void)sayNB; @end 在这里，着重查看LGPerson alloc 方法，以及其实例 person sayHello` 在汇编里的实现 : 进入到目录下，输入编译代码： clang -rewrite-objc main.m 得到main.cpp 的文件 打开main.cpp 结构如下: #pragma clang assume_nonnull end int main(int argc, const char * argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; LGPerson *person = ((LGPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"LGPerson\"), sel_registerName(\"alloc\")); ((void (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(\"sayHello\")); } return NSApplicationMain(argc, argv); } 上文代码中，可以简化为, Runtime 语法 OC 语法 (LGPerson ()(id, SEL))(void *) – (id)objc_getClass(“LGPerson”) [LGPerson class] sel_registerName(“alloc”) @selector(alloc) 即代码为： LGPerson *person = ((LGPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"LGPerson\"), sel_registerName(\"alloc\")); // 转换后 LGPerson *person = objc_msgSend([LGPerson class], @selector(alloc)); 解释为: 向LGPerson 的类，发送了alloc 方法 扩展代码实践开始设定一个类Student #import \"Student.h\" interface Student : Person - (void)sayCode; @end OC语法#import \"Student.h\" Student *student = [Student new]; [student sayCode]; NSObject 写法objc_msgSend(student, NSSelectorFromString(@\"sayCode\")); sel_registerName 的函数APIobjc_msgSend(student, sel_registerName(\"sayCode\")); 三、底层分析汇编源码 我们现在分析，当类对象发送消息是，底层发生了什么。 1、方法入口新建工程，输入如下代码，进行断点检测； 另外在Xcode 的Debug–Debug Workflow—Always show Disassembly 很明显，这里的Student sayCode 在汇编里，执行了 objc_msgSend 方法，继续查看 打开Xcode, 搜索objc_msgSend，找到相关结果如下： 由于研究的环境是移动平台，选择arm64，通过ENTRY _objc_msgSend结果进入 首先看到的代码如下： ENTRY _objc_msgSend UNWIND _objc_msgSend, NoFrame 1 cmp p0, #0 // nil check and tagged pointer check #if SUPPORT_TAGGED_POINTERS 2 b.le LNilOrTagged // (MSB tagged pointer looks negative) #else 3 b.eq LReturnZero #endif 2、类Tagged Pointer 检查代码解析： 序号 代码 解释 1 cmp p0 #0 cmp = compare检测0位寄存器 = 空？，以及tagged point 检测 2 b.le LNilOrTagged // 即1代码成立，跳转至LNilOrTagged的宏（下文叙述） 3 b.eq LReturnZero // b.eq 即不成立，结果为空，返回并跳出 这一小节，主要是用来判断 tagged pointer 是否存在，存在则继续进行，否则跳出。 Tagged point是苹果推出的针对64位机器的特定的指针，概念如下： 苹果对于Tagged Pointer特点的介绍： Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。 在内存读取上有着3倍的效率，创建时比以前快106倍。 3、加载isa这一部分主要是通过加载的isa，获取当前底层的类的实现 // person - isa - 类 ldr p13, [x0] // p13 = isa GetClassFromIsa_p16 p13 // p16 = class 序号 代码 解释 1 ldr p13, [x0] 将13位存储器isa 字，加载到0位寄存器LDR = LoaD woRd 2 GetClassFromIsa_p16 p13 通过加载的isa，宏逻辑获取到当前的类GetClassFromIsa_p16 是一个汇编宏 GetClassFromIsa_p16 的汇编实现如下: .macro GetClassFromIsa_p16 /* src */ #if SUPPORT_INDEXED_ISA // Indexed isa mov p16, $0 // optimistically set dst = src tbz p16, #ISA_INDEX_IS_NPI_BIT, 1f // done if not non-pointer isa // isa in p16 is indexed adrp x10, _objc_indexed_classes@PAGE add x10, x10, _objc_indexed_classes@PAGEOFF ubfx p16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS // extract index ldr p16, [x10, p16, UXTP #PTRSHIFT] // load class from array 1: #elif __LP64__ // 64-bit packed isa and p16, $0, #ISA_MASK #else // 32-bit raw isa mov p16, $0 #endif .endmacro 分析流程图如下： 4、用isa查询方法缓存当在3步，isa 拿到之后，现在要做的事情，就是对当前要执行的方法进行缓存查找。 LGetIsaDone: CacheLookup NORMAL // calls imp or objc_msgSend_uncached CacheLookup 在这里的做法是查询类里是否含有方法到缓存。 一般有两种结果：拿到缓存IMP，或者未曾缓存。 查询可以得到有三种查询方式: NORMAL 正常查找 GETIMP 获取IMP LOOKUP 慢速查询方法 根据源码，做了一些注释： 其中多次出现CheckMiss ,也是个汇编宏，使用在缓存查找失败后。 源码如下: .macro CheckMiss // miss if bucket->sel == 0 .if $0 == GETIMP cbz p9, LGetImpMiss .elseif $0 == NORMAL cbz p9, __objc_msgSend_uncached .elseif $0 == LOOKUP cbz p9, __objc_msgLookup_uncached .else .abort oops .endif .endmacro 根据查找的模式位NORMAL, 对应的*__objc_msgSend_uncached *。 在源码中搜索，得到相关逻辑如下： STATIC_ENTRY __objc_msgSend_uncached UNWIND __objc_msgSend_uncached, FrameWithNoSaves // THIS IS NOT A CALLABLE C FUNCTION // Out-of-band p16 is the class to search MethodTableLookup TailCallFunctionPointer x17 END_ENTRY __objc_msgSend_uncached 执行方法查找的核心方法，就是MethodTableLookup， 继续点开查看，得到的是 这里的内容，则是到objc_class 的 class_data_bits_t 里寻找方法的具体实现了，下一篇文章我们来讲。 四、小结这一篇，主要是开始从汇编的角度，来实现方法查找流程，流程草写了一下，图一定补。。。 拿到isa 查找Class 在Cache_t 查找bucket bucket 相同，返回IMP 否则 跳到BITS BITS 中 查找Rw 查找ro 查找methodList","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/类/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/结构/"},{"name":"objc","slug":"objc","permalink":"http://nilsli.com/tags/objc/"},{"name":"msgSend","slug":"msgSend","permalink":"http://nilsli.com/tags/msgSend/"}]},{"title":"方法的本质1--cache_t方法缓存分析","slug":"analyzeOfCacheT","date":"2020-01-20T17:18:38.000Z","updated":"2020-03-17T15:07:11.487Z","comments":true,"path":"2020/01/21/analyzeOfCacheT/","link":"","permalink":"http://nilsli.com/2020/01/21/analyzeOfCacheT/","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 1.概念1.1 objc_class 结构前面探索了类的结构，知道了类的结构本质上是objc_class的结构体，而在 C 源码例， objc_class 结构体的结构如下： struct objc_class : objc_object { // Class ISA; // 指向类的isa Class superclass; // 父类 cache_t cache; // 缓存的方法列表 // formerly cache pointer and vtable class_data_bits_t bits; // 缓存的属性和变量 // class_rw_t * plus custom rr/alloc flags 上一篇文章，具体分析了class_data_bits_t，那么上面的缓存cache_t 还没有展开学习，下面就继续进行讲解。","text":"本页所使用的objc runtime 756.2，来自GITHUB 1.概念1.1 objc_class 结构前面探索了类的结构，知道了类的结构本质上是objc_class的结构体，而在 C 源码例， objc_class 结构体的结构如下： struct objc_class : objc_object { // Class ISA; // 指向类的isa Class superclass; // 父类 cache_t cache; // 缓存的方法列表 // formerly cache pointer and vtable class_data_bits_t bits; // 缓存的属性和变量 // class_rw_t * plus custom rr/alloc flags 上一篇文章，具体分析了class_data_bits_t，那么上面的缓存cache_t 还没有展开学习，下面就继续进行讲解。 1.2 Cache_t 结构:cache_t 是objc_class 的重要组成属性，它主要用来存储方法。 struct cache_t { struct bucket_t *_buckets; // 缓存的方法列表 mask_t _mask; // 散列表的长度 mask_t _occupied; // 缓存过的方法数量 ****** } bucket 的定义 顾名思义是桶 ，装水的桶，装奥特曼的桶…… 在这里是一个hash表，计算公式是hash = sel 地址%mask，其中mask 是存放空间的大小，初始值是4。 通过源码查看，可以知道结构体如下： struct bucket_t { private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64. #if __arm64__ MethodCacheIMP _imp; // 方法实现 cache_key_t _key; // 方法编号 #else cache_key_t _key; MethodCacheIMP _imp; #endif 可以看到，这里缓存了MethodCacheIMP 方法，其中 MethodCacheIMP 是IMP的子类： MethodCacheIMP ——对于方法实现 cache_key_t ——对应方法缓存编号 2. 实现2.1方法缓存入口 入口引起我们注意的是如下这段代码: void cache_fill(Class cls, SEL sel, IMP imp, id receiver) { #if !DEBUG_TASK_THREADS mutex_locker_t lock(cacheUpdateLock); cache_fill_nolock(cls, sel, imp, receiver); #else _collecting_in_critical(); return; #endif } 代码解释： cache_fill 方法的缓存写入操作 cache_fill_nolock 线程解锁后的缓存写入 断言保护这里的方法cache_fill_nolock 就是我们的方法入口，为追求速度，执行的内容是无锁操作下的缓存填充，即对开辟的内存空间，进行方法写入，实现源码如下： static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver) { cacheUpdateLock.assertLocked(); // Never cache before +initialize is done if (!cls->isInitialized()) return; // Make sure the entry wasn't added to the cache by some other thread // before we grabbed the cacheUpdateLock. if (cache_getImp(cls, sel)) return; cache_t *cache = getCache(cls); cache_key_t key = getKey(sel); **** 代码解释： cacheUpdateLock.assertLocked() ：这里对内存区域锁定进行了跳出断言 if (!cls-&gt;isInitialized()) return; 对为初始化内存空间进行跳出断言 if (cache_getImp(cls, sel)) 对缓存空间已有该方法跳出断言 2.2 检查容量 在检查容量之前，cache_t 做了两个操作： 将类的引用地址转化成了cache 结构体: cache_t *cache = getCache(cls) 将方法编号sel 转换成了整型，方便寻址 cache_key_t key = getKey(sel) 容量为空检测 将方法缓存时，先确定是否为空对缓存。这里使用了 if (cache->isConstantEmptyCache()) { // Cache is read-only. Replace it. cache->reallocate(capacity, capacity ?: INIT_CACHE_SIZE); } 来判断空间是否为空，isConstantEmptyCache这个函数更详细的操作如下： return occupied() == 0 &amp;&amp; buckets() == emptyBucketsForCapacity(capacity(), false); 即occupied占位为空，而且容器桶 也无法从其他堆中空间共享空间，就必须重新开辟新的空间，开辟空间操作见 2.3。 扩容的条件： 扩容条件的操作为将当前容量 occupied + 1, 然后检查是否达到 3/4，超过则需要扩容；否则不需要扩容，直接进行缓存的写入，下面的代码足够明了的解释； // Use the cache as-is if it is less than 3/4 full mask_t newOccupied = cache->occupied() + 1; mask_t capacity = cache->capacity(); if (cache->isConstantEmptyCache()) { // Cache is read-only. Replace it. cache->reallocate(capacity, capacity ?: INIT_CACHE_SIZE); } else if (newOccupied &lt;= capacity / 4 * 3) { // Cache is less than 3/4 full. Use it as-is. } else { // Cache is too full. Expand it. cache->expand(); } 代码详解： mask_t newOccupied = cache-&gt;occupied() + 1 mask_t capacity = cache-&gt;capacity(); if (newOccupied &lt;= capacity / 4 * 3) 这里的 newOccupied 是当前的占用容量+1, 与目前的总容量 capacity 的 3/4 来做比较，这里使用占位+1 后来做比较，目的是提前准备，防止内存溢出。 2.3 内存扩容2.3.1 空间计算 扩容方法： 判断当前容量是否为空，若为空，就给初始化的内存为为4； 如果之前就有空间，则加倍。 void cache_t::expand() { cacheUpdateLock.assertLocked(); uint32_t oldCapacity = capacity(); uint32_t newCapacity = oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE; if ((uint32_t)(mask_t)newCapacity != newCapacity) { // mask overflow - can't grow further // fixme this wastes one bit of mask newCapacity = oldCapacity; } reallocate(oldCapacity, newCapacity); } 代码详解： oldCapacity 定义了当前的容量 如果 oldCapacity 为空，则立刻开辟大小为4 的空间。 否则，给当前空间加倍，即 oldCapacity*2，并在新空间内进行缓存空间开辟 reallocate。 2.3.2 新建容器reallocate新开内存空间的操作步骤： 确定是否可以释放旧空间 将开辟的空间和内存方法绑定，并将mask 和占位值occupied 归零。 void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity) { bool freeOld = canBeFreed(); bucket_t *oldBuckets = buckets(); bucket_t *newBuckets = allocateBuckets(newCapacity); // Cache's old contents are not propagated. // This is thought to save cache memory at the cost of extra cache fills. // fixme re-measure this assert(newCapacity > 0); assert((uintptr_t)(mask_t)(newCapacity-1) == newCapacity-1); setBucketsAndMask(newBuckets, newCapacity - 1); if (freeOld) { cache_collect_free(oldBuckets, oldCapacity); cache_collect(false); } } 代码讲解： bool freeOld = canBeFreed() 决定了是否可以释放旧内存。 bool cache_t::canBeFreed() { return !isConstantEmptyCache(); } 这里的canBeFreed依赖于isConstantEmptyCache的取反，即需要之前方法缓存有占位，并且旧bucket 本身容量不为空。 即以下源码里返回为空： bool cache_t::isConstantEmptyCache() { return occupied() == 0 &amp;&amp; buckets() == emptyBucketsForCapacity(capacity(), false); } 需要 occupied == 1, 以及 buckets() != emptyBucketsForCapacity(capacity(), false) setBucketsAndMask 用来初始化 新的bucket 和 occupied newCapacity - 1 更新索引，用来查询散列表里的元素。 cache_collect_free 用来释放旧容量（oldCapacity）下的旧方法数据（oldBuckets） 2.4 缓存写入2.4.1 查找缓存通过 cache-&gt;find 查找对应的缓存，如果没有找到，就添加新缓存，在这之前将占位occupied 添加1 ，实现源码如下： static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver) { *** // 找到对应的 bucket bucket_t *bucket = cache->find(key, receiver); if (bucket->key() == 0) cache->incrementOccupied(); bucket->set(key, imp); } void cache_t::incrementOccupied() { _occupied++; // 占位增加 } 2.4.2 未扩容过找到之前的bucket，按照编号和方法，写入缓存: bucket_t *bucket = cache->find(key, receiver); bucket->set(key, imp); 2.4.3 缓存写入实现void bucket_t::set(cache_key_t newKey, IMP newImp) { assert(_key == 0 || _key == newKey); // objc_msgSend uses key and imp with no locks. // It is safe for objc_msgSend to see new imp but NULL key // (It will get a cache miss but not dispatch to the wrong place.) // It is unsafe for objc_msgSend to see old imp and new key. // Therefore we write new imp, wait a lot, then write new key. _imp = newImp; if (_key != newKey) { mega_barrier(); _key = newKey; } } 代码详解： 注释中写明了： objc_msgSend 在无锁环境下使用key 和 imp 实现。 objc_msgSend 查看到新的imp 实现是安全的，除了空的key地址外。（可能会造成小的缓存丢失，但是并不会分发到错误的空间） objc_msgSend 旧的imp 和新的key 是不安全的，因此我们先写新imp，等一会儿，再写新的 key 代码中的 mega_barrier 就是 使用了阻塞，让方法先看到imp ，保证线程的安全。 3. 总结3.1 梳理cache_t 起源于 OC中的方法传递，也就是objc_msgSend 的实现。在类的方法传递时，为了追求，先去cache_t 中查找是否有缓存，如果有，可以直接调用，如果没有缓存，则需要对类进行一系列的内存空间确认，进行imp - key 的写入，并进行最终调用。 这一章节应该是目前分析最难的，花了大概三到四天弄明白，希望这艰难的一步能为以后的分析打好更好的基础。 3.2 流程图","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/类/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/结构/"},{"name":"cache_t","slug":"cache-t","permalink":"http://nilsli.com/tags/cache-t/"}]},{"title":"OC底层研究4--类的结构分析","slug":"StructOfClass","date":"2020-01-12T06:00:53.000Z","updated":"2020-03-17T15:07:11.485Z","comments":true,"path":"2020/01/12/StructOfClass/","link":"","permalink":"http://nilsli.com/2020/01/12/StructOfClass/","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 1.概念1.1 类Class 的类型 Class在源码里的真正类型为objc_class的结构体。 先查看源码——在Xcode按下Shift+Command+O，选择objc-runtime-new.h，搜索objc_class，可以得知，Class底层编译实现的前4行如下： 可知类结构如下： A. //Class ISA ​ 继承自父类 objc_class 的 isa ，指向类的指针不需显示（内存占8位），这里它返回一个nonpointer的指针，相关源码如下： /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; B. Class superclass; ​ 指向本类的父类（内存占8位） C. cache_t cache; ​ 存储指针和vtable，加速方法调用（内存占8位） D. class_data_bits_t bits; ​ 存储类的方法、属性、遵循的协议等信息的地方（内存占8位） E. 其他方法/函数 – 不占内存 为何cache_t cache 这个变量占位位16，而不是8？ 原因是因为这里的cache_t是结构体，其占内存为根据内部属性结构而定，为防止溢出，给予16位字节，而不是指针所需的8位。 Talk is cheap, show me the code, 伸伸手指，点开cache_t 的内部结构","text":"本页所使用的objc runtime 756.2，来自GITHUB 1.概念1.1 类Class 的类型 Class在源码里的真正类型为objc_class的结构体。 先查看源码——在Xcode按下Shift+Command+O，选择objc-runtime-new.h，搜索objc_class，可以得知，Class底层编译实现的前4行如下： 可知类结构如下： A. //Class ISA ​ 继承自父类 objc_class 的 isa ，指向类的指针不需显示（内存占8位），这里它返回一个nonpointer的指针，相关源码如下： /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; B. Class superclass; ​ 指向本类的父类（内存占8位） C. cache_t cache; ​ 存储指针和vtable，加速方法调用（内存占8位） D. class_data_bits_t bits; ​ 存储类的方法、属性、遵循的协议等信息的地方（内存占8位） E. 其他方法/函数 – 不占内存 为何cache_t cache 这个变量占位位16，而不是8？ 原因是因为这里的cache_t是结构体，其占内存为根据内部属性结构而定，为防止溢出，给予16位字节，而不是指针所需的8位。 Talk is cheap, show me the code, 伸伸手指，点开cache_t 的内部结构 我们来看看属性： bucket_t， 结构体，占8位字节 mask_t，点开后具体实现为如下： typedef uint32_t mask_t; ​ 为整型，占4个字节 mask_t typedef uint32_t mask_t; ​ 也是整形，占4个字节 共计8+4+4 = 16个字节 1.2 objc_class继承在底层实现里，objc_class 继承自objc_object 的结构体 /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; 1.3 关于NSobject 万物皆对象 - Class 继承自NSObject @interface NSObject &lt;NSObject> { #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY; #pragma clang diagnostic pop } 2. 类的属性与成员变量 属性的存储上面提到了类对象的结构原理，我们知道了类结构里，类型位class_data_bits_t 的bits下面我们来探寻一下，类里面的属性上怎么保存的。 我们在代码里生成一个类，分别有成员变量hobby，以及属性nickName 代码如下: @interface Person : NSObject{ NSString *hobby; } @property (nonatomic, copy) NSString *nickName; 在主线代码引入: int main(int argc, const char * argv[]) { @autoreleasepool { LGPerson *person = [LGPerson alloc]; Class pClass = object_getClass(person); NSLog(@\"%@ -- %p\", person, pClass); } return 0; } 然后打印得到的类pClass，通过x/4gx 获取类结构如下： (lldb) x/4gx pClass 0x1000023d0: 0x001d8001000023a9 0x0000000100b37140 0x1000023e0: 0x00000001003da280 0x0000000000000000 观察结果得知0x1000023d0 位pClass在内存中的首地址，根据内存偏移原则，加上16+8+8共32位，即可得到bits的结构。 0x1000023d0，偏移32位，得到0x1000023f0。注意，这里要用p打印指针，而非打印值用的po (lldb) p 0x1000023f0 4294976496 oh NO！得到的是具体的值，这里需要强转一下： (lldb) p (class_data_bits_t *)0x1000023f0 (class_data_bits_t *) $3 = 0x00000001000023f0 得到$3 的值，并不是我们想要的结构，留意到objc_class里的方法 data() 方法: struct objc_class : objc_object { // Class ISA; // 8 Class superclass; // 8 cache_t cache; // 16 不是8 // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } data() 返回是class_rw_t，点进去看看， struct class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName; 留意到里面有 methods、properties、protocols等，原来这里等值便是类的相关属性方法等等结构。 现在对$3 执行data() 方法: (lldb) p $3->data() (class_rw_t *) $5 = 0x0000000000000000 对得到的$5 进行值打印: (lldb) p *$5 (class_rw_t) $5 = { flags = 2148139008 version = 0 ro = 0x0000000100002308 methods = { list_array_tt&lt;method_t, method_list_t> = { = { list = 0x0000000100002240 arrayAndFlag = 4294976064 } } } properties = { list_array_tt&lt;property_t, property_list_t> = { = { list = 0x00000001000022f0 arrayAndFlag = 4294976240 } } } protocols = { list_array_tt&lt;unsigned long, protocol_list_t> = { = { list = 0x0000000000000000 arrayAndFlag = 0 } } } firstSubclass = nil nextSiblingClass = NSUUID demangledName = 0x0000000000000000 } 如上所示，$5 内结构一目了然，方法，属性，协议都显示了。 继续获取属性值: (lldb) p $5.properties (property_array_t) $7 = { list_array_tt&lt;property_t, property_list_t> = { = { list = 0x00000001000022f0 arrayAndFlag = 4294976240 } } } 得到一个二维数组的$7，观察属性列表的类型为property_array_t，继承自list_array_tt，内部拥有 (lldb) p $7.list (property_list_t *) $8 = 0x00000001000022f0 再次对$8 进行* 取值，得到如下结果： (lldb) p *$8 (property_list_t) $9 = { entsize_list_tt&lt;property_t, property_list_t, 0> = { entsizeAndFlags = 16 count = 1 first = (name = \"nickName\", attributes = \"T@\\\"NSString\\\",C,N,V_nickName\") } } 从结果可以看出，我们的属性，就保存在properties 里中。 成员变量的存储上面分析了属性的存储，但是我们没有看到成员变量 hobby,我们在properties 属性里，没有看到它，到底在哪里呢?下面我们继续查找。 既然不在properties 里，那尝试一下在$5 的 ro 里进行取值 (lldb) p $5.ro (const class_ro_t *) $10 = 0x0000000100002308 得到class_ro_t 类型的结构体，继续对他取值 (lldb) p *$10 (const class_ro_t) $11 = { flags = 388 instanceStart = 8 instanceSize = 24 reserved = 0 ivarLayout = 0x0000000100001f8a \"\\x02\" name = 0x0000000100001f81 \"LGPerson\" baseMethodList = 0x0000000100002240 baseProtocols = 0x0000000000000000 ivars = 0x00000001000022a8 weakIvarLayout = 0x0000000000000000 baseProperties = 0x00000001000022f0 } 值这里可以看到ivars，就是我们需要的变量列表，打印一下： (lldb) p $11.ivars (const ivar_list_t *const) $12 = 0x00000001000022a8 继续对 ivar_list_t 类型的$12 取值: (lldb) p *$12 (const ivar_list_t) $13 = { entsize_list_tt&lt;ivar_t, ivar_list_t, 0> = { entsizeAndFlags = 32 count = 2 first = { offset = 0x0000000100002378 name = 0x0000000100001e64 \"hobby\" type = 0x0000000100001fa7 \"@\\\"NSString\\\"\" alignment_raw = 3 size = 8 } } } (lldb) p $.first (const ivar_t) $13 = { offset = 0x0000000100002378 name = 0x0000000100001e64 \"hobby\" type = 0x0000000100001fa7 \"@\\\"NSString\\\"\" alignment_raw = 3 size = 8 } 可以看到成员变量存在类的 ivars 属性里 3. 类的方法3.1 类的实例方法我们继续对类进行代码编辑，对Person类添加实例方法和类方法 - (void)sayHello; // 实例方法 + (void)sayHappy; // 类方法 还是对类结构$5 进行解析，这次我们打印它的 methods 属性 (lldb) p $5.methods (method_array_t) $14 = { list_array_tt&lt;method_t, method_list_t> = { = { list = 0x0000000100002240 arrayAndFlag = 4294976064 } } } 得到的是method_array_t 类型的$14, 是个数组类型，继续打印: (lldb) p $14.list (method_list_t *) $15 = 0x0000000100002240 (lldb) p *$15 (method_list_t) $16 = { entsize_list_tt&lt;method_t, method_list_t, 3> = { entsizeAndFlags = 26 count = 4 first = { name = \"sayHello\" types = 0x0000000100001f8c \"v16@0:8\" imp = 0x0000000100001b90 (LGTest`-[LGPerson sayHello] at LGPerson.m:13) } } } 可见，实例方法sayHello 方法，存储在类的methods属性里 3.2 类的类方法存储类方法在上述的过程中没有看到，那么它会在哪里呢? 为了找到它，我们重新回到最初的pClass (lldb) x/4gx pClass 0x1000023b0: 0x001d800100002389 0x0000000100b37140 0x1000023c0: 0x00000001003da280 0x0000000000000000 得到isa值为0x001d800100002389，这时，唤出它的掩码 ISA_MASK 来获取它的元类 (lldb) p/x 0x001d800100002389 &amp; 0x0000000ffffffff8 (long) $1 = 0x0000000100002388 继续对元类$1的结构进行解析： (lldb) x/4gx 0x0000000100002388 0x100002388: 0x001d800100b370f1 0x0000000100b370f0 0x100002398: 0x0000000100f946c0 0x0000000100000003 可知0x100002388是这个元类的地址，根据上文提到的内存便宜，我们继续加上2个16进制位，得到0x1000023a8，p一下： (lldb) p (class_data_bits_t *)$2 (class_data_bits_t *) $3 = 0x00000001000023a8 继续执行上文实例方法类似的方案，执行data() — 取值 – 获取methods 的思路，具体代码如下： (lldb) p $3->data() (class_rw_t *) $4 = 0x0000000100f94620 (lldb) p *$4 (class_rw_t) $5 = { flags = 2685075456 version = 7 ro = 0x00000001000021f8 methods = { list_array_tt&lt;method_t, method_list_t> = { = { list = 0x00000001000021d8 arrayAndFlag = 4294975960 } } } properties = { list_array_tt&lt;property_t, property_list_t> = { = { list = 0x0000000000000000 arrayAndFlag = 0 } } } protocols = { list_array_tt&lt;unsigned long, protocol_list_t> = { = { list = 0x0000000000000000 arrayAndFlag = 0 } } } firstSubclass = nil nextSiblingClass = 0x00007fff942e6990 demangledName = 0x0000000000000000 } (lldb) p $5.methods (method_array_t) $10 = { list_array_tt&lt;method_t, method_list_t> = { = { list = 0x00000001000021d8 arrayAndFlag = 4294975960 } } } (lldb) p $10.list (method_list_t *) $11 = 0x00000001000021d8 (lldb) p *$11 (method_list_t) $12 = { entsize_list_tt&lt;method_t, method_list_t, 3> = { entsizeAndFlags = 26 count = 1 first = { name = \"sayHappy\" types = 0x0000000100001f8c \"v16@0:8\" imp = 0x0000000100001bc0 (LGTest`+[LGPerson sayHappy] at LGPerson.m:17) } } } (lldb) 可见，类方法sayHappy 方法，存储在类的元类 methods属性里 4. 总结 类的本质上一个类型为objc_class的结构体，包含有isa、父类、属性、成员变量及方法列表等 类属性存在结构体的properties里 类的成员变量存在结构体的 ivars里 类的实例方法，存在结构体 的methods 属性里 类的类方法，存在父类的class_ro_t 里的methods里 如下图示：","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"类","slug":"类","permalink":"http://nilsli.com/tags/类/"},{"name":"结构","slug":"结构","permalink":"http://nilsli.com/tags/结构/"}]},{"title":"2020新年感想","slug":"newyearnote","date":"2020-01-01T16:39:53.000Z","updated":"2020-03-17T15:07:11.554Z","comments":true,"path":"2020/01/02/newyearnote/","link":"","permalink":"http://nilsli.com/2020/01/02/newyearnote/","excerpt":"","text":"2020年是一个闰年，第一天从星期三开始。 今天看了小羊肖恩大电影，故事讲得真好看，小朋友全程开心，全情投入，大朋友也觉得耳目一新，深受感动。 这是我们带他看的第一部电影，新的一年，从第一开始。 用一句涂鸦来鼓舞自己 宁愿最后徒劳无功， 也不选择无动于衷。 希望今年也有始有终，有所收获。","categories":[],"tags":[{"name":"2020","slug":"2020","permalink":"http://nilsli.com/tags/2020/"},{"name":"感想","slug":"感想","permalink":"http://nilsli.com/tags/感想/"}]},{"title":"OC底层研究3--isa的初始化和指向分析","slug":"initialOfIsaNDirection","date":"2019-12-27T07:05:19.000Z","updated":"2020-03-17T15:07:11.535Z","comments":true,"path":"2019/12/27/initialOfIsaNDirection/","link":"","permalink":"http://nilsli.com/2019/12/27/initialOfIsaNDirection/","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 开始继续学习研究OC源码，这次研究的是isa的初始化和指向分析。 1. 概念什么是isa看看苹果文档的介绍： isa A Pointer to the class definition of which this object is an instance. isa ： 一个指向该对象的类的指针。 打开Xcode，找到objc.h，我们可以看看到如下代码 #if !OBJC_TYPES_DEFINED /// An opaque type that represents an Objective-C class. /// 一个展示OC类的未知的类型 typedef struct objc_class *Class; /// Represents an instance of a class. /// 展示一个类的实例 struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. /// 一个指向类的实例的指针 typedef struct objc_object *id; #endif 可以看出，Class 是一个objc_class 类型的结构体。 而id类型，则是objc_object 类型的结构体.","text":"本页所使用的objc runtime 756.2，来自GITHUB 开始继续学习研究OC源码，这次研究的是isa的初始化和指向分析。 1. 概念什么是isa看看苹果文档的介绍： isa A Pointer to the class definition of which this object is an instance. isa ： 一个指向该对象的类的指针。 打开Xcode，找到objc.h，我们可以看看到如下代码 #if !OBJC_TYPES_DEFINED /// An opaque type that represents an Objective-C class. /// 一个展示OC类的未知的类型 typedef struct objc_class *Class; /// Represents an instance of a class. /// 展示一个类的实例 struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. /// 一个指向类的实例的指针 typedef struct objc_object *id; #endif 可以看出，Class 是一个objc_class 类型的结构体。 而id类型，则是objc_object 类型的结构体. 2. isa 的初始化在此之前，先回顾一下对象初始化的流程图 在这里，初始化实例的isa，其中 cls 为初始化的类对象，hasCxxDtor 即为是否含有C++的析构器。 我们进入 initIsa(cls, true, hasCxxDtor) 这个函数，看看内部实现了什么 2.1 isa非nonpointerif (!nonpointer) { isa.cls = cls; } nonpointer概念: 表示是否对isa 指针开启指针优化 ​ 0: 纯isa指针 ​ 1: 不止是类对象的地址，还包含类信息、对象的引用计数等。 此时，如果为纯isa指针，将当前类 cls 赋值给 isa 的绑定属性 cls 为什么有这个绑定属性，而isa究竟是什么看结构呢？ 点击isa.cls = cls;中的cls查看它的结构，如下： union isa_t { isa_t() { } // isa 初始化方法 isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; #if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // defined in isa.h }; #endif }; 可以看见isa 是一个 union，联合体，里面包含了 isa_t 初始化方法 isa_t(uintptr_t value) 工厂方法 Class cls 绑定属性 结构体ISA_BITFIELD位域 ISA_BITFIELD概念 我们点开类型为struct的ISA_BITFIELD，结构如下： # if __arm64__ # define ISA_MASK 0x0000000ffffffff8ULL # define ISA_MAGIC_MASK 0x000003f000000001ULL # define ISA_MAGIC_VALUE 0x000001a000000001ULL # define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19 # define RC_ONE (1ULL&lt;&lt;45) # define RC_HALF (1ULL&lt;&lt;18) NONPOINTER_ISA效果图（手绘中，待补全……） 还原isa_t 的结构 我们这时发现，isa的整体结构可以替换为如下的样子: union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; #if defined(ISA_BITFIELD) struct { uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19; // ISA_BITFIELD; // defined in isa.h }; #endif }; nonpointer: 表示是否对 isa 指针开启指针优化 0:纯isa指针，1:不止是类对象地址,isa 中包含了类信息、对象的引用计数等（占1位） has_assoc: 关联对象标志位，0没有，1存在（占1位） has_cxx_dtor: 该对象是否有 C++ 或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更快的释放对象（占1位） shiftcls:存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位用来存储类指针。（占33位） magic:用于调试器判断当前对象是真的对象还是没有初始化的空间 weakly_referenced:志对象是否被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放。（占6位） deallocating:标志对象是否正在释放内存（占1位） has_sidetable_rc:当对象引用计数大于 10 时，则需要借用该变量存储进位（占1位） extra_rc:当表示该对象的引用计数值，实际上是引用计数值减 1， 例如，如果对象的引用计数为 10，那么 extra_rc 为 9。如果引用计数大于 10， 则需要使用到下面的 has_sidetable_rc。（占1位） 2.2 isa是nonpointer类型 isa_t newisa(0); #if SUPPORT_INDEXED_ISA assert(cls->classArrayIndex() > 0); newisa.bits = ISA_INDEX_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls->classArrayIndex(); #else newisa.bits = ISA_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls >> 3; #endif 生成新的isa: isa_t newisa(0); c++ 析构器： newisa.has_cxx_dtor = hasCxxDtor;` 表示当前对象是否有C++的析构函数（destructor）,如果没有，释放时会快速的释放内存。 位域赋值 newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;对存储指针的值进行右移动3位赋值。 返回isa isa = newisa; 3. isa 的指向3.1 指向图：关于isa的指向以及子类父类的关系，苹果官方给出了一张图如下所示： 3.2 代码分析3.2.1 对象的isa我们执行一项代码如下，并对该行打断点： Person *object = [Person alloc]; 我们知道：对象里的 isa ——指向——&gt; 类。 3.2.2类的isa现在我们想知道类的内存空间结构，在控制台执行如下指令x/4gx Person.class，结果如下： (lldb) x/4gx Person.class 0x100001130: 0x001d800100001109 0x0000000100b39140 0x100001140: 0x0000000101a46ed0 0x0000000200000007 由于isa是类对象的第一个属性，我们知道0x001d800100001109是改对象的isa，我们看看他指向哪里呢，使用p/x 指令试试: (lldb) p/x 0x001d800100001109 (long) $16 = 0x001d800100001109 糟糕，查看不到结果？怎么回事？类的isa 格式需要强转，可以退一步，打印类的地址试试： po 0x100001130 Person 原来如此，在内存空间里，名为Person的类的第一个位置，指向Person类，岂不是循环指向了？ 非也非也，这里指向的类，我们把它称为元类（meta-class） 类的isa ——指向——&gt; 元类 3.2.3 元类的isa我们现在获得元类的具体地址，找到isa 的MASK（掩码），值为0x00007ffffffffff8， 输入以下指令： (lldb) p/x 0x001d800100001109 &amp; 0x00007ffffffffff8 (long) $17 = 0x0000000100001108 (lldb) po 0x0000000100001108 Person 得到元类地址为：0x0000000100001108，16进制打印一下： (lldb) x/4gx 0x0000000100001108 0x100001108: 0x001d800100b390f1 0x0000000100b390f0 0x100001118: 0x0000000100f5a480 0x0000000400000007 可以看到元类结构里，isa指针为 0x001d800100b390f1，继续获取它的指向，我们通过与掩码来计算： (lldb) p/x 0x001d800100b390f1 &amp; 0x00007ffffffffff8 (long) $21 = 0x0000000100b390f0 好嘞，拿到内存指针地址为0x0000000100b390f0， 打印一下： po 0x0000000100b390f0 NSObject 至此，我们可以看到元类的isa指向它的上一级元类，也就是跟元类(root meta-class)，为NSObject。 所以得出: 元类的isa ——指向——&gt; 根元类 3.2.4 根元类的isa我们打印下根元类结构： x/4gx 0x0000000100b390f0 0x100b390f0: 0x001d800100b390f1 0x0000000100b39140 0x100b39100: 0x0000000101a47020 0x0000000500000007 拿到它的isa，与掩码继续进行与运算 p/x 0x001d800100b390f1 &amp; 0x00007ffffffffff8 (long) $27 = 0x0000000100b390f0 得到的结果0x0000000100b390f0，与根元类0x0000000100b390f0，完全吻合。 至此，我们得出结论：根元类的isa ——指向——&gt; 根类NSObject。 什么？你不信，这些都是猜测，证实一下？ 好的，创建如下代码 void TestNSObject(){ // NSObject实例对象 NSObject *object1 = [NSObject alloc]; // NSObject类 Class class = object_getClass(object1); // NSObject元类 Class metaClass = object_getClass(class); // NSObject根元类 Class rootMetaClass = object_getClass(metaClass); // NSObject根根元类 Class rootRootMetaClass = object_getClass(rootMetaClass); NSLog(@\"\\n%p 实例对象\\n%p 类\\n%p 元类\\n%p 根元类\\n%p 根根元类\",object1,class,metaClass,rootMetaClass,rootRootMetaClass); } 打印结果如下： 0x10066ddc0 实例对象 0x7fff9294a118 类 0x7fff9294a0f0 元类 0x7fff9294a0f0 根元类 0x7fff9294a0f0 根根元类 可见，除了NSObject 类是独有的创建，其他元类、根元类、根根元类，都是一样的，因为都是NSObject，所以结果得到了证明。 3.3 总结：我们再回到这幅图，最红是这样的： isa指向： 对象中的isa——&gt; 类 类中的isa ——&gt; 元类 元类中的isa —-&gt; 根元类 根元类中的isa —-&gt; 根元类 类继承关系： 子类 ———superClass——— 父类 父类 ———superClass——— 根元类 根元类 ———superClass——— NSObject NSObject ———superClass——— nil","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"对齐","slug":"对齐","permalink":"http://nilsli.com/tags/对齐/"},{"name":"内存","slug":"内存","permalink":"http://nilsli.com/tags/内存/"}]},{"title":"OC底层研究2--内存对齐原理","slug":"memoryAlignPrinciple","date":"2019-12-22T03:05:11.000Z","updated":"2020-03-17T15:07:11.543Z","comments":true,"path":"2019/12/22/memoryAlignPrinciple/","link":"","permalink":"http://nilsli.com/2019/12/22/memoryAlignPrinciple/","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 开始继续学习研究OC源码，今天看的是OC的内存原理，以及对齐原理的分析。 1.概念内存对齐在数据结构中，是比较基础也比较重要的一环，对于iOS开发，研究底层更免不了要了解他们的原理，方便我们更透彻的学习iOS的原理。 我们先来一段维基百科的数据结构对齐的相关知识。 内存对齐，也可以理解为数据结构对齐（Data structure alignment），是代码编译后在内存的布局与使用方式。包括三方面内容：数据对齐、数据结构填充（padding）与包入（packing）。 下图是内存中各类型属性所占的空间大小：","text":"本页所使用的objc runtime 756.2，来自GITHUB 开始继续学习研究OC源码，今天看的是OC的内存原理，以及对齐原理的分析。 1.概念内存对齐在数据结构中，是比较基础也比较重要的一环，对于iOS开发，研究底层更免不了要了解他们的原理，方便我们更透彻的学习iOS的原理。 我们先来一段维基百科的数据结构对齐的相关知识。 内存对齐，也可以理解为数据结构对齐（Data structure alignment），是代码编译后在内存的布局与使用方式。包括三方面内容：数据对齐、数据结构填充（padding）与包入（packing）。 下图是内存中各类型属性所占的空间大小： 列举一下各数据类型所占字节（32位）： A char (one byte) will be 1-byte aligned. A short (two bytes) will be 2-byte aligned. An int (four bytes) will be 4-byte aligned. A long (four bytes) will be 4-byte aligned. A float (four bytes) will be 4-byte aligned. A double (eight bytes) will be 8-byte aligned on Windows and 4-byte aligned on Linux (8-byte with -malign-double compile time option). A long long (eight bytes) will be 4-byte aligned. A long double (ten bytes with C++Builder and DMC, eight bytes with Visual C++, twelve bytes with GCC) will be 8-byte aligned with C++Builder, 2-byte aligned with DMC, 8-byte aligned with Visual C++, and 4-byte aligned with GCC. Any pointer (four bytes) will be 4-byte aligned. (e.g.: char, int) 需要注意的是，在64位机上，有以下不同 A long (eight bytes) will be 8-byte aligned. A double (eight bytes) will be 8-byte aligned. A long long (eight bytes) will be 8-byte aligned. A long double (eight bytes with Visual C++, sixteen bytes with GCC) will be 8-byte aligned with Visual C++ and 16-byte aligned with GCC. Any pointer (eight bytes) will be 8-byte aligned. 2. 原则 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在32位机为４字节,则要从４的整数倍地址开始存储。 结构体作为成员: 如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.) 收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐. 3. 实践3.1 属性8字节对齐：当创建对象时，其属性的按类型占据不同的内存空间，但是由于大小不一，需要进行补齐；原则则是以第一位补齐为8的倍数（64位系统是8为对齐，而32位系统是4位对齐）。 以下面的代码举例子 struct MyStruct { double a; char b; // 第2行 char 在前 int 在后 int c; short d; } MyStr1; struct MyStruct2 { double a; int c; // 第2行 int 在前 char 在后 char b; short d; } MyStr2; // 我们打印一下各自的所占空间 NSLog(@\"%lu -- %lu\",sizeof(MyStr1), sizeof(MyStr2)); 结果如下: 为何两者不一致? 我们来看第一个结构体对象的内部结构，排第一的属性double占8位，而char需要补齐7位成为8位，而剩余的int，short 则分别占4位，不需补齐，可以灵活堆在同一个内存区域。 struct MyStruct { double a; // 8位 char b; // 1位 + 7 补齐 = 8 int c; // 4位 short d; // 4位 } MyStr1; 总计是 8 + 8 + 4 + 4 = 24； 而第二个结构体对象，排第一的属性double占8位，而剩余的int，short ，short 总计都，不需补齐，可以灵活堆在同一个内存区域。 struct MyStruct2 { double a; // 8 int c; // 4 char b; // 1 补齐1位 short d; // 2 } MyStr2; 这里后3位，可以放到一个8位内存区间，即4 + 1 + 2，只需补齐1位至8位，可以灵活排列在一个内存空间内，所以本结构体对象总占内存为8+4+1+2 + 1（补齐1位） = 16。 如果没有弄懂，我们找出源码来读一读：(/objc/Private Headers/Project Headers/objc-os.h) 创建对象 alloc alloc方法的实现——返回rootAlloc方法 返回callAlloc的实现 当缓存区没有对象时，创建对象 去内存区域创建对象 执行类的属性方法，确定创建的空间大小 对齐内存 内存对齐的返回：类的属性大小取决于指针大小 8字节对齐：实现方法 3.2 对象16字节对齐在OC 底层研究1–alloc和init原理 我们分析过，iOS环境下，为了容错处理，创建。 在 libmalloc/src/nano_malloc.c 第193行，我们发现如下的代码: 而其中NANO_REGIME_QUANTA_SIZE 为16， SHIFT_NANO_QUANTUM 为4 那可以开始分析源码如下： if (0 == size) { size = NANO_REGIME_QUANTA_SIZE; // Historical behavior } 这里的意思是，如果size为0，即创建空对象，返回16位默认空间。 而 k = (size + NANO_REGIME_QUANTA_SIZE - 1) >> SHIFT_NANO_QUANTUM 是向右移动4位，即16字节对齐，那究竟是怎么实现的，我们不妨来看下，假定给定申请的内存size 为40，那么 40(size) + 16 - 1 = 55 0011 0111 // 55 的2进制显示 0000 0011 // >> 右移动4位 == 3 0011 0000 // 执行 slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; 左移动4位 slot_bytes = 48(0011 0000) er, 第205行中返回的slot_bytes 即是最终对齐后的内存空间位，即给入40，最终系统对齐后，返回48位(16的整数位)。 4 结论在iOS环境下，我们创建的对象和指针遵循16位对齐的原则，而其属性位8字节对齐。","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"对齐","slug":"对齐","permalink":"http://nilsli.com/tags/对齐/"},{"name":"内存","slug":"内存","permalink":"http://nilsli.com/tags/内存/"}]},{"title":"OC 底层研究1--alloc和init原理","slug":"pricipleofalloc","date":"2019-12-16T07:31:51.000Z","updated":"2020-03-17T15:07:11.572Z","comments":true,"path":"2019/12/16/pricipleofalloc/","link":"","permalink":"http://nilsli.com/2019/12/16/pricipleofalloc/","excerpt":"本页所使用的objc runtime 756.2，来自GITHUB 1. 题目开始学习研究OC源码，今天看的是对象的初始化，也就是alloc以及init的分析。 2. 附流程图如下 3. 内容3.1引子我们先看一段代码，Person类的初始化，打印p1,p2,p3对象，以及指向他们的指针： Person *p1 = [Person alloc]; Person *p2 = [p1 init]; Person *p3 = [p1 init]; NSLog(@&quot;%@ -- %p&quot;, p1, &amp;p1); NSLog(@&quot;%@ -- %p&quot;, p2, &amp;p2); NSLog(@&quot;%@ -- %p&quot;, p3, &amp;p3); 打印结果是： 这里为什么p1相同的情况下，经过init后的p2，p3 的地址都不一样呢，我们要用这个图来分析: 在这里，我们[Person alloc]创建了一个p 对象的内存空间，而[p1 init]则是创建同样是指向p1的指针p2，p3，因为和p1 内存空间一致，所以地址均为0x6000024f4950，但是指向该3个指针的指针不一样，所以&amp;p1, &amp;p2, &amp;p3 地址不一致。 3.2源码分析：alloc 步骤如下 1. alloc该步骤主要为创建对象，申请内存空间。相关objc源代码如下 + (id)alloc { return _objc_rootAlloc(self); }","text":"本页所使用的objc runtime 756.2，来自GITHUB 1. 题目开始学习研究OC源码，今天看的是对象的初始化，也就是alloc以及init的分析。 2. 附流程图如下 3. 内容3.1引子我们先看一段代码，Person类的初始化，打印p1,p2,p3对象，以及指向他们的指针： Person *p1 = [Person alloc]; Person *p2 = [p1 init]; Person *p3 = [p1 init]; NSLog(@\"%@ -- %p\", p1, &p1); NSLog(@\"%@ -- %p\", p2, &p2); NSLog(@\"%@ -- %p\", p3, &p3); 打印结果是： 这里为什么p1相同的情况下，经过init后的p2，p3 的地址都不一样呢，我们要用这个图来分析: 在这里，我们[Person alloc]创建了一个p 对象的内存空间，而[p1 init]则是创建同样是指向p1的指针p2，p3，因为和p1 内存空间一致，所以地址均为0x6000024f4950，但是指向该3个指针的指针不一样，所以&amp;p1, &amp;p2, &amp;p3 地址不一致。 3.2源码分析：alloc 步骤如下 1. alloc该步骤主要为创建对象，申请内存空间。相关objc源代码如下 + (id)alloc { return _objc_rootAlloc(self); } 2. objc_rootAlloc基类对于alloc 的实现，此时cls不为空，源码如下： init方法： 类的init 如下 +(id)init{ return (id)self; } 对象的init如下 - (id)init{ return _objc_rootAlloc(self); } id _objc_rootAlloc(Class cls) { return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/); } 此处init 方法仅仅为工厂初始方法，作为父类方法，方便子类重写。 3. callAlloc**callAlloc 的实现如下: // Call [cls alloc] or [cls allocWithZone:nil], with appropriate // shortcutting optimizations. static ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false) { if (slowpath(checkNil &amp;&amp; !cls)) return nil; #if __OBJC2__ if (fastpath(!cls->ISA()->hasCustomAWZ())) { // No alloc/allocWithZone implementation. Go straight to the allocator. // fixme store hasCustomAWZ in the non-meta class and // add it to canAllocFast's summary if (fastpath(cls->canAllocFast())) { // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls->hasCxxDtor(); id obj = (id)calloc(1, cls->bits.fastInstanceSize()); if (slowpath(!obj)) return callBadAllocHandler(cls); obj->initInstanceIsa(cls, dtor); return obj; } else { // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (slowpath(!obj)) return callBadAllocHandler(cls); return obj; } } #endif // No shortcuts available. if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc]; } 4. class_createInstance如上代码，如无捷径，类对象即创建实例 class_createInstance(Class cls, size_t extraBytes) { return _class_createInstanceFromZone(cls, extraBytes, nil); } 5. _class_createINstanceFramZone Cls-&gt;instanceSize 此时为对其寻址空间，统一为为每个对象开辟16位的位置，防止溢出。 size_t size = cls->instanceSize(extraBytes); // CF requires all objects be at least 16 bytes. if (outAllocatedSize) *outAllocatedSize = size; calloc 如果空间已开辟，则指定空间并返回，类似去学校报道，宿管阿姨带你去宿舍并交付钥匙给你，代码如下: if (zone) { // malloc_zone_calloc 即为开辟内存 obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); } else { obj = (id)calloc(1, size); } objc-&gt;initInstanceIsa 这一步为确定指针，即给宿舍贴上门牌号，相关代码如下： if (!zone &amp;&amp; fast) { obj = (id)calloc(1, size); // 该行开辟了名为obj空间 if (!obj) return nil; obj->initInstanceIsa(cls, hasCxxDtor); } 在这一环节，obj = (id)calloc(1, size) 该行开辟了名为obj空间。 而obj-&gt;initInstanceIsa(cls, hasCxxDtor) 则真正的将内存空间obj 与类cls 进行关联上。 4. 总结总的来说，alloc的过程，即时在堆区开辟空间给对象，并在栈区开辟指针（大小为8字节）指向该对象的内存区，即给定isa，以方便寻址。 以上，如果有更深入的理解，会再来补充，供参考。","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"源码","slug":"源码","permalink":"http://nilsli.com/tags/源码/"},{"name":"底层","slug":"底层","permalink":"http://nilsli.com/tags/底层/"},{"name":"alloc","slug":"alloc","permalink":"http://nilsli.com/tags/alloc/"}]},{"title":"使用Runtime获取第三方成员变量","slug":"runtimes","date":"2019-12-12T07:04:43.000Z","updated":"2020-03-17T15:07:11.581Z","comments":true,"path":"2019/12/12/runtimes/","link":"","permalink":"http://nilsli.com/2019/12/12/runtimes/","excerpt":"","text":"我们使用第三方库，有时候需要获取其成员变量。方法如下： 导入runtime #import &lt;objc/runtime.h> 声明一个Person类 @interface Person : NSObject { NSString *address; } @property(nonatomic,strong)NSString *name; @property(nonatomic,assign)NSInteger age; @end 使用runtime获取私有属性 //遍历获取Person类所有的成员变量IvarList - (void) getAllIvarList { unsigned int methodCount = 0; Ivar * ivars = class_copyIvarList([Person class], &amp;methodCount); for (unsigned int i = 0; i &lt; methodCount; i ++) { Ivar ivar = ivars[i]; const char * name = ivar_getName(ivar); const char * type = ivar_getTypeEncoding(ivar); NSLog(@\"Person拥有的成员变量的类型为%s，名字为 %s \",type, name); } free(ivars); } 打印结果如下： 2019-12-12 15:14:02.115744+0800 PersonRuntime[11576:1071364] Person拥有的成员变量的类型为@\"NSString\"，名字为 address 2019-12-12 15:14:02.115902+0800 PersonRuntime[11576:1071364] Person拥有的成员变量的类型为@\"NSString\"，名字为 _name 2019-12-12 15:14:02.115997+0800 PersonRuntime[11576:1071364] Person拥有的成员变量的类型为q，名字为 _age","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"runtime","slug":"runtime","permalink":"http://nilsli.com/tags/runtime/"},{"name":"进阶","slug":"进阶","permalink":"http://nilsli.com/tags/进阶/"}]},{"title":"Flutter 深入学习","slug":"Flutter-beginer","date":"2019-10-31T10:00:19.000Z","updated":"2020-03-17T15:07:11.485Z","comments":true,"path":"2019/10/31/Flutter-beginer/","link":"","permalink":"http://nilsli.com/2019/10/31/Flutter-beginer/","excerpt":"引言Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。 1.快速开发毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。 2.富有表现力和灵活的UI快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。 3.原生性能Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。","text":"引言Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。 1.快速开发毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。 2.富有表现力和灵活的UI快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。 3.原生性能Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。 快速开发Flutter的热重载可帮助您快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以在亚秒内重载，并且不会丢失状态。 现代式，响应式框架使用Flutter的现代、响应式框架，和一系列基础widget，轻松构建您的用户界面。使用功能强大且灵活的API（针对2D、动画、手势、效果等）解决艰难的UI挑战。 示例代码： class CounterState extends State&lt;Counter> { int counter = 0; void increment() { // 告诉Flutter state已经改变, Flutter会调用build()，更新显示 setState(() { counter++; }); } Widget build(BuildContext context) { // 当 setState 被调用时，这个方法都会重新执行. // Flutter 对此方法做了优化，使重新执行变的很快 // 所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget return new Row( children: &lt;Widget>[ new RaisedButton( onPressed: increment, child: new Text('Increment'), ), new Text('Count: $counter'), ], ); } }","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://nilsli.com/tags/Flutter/"},{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"大前端，跨栈","slug":"大前端，跨栈","permalink":"http://nilsli.com/tags/大前端，跨栈/"}]},{"title":"【译】产品经理vs项目经理：如何区别他们","slug":"pmvspm","date":"2019-08-23T07:16:02.000Z","updated":"2020-03-17T15:07:11.571Z","comments":true,"path":"2019/08/23/pmvspm/","link":"","permalink":"http://nilsli.com/2019/08/23/pmvspm/","excerpt":"（原链接在此）序言大公司和较大的团队常常存在许多战略部门与角色。因此，人们往往会对其中众多角色岗位一脸懵逼不足为奇。 不同的经理在团队中的关键职责是否那么容易区分呢？举个栗子，一个产品经理和项目经理的角色就有很多共同点。据说，这些经理中每一个人在他的生命中起码听过这样直接的问题：他们（产品经理、项目经理）有区别吗？不过，也别急着埋怨他们或者觉得难堪，就因为他们对这些职能弄不清楚。产品经理和项目经理是完全不同的角色。这篇文章的目标是定义清楚这两种在软件开发公司里的关键位置的区别，让你彻底甩掉疑惑。","text":"（原链接在此）序言大公司和较大的团队常常存在许多战略部门与角色。因此，人们往往会对其中众多角色岗位一脸懵逼不足为奇。 不同的经理在团队中的关键职责是否那么容易区分呢？举个栗子，一个产品经理和项目经理的角色就有很多共同点。据说，这些经理中每一个人在他的生命中起码听过这样直接的问题：他们（产品经理、项目经理）有区别吗？不过，也别急着埋怨他们或者觉得难堪，就因为他们对这些职能弄不清楚。产品经理和项目经理是完全不同的角色。这篇文章的目标是定义清楚这两种在软件开发公司里的关键位置的区别，让你彻底甩掉疑惑。 想象一下，你的组织需要进行人力资源优化以及一些人员裁减。如果你不得不决定团队里谁会留下，而谁该友好说再见。哪个经理你会选择留下？ 显然，做出选择并不容易。如果你被问到，说出谁对团队更重要，你肯定会发现难以回答。 这个问题有正确答案吗？让我们试着理清楚。 产品经理 vs 项目经理：谁的负担更重 产品 是你给客户或用户提出的最终结果。产品可以是可以触摸到的实物；也可能是软件平台或者服务。 项目 是一个包含着后续活动的计划。这些活动有设定好的启动和截止时间，以及一个结果。只有在最终结果达成后，项目才算完成。 举个栗子，你的产品是一个约会app。开发这个应用意味着不同的项目。其中一个是编写一个内容计划以及运行一个公司博客。这个项目有自己的截止时间和结束点。 比较两种角色最无聊（但并不正确！）的方式是去观察他们的薪资收入。下图显示了详细数据： 软件行业产品经理年收入（年份未知） IT行业产品项目经理年收入（年份未知） 产品经理和项目经理关键职能是什么？产品经理 在IT领域，产品经理负责管理软件开发。他们通常负责定义产品战略、功能有限顺序以及产品的最终交付上线。 他们负责创造想法和主动性来帮助实现战略和目标，促进内部和外部的相关部门交流；他们会访问潜在的和现有的客户，获取可能会对未来版本有帮助的反馈；他们也会和经销商一起工作，有成效地向用户展示产品细节；他们战略路线下工作，处理产品积压。 产品经理通常参加工业事件和会议，以停留在当前行业最前沿。因此，他们的核心职能列表如下： 产品战略 市场调研 期望与主动性 发布 损益问题 项目经理 在软件开发中行业，项目经理的职责与计划固定类型公司里的项目紧密相连。这些专家保证他们在正轨上运行，通过所有执行阶段，他们关心可能的制约和资源风险。 通常，他们较少关心具体的产品目标。他们分析所有的主动性和特性，来开发一个项目时间表。 作为一份工作，项目经理可能需要每天评估员工，他们的积极性来达成具体的目标。 项目经理管控项目知道他们完成，然后会评估要继续跟进的必要性。 他们的主要职责关联如下： 项目交付 资源 利用软件生命周期方法 状态更新 项目预算 产能 团队合作成功 问题解决方案 两种岗位可能的职业路线是什么？这些管理们毫无疑问的寻求职业成长。从一个工作（提升）到下一个水平的行动，需要坚强的经理技能和足够的经验。 典型的来说，产品经理李正成为高级产品经理或者产品管理负责人。项目经理们的职业路线通常说升级到高级项目经理和项目负责人角色。 在公司里哪一种角色更重要？如果你的公司同时需要产品经理和项目经理，那么组织结构上是完全合理的。如何定义，谁说更重要呢？ 可能，下面的问题会帮助你： 如果没有产品经理，团队能否运行良好？ 如果项目经理离开团队，会发生什么？ 很有可能，你的答案会显示两个角色都是重要且不可取代。他们的紧密合作是迈向成功的关键。 项目管理和产品管理工具选择项目管理和产品管理一个专业工具，需要考虑明确的公司需求、团队相关成员的数量、相关行业，以及其他的因素。 当下你可以尝试小型在线管理解决方案，它能满足经理们的必要需求。 一些流行的软件方案如Trello，Wrike, Hygger或Aha提供了所有产品管理和项目管理领域的强大的工具套装。 大部分这些工具会提供用户便利便利的tas面板（为看板和敏捷开发适配），跟踪系统，待办事项列表，确定优先事项，高级别评估，有用时间线，等等等等。 最后一句话让我们简单的总结一下上面提到的事情： 产品经理和项目经理角色可能被弄混，但他们是完全不同的。他们对于软件开发公司是同等重要。 产品经理驱动产品开发，主动性的工作，确定优先顺序以及制定战略决定。项目经理管控已经被开发和审批过的项目计划。 两个经理都需要专业管理软件来可视化和追踪产品和项目活动，并与团队通力合作。 你怎么区分项目和产品经理呢？哪些软件你尝试过，为什么？","categories":[],"tags":[{"name":"项目经理","slug":"项目经理","permalink":"http://nilsli.com/tags/项目经理/"},{"name":"产品经理","slug":"产品经理","permalink":"http://nilsli.com/tags/产品经理/"},{"name":"IT","slug":"IT","permalink":"http://nilsli.com/tags/IT/"},{"name":"产品","slug":"产品","permalink":"http://nilsli.com/tags/产品/"},{"name":"项目","slug":"项目","permalink":"http://nilsli.com/tags/项目/"}]},{"title":"iOS开发中的问题集锦","slug":"tips-on-swift","date":"2019-07-28T07:33:22.000Z","updated":"2020-03-24T10:07:21.370Z","comments":true,"path":"2019/07/28/tips-on-swift/","link":"","permalink":"http://nilsli.com/2019/07/28/tips-on-swift/","excerpt":"","text":"开发中难免遇到各式各样的小问题，平时收集一下，汇总如下，按Q（问题）和 A（解决方法）。 Q1遇到unable to index file详细内容： ​ 详细内容： unable to index file fatal: updating files failed A 解决： git reset HEAD qooxdoo Q2 hexo部署后，CNAME会被自动删除推送上去后，包含域名内容的CNAME 被删除，博客无法用域名解析。 A 解决： 出现这样的问题一般是CNAME 放在blog根目录下，正确是放在source 目录下。 然后执行 部署推送 hexo d -g 问题得到解决。 Q3 This copy of libswiftCore.dylib requires an OS version prior to 10.14.4.问题: 在掘金这篇文章, 尝试配置SPM，通过命令创建包时，执行swift run 后，出现如下问题 A 解决： cp -r /usr/lib/swift/*.dylib /Applications/Xcode.app/Contents/Frameworks Q4: Git 遇到了 early EOF index-pack failed$ git clone https://github.com/boostorg/boost.git Cloning into 'boost'... remote: Counting objects: 183543, done. remote: Compressing objects: 100% (69361/69361), done. fatal: The remote end hung up unexpectedly fatal: early EOF fatal: index-pack failed 解决： git config --add core.compression -1 ———————— 持续添加中","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"swift","slug":"swift","permalink":"http://nilsli.com/tags/swift/"},{"name":"小问题","slug":"小问题","permalink":"http://nilsli.com/tags/小问题/"},{"name":"git","slug":"git","permalink":"http://nilsli.com/tags/git/"}]},{"title":"【译】从阿波罗7号卫星上俯瞰加州南部","slug":"view-from-south-cali","date":"2019-07-24T07:03:19.000Z","updated":"2020-03-17T15:07:11.605Z","comments":true,"path":"2019/07/24/view-from-south-cali/","link":"","permalink":"http://nilsli.com/2019/07/24/view-from-south-cali/","excerpt":"","text":"这是从阿波罗7号上拍摄的加州南部的照片 图片来自 NASA 这片照片拍摄于1968年10月12日，由阿波罗7号航天器在执行它的绕地飞行第18圈时拍摄。拍摄时对地高度为124海里，加州海岸线上的穆古岬向南一直到欧申赛德，都能尽收眼底。透过云层，依稀能看见圣卡塔利娜岛屿。洛杉矶地区的近景则被从班宁市向西连绵100多英里直到马里海滩上空污染物所遮盖的模糊不清。在图片的上部（从左至右）能看见圣华金谷）在贝克斯菲尔德之外，特哈查比山脉,内华达山脉,欧文斯谷,死亡山谷以及莫哈韦沙漠。 阿波罗7号于1968年10月11日升空，被亲切称为”华尔特，华里和唐·修”, 是首次载人发射火箭计划。该计划在载人行动期间证明了指令/服务仓任务模组技术、项目地面支援能力、阿波罗的空间交会能力，同时也实现了首次从太空进行实时电视直播。 原文链接","categories":[],"tags":[{"name":"NASA","slug":"NASA","permalink":"http://nilsli.com/tags/NASA/"},{"name":"太空","slug":"太空","permalink":"http://nilsli.com/tags/太空/"},{"name":"卫星","slug":"卫星","permalink":"http://nilsli.com/tags/卫星/"}]},{"title":"【译】SaaS发展历程","slug":"journey-of-SaaS","date":"2019-07-24T06:48:02.000Z","updated":"2020-03-17T15:07:11.543Z","comments":true,"path":"2019/07/24/journey-of-SaaS/","link":"","permalink":"http://nilsli.com/2019/07/24/journey-of-SaaS/","excerpt":"撰稿人：Neeraj Agrawal 梗概： 总结了成功的SaaS公司上市前的发展轨迹：找到 product-market fit，年入$200万（ARR），然后进入T2D3阶段 - 连续两年ARR翻三倍，然后连续三年翻两倍。ARR至少$1亿，然后上市。 所谓T2D3： 连续两年 triple（三倍），然后连续三年 double（两倍）。","text":"撰稿人：Neeraj Agrawal 梗概： 总结了成功的SaaS公司上市前的发展轨迹：找到 product-market fit，年入$200万（ARR），然后进入T2D3阶段 - 连续两年ARR翻三倍，然后连续三年翻两倍。ARR至少$1亿，然后上市。 所谓T2D3： 连续两年 triple（三倍），然后连续三年 double（两倍）。 原文【编者按】 作者 Neeraj Agrawal 是美国波斯顿著名科技行业投行 Batter Ventures 的一名普通合伙人。 “打造一个十亿级的SaaS企业软件公司需要怎么做？”，作为一个科技行业投资者，在从业一来，曾无数次被问到这个问题，然而很难回答。我敢打赌登山者们被问到他们到底如何征服山峦的主峰时，也会有同样的感受。问题的答案是一步步来——你不过是把一只脚从另一只脚前迈过去，当然——务实一点来讲，整个过程总是能分解成多个、清晰的步骤。 你不能在一天内翻越乞力马扎罗山，所以你也不可能迅速的弄出一套优秀的SaaS系统出来。相反的，你该将缩小焦点而且明确目标，接下来搞清楚下一步该怎样做，然后快速奔向目标。 “我的儿子在Battery Adventures工作” 我之所以开始思考在风险投资行业的工作和登山的相似性，要感谢一个意想不到的人：我的母亲。她和我的父亲在1960年代中期从当时还是英属的印度拉贾斯坦邦移居到皇后区（译注:纽约）。我的父母都是聪明，努力工作，务实的人，但他们都不理解他们的儿子在工作些什么。 我曾无数次的向我亲爱的、娇小的妈妈（她只有约1.5米高）描述我的工作，但她从没能清晰的记得我在做些什么。在最近的一次聚会上，她骄傲的告诉她的朋友：“我的儿子在Battery Adventures工作”。她的朋友笑了，因为他们对我不像我父亲一样是个医生，或者在大牌的银行——像高盛或是摩根斯坦利工作而倍感失望。 她的话引起我的思考。或许他把我的工作描述的比我认为的更好一些。或许思考如何建立一家公司最好的方式是去冒险，而非历险。而或许我在风投公司的角色就像一次冒险历程里的向导：是那些曾攀登过这座山很多次的那种人，事无巨细的了解攀登过程中的岩层与沟壑，能给足够勇敢的人提供指导来面对挑战。 我很荣幸曾在我15年风投任职生涯中，与许多世界级的创始人共事，其中包括许多B2B，SaaS企业软件公司，诸如Marketo、Omniture、Guidewire、Bazaarvoice以及Sprinklr（如需了解所有Battery 公司投资与撤出的详细清单，请点击这里）。 所以我从我个人的经历中分享一些故事和建议——姑且称之为“冒险”故事，作为向导来帮助那些里程碑上的企业者去到达他们的顶峰：估值十亿美元。 SaaS企业成功走向市场的7个阶段 我相信一个SaaS企业的走向市场会成功，会有7个关键阶段。大部分的阶段围绕这一个中心店，我称之为“三倍、三倍、两倍、两倍”（简称T2D3），反映一个公司的年度财报进展。 这并不是通往SaaS成功的唯一的步进之路，像Cornerstone、ExactTarget和SuccessFactors这样的公司他们所展示的一样，但是这是一条通往目标稳妥的路。每一个阶段需要不同的聚焦，比方说调整你的销售进程，发展你的团队和你的组织策略，以及国际上的扩张。 你会注意到我提到“市场进入策略”，因为SaaS公司发展中也有很多关键阶段。它们包含了选择合伙人、选择投资人、开发灵活的产品架构以及培养成功的企业文化，等等诸如此类。在这里，我们只着眼于“攀登”的技术。所以带上你的户外工具——我们要走向偏僻跑到，直奔顶峰了。 阶段1：达成一个伟大的产品-市场体系。 这包含了找到并且按重要性排列好消费者的通电，接着把你的产品准确指向这些痛点。很多创业者问我怎样知道他们实现了产品-市场体系。遗憾的是，没有确切的方法来测试证明。 我经常问一些特定行业的潜在消费者或者用户来描述他们的痛点。当我听到样本的稳定性时，我知道到位了。一旦产品成型，很容易来测试它是否让消费者觉得有对其帮助。– … 译制中，原链接在此","categories":[],"tags":[{"name":"创业","slug":"创业","permalink":"http://nilsli.com/tags/创业/"},{"name":"SaaS","slug":"SaaS","permalink":"http://nilsli.com/tags/SaaS/"},{"name":"科技","slug":"科技","permalink":"http://nilsli.com/tags/科技/"}]},{"title":"如何在苹果AppStore 上下架应用","slug":"offline-app-from-app-store","date":"2018-07-24T07:46:11.000Z","updated":"2020-03-17T15:07:11.555Z","comments":true,"path":"2018/07/24/offline-app-from-app-store/","link":"","permalink":"http://nilsli.com/2018/07/24/offline-app-from-app-store/","excerpt":"序言：作为开发者，如何快捷的在苹果商店下架上架App，请看图吧如何下架1. 进入开发者中心 itunesConnect","text":"序言：作为开发者，如何快捷的在苹果商店下架上架App，请看图吧如何下架1. 进入开发者中心 itunesConnect 2. 选择相应的App 3. 如图，选择价格与销售范围—— 下架 4. 等等10分钟左右，再次搜索，此时AppStore 已经搜索不到该App了 此时的状态是： 重新上架1. 此时，也是选择 该应用的 价格与销售范围，选择【在所有地区供应】– 存储 2. 此时是立即上架，AppStore也是需要5-10分钟可以搜索到 就是这么简单，希望可以帮到你。","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"appstore","slug":"appstore","permalink":"http://nilsli.com/tags/appstore/"},{"name":"上架","slug":"上架","permalink":"http://nilsli.com/tags/上架/"},{"name":"下架","slug":"下架","permalink":"http://nilsli.com/tags/下架/"},{"name":"苹果商店","slug":"苹果商店","permalink":"http://nilsli.com/tags/苹果商店/"}]},{"title":"图解SDWebImage(读sdwebimage源码分析)","slug":"pic-of-sdwebimage","date":"2018-02-24T07:33:15.000Z","updated":"2020-03-17T15:07:11.560Z","comments":true,"path":"2018/02/24/pic-of-sdwebimage/","link":"","permalink":"http://nilsli.com/2018/02/24/pic-of-sdwebimage/","excerpt":"最近在看一些第三方库的源码，其中SDWebImage 尤其让人惊叹，尝试用XMind 画出原理，以后有机会， 会增加更多的细节图。 大纲如下：","text":"最近在看一些第三方库的源码，其中SDWebImage 尤其让人惊叹，尝试用XMind 画出原理，以后有机会， 会增加更多的细节图。 大纲如下： 图片缓存的实现如下： 以下为异步下载部分：","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://nilsli.com/tags/ios/"},{"name":"开发","slug":"开发","permalink":"http://nilsli.com/tags/开发/"},{"name":"SDWebImage","slug":"SDWebImage","permalink":"http://nilsli.com/tags/SDWebImage/"}]},{"title":"通过Universal Link在微信页面中唤起原生App","slug":"wake-up-app-with-universal-link","date":"2017-06-24T07:39:05.000Z","updated":"2020-03-17T15:07:11.605Z","comments":true,"path":"2017/06/24/wake-up-app-with-universal-link/","link":"","permalink":"http://nilsli.com/2017/06/24/wake-up-app-with-universal-link/","excerpt":"因微信封杀，已失效，微信大刀威武！ 在某些电商项目，或者是社交媒体的分享页面中，我们经常会看到在页面的顶端或者底部遇到有【打开App】或者【下载App】这样的按钮。比较友好的产品经理，会做设备识别，以及检测APP是否安装，来做打开或者下载App 的需求。这些功能在Safari下使用location.href=”scheme://example” 即可实现。但是在微信中，这方面做的比较恶心，微信下面几乎是全面屏蔽了唤起原生App 的功能，所有的启动都需要通过应用宝。 在iOS 9以后，苹果推出了Universal Link 这个概念，解决了使用A标签，以及iFrame 的弊端。WWDC2015 Session 509 有介绍,通过Universal Link，将App 与网页端建立连接桥，可以从Safari 或者其他前端浏览器来识别并唤醒App，甚至是微信环境下也可以冲破障碍。","text":"因微信封杀，已失效，微信大刀威武！ 在某些电商项目，或者是社交媒体的分享页面中，我们经常会看到在页面的顶端或者底部遇到有【打开App】或者【下载App】这样的按钮。比较友好的产品经理，会做设备识别，以及检测APP是否安装，来做打开或者下载App 的需求。这些功能在Safari下使用location.href=”scheme://example” 即可实现。但是在微信中，这方面做的比较恶心，微信下面几乎是全面屏蔽了唤起原生App 的功能，所有的启动都需要通过应用宝。 在iOS 9以后，苹果推出了Universal Link 这个概念，解决了使用A标签，以及iFrame 的弊端。WWDC2015 Session 509 有介绍,通过Universal Link，将App 与网页端建立连接桥，可以从Safari 或者其他前端浏览器来识别并唤醒App，甚至是微信环境下也可以冲破障碍。 参考了苹果的原生介绍，做出了微信下唤醒自己的 App 效果如下： 实操如下服务器配置：准备独立域名。 一级域名，二级域名均可。 SSL 证书这里需要为服务器配置HTTPS 用的SSL 证书。 上传签名好的JSON 配置文件新建一个JSON文件，不需要后缀名，内容输入以下代码： { \"applinks\": { \"apps\": [], \"details\": [ { \"appID\": \"5B5Q4xxxx.com.xxxx.xxxx\", \"paths\": [ \"/html/1/*\", \"/*\"] }, ] } } 这里的 appID 相关内容可以在Developer 中心找到相关的内容。如图，前半部分为Prefix 后半部分为ID，即你的App 的bundle id，两者通过.相连。 注意：这里的AppID中前半部分，在App 转让主体后会改变，需重新更新。 paths 则是用来唤醒App 所需要指定的JSON文件在服务器中的路径。用”/* “ 是根目录，而/html 则是指html目录下的。 填好后保存为apple-app-site-association 名，上传到域名指向的服务器根目录。 App配置： 在工程文件中，找到Targets - Capabilities - Associated Domains 将开关选为On，并添加你的域名，格式为applinks:你的域名.com iOS 移动端的代码配置 - (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler { if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb]) { NSString *url = userActivity.webpageURL.description; // 这里可以通过拆分url 来传入参数，达到跳转原生页面的功能，如跳转某商品页 [UIApplication sharedApplication] openURL:webpageURL]; } return YES; } h5网页配置： h5网页中对需要唤起App 的按钮或者控件添加点击事件，事件的函数代码如下: function wakeUpApp(){ if (navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) { var loadDateTime = new Date(); window.setTimeout(function() { var timeOutDateTime = new Date(); if (timeOutDateTime - loadDateTime &lt; 5000) { window.location.href = \"http://a.app.qq.com/o/simple.jsp?pkgname=你的应用宝BundleID\"; }else{ window.close(); } }, 25); window.location.href = \"https://yourdomainname.com/\"; }else if (navigator.userAgent.match(/android/i)) { var state = null; try { state = window.open(\"apps custom url schemes \", '_blank'); } catch(e) {} if (state) { window.close(); } else { window.location.href = \"要跳转的页面URL\"; } } } 注：代码中 yourdomainname.com 还可以后面添加 /goodid/123456 之类的属性id后缀，用来传递事件类型和id，方便移动端做更丰富的功能需求，比如通过goodid 识别要做的下一步动作是打开商品id 为123456 的商品详情页，等等。 配置完成，查看是否能唤起App，也可以通过如下图中，输入域名，长按来唤起App 做验证。 至此，大功告成。 值得注意的是，只能在iOS 9环境及以上实现该功能。iOS 8或者以下，只能采取老式的跳转至应用宝来实现。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://nilsli.com/tags/iOS/"},{"name":"原生","slug":"原生","permalink":"http://nilsli.com/tags/原生/"},{"name":"微信","slug":"微信","permalink":"http://nilsli.com/tags/微信/"},{"name":"universallink","slug":"universallink","permalink":"http://nilsli.com/tags/universallink/"},{"name":"hyper","slug":"hyper","permalink":"http://nilsli.com/tags/hyper/"},{"name":"混合交互","slug":"混合交互","permalink":"http://nilsli.com/tags/混合交互/"}]},{"title":"下棋","slug":"play-chess","date":"2016-03-24T07:52:01.000Z","updated":"2020-03-17T15:07:11.571Z","comments":true,"path":"2016/03/24/play-chess/","link":"","permalink":"http://nilsli.com/2016/03/24/play-chess/","excerpt":"","text":"在公园和大爷下象棋，有点紧张。走了第一步后，大爷沉默了很久说：“你是新手吧？”“大爷你怎么知道？”“我在这玩了几年，第一步走帅的真不多。”“不应该让领导先走吗？”","categories":[],"tags":[{"name":"休闲","slug":"休闲","permalink":"http://nilsli.com/tags/休闲/"},{"name":"人生哲理","slug":"人生哲理","permalink":"http://nilsli.com/tags/人生哲理/"}]}]}